---
title: å†…å­˜ç®¡ç†
date: 2020-08-14 17:16:33
tags: OCåº•å±‚åŸç†
---

æ€è€ƒï¼š
* ä½¿ç”¨ CADisplayLinkã€NSTimer æœ‰ä»€ä¹ˆæ³¨æ„ç‚¹ï¼Ÿ
* ä»‹ç»ä¸‹å†…å­˜çš„å‡ å¤§åŒºåŸŸ
* è®²ä¸€ä¸‹ä½ å¯¹ iOS å†…å­˜ç®¡ç†çš„ç†è§£
* ARC éƒ½å¸®æˆ‘ä»¬åšäº†ä»€ä¹ˆï¼Ÿ(LLVM + Runtime)
* weak æŒ‡é’ˆçš„å®ç°åŸç†
* autorelease å¯¹è±¡åœ¨ä»€ä¹ˆæ—¶æœºä¼šè¢«è°ƒç”¨ release
* æ–¹æ³•é‡Œæœ‰å±€éƒ¨å¯¹è±¡ï¼Œ å‡ºäº†æ–¹æ³•åä¼šç«‹å³é‡Šæ”¾å—?
<!-- more -->

# CADisplayLinkã€NSTimer å®šæ—¶å™¨
CADisplayLinkã€NSTimer ä¼šå¯¹ target äº§ç”Ÿå¼ºå¼•ç”¨ï¼Œå¦‚æœ target åˆå¯¹å®ƒä»¬äº§ç”Ÿå¼ºå¼•ç”¨ï¼Œé‚£ä¹ˆå°±ä¼šå¼•å‘å¾ªç¯å¼•ç”¨ã€‚

## å¾ªç¯å¼•ç”¨é—®é¢˜

### CADisplayLink
CADisplayLink ä¿è¯è°ƒç”¨ `-(void)timerTest` æ–¹æ³•çš„é¢‘ç‡å’Œå±å¹•çš„åˆ·æ–°å¸§é¢‘ç‡ä¸€è‡´ï¼Œ60FPSã€‚å®é™…çš„è°ƒç”¨é¢‘ç‡å¯èƒ½ä¸å¤ªä¸€æ ·ï¼Œæ ¹æ®ä»»åŠ¡çš„è€—æ—¶æƒ…å†µä¼šæœ‰å‡å°‘ã€‚
```
@interface TimerViewController ()
@property (nonatomic, strong) CADisplayLink *link;
@end

@implementation TimerViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.link invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
......
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œè¿›å…¥ TimerViewController æ§åˆ¶å™¨åè¿”å›ï¼Œä¼šå‘ç° TimerViewController æ²¡æœ‰é‡Šæ”¾ï¼ŒCADisplayLink å®šæ—¶å™¨è¿˜åœ¨ç»§ç»­è¿è¡Œã€‚

### NSTimer
```
@interface TimerViewController ()
@property (nonatomic, strong) NSTimer *timer;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.timer invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
......
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œè¿›å…¥ TimerViewController æ§åˆ¶å™¨åè¿”å›ï¼Œä¼šå‘ç° TimerViewController æ²¡æœ‰é‡Šæ”¾ï¼ŒNSTimer å®šæ—¶å™¨è¿˜åœ¨ç»§ç»­è¿è¡Œã€‚

### é—®é¢˜åˆ†æ
![å†…å­˜ç®¡ç†01](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†01.png)

## è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šä½¿ç”¨ block
```
@interface TimerViewController ()
@property (nonatomic, strong) NSTimer *timer;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    __weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
        [weakSelf timerTest];
    }];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.timer invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController dealloc]
```

åœ¨ä½¿ç”¨ NSTimer çš„æ—¶å€™ï¼Œä½¿ç”¨ block çš„æ–¹å¼ä¼ å…¥ weakSelf å¯ä»¥æœ‰æ•ˆè§£å†³å¾ªç¯å¼•ç”¨çš„é—®é¢˜ã€‚å¹¶ä¸”ä»¥ scheduled å¼€å¤´çš„æ–¹æ³•ä¼šè‡ªåŠ¨å°† timer æ·»åŠ åˆ°å½“å‰çš„ runloop ä¸­å¹¶ä½¿ç”¨ default modeã€‚
```
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
```

target ä¼ å…¥ weakSelf å¹¶ä¸èƒ½è§£å†³å¾ªç¯å¼•ç”¨ä¸ªé—®é¢˜ï¼Œå› ä¸º NSTimer å†…éƒ¨å¯¹ä¼ å…¥çš„ target ä¹Ÿæ˜¯å¼ºå¼•ç”¨çš„ï¼Œè€Œä¸” weakSelf åªæ˜¯ç”¨æ¥è§£å†³ block å¾ªç¯å¼•ç”¨é—®é¢˜çš„æ–¹æ¡ˆã€‚
```
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
```

CADisplayLink æ²¡æœ‰ block ç›¸å…³çš„ APIã€‚

### æ–¹æ¡ˆäºŒï¼šä½¿ç”¨ä¸­é—´å¯¹è±¡
![å†…å­˜ç®¡ç†02](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†02.png)

å®šä¹‰ä¸­é—´å¯¹è±¡ï¼š
```
@interface YQProxy : NSObject
+ (instancetype)proxyWithTarget:(id)target;
@property (nonatomic, weak) id target;
@end

@implementation YQProxy
+ (instancetype)proxyWithTarget:(id)target
{
    YQProxy *proxy = [[YQProxy alloc] init];
    proxy.target = target;
    return proxy;
}

- (id)forwardingTargetForSelector:(SEL)aSelector
{
    return self.target;
}
@end
```

#### NSTimer
```
@interface TimerViewController ()
//@property (nonatomic, strong) CADisplayLink *link;
@property (nonatomic, strong) NSTimer *timer;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[YQProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.timer invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController dealloc]
```

#### CADisplayLink
```
@interface TimerViewController ()
@property (nonatomic, strong) CADisplayLink *link;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.link = [CADisplayLink displayLinkWithTarget:[YQProxy proxyWithTarget:self] selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.link invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
......
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController dealloc]
```

ä¼ ç»™å®šæ—¶å™¨çš„ target æ˜¯ YQProxy å¯¹è±¡ï¼Œåœ¨ YQProxy å¯¹è±¡å°è¯•è°ƒç”¨ `-(void)timerTest` æ–¹æ³•æ—¶ï¼Œå‘ç°æ²¡æœ‰å®ç°åä¼šè°ƒç”¨ `- (id)forwardingTargetForSelector:(SEL)aSelector` æ–¹æ³•èµ°æ¶ˆæ¯è½¬å‘çš„é€»è¾‘ï¼Œåœ¨è¯¥æ–¹æ³•å†…éƒ¨è¿”å›å·²ç»å®ç°äº† `-(void)timerTest` æ–¹æ³•çš„å¯¹è±¡ï¼Œå°±å¯ä»¥æ­£å¸¸å®ç° timer å®šæ—¶å™¨è°ƒç”¨ `-(void)timerTest` æ–¹æ³•çš„é€»è¾‘äº†ã€‚ 

å› ä¸º YQProxy å¯¹è±¡æ²¡æœ‰å®ç° `-(void)timerTest` æ–¹æ³•ï¼Œæ‰€ä»¥éœ€è¦æ·»åŠ æ¶ˆæ¯è½¬å‘é€»è¾‘ã€‚å¦‚æœ YQProxy ä¸­æ²¡æœ‰æ·»åŠ æ¶ˆæ¯è½¬å‘çš„é€»è¾‘ä¼šå‡ºç°å¦‚ä¸‹æŠ¥é”™ï¼š
![å†…å­˜ç®¡ç†03](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†03.png) 

YQProxy ä¼šåœ¨å…¶ç±»å¯¹è±¡ä»¥åŠçˆ¶ç±»çš„ç±»å¯¹è±¡é‡ŒæŸ¥æ‰¾ `-(void)timerTest` æ–¹æ³•ï¼ŒæŸ¥æ‰¾äº†ä¸€åœˆåå‘ç°æ‰¾ä¸åˆ°ï¼Œå°±ä¼šæŠ›å‡ºé”™è¯¯ã€‚

## ä½¿ç”¨ä»£ç†å¯¹è±¡ï¼ˆNSProxyï¼‰

å®šä¹‰ YQTimerProxy ç»§æ‰¿è‡ª NSProxyï¼š
```
@interface YQTimerProxy : NSProxy
+ (instancetype)proxyWithTarget:(id)target;
@property (nonatomic, weak) id target;
@end

@implementation YQTimerProxy
+ (instancetype)proxyWithTarget:(id)target
{
    YQTimerProxy *proxy = [YQTimerProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}
@end
```

NSProxy å¯¹è±¡æ²¡æœ‰ `-(instancetype)init` æ–¹æ³•ï¼Œç›´æ¥ alloc å°±å¯ä»¥äº†ã€‚

### NSTimer
```
@interface TimerViewController ()
@property (nonatomic, strong) NSTimer *timer;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0
                                                  target:[YQTimerProxy proxyWithTarget:self]
                                                selector:@selector(timerTest)
                                                userInfo:nil
                                                 repeats:YES];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.timer invalidate];
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController timerTest]
-[TimerViewController dealloc]
```

### CADisplayLink
```
@interface TimerViewController ()
@property (nonatomic, strong) CADisplayLink *link;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.link = [CADisplayLink displayLinkWithTarget:[YQTimerProxy proxyWithTarget:self] selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)dealloc
{
    NSLog(@"%s", __func__);
    [self.link invalidate];
}

@end
```

ä¼ ç»™å®šæ—¶å™¨çš„ target æ˜¯ YQTimerProxy å¯¹è±¡ï¼ŒYQTimerProxy å¯¹è±¡ä¸ä¼šå°è¯•è°ƒç”¨ `-(void)timerTest` æ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥èµ°æ¶ˆæ¯è½¬å‘é€»è¾‘ï¼Œåœ¨å¯¹åº”çš„æ¶ˆæ¯è½¬å‘çš„æ–¹æ³•é‡Œè¿”å›å·²ç»å®ç°äº† `-(void)timerTest` æ–¹æ³•çš„å¯¹è±¡ï¼Œå°±å¯ä»¥æ­£å¸¸å®ç° timer å®šæ—¶å™¨è°ƒç”¨ `-(void)timerTest` æ–¹æ³•çš„é€»è¾‘äº†ã€‚

å› ä¸º YQTimerProxy å¯¹è±¡ä¸ä¼šå°è¯•è°ƒç”¨ `-(void)timerTest` æ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨ `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` æ–¹æ³•ï¼Œæ‰€ä»¥éœ€è¦æ·»åŠ æ¶ˆæ¯è½¬å‘é€»è¾‘ã€‚å¦‚æœ YQTimerProxy ä¸­æ²¡æœ‰æ·»åŠ æ¶ˆæ¯è½¬å‘çš„é€»è¾‘ä¼šå‡ºç°å¦‚ä¸‹æŠ¥é”™ï¼š
![å†…å­˜ç®¡ç†04](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†04.png) 

å¯ä»¥çœ‹åˆ° YQTimerProxy æ²¡æœ‰å»æŸ¥æ‰¾ `-(void)timerTest` æ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥æŸ¥æ‰¾çš„ `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` æ–¹æ³•ã€‚è¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡ [GNUStep](http://www.gnustep.org/resources/downloads.php) æŸ¥çœ‹ NSProxy çš„æºç æ‰¾åˆ°åŸå› ã€‚NSProxy å†…éƒ¨çš„æ–¹æ³•çš„å®ç°éƒ½æ˜¯ç›´æ¥è°ƒç”¨çš„ `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` æ–¹æ³•ï¼Œå› æ­¤ NSProxy ä½œä¸ºä»£ç†å¯¹è±¡æ•ˆç‡æ›´é«˜ã€‚

## NSProxy
```
@interface ViewController ()
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    YQProxy *proxy1 = [YQProxy proxyWithTarget:self];
    YQTimerProxy *proxy2 = [YQTimerProxy proxyWithTarget:self];
    NSLog(@"%d %d", [proxy1 isKindOfClass:[ViewController class]], [proxy2 isKindOfClass:[ViewController class]]);
}
@end
```

æ‰“å°ç»“æœï¼š
```
0 1
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼ŒYQProxy çš„å®ä¾‹å¯¹è±¡å’Œ YQTimerProxy çš„å®åˆ—å¯¹è±¡åœ¨åˆ¤æ–­æ˜¯å¦æ˜¯ ViewController çš„å¯¹è±¡ç±»å‹çš„æ—¶å€™ç»“æœä¸åŒã€‚è¿™æ˜¯å› ä¸º YQTimerProxy ç»§æ‰¿è‡ª NSProxyï¼ŒNSProxy çš„ `-(BOOL) isKindOfClass:(Class)aClass` æ–¹æ³•çš„å®ç°ä¸æ™®é€šçš„ OC å¯¹è±¡åŒã€‚é€šè¿‡ [GNUStep](http://www.gnustep.org/resources/downloads.php) æŸ¥çœ‹ NSProxy çš„æºç ï¼š
```
- (BOOL)isKindOfClass:(Class)aClass
{
    NSMethodSignature	*sig;
    NSInvocation		*inv;
    BOOL			ret;

    sig = [self methodSignatureForSelector: _cmd];
    inv = [NSInvocation invocationWithMethodSignature: sig];
    [inv setSelector: _cmd];
    [inv setArgument: &aClass atIndex: 2];
    [self forwardInvocation: inv];
    [inv getReturnValue: &ret];
    return ret;
}
```

å¯ä»¥çœ‹åˆ°ï¼ŒNSProxy çš„ `-(BOOL)isKindOfClass:(Class)aClass` æ–¹æ³•å†…éƒ¨ç›´æ¥è°ƒç”¨äº† `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` æ–¹æ³•ã€‚

æ™®é€š OC å¯¹è±¡çš„ `-(BOOL)isKindOfClass:(Class)aClass` æ–¹æ³•å®ç° [objc4-781](https://opensource.apple.com/tarballs/objc4/) ï¼š
```
- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}
```

# GCD å®šæ—¶å™¨
CADisplayLink å’Œ NSTimer ä¾èµ–äº RunLoopï¼Œå¦‚æœ RunLoop çš„ä»»åŠ¡è¿‡äºç¹é‡ï¼Œå¯èƒ½ä¼šå¯¼è‡´ CADisplayLink å’Œ NSTimer ä¸å‡†æ—¶ã€‚GCD çš„å®šæ—¶å™¨ä¼šæ›´åŠ å‡†æ—¶ã€‚

## block å›è°ƒï¼š
```
@interface ViewController ()
@property (nonatomic, strong) dispatch_source_t timer;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"%s", __func__);
    // é˜Ÿåˆ—
    dispatch_queue_t queue = dispatch_get_main_queue();
    // åˆ›å»ºå®šæ—¶å™¨
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    // è®¾ç½®æ—¶é—´ï¼ˆå®šæ—¶å™¨ï¼Œå»¶è¿Ÿæ‰§è¡Œæ—¶é—´ï¼Œæ‰§è¡Œæ—¶é—´é—´éš”ï¼Œè¯¯å·®ï¼‰
    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);
    // å›è°ƒ
    dispatch_source_set_event_handler(timer, ^{
        NSLog(@"GCD timer");
    });
    // å¯åŠ¨å®šæ—¶å™¨
    dispatch_resume(timer);
    self.timer = timer;
}
@end
```

æ‰“å°ç»“æœï¼š
```
18:16:38.889349+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[15880:352867] -[ViewController viewDidLoad]
18:16:40.889609+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[15880:352867] GCD timer
18:16:41.889685+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[15880:352867] GCD timer
18:16:42.889624+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[15880:352867] GCD timer
......
```

## å‡½æ•°å›è°ƒï¼š
```
@interface ViewController ()
@property (nonatomic, strong) dispatch_source_t timer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"%s", __func__);
    // é˜Ÿåˆ—
    dispatch_queue_t queue = dispatch_get_main_queue();
    // åˆ›å»ºå®šæ—¶å™¨
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    // è®¾ç½®æ—¶é—´ï¼ˆå®šæ—¶å™¨ï¼Œå»¶è¿Ÿæ‰§è¡Œæ—¶é—´ï¼Œæ‰§è¡Œæ—¶é—´é—´éš”ï¼Œè¯¯å·®ï¼‰
    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);
    // å›è°ƒ
    dispatch_source_set_event_handler_f(timer, timerFire);
    
    // å¯åŠ¨å®šæ—¶å™¨
    dispatch_resume(timer);
    self.timer = timer;
}

void timerFire(void *param)
{
    NSLog(@"GCD timer - %@", [NSThread currentThread]);
}
@end
```

æ‰“å°ç»“æœï¼š
```
20:37:01.629410+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1363:25276] -[ViewController viewDidLoad]
20:37:03.629774+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}
20:37:04.629784+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}
20:37:05.629800+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}
......
```

## è‡ªå®šä¹‰é˜Ÿåˆ—
```
@interface ViewController ()
@property (nonatomic, strong) dispatch_source_t timer;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"%s", __func__);
    // è‡ªå®šä¹‰é˜Ÿåˆ—
    dispatch_queue_t queue = dispatch_queue_create("GCDTimer", NULL);
    // åˆ›å»ºå®šæ—¶å™¨
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    // è®¾ç½®æ—¶é—´ï¼ˆå®šæ—¶å™¨ï¼Œå»¶è¿Ÿæ‰§è¡Œæ—¶é—´ï¼Œæ‰§è¡Œæ—¶é—´é—´éš”ï¼Œè¯¯å·®ï¼‰
    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);
    // å›è°ƒ
    dispatch_source_set_event_handler_f(timer, timerFire);
    // å¯åŠ¨å®šæ—¶å™¨
    dispatch_resume(timer);
    self.timer = timer;
}

void timerFire(void *param)
{
    NSLog(@"GCD timer - %@", [NSThread currentThread]);
}
@end
```

æ‰“å°ç»“æœï¼š
```
20:39:58.857389+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1460:28690] -[ViewController viewDidLoad]
20:40:00.857845+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}
20:40:01.857692+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1460:28835] GCD timer - <NSThread: 0x6000021272c0>{number = 6, name = (null)}
20:40:02.857792+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}
......
```

## å°è£… GCD

```
@interface YQGCDTimer : NSObject
/**
block å›è°ƒ
*/
+ (NSString *)execTask:(void(^)(void))task
                 start:(NSTimeInterval)start
              interval:(NSTimeInterval)interval
               repeats:(BOOL)repeats
                 async:(BOOL)async;
/**
å‡½æ•°å›è°ƒ
*/
+ (NSString *)execTaskWithTarget:(id)target
                        selector:(SEL)selector
                           start:(NSTimeInterval)start
                        interval:(NSTimeInterval)interval
                         repeats:(BOOL)repeats
                           async:(BOOL)async;
/**
å–æ¶ˆ
*/
+ (void)cancelTask:(NSString *)name;
@end


NSInteger index_;
static NSMutableDictionary *timers_;
dispatch_semaphore_t semaphore_;

@implementation YQGCDTimer

+ (void)initialize
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        timers_ = [NSMutableDictionary dictionary];
        semaphore_ = dispatch_semaphore_create(1);
        index_ = 0;
    });
}

+ (NSString *)execTask:(void (^)(void))task start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async
{
    if (!task || start < 0 || (interval <= 0 && repeats)) return nil;
    // é˜Ÿåˆ—ï¼ˆå…¨å±€ä¸²è¡Œé˜Ÿåˆ—æˆ–ä¸»é˜Ÿåˆ—ï¼‰
    dispatch_queue_t queue = async ? dispatch_get_global_queue(0, 0) : dispatch_get_main_queue();
    // åˆ›å»ºå®šæ—¶å™¨
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    // è®¾ç½®æ—¶é—´
    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);
    // å›è°ƒ
    dispatch_source_set_event_handler(timer, ^{
        task();
        // ä¸éœ€è¦é‡å¤ä»»åŠ¡
        if (!repeats) {
            dispatch_source_cancel(timer);
        }
    });
    // åŠ é”
    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);
    // å®šæ—¶å™¨å”¯ä¸€æ ‡è¯†
    NSString *identify = [NSString stringWithFormat:@"%ld", (long)index_++];
    // ä¿å­˜
    timers_[identify] = timer;
    // è§£é”
    dispatch_semaphore_signal(semaphore_);
    // å¯åŠ¨å®šæ—¶å™¨
    dispatch_resume(timer);
    return identify;
}

+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async
{
    return [self execTask:^{
        if ([target respondsToSelector:selector]) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
            [target performSelector:selector];
#pragma clang diagnostic pop
        }
    } start:start interval:interval repeats:repeats async:async];
}

+ (void)cancelTask:(NSString *)name
{
    if (name.length == 0) return;
    // åŠ é”
    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);
    dispatch_source_t timer = timers_[name];
    if (timer) {
        dispatch_source_cancel(timer);
        [timers_ removeObjectForKey:name];
    }
    // è§£é”
    dispatch_semaphore_signal(semaphore_);
}
@end
```

è°ƒç”¨ block å›è°ƒæ–¹æ³•ï¼š
```
@interface TimerViewController ()
@property (nonatomic, copy) NSString *task;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"%s", __func__);
    self.task = [YQGCDTimer execTask:^{
        NSLog(@"GCD timer");
    } start:2 interval:1 repeats:YES async:NO];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    [YQGCDTimer cancelTask:self.task];
}
@end
```

è°ƒç”¨å‡½æ•°å›è°ƒæ–¹æ³•ï¼š
```
@interface TimerViewController ()
@property (nonatomic, copy) NSString *task;
@end

@implementation TimerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"%s", __func__);
    self.task = [YQGCDTimer execTaskWithTarget:self selector:@selector(timerTest) start:2 interval:1 repeats:YES async:NO];
}

- (void)timerTest
{
    NSLog(@"%s", __func__);
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    [YQGCDTimer cancelTask:self.task];
}
@end
```

æ‰“å°ç»“æœï¼š
```
21:18:01.050592+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[2321:52592] -[TimerViewController viewDidLoad]
21:18:03.050800+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[2321:52592] GCD timer
21:18:04.050986+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[2321:52592] GCD timer
21:18:05.050943+0800 å†…å­˜ç®¡ç†-å®šæ—¶å™¨[2321:52592] GCD timer
```

å»æ‰è­¦å‘Šï¼š
```
+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async
{
    return [self execTask:^{
        if ([target respondsToSelector:selector]) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
            [target performSelector:selector];
#pragma clang diagnostic pop
        }
    } start:start interval:interval repeats:repeats async:async];
}
```

`"-Warc-performSelector-leaks"` å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼š
![å†…å­˜ç®¡ç†05](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†05.png) 

# iOSç¨‹åºçš„å†…å­˜å¸ƒå±€
* ä»£ç æ®µï¼šç¼–è¯‘ä¹‹åçš„ä»£ç 
* æ•°æ®æ®µï¼š
  å­—ç¬¦ä¸²å¸¸é‡  
  å·²åˆå§‹åŒ–æ•°æ®  
  æœªåˆå§‹åŒ–æ•°æ®
* æ ˆï¼šå‡½æ•°è°ƒç”¨å¼€é”€ï¼Œæ¯”å¦‚å±€éƒ¨å˜é‡ã€‚ï¼ˆåˆ†é…çš„å†…å­˜ç©ºé—´åœ°å€è¶Šæ¥è¶Šå°ï¼‰
* å †ï¼šé€šè¿‡ allocã€mallocã€calloc ç­‰åŠ¨æ€åˆ†é…çš„ç©ºé—´ï¼Œåˆ†é…çš„å†…å­˜ç©ºé—´åœ°å€è¶Šæ¥è¶Šå¤§
![å†…å­˜ç®¡ç†06](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†06.png) 

```
// å·²åˆå§‹åŒ–çš„å…¨å±€å˜é‡
int a = 10;
// æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡
int b;

int main(int argc, char * argv[]) {
    @autoreleasepool {
        // å·²åˆå§‹åŒ–çš„é™æ€å˜é‡
        static int c = 20;
        // æœªåˆå§‹åŒ–çš„é™æ€å˜é‡
        static int d;
        // æ ˆ
        int e;
        int f = 20;
        // å­—ç¬¦ä¸²å¸¸é‡
        NSString *str = @"123";
        // å †
        NSObject *obj = [[NSObject alloc] init];
        
        NSLog(@"\n&a=%p\n&b=%p\n&c=%p\n&d=%p\n&e=%p\n&f=%p\nstr=%p\nobj1=%p\nobj2=%p\n",
              &a, &b, &c, &d, &e, &f, str, obj1, obj2);
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```

æ‰“å°ç»“æœï¼š
```
&a=0x105bbee38
&b=0x105bbef04
&c=0x105bbee3c
&d=0x105bbef00
&e=0x7ffeea042c2c
&f=0x7ffeea042c28
str=0x105bbe070
obj1=0x600002528110
obj2=0x600002528120
```

æ‰“å°ç»“æœè§£æï¼ˆå†…åœ°åœ°å€ä»å°åˆ°å¤§æ’åºï¼‰ï¼š
```
// å­—ç¬¦ä¸²å¸¸é‡
str=0x105bbe070

// å·²åˆå§‹åŒ–çš„å…¨å±€å˜é‡ã€é™æ€å˜é‡
&a=0x105bbee38
&c=0x105bbee3c

// æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ã€é™æ€å˜é‡
&d=0x105bbef00
&b=0x105bbef04

// å †
obj1=0x600002528110
obj2=0x600002528120

// æ ˆ
&f=0x7ffeea042c28
&e=0x7ffeea042c2c
```

å†…å­˜åœ°å€å¤§å°æ¯”è¾ƒï¼š
```
str < a < c < d < b < obj1 < obj2 < f < e 
```

æ•°æ®æ®µï¼šstr < a < c < d < bï¼Œç©ºé—´åœ°å€è¶Šæ¥è¶Šå¤§ã€‚   
å †åŒºï¼šobj1 æ¯” b å¤šäº†3ä½æ•°ï¼Œè¿™3ä½æ•°çš„ç©ºé—´éƒ½å±äºæ•°æ®æ®µã€‚obj1 çš„å†…å­˜åœ°å€é¦–ä½æ•°å­—ä¸º6ï¼Œobj1 < obj2ï¼Œåˆ†é…çš„å†…å­˜ç©ºé—´è¶Šæ¥è¶Šå¤§ï¼ˆè¶Šæ¥è¶Šé€¼è¿‘æ ˆåŒºï¼‰ã€‚  
æ ˆåŒºï¼še çš„å†…å­˜åœ°å€é¦–ä½æ•°å­—ä¸º7ï¼Œf < eï¼Œåˆ†é…çš„å†…å­˜ç©ºé—´è¶Šæ¥è¶Šå°ï¼ˆè¶Šæ¥è¶Šé€¼è¿‘å †åŒºï¼‰ã€‚  

# Tagged Pointer

* ä»64bitå¼€å§‹ï¼ŒiOS å¼•å…¥äº† Tagged Pointer æŠ€æœ¯ï¼Œç”¨äºä¼˜åŒ– NSNumberã€NSDateã€NSString ç­‰å°å¯¹è±¡çš„å­˜å‚¨ã€‚
* åœ¨æ²¡æœ‰ä½¿ç”¨ Tagged Pointer ä¹‹å‰ï¼ŒNSNumber ç­‰å¯¹è±¡éœ€è¦åŠ¨æ€åˆ†é…å†…å­˜ã€ç»´æŠ¤å¼•ç”¨è®¡æ•°ç­‰ï¼ŒNSNumber ç­‰å¯¹è±¡çš„æŒ‡é’ˆå­˜å‚¨çš„æ˜¯å †ä¸­ NSNumber å¯¹è±¡çš„åœ°å€å€¼ã€‚
* ä½¿ç”¨ Tagged Pointer ä¹‹åï¼ŒNSNumber æŒ‡é’ˆé‡Œé¢å­˜å‚¨çš„æ•°æ®å˜æˆäº†ï¼šTag + Dataï¼Œä¹Ÿå°±æ˜¯å°†æ•°æ®ç›´æ¥å­˜å‚¨åœ¨äº†æŒ‡é’ˆä¸­ã€‚
* å½“æŒ‡é’ˆä¸å¤Ÿå­˜å‚¨æ•°æ®æ—¶ï¼Œæ‰ä¼šä½¿ç”¨åŠ¨æ€åˆ†é…å†…å­˜çš„æ–¹å¼æ¥å­˜å‚¨æ•°æ®ã€‚
* `objc_msgSend()` èƒ½è¯†åˆ« Tagged Pointerï¼Œæ¯”å¦‚ NSNumber çš„ intValue æ–¹æ³•ï¼Œç›´æ¥ä»æŒ‡é’ˆæå–æ•°æ®ï¼ŒèŠ‚çœäº†ä»¥å‰çš„è°ƒç”¨å¼€é”€ã€‚
* å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªæŒ‡é’ˆæ˜¯å¦ä¸ºTagged Pointerï¼Ÿ  
  iOSå¹³å°ï¼Œæœ€é«˜æœ‰æ•ˆä½æ˜¯1ï¼ˆç¬¬64bitï¼‰  
  Macå¹³å°ï¼Œæœ€ä½æœ‰æ•ˆä½æ˜¯1  

## NSNumber
```
int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        
        NSNumber *number1 = @4;
        NSNumber *number2 = @5;
        NSNumber *number3 = @(0xFFFFFFFFFFFFFFFF);
        NSLog(@"%p %p %p", number1, number2, number3);
        
        int a = [number1 intValue];

        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
```

æ‰“å°ç»“æœï¼š
```
0xb0d1e4bcdb858740 0xb0d1e4bcdb858750 0x600000b4c080
```

`0xb0d1e4bcdb858740` å’Œ `0xb0d1e4bcdb858750` å»æ‰å‰é¢ç›¸åŒçš„éƒ¨åˆ†åæ˜¯ `0x40` å’Œ `0x50`ï¼Œå¯ä»¥çœ‹å‡ºæ•°æ®ç›´æ¥å­˜å‚¨åœ¨äº†æŒ‡é’ˆä¸­ã€‚å½“æŒ‡é’ˆä¸å¤Ÿå­˜å‚¨æ•°æ®æ—¶ï¼Œå¦‚ `@(0xFFFFFFFFFFFFFFFF)` æ‰“å°å‡ºæ¥çš„å†…å­˜åœ°å€æ˜¯ `0x600000b4c080`ï¼ˆå †ç©ºé—´é‡Œ NSNumber å¯¹è±¡çš„åœ°å€å€¼ï¼‰ï¼Œæ˜¯ä½¿ç”¨äº†åŠ¨æ€åˆ†é…å†…å­˜çš„æ–¹å¼æ¥å­˜å‚¨æ•°æ®ã€‚

å› ä¸º `objc_msgSend()` èƒ½è¯†åˆ« Tagged Pointerï¼Œæ‰€ä»¥åœ¨ number1 è°ƒç”¨ `intValue` æ–¹æ³•æ—¶ï¼Œ`objc_msgSend()` ç›´æ¥ä»æŒ‡é’ˆæå–æ•°æ®ã€‚
```
int a = [number1 intValue];
```

å¯ä»¥çœ‹å‡º Tagged Pointer æŠ€æœ¯ä¸ä»…ä»…æ˜¯å†…å­˜ç©ºé—´çš„ä¼˜åŒ–ï¼Œä¹Ÿå¯¹ä½¿ç”¨è¿‡ç¨‹è¿›è¡Œäº†ä¼˜åŒ–ã€‚

## NSString

### ä¾‹ä¸€ï¼š
```
@interface ViewController ()
@property (nonatomic, copy) NSString *name;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i=0; i<1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abcdefghijk"];
        });
    }
}
@end
```

è¿è¡ŒåæŠ¥é”™ï¼ˆåå†…å­˜è®¿é—®ï¼‰ï¼š
![å†…å­˜ç®¡ç†07](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†07.png)

å› ä¸º `name` æ˜¯éåŸå­æ€§ï¼ˆ`nonatomic`ï¼‰çš„ï¼Œå¤šæ¡çº¿ç¨‹åŒæ—¶è®¿é—® `name` çš„ set æ–¹æ³•æ—¶ï¼Œå¦‚æœæœ‰ä¸€æ¡çº¿ç¨‹å·²ç»å°† `_name` é‡Šæ”¾äº†ï¼Œå…¶å®ƒçº¿ç¨‹å†æ¬¡å¯¹ `_name` è¿›è¡Œé‡Šæ”¾æ“ä½œå°±ä¼šå‡ºç°åå†…å­˜è®¿é—®çš„é”™è¯¯ï¼š
```
- (void)setName:(NSString *)name
{
    if (_name != name) {
        [_name release]; // å¤šæ¡çº¿ç¨‹åŒæ—¶æ“ä½œè¿™ä¸€è¡Œï¼Œå¦‚æœ `_name` å·²ç»è¢«é‡Šæ”¾äº†ï¼Œå…¶å®ƒçº¿ç¨‹å†æ¬¡å¯¹ `_name` è¿›è¡Œ release æ“ä½œï¼Œåå†…å­˜è®¿é—®
        _name = [name copy];
    }
}
```

#### è§£å†³æ–¹æ¡ˆä¸€ï¼š
å°† `name` æ”¹æˆåŸå­æ€§çš„ï¼š
```
@property (atomic, copy) NSString *name;
```

ç¨‹åºè¿è¡Œæ­£å¸¸ã€‚

å°† `name` æ”¹æˆåŸå­æ€§åï¼Œ`name` çš„ set æ–¹æ³•å°±æ˜¯çº¿ç¨‹å®‰å…¨çš„äº†ï¼Œä¸ä¼šå‡ºç°å¤šæ¡çº¿ç¨‹åŒæ—¶å¯¹ `name` è¿›è¡Œ release æ“ä½œã€‚

#### è§£å†³æ–¹æ¡ˆäºŒï¼š
å°† `name` æ”¹æˆåŸå­æ€§åï¼Œä»»ä½•åœ°æ–¹ã€ä»»ä½•æ—¶å€™è°ƒç”¨ `name` çš„ get æ–¹æ³•éƒ½æ˜¯æœ‰é”çš„ã€‚å› ä¸º `name` åªéœ€è¦åœ¨å¼‚æ­¥çº¿ç¨‹è®¿é—®æ—¶åŠ é”ï¼Œå¦‚æœåœ¨ä¸»çº¿ç¨‹çš„è¯æ²¡æœ‰å¿…è¦åŠ é”ï¼Œæ‰€ä»¥ä¸ä½¿ç”¨ `atomic` è€Œæ˜¯é€‰æ‹©æ‰‹åŠ¨åŠ é”ï¼Œå“ªé‡Œéœ€è¦å°±åœ¨å“ªé‡ŒåŠ é”ï¼Œå°½å¯èƒ½çš„æå‡æ•ˆç‡èŠ‚çœèµ„æºï¼š
```
/// åŠ é”
#define SemaphoreBegin \
static dispatch_semaphore_t semaphore; \
static dispatch_once_t onceToken; \
dispatch_once(&onceToken, ^{ \
    semaphore = dispatch_semaphore_create(1); \
}); \
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
/// è§£é”
#define SemaphoreEnd \
dispatch_semaphore_signal(semaphore);

@interface ViewController ()
@property (nonatomic, copy) NSString *name;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i=0; i<1000; i++) {
        dispatch_async(queue, ^{
            // åŠ é”
            SemaphoreBegin;
            self.name = [NSString stringWithFormat:@"abcdefghijk"];
            // è§£é”
            SemaphoreEnd;
        });
    }
}
@end
```

ç¨‹åºè¿è¡Œæ­£å¸¸ã€‚

### ä¾‹äºŒï¼š  
å°† `@"abcdefghijk"` æ”¹æˆ `@"abc"`ï¼š
```
@interface ViewController ()
@property (nonatomic, copy) NSString *name;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i=0; i<1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abc"];
        });
    }
}
@end
```

è¿è¡Œæ­£å¸¸ã€‚  

åŒæ ·æ˜¯å¤šçº¿ç¨‹è®¿é—®ã€æ²¡æœ‰åŠ é”ï¼Œä½†æ˜¯å°† `@"abcdefghijk"` æ”¹æˆ `@"abc"` åï¼Œå°±ä¸ä¼šå‡ºç°åå†…å­˜è®¿é—®çš„é”™è¯¯ï¼Œéš¾é“æ˜¯æ²¡æœ‰è°ƒç”¨ `name` çš„ set æ–¹æ³•å—ï¼Ÿæ˜¯çš„ã€‚
```
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSString *str1 = [NSString stringWithFormat:@"abcdefghijk"];
    NSString *str2 = [NSString stringWithFormat:@"abc"];
    NSLog(@"%p %p", str1, str2);
    NSLog(@"%@ %@", [str1 class], [str2 class]);
}
@end
```

æ‰“å°ç»“æœï¼š
```
0x600002aefdc0 0x9cedd15798132057
__NSCFString NSTaggedPointerString
```

str1 æ˜¯ä¸€ä¸ª `__NSCFString`ï¼Œå…¶å†…å­˜åœ°å€æ˜¯6å¼€å¤´çš„ï¼Œè¯´æ˜ str1 æ˜¯å­˜å‚¨åœ¨å †ç©ºé—´é‡Œçš„ã€‚  
str2 æ˜¯ä¸€ä¸ª `NSTaggedPointerString`ï¼Œ`@"abc"` å­˜å‚¨åœ¨ str2 æŒ‡é’ˆé‡Œï¼Œä¸ä¼šè°ƒç”¨ set æ–¹æ³•ï¼Œå–å€¼æ—¶ä¹Ÿä¸ä¼šè°ƒç”¨ get æ–¹æ³•è€Œæ˜¯ç›´æ¥ä»æŒ‡é’ˆé‡Œå–å€¼ã€‚

## åˆ¤æ–­æ˜¯å¦æ˜¯ Tagged Pointer

[objc4-781](https://opensource.apple.com/tarballs/objc4/) çš„ objc-internal.h æ–‡ä»¶é‡Œï¼š

`_OBJC_TAG_MASK` å®šä¹‰ï¼š
```
#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__
    // 64-bit Mac - tag bit is LSB
#   define OBJC_MSB_TAGGED_POINTERS 0 // Mac
#else
    // Everything else - tag bit is MSB
#   define OBJC_MSB_TAGGED_POINTERS 1 // iPhoneï¼ˆçœŸæœº/æ¨¡æ‹Ÿå™¨ï¼‰
#endif

#if OBJC_MSB_TAGGED_POINTERS
#   define _OBJC_TAG_MASK (1UL<<63) 
#else
#   define _OBJC_TAG_MASK 1UL 
#endif
```

åˆ¤æ–­æ˜¯å¦æ˜¯ tagged pointerï¼š
```
static inline bool 
_objc_isTaggedPointer(const void * _Nullable ptr)
{
    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}
```

å¦‚æœæ˜¯ macï¼Œ`_OBJC_TAG_MASK` ç­‰äº1ã€‚å¦‚æœä¸æ˜¯ macï¼Œ `_OBJC_TAG_MASK` ç­‰äº 1UL<<63ã€‚`_OBJC_TAG_MASK` å’ŒæŒ‡é’ˆåœ°å€è¿›è¡Œä¸è¿ç®—ï¼Œåˆ¤æ–­ç»“æœæ˜¯å¦æ˜¯ `_OBJC_TAG_MASK`ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œé‚£è¿™ä¸ªæŒ‡é’ˆå°±æ˜¯ tagged pointerã€‚  
åœ¨ iOS å¹³å°ï¼Œå¦‚æœæŒ‡é’ˆè½¬æˆ2è¿›åˆ¶åå®ƒçš„æœ€é«˜ä½ï¼ˆ64ä½ï¼‰ä¸º1çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªæŒ‡é’ˆå°±æ˜¯ tagged pointerã€‚  
åœ¨ Mac å¹³å°ï¼Œå¦‚æœæŒ‡é’ˆè½¬æˆ2è¿›åˆ¶åå®ƒçš„æœ€ä½ä½ä¸º1çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªæŒ‡é’ˆå°±æ˜¯ tagged pointerã€‚

# MRC
* åœ¨ iOS ä¸­ï¼Œä½¿ç”¨å¼•ç”¨è®¡æ•°æ¥ç®¡ç† OC å¯¹è±¡çš„å†…å­˜ã€‚  
* ä¸€ä¸ªæ–°åˆ›å»ºçš„ OC å¯¹è±¡å¼•ç”¨è®¡æ•°é»˜è®¤æ˜¯1ï¼Œå½“å¼•ç”¨è®¡æ•°å‡ä¸º0ï¼ŒOC å¯¹è±¡å°±ä¼šé”€æ¯ï¼Œé‡Šæ”¾å…¶å ç”¨çš„å†…å­˜ç©ºé—´ã€‚  
* è°ƒç”¨ retain ä¼šè®© OC å¯¹è±¡çš„å¼•ç”¨è®¡æ•°+1ï¼Œè°ƒç”¨ release ä¼šè®© OC å¯¹è±¡çš„å¼•ç”¨è®¡æ•°-1ã€‚  
* å†…å­˜ç®¡ç†çš„ç»éªŒæ€»ç»“ï¼š  
  å½“è°ƒç”¨ allocã€newã€copyã€mutableCopy æ–¹æ³•è¿”å›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨ä¸éœ€è¦è¿™ä¸ªå¯¹è±¡æ—¶ï¼Œè¦è°ƒç”¨ release æˆ–è€… autorelease æ¥é‡Šæ”¾å®ƒã€‚  
  æƒ³æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•°+1ï¼›ä¸æƒ³å†æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•°-1ã€‚  
* å¯ä»¥é€šè¿‡ä»¥ä¸‹ç§æœ‰å‡½æ•°æ¥æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± çš„æƒ…å†µ  
  ```
  extern void _objc_autoreleasePoolPrint(void);
  ```

ğŸ‘‰ ä½¿ç”¨ MRCï¼šBuild Setting -> Objective-C Automatic Referencd Counting è®¾ç½®ä¸º YESã€‚

å®šä¹‰ Person ç±»ï¼š
```
@interface Person : NSObject
@end

@implementation Person
- (void)dealloc
{
    [super dealloc];
    NSLog(@"%s", __func__);
}
@end
```

## release

åˆ›å»º person å¯¹è±¡ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[Person alloc] init]; // Person *person = [Person new];
        NSLog(@"%zd", person.retainCount);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
 1
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œperson å¯¹è±¡è°ƒç”¨å®Œ `alloc` æ–¹æ³•åå¼•ç”¨è®¡æ•°æ˜¯1ï¼Œæ²¡æœ‰è¢«é‡Šæ”¾ã€‚

æ·»åŠ  releaseï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[Person alloc] init];
        
        // ä½¿ç”¨ person å¯¹è±¡
        NSLog(@"%zd", person.retainCount);

        [person release];
        NSLog(@"111");
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
 1
 -[Person dealloc]
 111
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œå› ä¸º person å¯¹è±¡è°ƒç”¨å®Œ `alloc` æ–¹æ³•åå¼•ç”¨è®¡æ•°æ˜¯1ï¼Œè°ƒç”¨å®Œ `release` æ–¹æ³•åå¼•ç”¨è®¡æ•°å‡1ç­‰äº0ï¼Œæ‰€ä»¥ person å¯¹è±¡åœ¨è°ƒç”¨ `release` çš„é‚£ä¸€åˆ»å°±è¢«é‡Šæ”¾äº†ã€‚

MRC ä¸‹ `alloc` æ–¹æ³•å’Œ `release` æ–¹æ³•æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œæ¯ä¸ªå¯¹è±¡ä½¿ç”¨å®Œæˆåéƒ½è¦è°ƒç”¨ä¸€ä¸‹ `release` æ–¹æ³•ï¼Œè¿™æ ·æ‰èƒ½é¿å…å†…å­˜æ³„æ¼ã€‚å¦å¤–ï¼Œåœ¨ä½¿ç”¨ `release` æ–¹æ³•ç®¡ç† person å¯¹è±¡æ—¶ï¼Œè¦ä¿è¯åœ¨è°ƒç”¨ `release` æ–¹æ³•ä¹‹å‰ä½¿ç”¨ person å¯¹è±¡ã€‚

## autorelease
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[[Person alloc] init] autorelease];
        NSLog(@"%zd", person.retainCount);
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
1
111
-[Person dealloc]
222
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œå› ä¸º person å¯¹è±¡è°ƒç”¨å®Œ `alloc` æ–¹æ³•åˆè°ƒç”¨äº† `autorelease` åå¼•ç”¨è®¡æ•°æ˜¯1ï¼Œç›´åˆ° `@autoreleasepool {}` æ‰§è¡Œå®Œé‚£ä¸€åˆ»æ‰è¢«é‡Šæ”¾ã€‚  

åœ¨ `@autoreleasepool {}` æ‰§è¡Œå®Œé‚£ä¸€åˆ»ï¼Œä¼šå¯¹è°ƒç”¨äº† `autorelease` æ–¹æ³•çš„å¯¹è±¡è¿›è¡Œ `release` æ“ä½œï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person1 = [[[Person alloc] init] autorelease];
        Person *person2 = [[[Person alloc] init] autorelease];
        NSLog(@"111");
    } // [person release]ã€[person release]
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
111
-[Person dealloc]
-[Person dealloc]
222
```

ä½¿ç”¨ `autorelease` æ–¹æ³•ç®¡ç† person å¯¹è±¡çš„å†…å­˜ï¼Œåªéœ€è¦åœ¨è°ƒç”¨ `alloc` æ–¹æ³•çš„åŒæ—¶è°ƒç”¨ä¸€ä¸‹ `autorelease` æ–¹æ³•ï¼Œå°±å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨ person å¯¹è±¡äº†ï¼Œå½“ç„¶æ˜¯åœ¨ `@autoreleasepool {}` å†…éƒ¨ä½¿ç”¨ã€‚ä¸ç”¨å†å…³å¿ƒ person å¯¹è±¡çš„é‡Šæ”¾é—®é¢˜ï¼Œåœ¨ `@autoreleasepool {}` æ‰§è¡Œå®Œé‚£ä¸€åˆ»ï¼Œperson å¯¹è±¡ä¼šè‡ªåŠ¨è°ƒç”¨ `release` æ–¹æ³•ã€‚

## retain

é”™è¯¯æ¼”ç¤ºï¼š
```
// Dog
@interface Dog : NSObject
- (void)run;
@end

@implementation Dog
- (void)dealloc
{
    [super dealloc];
    NSLog(@"%s", __func__);
}

- (void)run
{
    NSLog(@"%s", __func__);
}
@end

// Person
@interface Person : NSObject
{
    Dog *_dog;
}
- (void)setDog:(Dog *)dog;
- (Dog *)dog;
@end

@implementation Person
- (void)dealloc
{
    [super dealloc];
    NSLog(@"%s", __func__);
}

- (void)setDog:(Dog *)dog
{
    _dog = dog;
}

- (Dog *)dog
{
    return _dog;
}
@end

// è°ƒç”¨
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Dog *dog = [[Dog alloc] init]; // å¼•ç”¨è®¡æ•°ï¼š1
        Person *person = [[Person alloc] init];
        [person setDog:dog];
        
        [dog release]; // å¼•ç”¨è®¡æ•°ï¼š0
        
        [[person dog] run];
        
        [person release];
        
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ä¿¡æ¯ï¼š
```
 -[Dog dealloc]
```

`[[person dog] run]` è¿™ä¸ªæ—¶å€™ dog å¯¹è±¡å› ä¸ºå¼•ç”¨è®¡æ•°ä¸º0å·²ç»è¢«é‡Šæ”¾äº†ã€‚
![å†…å­˜ç®¡ç†08](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†08.png)

`[person setDog:dog]` æ–¹æ³•è¡¨ç¤º person å¯¹è±¡æƒ³è¦ç”¨äº dog å¯¹è±¡ï¼Œé‚£ä¹ˆ person å¯¹è±¡åº”è¯¥å¯¹ dog çš„å¼•ç”¨è®¡æ•°åŠ 1ï¼Œåªè¦ person å¯¹è±¡è¿˜åœ¨ï¼Œdog å¯¹è±¡å°±ä¸å¯ä»¥è¢«é‡Šæ”¾ã€‚

ä¸Šé¢çš„å†™æ³•æœ‰ä¸¤ä¸ªåœ°æ–¹éœ€è¦ä¼˜åŒ–ï¼š  
1ã€Person ç±»çš„ `- (void)setDog:(Dog *)dog` æ–¹æ³•åœ¨è·å– dog å¯¹è±¡æ—¶ï¼Œå¼•ç”¨è®¡æ•°éœ€è¦åŠ 1ã€‚  
2ã€Person ç±»çš„ `- (void)dealloc` æ–¹æ³•éœ€è¦å¯¹ dog å¯¹è±¡è¿›è¡Œ `release` æ“ä½œã€‚  

Person ç±»ä¼˜åŒ–åï¼š
```
@implementation Person
- (void)dealloc
{
    [_dog release];
    _dog = nil;
    
    [super dealloc]; // çˆ¶ç±»çš„ dealloc æ”¾åˆ°å­ç±»å
    NSLog(@"%s", __func__);
}

- (void)setDog:(Dog *)dog
{
    _dog = [dog retain];
}

- (Dog *)dog
{
    return _dog;
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[Dog run]
-[Dog dealloc]
-[Person dealloc]
111
222
```

åˆ›å»ºä¸¤ä¸ª person å¯¹è±¡å¼•ç”¨ dog å¯¹è±¡ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Dog *dog = [[Dog alloc] init]; // dog å¼•ç”¨è®¡æ•°ï¼š1
        
        Person *person1 = [[Person alloc] init];
        [person1 setDog:dog]; // dog å¼•ç”¨è®¡æ•°ï¼š2
        
        Person *person2 = [[Person alloc] init];
        [person2 setDog:dog]; // dog å¼•ç”¨è®¡æ•°ï¼š3
        
        [dog release]; // dog å¼•ç”¨è®¡æ•°ï¼š2
        
        [person1 release]; // dog å¼•ç”¨è®¡æ•°ï¼š1
        
        [[person2 dog] run];
        
        [person2 release]; // dog å¼•ç”¨è®¡æ•°ï¼š0
        
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
-[Person dealloc]
-[Dog run]
-[Dog dealloc]
-[Person dealloc]
111
222
```

## set æ–¹æ³•

ä¸Šé¢ Person ç±»é‡Œçš„ set æ–¹æ³•è¿˜æœ‰é—®é¢˜ï¼Œåœ¨ person å¯¹è±¡æ›¿æ¢ dog å¯¹è±¡æ—¶ä¼šå‡ºç°ä¸é‡Šæ”¾çš„é—®é¢˜ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Dog *dog1 = [[Dog alloc] init]; // dog1 : 1
        Dog *dog2 = [[Dog alloc] init]; // dog2 : 1
        Person *person = [[Person alloc] init];
        
        [person setDog:dog1]; // dog1 : 2
        [person setDog:dog2]; // dog2 : 2
        
        [dog1 release]; // dog1 : 1
        [dog2 release]; // dog2 : 1
        [person release]; // dog0 : 0
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
-[Dog dealloc]
-[Person dealloc]
111
222
```

ä»æ‰“å°ç»“æœå’Œæ³¨é‡Šå¯ä»¥çœ‹åˆ°ï¼Œdog1 æœ€åçš„å¼•ç”¨è®¡æ•°æ˜¯1ï¼Œæ²¡æœ‰é‡Šæ”¾ã€‚è¿™æ˜¯å› ä¸º person å¯¹è±¡åœ¨æ‹¥æœ‰ dog1 æ—¶ï¼Œå°† `_dog` æŒ‡å‘äº† dog1 å¹¶å¯¹å…¶å¼•ç”¨è®¡æ•°åŠ 1ï¼Œååˆå°† `_dog` æŒ‡å‘äº† dog2 å¹¶å¯¹å…¶å¼•ç”¨è®¡æ•°åŠ 1ï¼Œæ‰€ä»¥ person å¯¹è±¡åœ¨è°ƒç”¨ `[_dog release]` æ—¶çš„ `_dog` æ˜¯ dog2 å¯¹è±¡ï¼Œdog1 å¯¹è±¡å› æ­¤å°‘è°ƒç”¨äº†ä¸€æ¬¡ release æ–¹æ³•ï¼Œæœ€åçš„å¼•ç”¨è®¡æ•°æœ€åä¸º1æ— æ³•é‡Šæ”¾ã€‚

ä¼˜åŒ– set æ–¹æ³•ï¼šåœ¨ person å¯¹è±¡å¼•ç”¨æ–°çš„ dog å¯¹è±¡æ—¶ï¼Œéœ€è¦å…ˆå°†ä¹‹å‰çš„ dog å¯¹è±¡è¿›è¡Œ release æ“ä½œã€‚
```
@implementation Person
- (void)dealloc
{
    [_dog release];
    _dog = nil;
    
    [super dealloc];
    NSLog(@"%s", __func__);
}

- (void)setDog:(Dog *)dog
{
    [_dog release];
    _dog = [dog retain];
}

- (Dog *)dog
{
    return _dog;
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[Dog dealloc]
-[Dog dealloc]
-[Person dealloc]
111
222
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œdog1 å’Œ dog2 å¯¹è±¡éƒ½è¢«é‡Šæ”¾è°ƒç”¨ã€‚ä½†æ˜¯ä¼˜åŒ–åçš„ set æ–¹æ³•è¿˜ä¸å¤Ÿå®Œå–„ï¼Œperson å¯¹è±¡åœ¨é‡å¤è®¾ç½®åŒä¸€ä¸ª dog å¯¹è±¡çš„æ—¶å€™è¿˜æ˜¯æœ‰é—®é¢˜ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Dog *dog = [[Dog alloc] init]; // dog1 : 1
        Person *person = [[Person alloc] init];
        
        [person setDog:dog]; // dog1 : 2
        
        [dog release]; // dog1 : 1
        
        [person setDog:dog]; // dog1 : 0
        
        [person release];
        
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

é”™è¯¯ä¿¡æ¯ï¼š
![å†…å­˜ç®¡ç†09](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†09.png)

é—®é¢˜å‡ºåœ¨ Person ç±»çš„ set æ–¹æ³•ï¼š  
ç¬¬ä¸€æ¬¡èµ‹å€¼ï¼Œdog å¯¹è±¡çš„å¼•ç”¨è®¡æ•°åŠ ä¸€ï¼Œæ­¤æ—¶ dog å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ç­‰äº2ã€‚  
dog å¯¹è±¡è°ƒç”¨äº†ä¸€æ¬¡ release æ–¹æ³•ï¼Œæ­¤æ—¶ dog å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ç­‰äº1ã€‚  
ç¬¬äºŒæ¬¡èµ‹å€¼ï¼Œä¼šå…ˆè°ƒç”¨ `[_dog release]`, æ­¤æ—¶ dog å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ç­‰äº0ï¼Œdog å¯¹è±¡è¢«é‡Šæ”¾ã€‚å†è°ƒç”¨ `_dog = [dog retain]`ï¼Œæ­¤æ—¶ dog æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é”€æ¯äº†ï¼š
```
- (void)setDog:(Dog *)dog
{
    [_dog release]; // dog : 0
    _dog = [dog retain]; // dog æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é”€æ¯
}
```

å› æ­¤ï¼Œåœ¨ set æ–¹æ³•é‡Œå¯¹ `_dog` å¤„ç†å‰ï¼Œéœ€è¦å…ˆåˆ¤æ–­ä¸€ä¸‹ `_dog` æ˜¯å¦ç­‰äºä¼ å…¥çš„ dog å¯¹è±¡ã€‚å› ä¸ºä¸€ä¸ª person å¯¹è±¡åœ¨æ‹¥æœ‰ä¸€ä¸ª dog å¯¹è±¡æ—¶åªéœ€è¦å¯¹å…¶ retain ä¸€æ¬¡ï¼Œæ‰€ä»¥å¦‚æœ `_dog == dog` å°±ä¸åšå¤„ç†ã€‚

ä¼˜åŒ– Person ç±»é‡Œçš„ set æ–¹æ³•ï¼š
```
@implementation Person
- (void)dealloc
{
    self.dog = nil;
    
    [super dealloc];
    NSLog(@"%s", __func__);
}

- (void)setDog:(Dog *)dog
{
    if (_dog != dog) {
        [_dog release];
        _dog = [dog retain];
    }
}

- (Dog *)dog
{
    return _dog;
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[Dog dealloc]
-[Person dealloc]
111
222
```

## property å±æ€§

åœ¨ .h æ–‡ä»¶é€šè¿‡ property å£°æ˜çš„å±æ€§ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆæˆå‘˜å˜é‡å’Œå±æ€§çš„ setterã€getter å®ç°ã€‚

## åŸºæœ¬æ•°æ®ç±»å‹
```
@interface Person : NSObject
@property (nonatomic, assign) int age;
@end
```

ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆï¼š
```
@implementation Person

@synthesize age = _age;

- (void)setAge:(int)age
{
    _age = age;
}

- (int)age
{
    return _age;
}
@end
```

## å¯¹è±¡ç±»å‹
```
@interface Person : NSObject
@property (nonatomic, retain) Dog *dog;
@end
```

ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆï¼š
```
@implementation Person

@synthesize dog = _dog;

- (void)setDog:(Dog *)dog
{
    if (_dog != dog) {
        [_dog release];
        _dog = [dog retain];
    }
}

- (Dog *)dog
{
    return _dog;
}
@end
```

å¦‚æœæ˜¯åœ¨ MRC ç¯å¢ƒä¸‹ï¼Œè¿™ç§æƒ…å†µä¸‹è¿˜éœ€è¦åœ¨ delloc æ–¹æ³•é‡Œæ‰‹åŠ¨è°ƒç”¨ _dog çš„ release æ–¹æ³•ï¼š
```
@implementation Person
- (void)dealloc
{
    self.dog = nil;
    
    [super dealloc];
    NSLog(@"%s", __func__);
}
@end
```

## å¸¸ç”¨ä»£ç è§£æ

åˆ›å»ºä¸€ä¸ª iOS é¡¹ç›®ï¼Œè®¾ç½® MRC ç¯å¢ƒã€‚

```
@interface ViewController ()
@property (nonatomic, retain) NSMutableArray *data;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSMutableArray *data = [[NSMutableArray alloc] init];
    self.data = data;
    [data release];
}

- (void)dealloc
{
    self.data = nil;
    
    [super dealloc];
}
@end
```

ç®€åŒ–ï¼š
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.data = [[NSMutableArray alloc] init];
    [self.data release];
}
```

`autorelease`ï¼š
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.data = [[[NSMutableArray alloc] init] autorelease];
}
```

`+array`ï¼š
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.data = [NSMutableArray array];
}
```

ä¸æ˜¯é€šè¿‡ `alloc` æ–¹æ³•åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯é€šè¿‡ç±»æ–¹æ³•åˆå§‹åŒ–çš„ï¼Œåœ¨ç±»æ–¹æ³•å†…éƒ¨å·²ç»è°ƒç”¨è¿‡ `autorelease` äº†ã€‚ç±»æ–¹æ³• `+array` å¤§æ¦‚æ˜¯è¿™æ ·ï¼š
```
@implementation NSMutableArray
+ (instancetype)array
{
    return [[[NSMutableArray alloc] init] autorelease];
}
@end
```

## å·¥å‚æ–¹æ³•
```
@interface Person : NSObject
+ (instancetype)person;
@end

@implementation Person
+ (instancetype)person
{
    return [[[Person alloc] init] autorelease];
}

- (void)dealloc
{
    [super dealloc];
    NSLog(@"%s", __func__);
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        Person *person = [Person person];
        NSLog(@"111");
    }
    NSLog(@"222");
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
111
-[Person dealloc]
222
```

# copyå’ŒmutableCopy

* æ‹·è´çš„ç›®çš„ï¼šäº§ç”Ÿä¸€ä¸ªå‰¯æœ¬å¯¹è±¡ï¼Œè·ŸåŸå¯¹è±¡äº’ä¸å½±å“  
  ä¿®æ”¹äº†åŸå¯¹è±¡ï¼Œä¸ä¼šå½±å“å‰¯æœ¬å¯¹è±¡  
  ä¿®æ”¹äº†å‰¯æœ¬å¯¹è±¡ï¼Œä¸ä¼šå½±å“åŸå¯¹è±¡  

* iOS æä¾›äº†ä¸¤ä¸ªæ‹·è´æ–¹æ³•  
  1ã€copyï¼Œä¸å¯å˜æ‹·è´ï¼Œäº§ç”Ÿä¸å¯å˜å‰¯æœ¬  
  2ã€mutableCopyï¼Œå¯å˜æ‹·è´ï¼Œäº§ç”Ÿå¯å˜å‰¯æœ¬  

## æ‹·è´
### NSString
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [NSString stringWithFormat:@"test"];
        NSString *str2 = [str1 copy]; // è¿”å›çš„æ˜¯ NSString
        NSMutableString *str3 = [str1 mutableCopy]; // è¿”å›çš„æ˜¯ NSMutableString

        NSLog(@"%@ %@ %@", str1, str2, str3);
        NSLog(@"%d %d %d",
              [str1 isKindOfClass:[NSMutableString class]],
              [str2 isKindOfClass:[NSMutableString class]],
              [str3 isKindOfClass:[NSMutableString class]]);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
test test test
0 0 1
```

str1ã€str2 å’Œ str3 æ‰“å°å‡ºæ¥éƒ½æ˜¯ testï¼Œä½†æ˜¯ str1 å’Œ str2 æ˜¯ä¸å¯å˜å­—ç¬¦ä¸²ï¼Œstr3 æ˜¯å¯å˜å­—ç¬¦ä¸²ã€‚å³ï¼š  
[ä¸å¯å˜ copy] -> ä¸å¯å˜  
[ä¸å¯å˜ mutableCopy] -> å¯å˜  

### NSMutableString
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableString *str1 = [NSMutableString stringWithFormat:@"test"];
        NSString *str2 = [str1 copy];
        NSMutableString *str3 = [str1 mutableCopy];
        
        NSLog(@"%@ %@ %@", str1, str2, str3);
        NSLog(@"%d %d %d",
              [str1 isKindOfClass:[NSMutableString class]],
              [str2 isKindOfClass:[NSMutableString class]],
              [str3 isKindOfClass:[NSMutableString class]]);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
test test test
1 0 1
```

ä¸ç®¡æ˜¯å¯å˜å­—ç¬¦ä¸²è¿˜æ˜¯ä¸å¯å˜å­—ç¬¦ä¸²ï¼Œè°ƒç”¨ `copy` è¿”å›çš„éƒ½æ˜¯ä¸å¯å˜å­—ç¬¦ä¸²ï¼Œè°ƒç”¨ `mutableCopy` è¿”å›çš„éƒ½æ˜¯å¯å˜å­—ç¬¦ä¸²ã€‚

### å†…å­˜ç®¡ç†
åœ¨ MRC ç¯å¢ƒä¸‹ï¼Œè°ƒç”¨ allocã€newã€copyã€mutableCopy æ–¹æ³•è¿”å›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨ä¸éœ€è¦è¿™ä¸ªå¯¹è±¡æ—¶ï¼Œè¦è°ƒç”¨ release æˆ–è€… autorelease æ¥é‡Šæ”¾å®ƒã€‚

```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [[NSString alloc] initWithString:@"test"];
        NSString *str2 = [str1 copy];
        NSMutableString *str3 = [str1 mutableCopy];

        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

## æ·±æ‹·è´å’Œæµ…æ‹·è´

* æ·±æ‹·è´ï¼šå†…å®¹æ‹·è´ï¼Œäº§ç”Ÿæ–°çš„å¯¹è±¡
* æµ…æ‹·è´ï¼šæŒ‡é’ˆæ‹·è´ï¼Œæ²¡æœ‰äº§ç”Ÿæ–°çš„å¯¹è±¡

### NSString
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [[NSString alloc] initWithFormat:@"test"];
        NSString *str2 = [str1 copy]; // æµ…æ‹·è´ï¼šæŒ‡é’ˆæ‹·è´ï¼Œæ²¡æœ‰äº§ç”Ÿæ–°å¯¹è±¡
        NSMutableString *str3 = [str1 mutableCopy]; // æ·±æ‹·è´ï¼šå†…å®¹æ‹·è´ï¼Œåˆäº§ç”Ÿæ–°å¯¹è±¡
        
        NSLog(@"%@ %@ %@", str1, str2, str3);
        NSLog(@"%p %p %p", str1, str2, str3);
        
        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
test test test
0x100001018 0x100001018 0x1007bb4e0
```

str1ã€str2 å’Œ str3 æ‰“å°å‡ºæ¥éƒ½æ˜¯ testï¼Œä½†æ˜¯ str1 å’Œ str2 æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªå†…å­˜åœ°å€ï¼Œstr3 æŒ‡å‘çš„æ˜¯å¦ä¸€ä¸ªå†…å­˜åœ°å€ã€‚å³ str1 é€šè¿‡ `copy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ str2 è¿˜æ˜¯åŸå¯¹è±¡ï¼ˆstr1ï¼‰ï¼Œè€Œ str1 é€šè¿‡ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ str3 æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚
![å†…å­˜ç®¡ç†10](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†10.png)

ğŸ‘‰ æ‹·è´çš„ç›®çš„ï¼šäº§ç”Ÿä¸€ä¸ªå‰¯æœ¬å¯¹è±¡ï¼Œè·ŸåŸå¯¹è±¡äº’ä¸å½±å“ã€‚  
str1 æ˜¯ä¸€ä¸ªä¸å¯å˜å­—ç¬¦ä¸²å¯¹è±¡ï¼Œé€šè¿‡ `copy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ä¹Ÿæ˜¯ä¸å¯å˜å­—ç¬¦ä¸²å¯¹è±¡ã€‚å› ä¸ºä¸å¯å˜å­—ç¬¦ä¸²å¯¹è±¡ä¸å¯ä»¥è¢«ä¿®æ”¹ï¼Œä¸å¯ä»¥è¢«ä¿®æ”¹å°±ä¸ä¼šäº’ç›¸å½±å“ï¼Œæ‰€ä»¥ str1 å’Œ str2 æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡æ»¡è¶³æ‹·è´çš„åŸåˆ™ï¼ˆäº’ä¸å½±å“ï¼‰ã€‚è€Œä¸”å°† str1 å’Œ str2 æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡è¿˜èŠ‚çœäº†å†…å­˜ã€‚  
str1 æ˜¯ä¸€ä¸ªä¸å¯å˜å­—ç¬¦ä¸²å¯¹è±¡ï¼Œé€šè¿‡ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬æ˜¯å¯å˜å­—ç¬¦ä¸²å¯¹è±¡ã€‚å› ä¸ºå¯å˜å­—ç¬¦ä¸²å¯¹è±¡å¯ä»¥è¢«ä¿®æ”¹ï¼Œæ‰€ä»¥ str3 æŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œä¿è¯åœ¨ä¿®æ”¹ str3 æ—¶ä¸ä¼šå½±å“åˆ° str1ã€‚  

ï¼ˆæ€»çš„æ¥çœ‹ï¼Œæ—¢è¦ä¿è¯äº’ä¸å½±å“ï¼Œä¹Ÿè¦åšåˆ°èŠ‚çœèµ„æºï¼‰

```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [[NSString alloc] initWithString:@"test"];
        NSString *str2 = [[NSString alloc] initWithString:@"test"];
        NSString *str3 = [str2 copy];
        NSString *str4 = @"test";
        NSMutableString *str5 = [str1 mutableCopy];
        
        NSLog(@"%@ %@ %@ %@ %@ %@", @"test", str1, str2, str3, str4, str5);
        NSLog(@"%p %p %p %p %p %p", @"test", str1, str2, str3, str4, str5);
        
        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
test test test test test test
0x100002040 0x100002040 0x100002040 0x100002040 0x100002040 0x1006bd980
```

str1ã€str2ã€str3 å’Œ str4 éƒ½æ˜¯ `@"test"` å¯¹è±¡ã€‚

å¼•ç”¨è®¡æ•°ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [[NSString alloc] initWithFormat:@"test111111111"]; // str1 : 1
        NSString *str2 = [str1 copy]; // str1 : 2
        NSMutableString *str3 = [str1 mutableCopy];
        
        NSLog(@"%zd", str1.retainCount);
        
        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
2
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œstr1 åœ¨è°ƒç”¨ `copy` æ–¹æ³•åï¼Œå¼•ç”¨è®¡æ•°åŠ 1ï¼Œç›¸å½“äºè°ƒç”¨äº†ä¸€æ¬¡ `retain` æ–¹æ³•ã€‚
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = [[NSString alloc] initWithFormat:@"test111111111"];
        NSString *str2 = [[NSString alloc] initWithFormat:@"test"];
        NSString *str3 = [[NSString alloc] initWithString:@"test"];
        
        NSLog(@"%@ %@ %@", [str1 class], [str2 class], [str3 class]);
        NSLog(@"%zd %zd %zd", str1.retainCount, str2.retainCount, str3.retainCount);
        
        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
__NSCFString NSTaggedPointerString __NSCFConstantString
1 -1 -1
```

ä½¿ç”¨ `initWithFormat:` æ–¹æ³•åˆå§‹åŒ–å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²é•¿åº¦è¶³å¤Ÿé•¿ï¼Œåˆ›å»ºå‡ºæ¥çš„æ˜¯ `__NSCFString` ç±»å‹çš„å­—ç¬¦ä¸²ã€‚`__NSCFString` ç±»å‹çš„å­—ç¬¦ä¸²æ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°ç®¡ç†å†…å­˜çš„ã€‚  
ä½¿ç”¨ `initWithFormat:` æ–¹æ³•åˆå§‹åŒ–å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²é•¿åº¦ä¸å¤Ÿé•¿ï¼Œåˆ›å»ºå‡ºæ¥çš„æ˜¯ `NSTaggedPointerString` ç±»å‹çš„å­—ç¬¦ä¸²ã€‚`NSTaggedPointerString` ç±»å‹çš„å­—ç¬¦ä¸²ä¸æ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°ç®¡ç†å†…å­˜çš„ã€‚  
ä½¿ç”¨ `initWithString:` æ–¹æ³•åˆå§‹åŒ–å­—ç¬¦ä¸²ï¼Œä¸ç®¡å­—ç¬¦ä¸²é•¿åº¦ï¼Œåˆ›å»ºå‡ºæ¥çš„æ˜¯ `__NSCFConstantString` ç±»å‹çš„å­—ç¬¦ä¸²ã€‚`__NSCFConstantString` ç±»å‹çš„å­—ç¬¦ä¸²ä¸æ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°ç®¡ç†å†…å­˜çš„ã€‚

psï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str1 = @"test";
        NSString *str1_1 = @"test";
        
        NSString *str2 = [[NSString alloc] initWithString:@"test"];
        NSString *str2_1 = [[NSString alloc] initWithString:@"test"];
        
        NSString *str3 = [NSString stringWithString:@"test"];
        NSString *str3_1 = [NSString stringWithString:@"test"];
        
        NSString *str4 = [[NSString alloc] initWithFormat:@"test"];
        NSString *str4_1 = [[NSString alloc] initWithFormat:@"test"];
        
        NSString *str5 = [NSString stringWithFormat:@"test"];
        NSString *str5_1 = [NSString stringWithFormat:@"test"];
        
        NSLog(@"%p", str1);
        NSLog(@"%p", str1_1);
        NSLog(@"------------------");
        NSLog(@"%p", str2);
        NSLog(@"%p", str2_1);
        NSLog(@"------------------");
        NSLog(@"%p", str3);
        NSLog(@"%p", str3_1);
        NSLog(@"------------------");
        NSLog(@"%p", str4);
        NSLog(@"%p", str4_1);
        NSLog(@"------------------");
        NSLog(@"%p", str5);
        NSLog(@"%p", str5_1);
        
        [str1 release];
        [str1_1 release];
        [str2 release];
        [str2_1 release];
        [str3 release];
        [str3_1 release];
        [str4 release];
        [str4_1 release];
        [str5 release];
        [str5_1 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
0x100002040
0x100002040
------------------
0x100002040
0x100002040
------------------
0x100002040
0x100002040
------------------
0x1f9d08801e47ec0b
0x1f9d08801e47ec0b
------------------
0x1f9d08801e47ec0b
0x1f9d08801e47ec0b
```

é€šè¿‡ [GNUStep](http://www.gnustep.org/resources/downloads.php) æŸ¥çœ‹æºç ï¼š  
ä»¥ Format ç»“å°¾çš„æ–¹æ³•æœ€ç»ˆè°ƒç”¨çš„éƒ½æ˜¯è¿™ä¸ªæ–¹æ³•ï¼š
```
- (id)initWithFormat:(NSString*)format locale:(NSDictionary*)locale arguments:(va_list)argList;
```

ä»¥ String ç»“å°¾çš„æ–¹æ³•æœ€ç»ˆè°ƒç”¨çš„éƒ½æ˜¯è¿™ä¸ªæ–¹æ³•ï¼š
```
- (id)initWithString:(NSString*)string;
```

### NSMutableString
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableString *str1 = [[NSMutableString alloc] initWithString:@"test"];
        NSString *str2 = [str1 copy]; // æ·±æ‹·è´
        NSMutableString *str3 = [str1 mutableCopy]; // æ·±æ‹·è´
        
        NSLog(@"%@ %@ %@", str1, str2, str3);
        NSLog(@"%p %p %p", str1, str2, str3);
        
        [str1 release];
        [str2 release];
        [str3 release];
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
test test test
0x103aaab50 0x48301b1a78a3a9e5 0x103aab150
```

str1ã€str2 å’Œ str3 æ‰“å°å‡ºæ¥éƒ½æ˜¯ testï¼Œä½†æ˜¯ä»–ä»¬æŒ‡å‘çš„éƒ½æ˜¯ä¸åŒçš„å†…å­˜åœ°å€ã€‚å³ str1 é€šè¿‡ `copy` å’Œ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ str2 å’Œ str3 éƒ½æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚
![å†…å­˜ç®¡ç†11](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†11.png)

### NSArray
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@"1", @"2"]];
        NSArray *arr2 = [arr1 copy]; // æµ…æ‹·è´
        NSMutableArray *arr3 = [arr1 mutableCopy]; // æ·±æ‹·è´
        
        NSLog(@"%@ %@ %@", arr1, arr2, arr3);
        NSLog(@"%p %p %p", arr1, arr2, arr3);
        NSLog(@"%d %d %d",
              [arr1 isKindOfClass:[NSMutableArray class]],
              [arr2 isKindOfClass:[NSMutableArray class]],
              [arr3 isKindOfClass:[NSMutableArray class]]);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
(
    1,
    2
) (
    1,
    2
) (
    1,
    2
)
0x1004bfc20 0x1004bfc20 0x1004c0100
0 0 1
```

arr1 å’Œ arr2 æ˜¯ä¸å¯å˜æ•°ç»„ï¼Œarr3 æ˜¯å¯å˜æ•°ç»„ã€‚å³ï¼š  
[ä¸å¯å˜ copy] -> ä¸å¯å˜  
[ä¸å¯å˜ mutableCopy] -> å¯å˜  

arr1ã€arr2 å’Œ arr3 æ‰“å°å‡ºæ¥éƒ½æ˜¯åŒæ ·çš„å†…å®¹ï¼Œä½†æ˜¯ arr1 å’Œ arr2 æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªå†…å­˜åœ°å€ï¼Œarr3 æŒ‡å‘çš„æ˜¯å¦ä¸€ä¸ªå†…å­˜åœ°å€ã€‚å³ arr1 é€šè¿‡ `copy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ arr2 è¿˜æ˜¯åŸå¯¹è±¡ï¼ˆarr1ï¼‰ï¼Œè€Œ arr1 é€šè¿‡ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ arr3 æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚

```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@"1", @"2"]];
        NSArray *arr2 = [arr1 copy]; // æµ…æ‹·è´
        NSMutableArray *arr3 = [arr1 mutableCopy]; // æ·±æ‹·è´
        NSLog(@"%p %p %p %p", @[@"1", @"2"], arr1, arr2, arr3);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
0x100713270 0x100712d60 0x100712d60 0x100713240
```

NSArray å’Œ NSString ä¸åŒï¼Œ`@[@"1", @"2"]`ã€arr1 å’Œ arr2 è™½ç„¶å†…å®¹ç›¸åŒï¼Œä½†æ˜¯å®ƒä»¬æ˜¯ä¸åŒçš„å¯¹è±¡ï¼ˆarr1 å’Œ arr2 æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼‰ã€‚

### NSMutableArray
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableArray *arr1 = [[NSMutableArray alloc] initWithArray:@[@"1", @"2"]];
        NSArray *arr2 = [arr1 copy]; // æ·±æ‹·è´
        NSMutableArray *arr3 = [arr1 mutableCopy]; // æ·±æ‹·è´
        
        NSLog(@"%@ %@ %@", arr1, arr2, arr3);
        NSLog(@"%p %p %p", arr1, arr2, arr3);
        NSLog(@"%d %d %d",
              [arr1 isKindOfClass:[NSMutableArray class]],
              [arr2 isKindOfClass:[NSMutableArray class]],
              [arr3 isKindOfClass:[NSMutableArray class]]);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
(
    1,
    2
) (
    1,
    2
) (
    1,
    2
)
0x100535780 0x1005358f0 0x100535910
1 0 1
```

arr1 å’Œ arr3 æ˜¯å¯å˜æ•°ç»„ï¼Œarr2 æ˜¯ä¸å¯å˜æ•°ç»„ã€‚å³ï¼š  
[å¯å˜ copy] -> ä¸å¯å˜  
[å¯å˜ mutableCopy] -> å¯å˜  

arr1ã€arr2 å’Œ arr3 æ‰“å°å‡ºæ¥éƒ½æ˜¯åŒæ ·çš„å†…å®¹ï¼Œä½†æ˜¯ä»–ä»¬æŒ‡å‘çš„éƒ½æ˜¯ä¸åŒçš„å†…å­˜åœ°å€ã€‚å³ arr1 é€šè¿‡ `copy` å’Œ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ arr2 å’Œ arr3 éƒ½æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚


### NSDictionary
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSDictionary *dict1 = [NSDictionary dictionaryWithObjectsAndKeys:@"value", @"key", nil];
        NSDictionary *dict2 = [dict1 copy]; // æµ…æ‹·è´
        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // æ·±æ‹·è´
        
        NSLog(@"%@ %@ %@", dict1, dict2, dict3);
        NSLog(@"%p %p %p", dict1, dict2, dict3);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
{
    key = value;
} {
    key = value;
} {
    key = value;
}
0x100491ff0 0x100491ff0 0x1004923f0
```

dict1 å’Œ dict2 æ˜¯ä¸å¯å˜å­—å…¸ï¼Œdict3 æ˜¯å¯å˜å­—å…¸ã€‚å³ï¼š  
[ä¸å¯å˜ copy] -> ä¸å¯å˜  
[ä¸å¯å˜ mutableCopy] -> å¯å˜  

dict1ã€dict2 å’Œ dict3 æ‰“å°å‡ºæ¥éƒ½æ˜¯åŒæ ·çš„å†…å®¹ï¼Œä½†æ˜¯ dict1 å’Œ dict2 æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªå†…å­˜åœ°å€ï¼Œdict3 æŒ‡å‘çš„æ˜¯å¦ä¸€ä¸ªå†…å­˜åœ°å€ã€‚å³ dict1 é€šè¿‡ `copy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ dict2 è¿˜æ˜¯åŸå¯¹è±¡ï¼ˆdict1ï¼‰ï¼Œè€Œ dict1 é€šè¿‡ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ dict3 æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚

### NSMutableDictionary
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableDictionary *dict1 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"value", @"key", nil];
        NSDictionary *dict2 = [dict1 copy]; // æ·±æ‹·è´
        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // æ·±æ‹·è´
        
        NSLog(@"%@ %@ %@", dict1, dict2, dict3);
        NSLog(@"%p %p %p", dict1, dict2, dict3);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
{
    key = value;
} {
    key = value;
} {
    key = value;
}
0x100463300 0x100463900 0x100463920
```

dict1 å’Œ dict3 æ˜¯å¯å˜å­—å…¸ï¼Œdict2 æ˜¯ä¸å¯å˜å­—å…¸ã€‚å³ï¼š  
[å¯å˜ copy] -> ä¸å¯å˜  
[å¯å˜ mutableCopy] -> å¯å˜  

dict1ã€dict2 å’Œ dict3 æ‰“å°å‡ºæ¥éƒ½æ˜¯åŒæ ·çš„å†…å®¹ï¼Œä½†æ˜¯ä»–ä»¬æŒ‡å‘çš„éƒ½æ˜¯ä¸åŒçš„å†…å­˜åœ°å€ã€‚å³ dict1 é€šè¿‡ `copy` å’Œ `mutableCopy` æ–¹æ³•æ‹·è´å‡ºæ¥çš„å‰¯æœ¬ dict2 å’Œ dict3 éƒ½æ˜¯ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚

### å°ç»“

|  | copy | mutableCopy |
| :-- | :-- | :-- |
| NSString | NSString<br><font color=#FF0000> æµ…æ‹·è´ </font> | NSMutableString<br>æ·±æ‹·è´ |
| NSMutableString | NSString<br>æ·±æ‹·è´| NSMutableString<br>æ·±æ‹·è´ |
| NSArray | NSArray<br><font color=#FF0000> æµ…æ‹·è´ </font>| NSMutableArray<br>æ·±æ‹·è´ |
| NSMutableArray | NSArray<br>æ·±æ‹·è´| NSMutableArray<br>æ·±æ‹·è´ |
| NSDictionary | NSDictionary<br><font color=#FF0000> æµ…æ‹·è´ </font>| NSMutableDictionary<br>æ·±æ‹·è´ |
| NSMutableDictionary | NSDictionary<br>æ·±æ‹·è´| NSDictionary<br>æ·±æ‹·è´ |


## copyç­–ç•¥çš„property

å®šä¹‰ Person
```
@interface Person : NSObject
@property (nonatomic, copy) NSMutableArray *data;
@end

@implementation Person
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[Person alloc] init];
        person.data = [NSMutableArray array];
        [person.data addObject:@"123"];
    }
    return 0;
}
```

æŠ¥é”™ï¼š
![å†…å­˜ç®¡ç†12](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†12.png)

`data` æ˜¯ Person ç”¨ `copy` ç­–ç•¥å®šä¹‰çš„ `NSMutableArray`ï¼Œ`data` çš„ set æ–¹æ³•æ˜¯ï¼š
```
@implementation Person
- (void)setData:(NSMutableArray *)data
{
    if (_data != data) {
        [_data release];
        _data = [data copy];
    }
}
@end
```

åœ¨ `person.data = [NSMutableArray array]` èµ‹å€¼çš„è¿™ä¸€åˆ»ï¼Œè™½ç„¶ä¼ å…¥çš„æ˜¯ä¸€ä¸ª `NSMutableArray`ï¼Œä½†æ˜¯å› ä¸ºæ˜¯ `copy` ç­–ç•¥ï¼Œæ‰€ä»¥åœ¨èµ‹å€¼æ—¶éœ€è¦è¿›è¡Œ `copy` æ“ä½œ `_data = [data copy]`ï¼Œæ‰€ä»¥ `_data` æ˜¯ä¸€ä¸ª `NSArray` ç±»å‹çš„ä¸å¯å˜æ•°ç»„ã€‚

å¯¹äºå¯å˜ç±»å‹çš„å˜é‡ï¼Œåœ¨å£°æ˜æ—¶ä½¿ç”¨ `strong` ç­–ç•¥ã€‚  
å¯¹äºä¸å¯å˜ç±»å‹çš„å˜é‡ï¼Œåœ¨å£°æ˜æ—¶ä½¿ç”¨ `copy` ç­–ç•¥ã€‚

æ¯”å¦‚ `UITextField` é‡Œçš„ textã€attributedText å’Œ placeholder ç­‰ï¼Œéƒ½æ˜¯ä½¿ç”¨çš„ copy ç­–ç•¥ï¼Œä¿è¯ä¸ç®¡ä¼ å…¥çš„æ˜¯å¯å˜ç±»å‹è¿˜æ˜¯ä¸å¯å˜ç±»å‹ï¼Œ`UITextField` å†…éƒ¨ä½¿ç”¨çš„éƒ½æ˜¯ä¸å¯å˜ç±»å‹ï¼š
```
@interface UITextField : UIControl <UITextInput, NSCoding, UIContentSizeCategoryAdjusting>

@property(nullable, nonatomic,copy)   NSString               *text;                 // default is nil
@property(nullable, nonatomic,copy)   NSAttributedString     *attributedText API_AVAILABLE(ios(6.0)); // default is nil
......
@property(nullable, nonatomic,copy)   NSString               *placeholder;          // default is nil. string is drawn 70% gray
@property(nullable, nonatomic,copy)   NSAttributedString     *attributedPlaceholder API_AVAILABLE(ios(6.0)); // default is nil
```

## copyWithZone:

å¯¹è±¡ç±»å‹è¿›è¡Œ `copy` æ“ä½œï¼Œé¦–å…ˆè¦éµå®ˆ `<NSCopying>` åè®®ï¼Œç„¶åå®ç° `- (id)copyWithZone:(struct _NSZone *)zone` æ–¹æ³•ï¼š
```
@interface Person : NSObject <NSCopying>
@property (nonatomic, assign) int age;
@property (nonatomic, assign) int weight;
@end

@implementation Person
- (id)copyWithZone:(struct _NSZone *)zone
{
    Person *person = [Person allocWithZone:zone];
    // è®¾ç½®éœ€è¦æ‹·è´çš„å±æ€§
    person.age = self.age;
    person.weight = self.weight;
    return person;
}

- (NSString *)description
{
    return [NSString stringWithFormat:@"age = %d, weight = %d", self.age, self.weight];
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[Person alloc] init];
        person.age = 10;
        person.weight = 20;
        
        Person *person2 = [person copy];
        NSLog(@"{%@} {%@}", person, person2);
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
{age = 10, weight = 20} {age = 10, weight = 20}
```

# å¼•ç”¨è®¡æ•°çš„å­˜å‚¨
åœ¨ 64bit ä¸­ï¼Œå¼•ç”¨è®¡æ•°å¯ä»¥ç›´æ¥å­˜å‚¨åœ¨ä¼˜åŒ–è¿‡çš„ isa æŒ‡é’ˆä¸­ï¼Œä¹Ÿå¯èƒ½å­˜å‚¨åœ¨ SideTable ç±»ä¸­ã€‚
```
struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts; // ä¸€ä¸ªå­˜æ”¾ç€å¯¹è±¡å¼•ç”¨è®¡æ•°çš„æ•£åˆ—è¡¨
    weak_table_t weak_table; // å¼±å¼•ç”¨è¡¨
    ......
};
```

åœ¨ objc-weak.h æ–‡ä»¶æŸ¥çœ‹ `weak_table_t` å®šä¹‰ï¼š
```
struct weak_table_t {
    weak_entry_t *weak_entries; // æ•°ç»„åœ°å€ï¼ˆé¦–å…ƒç´ åœ°å€ï¼‰
    size_t    num_entries; // æ•°ç»„çš„æ•°é‡
    uintptr_t mask; // æ•°ç»„ä¸‹æ ‡æœ€å¤§å€¼ï¼ˆweak_table_tçš„size-1ï¼‰
    uintptr_t max_hash_displacement; // æœ€å¤§hashåç§»é‡
};
```

## retainCount
åœ¨ [objc4-781](https://opensource.apple.com/tarballs/objc4/) çš„ NSObject.mm æ–‡ä»¶ä¸­æŸ¥çœ‹ `retainCount`ï¼š  
```
- (NSUInteger)retainCount {
    return _objc_rootRetainCount(self);
}

......

uintptr_t
_objc_rootRetainCount(id obj)
{
    ASSERT(obj);

    return obj->rootRetainCount();
}
```

åœ¨ objc-object.h æ–‡ä»¶ä¸­æŸ¥çœ‹ `rootRetainCount()` æ–¹æ³•ï¼š
```
inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    isa_t bits = LoadExclusive(&isa.bits);
    ClearExclusive(&isa.bits);
    if (bits.nonpointer) { // éæŒ‡é’ˆç±»å‹ï¼ˆä¼˜åŒ–è¿‡çš„isaæŒ‡é’ˆï¼‰
        uintptr_t rc = 1 + bits.extra_rc;
        if (bits.has_sidetable_rc) { // å¼•ç”¨è®¡æ•°ä¸æ˜¯å­˜å‚¨åœ¨isaä¸­ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨sidetableä¸­
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }

    sidetable_unlock();
    return sidetable_retainCount();
}
```

åœ¨ NSObject.mm æ–‡ä»¶ä¸­æŸ¥çœ‹ `sidetable_getExtraRC_nolock()` æ–¹æ³•ï¼š
```
size_t 
objc_object::sidetable_getExtraRC_nolock()
{
    ASSERT(isa.nonpointer);
    SideTable& table = SideTables()[this];
    RefcountMap::iterator it = table.refcnts.find(this); //å–å‡ºå¯¹è±¡å¯¹åº”çš„æ•£åˆ—è¡¨
    if (it == table.refcnts.end()) return 0;
    else return it->second >> SIDE_TABLE_RC_SHIFT;
}
```

`has_sidetable_rc`ï¼šå¼•ç”¨è®¡æ•°å™¨æ˜¯å¦è¿‡å¤§æ— æ³•å­˜å‚¨åœ¨ isa ä¸­ï¼Œå¦‚æœä¸º1ï¼Œé‚£ä¹ˆå¼•ç”¨è®¡æ•°ä¼šå­˜å‚¨åœ¨ä¸€ä¸ªå« SideTable çš„ç±»çš„å±æ€§ä¸­ã€‚
![å†…å­˜ç®¡ç†17](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†17.png)

## release
```
- (oneway void)release {
    _objc_rootRelease(self);
}

......

NEVER_INLINE void
_objc_rootRelease(id obj)
{
    ASSERT(obj);

    obj->rootRelease();
}
```

åœ¨ objc-object.h æ–‡ä»¶ä¸­æŸ¥çœ‹ `rootRelease()` æ–¹æ³•ï¼š
```
ALWAYS_INLINE bool 
objc_object::rootRelease(bool performDealloc, bool handleUnderflow)
{
    if (isTaggedPointer()) return false;

    bool sideTableLocked = false;

    isa_t oldisa;
    isa_t newisa;

 retry:
    do {
        oldisa = LoadExclusive(&isa.bits);
        newisa = oldisa;
        if (slowpath(!newisa.nonpointer)) {
            // ä¸æ˜¯ä¼˜åŒ–è¿‡çš„isaæŒ‡é’ˆ
            ClearExclusive(&isa.bits);
            if (rawISA()->isMetaClass()) return false;
            if (sideTableLocked) sidetable_unlock();
            return sidetable_release(performDealloc);
        }
        // don't check newisa.fast_rr; we already called any RR overrides
        uintptr_t carry;
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--
        // ç›¸å‡åä¸‹æº¢å‡º
        if (slowpath(carry)) {
            // don't ClearExclusive()
            goto underflow;
        }
    } while (slowpath(!StoreReleaseExclusive(&isa.bits, 
                                             oldisa.bits, newisa.bits)));

    if (slowpath(sideTableLocked)) sidetable_unlock();
    return false;

 underflow:
    // newisa.extra_rc-- underflowed: borrow from side table or deallocate

    // abandon newisa to undo the decrement
    newisa = oldisa;

    // å¼•ç”¨è®¡æ•°ä¸æ˜¯å­˜å‚¨åœ¨isaä¸­ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨sidetableä¸­ 
    if (slowpath(newisa.has_sidetable_rc)) {
        if (!handleUnderflow) {
            ClearExclusive(&isa.bits);
            // å†æ‰§è¡Œ rootRelease ä¸€æ¬¡ï¼Œå¤„ç†ä¸‹æº¢å‡º
            return rootRelease_underflow(performDealloc);
        }

        // Transfer retain count from side table to inline storage.

        if (!sideTableLocked) {
            ClearExclusive(&isa.bits);
            sidetable_lock();
            sideTableLocked = true;
            // Need to start over to avoid a race against 
            // the nonpointer -> raw pointer transition.
            goto retry;
        }

        // ä¸‹é¢æ˜¯ä» sideTable å€Ÿ RC_HALF çš„å¼•ç”¨è®¡æ•°æ”¾åˆ° extra_rc ä¸Š, å€Ÿä¸åˆ°çš„æƒ…å†µï¼Œå¯¹è±¡éœ€è¦è¢«é”€æ¯äº†
        // Try to remove some retain counts from the side table.        
        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);

        // To avoid races, has_sidetable_rc must remain set 
        // even if the side table count is now zero.

        if (borrowed > 0) {
            // Side table retain count decreased.
            // Try to add them to the inline count.
            newisa.extra_rc = borrowed - 1;  // redo the original decrement too
            bool stored = StoreReleaseExclusive(&isa.bits, 
                                                oldisa.bits, newisa.bits);
            if (!stored) {
                // Inline update failed. 
                // Try it again right now. This prevents livelock on LL/SC 
                // architectures where the side table access itself may have 
                // dropped the reservation.
                isa_t oldisa2 = LoadExclusive(&isa.bits);
                isa_t newisa2 = oldisa2;
                if (newisa2.nonpointer) {
                    uintptr_t overflow;
                    newisa2.bits = 
                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);
                    if (!overflow) {
                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, 
                                                       newisa2.bits);
                    }
                }
            }

            if (!stored) {
                // Inline update failed.
                // Put the retains back in the side table.
                sidetable_addExtraRC_nolock(borrowed);
                goto retry;
            }

            // Decrement successful after borrowing from side table.
            // This decrement cannot be the deallocating decrement - the side 
            // table lock and has_sidetable_rc bit ensure that if everyone 
            // else tried to -release while we worked, the last one would block.
            sidetable_unlock();
            return false;
        }
        else {
            // Side table is empty after all. Fall-through to the dealloc path.
        }
    }

    // Really deallocate.

    if (slowpath(newisa.deallocating)) {
        ClearExclusive(&isa.bits);
        if (sideTableLocked) sidetable_unlock();
        return overrelease_error();
        // does not actually return
    }
    newisa.deallocating = true;
    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;

    if (slowpath(sideTableLocked)) sidetable_unlock();

    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);

    if (performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return true;
}
```

åœ¨ NSObject.mm æ–‡ä»¶ä¸­æŸ¥çœ‹ `sidetable_release()` æ–¹æ³•ï¼š
```
#define SIDE_TABLE_RC_ONE            (1UL<<2)  // MSB-ward of deallocating bit

......

uintptr_t
objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];

    bool do_dealloc = false;
    
    //----- å¯¹å¼•ç”¨è®¡æ•°å‡æ“ä½œ -----
    table.lock();
    auto it = table.refcnts.try_emplace(this, SIDE_TABLE_DEALLOCATING);
    auto &refcnt = it.first->second;
    if (it.second) {
        do_dealloc = true;
    } else if (refcnt < SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        do_dealloc = true;
        refcnt |= SIDE_TABLE_DEALLOCATING;
    } else if (! (refcnt & SIDE_TABLE_RC_PINNED)) {
        refcnt -= SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    //----- å¯¹å¼•ç”¨è®¡æ•°å‡æ“ä½œ end -----

    // æ˜¯å¦è¦æ‰§è¡Œ dealloc
    if (do_dealloc  &&  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return do_dealloc;
}
```

## retain()
åœ¨ objc-object.h æ–‡ä»¶ä¸­æŸ¥çœ‹ `retain()` æ–¹æ³•ï¼š
```
inline id 
objc_object::retain()
{
    ASSERT(!isTaggedPointer());

    if (fastpath(!ISA()->hasCustomRR())) {
        return sidetable_retain();
    }

    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(retain));
}
```

åœ¨ NSObject.mm æ–‡ä»¶ä¸­æŸ¥çœ‹ `sidetable_retain()` æ–¹æ³•ï¼š
```
id
objc_object::sidetable_retain()
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];
    
    //----- å¯¹å¼•ç”¨è®¡æ•°åŠ æ“ä½œ -----
    table.lock();
    size_t& refcntStorage = table.refcnts[this];
    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
        refcntStorage += SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    //----- å¯¹å¼•ç”¨è®¡æ•°åŠ æ“ä½œ end -----

    return (id)this;
}
```

# weakæŒ‡é’ˆçš„åŸç†

## å±€éƒ¨å˜é‡çš„å†…å­˜ç®¡ç†
åˆ›å»ºå±€éƒ¨å˜é‡ personï¼š
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"111");
    {
        Person *person = [[Person alloc] init];
    }
    NSLog(@"222");
}
@end
```

æ‰“å°ç»“æœï¼š
```
111
-[Person dealloc]
222
```

### \_\_strong
ä½¿ç”¨ `__strong` ä¿®é¥°çš„å±€éƒ¨å˜é‡ personï¼š
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    __strong Person *strongPerson;
    NSLog(@"111");
    {
        Person *person = [[Person alloc] init];
        strongPerson = person;
    }
    NSLog(@"222");
    NSLog(@"%@", strongPerson);
}
@end
```

æ‰“å°ç»“æœï¼š
```
111
222
<Person: 0x60000177c310>
-[Person dealloc]
```

### \_\_weak 
ä½¿ç”¨ `__weak` ä¿®é¥°çš„å±€éƒ¨å˜é‡ personï¼š
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    __weak Person *weakPerson;
    NSLog(@"111");
    {
        Person *person = [[Person alloc] init];
        weakPerson = person;
    }
    NSLog(@"222");
    NSLog(@"%@", weakPerson);
}
@end
```

æ‰“å°ç»“æœï¼š
```
111
-[Person dealloc]
222
(null)
```

`weakPerson` æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜åœ°å€è¢«é”€æ¯åï¼Œ`weakPerson` æŒ‡é’ˆä¼šè‡ªåŠ¨ç½®ä¸º nilã€‚

### \_\_unsafe_unretained
ä½¿ç”¨ `__unsafe_unretained` ä¿®é¥°çš„å±€éƒ¨å˜é‡ personï¼š
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    __unsafe_unretained Person *unsafePerson;
    NSLog(@"111");
    {
        Person *person = [[Person alloc] init];
        unsafePerson = person;
    }
    NSLog(@"222");
}
@end
```

æŠ¥é”™ï¼š
![å†…å­˜ç®¡ç†12](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†12.png)

æŠ¥é”™çš„åŸå› æ˜¯æŒ‡é’ˆ `unsafePerson` è¿˜åœ¨ï¼Œä½†æ˜¯å®ƒæŒ‡å‘çš„å†…å­˜åœ°å€å·²ç»ä¸å­˜åœ¨äº†ã€‚è¿™ä¹Ÿæ˜¯è·Ÿ `weakPerson` æŒ‡é’ˆç›¸æ¯”ä¸åŒä¹Ÿæ˜¯ä¸å¤Ÿå®‰å…¨çš„åœ°æ–¹ã€‚

## dealloc

[objc4-781](https://opensource.apple.com/tarballs/objc4/) æŸ¥çœ‹æºç ï¼š  

NSObject.mm æ–‡ä»¶ï¼š
```
- (void)dealloc {
    _objc_rootDealloc(self);
}

......

void
_objc_rootDealloc(id obj)
{
    ASSERT(obj);

    obj->rootDealloc();
}
```

åœ¨ objc-object.h æ–‡ä»¶æŸ¥çœ‹ `rootDealloc()` æ–¹æ³•ï¼š
```
inline void
objc_object::rootDealloc()
{
    if (isTaggedPointer()) return;  // fixme necessary?

    if (fastpath(isa.nonpointer  &&  
                 !isa.weakly_referenced  &&  
                 !isa.has_assoc  &&  
                 !isa.has_cxx_dtor  &&  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        object_dispose((id)this);
    }
}
```

* nonpointer  
0ï¼Œä»£è¡¨æ™®é€šçš„æŒ‡é’ˆï¼Œisa åªå­˜å‚¨ç€ Classã€Meta-Class å¯¹è±¡çš„å†…å­˜åœ°å€  
1ï¼Œä»£è¡¨ä¼˜åŒ–è¿‡ï¼Œisa ä½¿ç”¨ä½åŸŸå­˜å‚¨æ›´å¤šçš„ä¿¡æ¯
* has_assoc  
æ˜¯å¦æœ‰è®¾ç½®è¿‡å…³è”å¯¹è±¡ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‡Šæ”¾æ—¶ä¼šæ›´å¿«
* has_cxx_dtor  
æ˜¯å¦æœ‰ C++ çš„ææ„å‡½æ•°ï¼ˆ.cxx_destructï¼‰ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‡Šæ”¾æ—¶ä¼šæ›´å¿«
* weakly_referenced  
æ˜¯å¦æœ‰è¢«å¼±å¼•ç”¨æŒ‡å‘è¿‡ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‡Šæ”¾æ—¶ä¼šæ›´å¿«
* has_sidetable_rc  
å¼•ç”¨è®¡æ•°å™¨æ˜¯å¦è¿‡å¤§æ— æ³•å­˜å‚¨åœ¨ isa ä¸­ï¼Œå¦‚æœä¸º1ï¼Œé‚£ä¹ˆå¼•ç”¨è®¡æ•°ä¼šå­˜å‚¨åœ¨ä¸€ä¸ªå« SideTable çš„ç±»çš„å±æ€§ä¸­

å¦‚æœæ¡ä»¶ä¸æˆç«‹ä¼šèµ°åˆ° objc-runtime-new.mm æ–‡ä»¶çš„ `object_dispose()` æ–¹æ³•ï¼š
```
id 
object_dispose(id obj)
{
    if (!obj) return nil;

    objc_destructInstance(obj);    
    free(obj);

    return nil;
}

......

void *objc_destructInstance(id obj) 
{
    if (obj) {
        // Read all of the flags at once for performance.
        bool cxx = obj->hasCxxDtor();
        bool assoc = obj->hasAssociatedObjects();

        // This order is important.
        if (cxx) object_cxxDestruct(obj); // æ¸…é™¤æˆå‘˜å˜é‡
        if (assoc) _object_remove_assocations(obj); // ç§»é™¤å…³è”å¯¹è±¡
        obj->clearDeallocating(); // å°†æŒ‡å‘å½“å‰å¯¹è±¡çš„å¼±æŒ‡é’ˆç½®ä¸ºnil
    }

    return obj;
}
```

åœ¨ objc-object.h æ–‡ä»¶æŸ¥çœ‹ `clearDeallocating()` æ–¹æ³•ï¼š
```
inline void 
objc_object::clearDeallocating()
{
    if (slowpath(!isa.nonpointer)) { // æ˜¯å¦æ˜¯æ™®é€šçš„isaæŒ‡é’ˆ
        // Slow path for raw pointer isa.
        sidetable_clearDeallocating();
    }
    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) { // æ˜¯å¦æœ‰è¢«å¼±å¼•ç”¨æŒ‡å‘è¿‡ || // æ˜¯å¦æ˜¯ä¼˜åŒ–è¿‡çš„isaæŒ‡é’ˆ
        // Slow path for non-pointer isa with weak refs and/or side table data.
        clearDeallocating_slow();
    }

    assert(!sidetable_present());
}
```

åœ¨ NSObject.mm æ–‡ä»¶ æŸ¥çœ‹ `clearDeallocating_slow()` æ–¹æ³•ï¼š
```
NEVER_INLINE void
objc_object::clearDeallocating_slow()
{
    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable& table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        weak_clear_no_lock(&table.weak_table, (id)this); // æ¸…é™¤å¼±åº”ç”¨
    }
    if (isa.has_sidetable_rc) {
        table.refcnts.erase(this); // æ¸…ç©ºå¼•ç”¨è®¡æ•°
    }
    table.unlock();
}
```

åœ¨ objc-weak.mm æ–‡ä»¶æŸ¥çœ‹ `weak_clear_no_lock()` æ–¹æ³•ï¼š
```
void 
weak_clear_no_lock(weak_table_t *weak_table, id referent_id) 
{
    // è·å–å½“å‰å¯¹è±¡
    objc_object *referent = (objc_object *)referent_id;

    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); // ä¼ å…¥å¼±å¼•ç”¨è¡¨å’Œå½“å‰å¯¹è±¡çš„åœ°å€å€¼ï¼Œæ‰¾åˆ°å¯¹åº”çš„å¼±å¼•ç”¨æ•°ç»„
    if (entry == nil) {
        return; // å¦‚æœæ²¡æœ‰è¡¨ç¤ºå½“å‰å¯¹è±¡æ²¡æœ‰å¼±å¼•ç”¨ï¼Œä¸ç”¨å¤„ç†ç›´æ¥è¿”å›
    }

    // zero out references
    weak_referrer_t *referrers;
    size_t count;
    
    if (entry->out_of_line()) {
        referrers = entry->referrers;
        count = TABLE_SIZE(entry);
    } 
    else {
        referrers = entry->inline_referrers;
        count = WEAK_INLINE_COUNT;
    }
    
    for (size_t i = 0; i < count; ++i) {
        objc_object **referrer = referrers[i];
        if (referrer) {
            if (*referrer == referent) {
                *referrer = nil;
            }
            else if (*referrer) {
                _objc_inform("__weak variable at %p holds %p instead of %p. "
                             "This is probably incorrect use of "
                             "objc_storeWeak() and objc_loadWeak(). "
                             "Break on objc_weak_error to debug.\n", 
                             referrer, (void*)*referrer, (void*)referent);
                objc_weak_error();
            }
        }
    }
    
    weak_entry_remove(weak_table, entry);
}

......

static weak_entry_t *
weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)
{
    ASSERT(referent);

    weak_entry_t *weak_entries = weak_table->weak_entries; // åœ¨weak_tableä¸­å–å‡ºweak_entry_tæ•°ç»„

    if (!weak_entries) return nil;

    size_t begin = hash_pointer(referent) & weak_table->mask; // é€šè¿‡hashå®ä¾‹å¯¹è±¡çš„åœ°å€ & weak_table->maskå¾—åˆ°begin(æ²¡æœ‰hashå†²çªçš„index)ï¼Œå› ä¸ºæ˜¯ & mask(2çš„næ¬¡æ–¹-1ï¼Œç±»ä¼¼00001111)ï¼Œæ‰€ä»¥ä¿è¯äº†beginåœ¨maskèŒƒå›´å†…(<=mask)
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_table->weak_entries[index].referent != referent) { // whileå¾ªç¯æ£€æµ‹hashå†²çªï¼Œå¦‚æœæœ‰å†²çª,index+1ï¼Œhash_displacement++ï¼ˆhashå†²çªåç§»é‡ï¼‰
        index = (index+1) & weak_table->mask;
        if (index == begin) bad_weak_table(weak_table->weak_entries);
        hash_displacement++;
        if (hash_displacement > weak_table->max_hash_displacement) {
            return nil;
        }
    }
    
    return &weak_table->weak_entries[index];
}
```

# è‡ªåŠ¨é‡Šæ”¾æ± 
è‡ªåŠ¨é‡Šæ”¾æ± çš„ä¸»è¦åº•å±‚æ•°æ®ç»“æ„æ˜¯ï¼š`__AtAutoreleasePool`ã€`AutoreleasePoolPage`ï¼Œè°ƒç”¨äº† `autorelease` çš„å¯¹è±¡æœ€ç»ˆéƒ½æ˜¯é€šè¿‡ `AutoreleasePoolPage` å¯¹è±¡æ¥ç®¡ç†çš„ã€‚

## \_\_AtAutoreleasePool

å †ä»£ç ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person = [[[Person alloc] init] autorelease];
    }
    return 0;
}
```

æ‰¾åˆ° main.m æ‰€åœ¨æ–‡ä»¶ï¼Œåœ¨ç»ˆç«¯è¾“å…¥ï¼š
```
$ xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc main.m
```

ä¸Šé¢çš„ä»£ç è½¬æˆ C++ ä»£ç åå°±æ˜¯è¿™ä¸ªæ ·å­ï¼š
```
int main(int argc, const char * argv[]) {
    {
        __AtAutoreleasePool __autoreleasepool; 
        Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init")), sel_registerName("autorelease"));
    }
    return 0;
}
```

ç®€åŒ–ä¸€ä¸‹ï¼š
```
int main(int argc, const char * argv[]) {
    {
        __AtAutoreleasePool __autoreleasepool; 
        Person *person = [[[Person alloc] init] autorelease];
    }
    return 0;
}
```

åœ¨ç”Ÿæˆçš„ main.mm æ–‡ä»¶ä¸­æœç´¢ `__AtAutoreleasePool`ï¼Œ`__AtAutoreleasePool` æ˜¯ä¸€ä¸ª C++ ç»“æ„ä½“ï¼š
```
struct __AtAutoreleasePool {
    // æ„é€ å‡½æ•°ï¼Œåœ¨åˆ›å»ºç»“æ„ä½“çš„æ—¶å€™è°ƒç”¨
    __AtAutoreleasePool() {
        atautoreleasepoolobj = objc_autoreleasePoolPush();
    }
    // ææ„å‡½æ•°ï¼Œåœ¨ç»“æ„ä½“é”€æ¯çš„æ—¶å€™è°ƒç”¨
    ~__AtAutoreleasePool() {
        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    void * atautoreleasepoolobj;
};
```

è®¤è¯†äº† `__AtAutoreleasePool` ç»“æ„ä½“åï¼Œé€šè¿‡ clang ç”Ÿæˆçš„ C++ ä»£ç å¯ä»¥çœ‹åšï¼š
```
int main(int argc, const char * argv[]) {
    atautoreleasepoolobj = objc_autoreleasePoolPush();
 
    MJPerson *person = [[[MJPerson alloc] init] autorelease];
 
    objc_autoreleasePoolPop(atautoreleasepoolobj);
    return 0;
}
```

é€šè¿‡ä¸Šé¢çš„æ‘¸ç´¢ï¼Œ`@autoreleasepool {}` çš„ç¬¬ä¸€ä¸ªå¤§æ‹¬å·å…¶å®æ˜¯è°ƒç”¨äº† `objc_autoreleasePoolPush()` æ–¹æ³•ï¼Œç¬¬äºŒä¸ªå¤§æ‹¬å·æ˜¯è°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œ`objc_autoreleasePoolPop()` æ–¹æ³•çš„å‚æ•°æ˜¯ `objc_autoreleasePoolPush()` æ–¹æ³•ç”Ÿæˆçš„ `atautoreleasepoolobj`ã€‚

å¦‚æœæœ‰å¤šä¸ª `@autoreleasepool {}` åµŒå¥—çš„è¯å°±æ˜¯è¿™æ ·ï¼š
```
int main(int argc, const char * argv[]) {
    @autoreleasepool { // objc_autoreleasePoolPush()
        
        @autoreleasepool { // objc_autoreleasePoolPush()
            
            @autoreleasepool { // objc_autoreleasePoolPush()
               
                Person *person = [[[Person alloc] init] autorelease];
            
            } // objc_autoreleasePoolPop()
        
        } // objc_autoreleasePoolPop()
    
    } // objc_autoreleasePoolPop()
    return 0;
}
```

æŸ¥çœ‹ `objc_autoreleasePoolPush()` æºç ï¼š
```
void *
objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}
```

æŸ¥çœ‹ `objc_autoreleasePoolPop()` æºç ï¼š
```
NEVER_INLINE
void
objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}
```

ä»æºç å¯ä»¥çœ‹åˆ°ï¼Œ`objc_autoreleasePoolPush()` å’Œ `objc_autoreleasePoolPop()` æ–¹æ³•å†…éƒ¨éƒ½æ˜¯é€šè¿‡ `AutoreleasePoolPage` å®ç°çš„ã€‚

## AutoreleasePoolPage

### å®šä¹‰
åœ¨ [objc4-781](https://opensource.apple.com/tarballs/objc4/) çš„ NSObject-internal.h æ–‡ä»¶å¯ä»¥çœ‹åˆ° AutoreleasePoolPage çš„å®šä¹‰ï¼š
```
class AutoreleasePoolPage;
struct AutoreleasePoolPageData
{
	magic_t const magic; // ç”¨äºæ ¡éªŒå†…å­˜æ˜¯å¦æŸå
	__unsafe_unretained id *next; // æŒ‡å‘äº†ä¸‹ä¸€ä¸ªèƒ½å­˜æ”¾autoreleaseå¯¹è±¡åœ°å€çš„åŒºåŸŸ
	pthread_t const thread; // çº¿ç¨‹
	AutoreleasePoolPage * const parent; // å‰é©±ç»“ç‚¹ï¼ŒæŒ‡å‘å‰ä¸€ä¸ªpage
	AutoreleasePoolPage *child; // åç»§ç»“ç‚¹ï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªpage
	uint32_t const depth;
	uint32_t hiwat;

	AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)
		: magic(), next(_next), thread(_thread),
		  parent(_parent), child(nil),
		  depth(_depth), hiwat(_hiwat)
	{
	}
};

class AutoreleasePoolPage : private AutoreleasePoolPageData
{
    ......
}
```

`AutoreleasePoolPage` ç»“æ„ä½“çš„ thread å­˜å‚¨çš„æ˜¯å…¶å¯¹åº”çš„çº¿ç¨‹ï¼Œä¹Ÿè¡¨ç¤ºä¸€ä¸ª `AutoreleasePoolPage` å¯¹åº”ä¸€ä¸ªçº¿ç¨‹ã€‚

### ç»“æ„
æ¯ä¸ª `AutoreleasePoolPage` å¯¹è±¡å ç”¨4096å­—èŠ‚å†…å­˜ï¼Œé™¤äº†ç”¨æ¥å­˜æ”¾å®ƒå†…éƒ¨çš„æˆå‘˜å˜é‡ï¼Œå‰©ä¸‹çš„ç©ºé—´ç”¨æ¥å­˜æ”¾ `autorelease` å¯¹è±¡çš„åœ°å€ï¼Œæ‰€æœ‰çš„ `AutoreleasePoolPage` å¯¹è±¡é€šè¿‡åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥åœ¨ä¸€èµ·ã€‚

å‡è®¾ `AutoreleasePoolPage` å¯¹è±¡çš„å†…å­˜åœ°å€ä» `0x1000` å¼€å§‹ï¼š
![å†…å­˜ç®¡ç†14](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†14.png)
ä» `0x1000` åˆ° `0x2000` å…±4096ä¸ªå­—èŠ‚ï¼ˆ`0x1000`ï¼‰ã€‚  
ä» `0x1000` åˆ° `0x1038` å…±56ä¸ªå­—èŠ‚ï¼ˆ`0x38`ï¼‰ï¼Œå³ `AutoreleasePoolPage` ç»“æ„ä½“å†…éƒ¨çš„æˆå‘˜å˜é‡å¤§å°ä¹‹å’Œã€‚  
ä» `0x1038` åˆ° `0x2000` å…±4040ä¸ªå­—èŠ‚ï¼Œåˆ†åˆ«æ˜¯ `begain()` å’Œ `end()` æ–¹æ³•è°ƒç”¨çš„ä½ç½®ï¼Œè¿™æ®µå†…å­˜ç”¨æ¥ä¿å­˜è°ƒç”¨äº† `autorelease` æ–¹æ³•çš„å¯¹è±¡çš„åœ°å€å€¼ã€‚  

æŸ¥çœ‹ `begain()` æ–¹æ³•æºç ï¼š
```
id * begin() {
    return (id *) ((uint8_t *)this+sizeof(*this));
}
```

å¯ä»¥çœ‹åˆ° `begain()` æ–¹æ³•å†…éƒ¨ç›´æ¥è¿”å›çš„æ˜¯ `AutoreleasePoolPage` å†…å­˜åœ°å€å¼€å§‹ä½ç½®åŠ ä¸Šå…¶è‡ªèº«å ç”¨å†…å­˜å¤§å°ï¼ˆ`0x1000` + `0x38` = `0x1038`ï¼‰ã€‚

æŸ¥çœ‹ `end()` æ–¹æ³•æºç ï¼š
```
id * end() {
    return (id *) ((uint8_t *)this+SIZE);
}
```

å¯ä»¥çœ‹åˆ° `end()` æ–¹æ³•å†…éƒ¨ç›´æ¥è¿”å›çš„æ˜¯ `AutoreleasePoolPage` å†…å­˜åœ°å€å¼€å§‹ä½ç½®åŠ ä¸Š `SIZE`ï¼š
```
#define I386_PGBYTES            4096            /* bytes per 80386 page */
#define PAGE_SIZE               I386_PGBYTES
#define PAGE_MAX_SIZE           PAGE_SIZE

static size_t const SIZE =
#if PROTECT_AUTORELEASEPOOL
		PAGE_MAX_SIZE;  // must be multiple of vm page size
#else
		PAGE_MIN_SIZE;  // size and alignment, power of 2
#endif
```

ä¸€ä¸ª `AutoreleasePoolPage` ç»“æ„ä½“èƒ½å¤Ÿå­˜æ”¾çš„ `autorelease` å¯¹è±¡çš„åœ°å€æ˜¯æœ‰é™çš„ï¼Œå¦‚æœè¶…å‡ºå­˜å‚¨æœ€å¤§å€¼ï¼Œä¼šæ–°åˆ›å»ºä¸€ä¸ª `AutoreleasePoolPage` ç»“æ„ä½“ç”¨æ¥å­˜å‚¨å‰©ä¸‹çš„éƒ¨åˆ†ã€‚å¤šä¸ª `AutoreleasePoolPage` ç»“æ„ä½“é€šè¿‡æœºæ„ä½“ä¸­çš„ child æŒ‡å‘ä¸‹ä¸€ä¸ª `AutoreleasePoolPage` ç»“æ„ä½“ï¼Œé€šè¿‡ parent æŒ‡å‘ä¸Šä¸€ä¸ª `AutoreleasePoolPage` ç»“æ„ä½“ï¼Œæ„æˆåŒå‘é“¾è¡¨ç»“æ„ï¼š
![å†…å­˜ç®¡ç†15](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†15.png)

* ğŸ‘‰ åŒå‘é“¾è¡¨ä¹Ÿå«åŒé“¾è¡¨ï¼Œæ˜¯é“¾è¡¨çš„ä¸€ç§ï¼Œå®ƒçš„æ¯ä¸ªæ•°æ®ç»“ç‚¹ä¸­éƒ½æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘ç›´æ¥åç»§å’Œç›´æ¥å‰é©±ã€‚æ‰€ä»¥ï¼Œä»åŒå‘é“¾è¡¨ä¸­çš„ä»»æ„ä¸€ä¸ªç»“ç‚¹å¼€å§‹ï¼Œéƒ½å¯ä»¥å¾ˆæ–¹ä¾¿åœ°è®¿é—®å®ƒçš„å‰é©±ç»“ç‚¹å’Œåç»§ç»“ç‚¹ã€‚
* ğŸ‘‰ å¾ªç¯é“¾è¡¨æ˜¯å¦ä¸€ç§å½¢å¼çš„é“¾å¼å­˜è´®ç»“æ„ã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯è¡¨ä¸­æœ€åä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆåŸŸæŒ‡å‘å¤´ç»“ç‚¹ï¼Œæ•´ä¸ªé“¾è¡¨å½¢æˆä¸€ä¸ªç¯ã€‚

### åŸç†
è°ƒç”¨ `push` æ–¹æ³•ä¼šå°†ä¸€ä¸ª `POOL_BOUNDARY` å…¥æ ˆï¼Œå¹¶ä¸”è¿”å›å…¶å­˜æ”¾çš„å†…å­˜åœ°å€ã€‚  
è°ƒç”¨ `pop` æ–¹æ³•æ—¶ä¼ å…¥ä¸€ä¸ª `POOL_BOUNDARY` çš„å†…å­˜åœ°å€ï¼Œä¼šä»æœ€åä¸€ä¸ªå…¥æ ˆçš„å¯¹è±¡å¼€å§‹å‘é€ `release` æ¶ˆæ¯ï¼Œç›´åˆ°é‡åˆ°è¿™ä¸ª `POOL_BOUNDARY`ã€‚  
`id *next` æŒ‡å‘äº†ä¸‹ä¸€ä¸ªèƒ½å­˜æ”¾ `autorelease` å¯¹è±¡åœ°å€çš„åŒºåŸŸã€‚    

æ¯”å¦‚åœ¨ `@autoreleasepool {}` å†…åˆ›å»º1000ä¸ª person å¯¹è±¡è°ƒç”¨ `autorelease`ã€‚
```
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        for (int i=0; i<1000; i++) {
            Person *person = [[[Person alloc] init] autorelease];
        }
    }
    return 0;
}
```

ä¸€ä¸ª person å¯¹è±¡çš„æŒ‡é’ˆå 8ä¸ªå­—èŠ‚ï¼Œ1000ä¸ª person å¯¹è±¡å°±æ˜¯8000ä¸ªå­—èŠ‚ã€‚ä¸€ä¸ª `AutoreleasePoolPage` å¯¹è±¡å¯ä»¥ä¿å­˜4040ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ä¼šå†åˆ›å»ºä¸€ä¸ª `AutoreleasePoolPage` å¯¹è±¡ç”¨æ¥ä¿å­˜å‰©ä¸‹çš„ person å¯¹è±¡çš„åœ°å€å€¼ã€‚

å°† `@autoreleasepool {}` è½¬æˆ `__AtAutoreleasePool`ï¼š
```
int main(int argc, const char * argv[]) {
    atautoreleasepoolobj = objc_autoreleasePoolPush(); // atautoreleasepoolobj = 0x1038
    
    for (int i=0; i<1000; i++) {
        Person *person = [[[Person alloc] init] autorelease];
    } // 8000ä¸ªå­—èŠ‚

    objc_autoreleasePoolPop(atautoreleasepoolobj); // atautoreleasepoolobj = 0x1038
    return 0;
}
```

`objc_autoreleasePoolPush()` ä¼šè°ƒç”¨ `AutoreleasePoolPage` å¯¹è±¡çš„ `push()` æ–¹æ³•ï¼Œå°†ä¸€ä¸ª `POOL_BOUNDARY` å…¥æ ˆï¼Œå¹¶ä¸”è¿”å›å…¶å­˜æ”¾çš„å†…å­˜åœ°å€ï¼ˆ`0x1038`ï¼‰ï¼š
![å†…å­˜ç®¡ç†18](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†18.png)

æ¯ä¸ªè°ƒç”¨ `autorelease` æ–¹æ³•çš„ person å¯¹è±¡éƒ½ä¼šæ·»åŠ åˆ° `AutoreleasePoolPage` å¯¹è±¡ä¸­ï¼š
![å†…å­˜ç®¡ç†19](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†19.png)
æ­£å¦‚ä¸Šé¢æåˆ°çš„ä¸€æ ·ï¼Œä¸€ä¸ª `AutoreleasePoolPage` å¯¹è±¡å¯ä»¥ä¿å­˜4040ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ `AutoreleasePoolPage` å¯¹è±¡ç”¨æ¥ä¿å­˜å‰©ä¸‹çš„ person å¯¹è±¡çš„åœ°å€å€¼ã€‚

`objc_autoreleasePoolPop(atautoreleasepoolobj)` æ–¹æ³•ä¼ å…¥çš„ `atautoreleasepoolobj` æ˜¯ `objc_autoreleasePoolPush()` æ–¹æ³•è¿”å›çš„ `POOL_BOUNDARY` çš„åœ°å€å€¼ï¼ˆ`0x1038`ï¼‰ï¼Œå³ `objc_autoreleasePoolPop(POOL_BOUNDARY)`ã€‚æ‹¿åˆ° `POOL_BOUNDARY` åï¼Œ`objc_autoreleasePoolPop()` æ–¹æ³•å†…éƒ¨ä¼šä»æœ€åä¸€ä¸ªåŠ å…¥åˆ° `AutoreleasePoolPage` é‡Œçš„å¯¹è±¡å¼€å§‹ï¼Œä¾æ¬¡è°ƒç”¨ `release` æ–¹æ³•ï¼Œç›´åˆ° `POOL_BOUNDARY` å®Œæˆé‡Šæ”¾å·¥ä½œã€‚

åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œ`next` æŒ‡å‘ page ä¸­ä¸‹ä¸€ä¸ªå°†è¦å­˜æ”¾çš„å¯¹è±¡çš„åœ°å€, é€šè¿‡ `*next++ = obj` æ¥å®ç°å¯¹è±¡çš„å­˜å…¥å¹¶ `next` æŒ‡é’ˆçš„ç´¯åŠ , ç”¨ `id obj = *--page->next` æ¥å–å‡ºè¦ `release` çš„å¯¹è±¡å¹¶å®ç° `next` çš„é€’å‡ã€‚

### éªŒè¯
å¯ä»¥é€šè¿‡ä»¥ä¸‹ç§æœ‰å‡½æ•°æ¥æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± çš„æƒ…å†µï¼š
```
extern void _objc_autoreleasePoolPrint(void);
```

`_objc_autoreleasePoolPrint()` æ–¹æ³•æ˜¯å®šä¹‰åœ¨ Runtime é‡Œçš„ï¼Œæ‰€ä»¥æ˜¯ä¸å¼€æºçš„ã€‚ä½†æ˜¯å¯ä»¥é€šè¿‡ `extern` å…³é”®å­—åœ¨ main.m æ–‡ä»¶ä¸­å£°æ˜ï¼Œç¼–è¯‘å™¨å°±ä¼šè‡ªåŠ¨å»æ‰¾åˆ°è¿™ä¸ªæ–¹æ³•ï¼Œä»è€Œå®ç°è°ƒç”¨ã€‚
```
extern void _objc_autoreleasePoolPrint(void);

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        _objc_autoreleasePoolPrint(); // ä½ç½®0

        Person *person1 = [[[Person alloc] init] autorelease];
        Person *person2 = [[[Person alloc] init] autorelease];
        
        //_objc_autoreleasePoolPrint(); // ä½ç½®1

        @autoreleasepool {
            Person *person3 = [[[Person alloc] init] autorelease];
            Person *person4 = [[[Person alloc] init] autorelease];

            //_objc_autoreleasePoolPrint(); // ä½ç½®2

            @autoreleasepool {
                Person *person5 = [[[Person alloc] init] autorelease];
                Person *person6 = [[[Person alloc] init] autorelease];

                //_objc_autoreleasePoolPrint(); // ä½ç½®3
            }

            //_objc_autoreleasePoolPrint(); // ä½ç½®4
        }

        //_objc_autoreleasePoolPrint(); // ä½ç½®5
    }

    //_objc_autoreleasePoolPrint(); // ä½ç½®6
    return 0;
}
```

ä½ç½®0ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13812]: ##############
objc[13812]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13812]: 0 releases pending.
objc[13812]: [0x1]  ................  PAGE (placeholder)
objc[13812]: [0x1]  ################  POOL (placeholder)
objc[13812]: ##############
Program ended with exit code: 0
```

ä½ç½®1ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13633]: ##############
objc[13633]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13633]: 3 releases pending.
objc[13633]: [0x10400a000]  ................  PAGE  (hot) (cold)
objc[13633]: [0x10400a038]  ################  POOL 0x10400a038
objc[13633]: [0x10400a040]       0x10293c6e0  Person
objc[13633]: [0x10400a048]       0x10293b7a0  Person
objc[13633]: ##############
Program ended with exit code: 0
```

ä½ç½®2ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13658]: ##############
objc[13658]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13658]: 6 releases pending.
objc[13658]: [0x10400a000]  ................  PAGE  (hot) (cold)
objc[13658]: [0x10400a038]  ################  POOL 0x10400a038
objc[13658]: [0x10400a040]       0x102974880  Person
objc[13658]: [0x10400a048]       0x102973940  Person
objc[13658]: [0x10400a050]  ################  POOL 0x10400a050
objc[13658]: [0x10400a058]       0x1029722e0  Person
objc[13658]: [0x10400a060]       0x102973800  Person
objc[13658]: ##############
Program ended with exit code: 0
```

ä½ç½®3ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13677]: ##############
objc[13677]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13677]: 9 releases pending.
objc[13677]: [0x10280d000]  ................  PAGE  (hot) (cold)
objc[13677]: [0x10280d038]  ################  POOL 0x10280d038
objc[13677]: [0x10280d040]       0x1006addd0  Person
objc[13677]: [0x10280d048]       0x1006ace90  Person
objc[13677]: [0x10280d050]  ################  POOL 0x10280d050
objc[13677]: [0x10280d058]       0x1006ab830  Person
objc[13677]: [0x10280d060]       0x1006acd50  Person
objc[13677]: [0x10280d068]  ################  POOL 0x10280d068
objc[13677]: [0x10280d070]       0x1006aba20  Person
objc[13677]: [0x10280d078]       0x1006ab4f0  Person
objc[13677]: ##############
Program ended with exit code: 0
```

ä½ç½®4ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13703]: ##############
objc[13703]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13703]: 6 releases pending.
objc[13703]: [0x10080d000]  ................  PAGE  (hot) (cold)
objc[13703]: [0x10080d038]  ################  POOL 0x10080d038
objc[13703]: [0x10080d040]       0x100437c20  Person
objc[13703]: [0x10080d048]       0x100436ce0  Person
objc[13703]: [0x10080d050]  ################  POOL 0x10080d050
objc[13703]: [0x10080d058]       0x100435680  Person
objc[13703]: [0x10080d060]       0x100436ba0  Person
objc[13703]: ##############
Program ended with exit code: 0
```

ä½ç½®5ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13735]: ##############
objc[13735]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13735]: 3 releases pending.
objc[13735]: [0x10480a000]  ................  PAGE  (hot) (cold)
objc[13735]: [0x10480a038]  ################  POOL 0x10480a038
objc[13735]: [0x10480a040]       0x10322c4d0  Person
objc[13735]: [0x10480a048]       0x10322b590  Person
objc[13735]: ##############
Program ended with exit code: 0
```

ä½ç½®6ï¼Œæ‰“å°ç»“æœï¼š
```
objc[13751]: ##############
objc[13751]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13751]: 0 releases pending.
objc[13751]: [0x10300d000]  ................  PAGE  (hot) (cold)
objc[13751]: ##############
Program ended with exit code: 0
```

æ‰“å°ç»“æœä¸­çš„ `POOL` ä»£è¡¨çš„å°±æ˜¯ `POOL_BOUNDARY`ï¼Œperson ä»£è¡¨çš„å°±æ˜¯è°ƒç”¨ `autorelease` æ–¹æ³•çš„å¯¹è±¡ã€‚`releases pending` è¡¨ç¤ºå½“å‰è‡ªåŠ¨é‡Šæ”¾æ± é‡Œçš„å¯¹è±¡ä¸ªæ•°ã€‚ 

å¤šä¸ª `AutoreleasePoolPage` å¯¹è±¡çš„æƒ…å†µï¼š
```
extern void _objc_autoreleasePoolPrint(void);

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *person1 = [[[Person alloc] init] autorelease];
        Person *person2 = [[[Person alloc] init] autorelease];

        @autoreleasepool {
            for (int i=0; i<600; i++) {
                Person *person3 = [[[Person alloc] init] autorelease];
            }

            @autoreleasepool {
                Person *person5 = [[[Person alloc] init] autorelease];
                Person *person6 = [[[Person alloc] init] autorelease];

                _objc_autoreleasePoolPrint();
            }
        }
    }
    return 0;
}
```

æ‰“å°ç»“æœï¼š
```
objc[13947]: ##############
objc[13947]: AUTORELEASE POOLS for thread 0x1000d3dc0
objc[13947]: 607 releases pending.
objc[13947]: [0x10280c000]  ................  PAGE (full)  (cold)
objc[13947]: [0x10280c038]  ################  POOL 0x10280c038
objc[13947]: [0x10280c040]       0x10067bc20  Person
objc[13947]: [0x10280c048]       0x10067a1d0  Person
objc[13947]: [0x10280c050]  ################  POOL 0x10280c050
objc[13947]: [0x10280c058]       0x100679d60  Person
objc[13947]: [0x10280c060]       0x100678e20  Person
objc[13947]: [0x10280c068]       0x1006777c0  Person
objc[13947]: [0x10280c070]       0x100678ce0  Person
...
objc[13947]: [0x10280cff8]       0x100681ba0  Person
objc[13947]: [0x10280a000]  ................  PAGE  (hot) 
objc[13947]: [0x10280a038]       0x100681bb0  Person
...
objc[13947]: [0x10280a348]       0x1006821d0  Person
objc[13947]: [0x10280a350]  ################  POOL 0x10280a350
objc[13947]: [0x10280a358]       0x1006821e0  Person
objc[13947]: [0x10280a360]       0x1006821f0  Person
```

ä»æ‰“å°ç»“æœä¸­å¯ä»¥çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ª page é‡Œæœ‰ä¸¤ä¸ª `POOL_BOUNDARY`ï¼Œç”±äºå¯¹è±¡å¤ªå¤šè¶…å‡ºäº†ç¬¬ä¸€ä¸ª page çš„å­˜å‚¨èŒƒå›´ï¼Œæ‰€ä»¥åˆ›å»ºå‡ºäº†ç¬¬äºŒä¸ª pageã€‚ç¬¬äºŒä¸ª page ä¸­å­˜å‚¨äº†å¤šå‡ºæ¥çš„ person å¯¹è±¡ï¼Œè¿˜æœ‰ä¸€ä¸ª `POOL_BOUNDARY`ã€‚  
`PAGE  (hot) ` è¡¨ç¤ºè¯¥ page ä¸ºå½“å‰é¡µï¼Œ`PAGE (full)  (cold)` ä¸­çš„ full è¡¨ç¤ºè¿™ä¸€é¡µå·²ç»æ»¡äº†ï¼Œcold è¡¨ç¤ºè¯¥ page ä¸æ˜¯å½“å‰é¡µã€‚

### æºç åˆ†æ

`objc_autoreleasePoolPush()` æ–¹æ³•çš„å®ç°åŸç†æ˜¯è°ƒç”¨ `AutoreleasePoolPage` å¯¹è±¡çš„ `push()` æ–¹æ³•ã€‚  
`objc_autoreleasePoolPop()` æ–¹æ³•çš„å®ç°åŸç†æ˜¯è°ƒç”¨ `AutoreleasePoolPage` å¯¹è±¡çš„ `pop()` æ–¹æ³•ã€‚  
`autorelease` æ–¹æ³•çš„å®ç°åŸç†åˆ™æ˜¯è°ƒç”¨äº† `AutoreleasePoolPage` å¯¹è±¡çš„ `autorelease()` æ–¹æ³•ã€‚

åœ¨ [objc4-781](https://opensource.apple.com/tarballs/objc4/) ä¸­çš„ NSObject.mm æ–‡ä»¶æŸ¥çœ‹ã€‚

#### objc_autoreleasePoolPush(void)
```
void *
objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}
```

`push()` æ–¹æ³•ï¼š
```
static inline void *push() 
{
    id *dest;
    if (slowpath(DebugPoolAllocation)) {
        dest = autoreleaseNewPage(POOL_BOUNDARY); // ä¼ å…¥ POOL_BOUNDARY æ¥æ–°å»ºä¸€ä¸ª AutoreleasePoolPage å¯¹è±¡
    } else {
        dest = autoreleaseFast(POOL_BOUNDARY); // AutoreleasePoolPage å¯¹è±¡å·²ç»å­˜åœ¨å°±ç›´æ¥æ·»åŠ 
    }
    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
    return dest;
}
```

å¦‚æœ page ä¸å­˜åœ¨å°±è°ƒç”¨ `autoreleaseNewPage()` æ–¹æ³•ä¼ å…¥ `POOL_BOUNDARY` åˆ›å»ºï¼š
```
static __attribute__((noinline))
id *autoreleaseNewPage(id obj)
{
    AutoreleasePoolPage *page = hotPage(); // è·å–å½“å‰ page
    if (page) return autoreleaseFullPage(obj, page);
    else return autoreleaseNoPage(obj);
}

static inline AutoreleasePoolPage *hotPage() 
{
    AutoreleasePoolPage *result = (AutoreleasePoolPage *)
        tls_get_direct(key);
    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;
    if (result) result->fastcheck();
    return result;
}

static __attribute__((noinline))
id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
{
    // The hot page is full. 
    // Step to the next non-full page, adding a new page if necessary.
    // Then add the object to that page.
    ASSERT(page == hotPage());
    ASSERT(page->full()  ||  DebugPoolAllocation);

    do {
        if (page->child) page = page->child;
        else page = new AutoreleasePoolPage(page);
    } while (page->full());

    setHotPage(page);
    return page->add(obj); // å…¥æ ˆ POOL_BOUNDARY
}
```

å¦‚æœ `AutoreleasePoolPage` å¯¹è±¡å·²ç»å­˜åœ¨å°±ç›´æ¥è°ƒç”¨ `autoreleaseFast()` æ–¹æ³•æ·»åŠ  `POOL_BOUNDARY`ï¼š
```
static inline id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    if (page && !page->full()) { // page å­˜åœ¨ && page æ²¡æœ‰æ»¡
        return page->add(obj); // æ·»åŠ  obj
    } else if (page) { // page å­˜åœ¨ && page æ»¡äº†
        return autoreleaseFullPage(obj, page);
    } else { // page ä¸å­˜åœ¨
        return autoreleaseNoPage(obj);
    }
}
```

#### - (id)autorelease
```
- (id)autorelease {
    return _objc_rootAutorelease(self);
}

NEVER_INLINE id
_objc_rootAutorelease(id obj)
{
    ASSERT(obj);
    return obj->rootAutorelease();
}

__attribute__((noinline,used))
id 
objc_object::rootAutorelease2()
{
    ASSERT(!isTaggedPointer());
    return AutoreleasePoolPage::autorelease((id)this); // å°†å½“å‰å¯¹è±¡ this åŠ å…¥ page
}
```

`autorelease((id)this)` æ–¹æ³•ï¼š
```
static inline id autorelease(id obj)
{
    ASSERT(obj);
    ASSERT(!obj->isTaggedPointer());
    id *dest __unused = autoreleaseFast(obj); // æ·»åŠ  obj
    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);
    return obj;
}
```

è°ƒç”¨ `autoreleaseFast()` æ–¹æ³•æ·»åŠ  objï¼š
```
static inline id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    if (page && !page->full()) { // page å­˜åœ¨ && page æ²¡æœ‰æ»¡
        return page->add(obj); // æ·»åŠ  obj
    } else if (page) { // page å­˜åœ¨ && page æ»¡äº†
        return autoreleaseFullPage(obj, page);
    } else { // page ä¸å­˜åœ¨
        return autoreleaseNoPage(obj);
    }
}
```

`autorelease` æ–¹æ³•æœ€ç»ˆæ˜¯é€šè¿‡è°ƒç”¨ `autoreleaseFast()` æ–¹æ³•ï¼Œå°†è°ƒç”¨äº† `autorelease` æ–¹æ³•çš„å¯¹è±¡ä¿å­˜åˆ°äº† page ä¸­ã€‚

#### objc_autoreleasePoolPop(void *ctxt)
```
NEVER_INLINE
void
objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}
```

`pop()` æ–¹æ³•ï¼š
```
static inline void
pop(void *token)
{
    AutoreleasePoolPage *page;
    id *stop;
    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
        page = hotPage(); // ä»å½“å‰çš„ page å¼€å§‹ pop
        if (!page) {
            // Pool was never used. Clear the placeholder.
            return setHotPage(nil);
        }
        // Pool was used. Pop its contents normally.
        // Pool pages remain allocated for re-use as usual.
        page = coldPage();
        token = page->begin();
    } else {
        page = pageForPointer(token);
    }

    stop = (id *)token;
    if (*stop != POOL_BOUNDARY) {
        if (stop == page->begin()  &&  !page->parent) {
            // Start of coldest page may correctly not be POOL_BOUNDARY:
            // 1. top-level pool is popped, leaving the cold page in place
            // 2. an object is autoreleased with no pool
        } else {
            // Error. For bincompat purposes this is not 
            // fatal in executables built with old SDKs.
            return badPop(token);
        }
    }

    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {
        return popPageDebug(token, page, stop);
    }

    return popPage<false>(token, page, stop); // é‡Šæ”¾å¯¹è±¡
}
```

`popPageDebug()` æ–¹æ³•ï¼š
```
__attribute__((noinline, cold))
static void
popPageDebug(void *token, AutoreleasePoolPage *page, id *stop)
{
    popPage<true>(token, page, stop);
}
```

`popPage()` æ–¹æ³•ï¼š
```
template<bool allowDebug>
static void
popPage(void *token, AutoreleasePoolPage *page, id *stop)
{
    if (allowDebug && PrintPoolHiwat) printHiwat();

    page->releaseUntil(stop); // é‡Šæ”¾ page é‡Œçš„æ‰€æœ‰å¯¹è±¡ï¼ŒçŸ¥é“é‡åˆ° stop æ‰åœæ­¢

    // memory: delete empty children
    if (allowDebug && DebugPoolAllocation  &&  page->empty()) {
        // special case: delete everything during page-per-pool debugging
        AutoreleasePoolPage *parent = page->parent;
        page->kill();
        setHotPage(parent);
    } else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {
        // special case: delete everything for pop(top)
        // when debugging missing autorelease pools
        page->kill();
        setHotPage(nil);
    } else if (page->child) {
        // hysteresis: keep one empty child if page is more than half full
        if (page->lessThanHalfFull()) {
            page->child->kill();
        }
        else if (page->child->child) {
            page->child->child->kill();
        }
    }
}
```

`releaseUntil()` æ–¹æ³•ï¼š
```
void releaseUntil(id *stop) 
{
    while (this->next != stop) {
        AutoreleasePoolPage *page = hotPage(); // å–å‡ºå½“å‰ page

        while (page->empty()) {
            page = page->parent;
            setHotPage(page);
        }

        page->unprotect();
        id obj = *--page->next; // å–å‡ºæœ€åé¢çš„ä¸€ä¸ª obj
        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
        page->protect();

        if (obj != POOL_BOUNDARY) {
            objc_release(obj); // è°ƒç”¨objçš„releaseæ–¹æ³•
        }
    }

    setHotPage(this);
}
```

`pop()` æ–¹æ³•æœ€ç»ˆæ˜¯é€šè¿‡è°ƒç”¨ `releaseUntil()` æ–¹æ³•ï¼Œå°† page é‡Œçš„å¯¹è±¡ä¾æ¬¡è°ƒç”¨ `objc_release(obj)` æ–¹æ³•é‡Šæ”¾æ‰äº†ã€‚

## autorelease é‡Šæ”¾æ—¶æœº
åˆ›å»ºä¸€ä¸ª iOS é¡¹ç›®ï¼Œé€‰æ‹© MRC ç¯å¢ƒï¼Œä¿®æ”¹ main.m æ–‡ä»¶ï¼ˆå½“å‰XCodeç‰ˆæœ¬11.6ï¼‰ã€‚
```
int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
        return UIApplicationMain(argc, argv, nil, appDelegateClassName);
    }
}
```

å®šä¹‰ Person ç±»ï¼Œæ·»åŠ æ‰“å°ï¼š
```
@implementation Person
- (void)dealloc
{
    NSLog(@"%s", __func__);
    [super dealloc];
}
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    Person *person = [[[Person alloc] init] autorelease];
    NSLog(@"%s", __func__);
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    NSLog(@"%s", __func__);
}

- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    NSLog(@"%s", __func__);
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[ViewController viewDidLoad]
-[ViewController viewWillAppear:]
-[Person dealloc]
-[ViewController viewDidAppear:]
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œperson å¯¹è±¡æ˜¯åœ¨ `viewWillAppear` æ–¹æ³•æ‰§è¡Œå®Œæˆåè¢«é‡Šæ”¾çš„ã€‚

### Runloopå’ŒAutorelease
iOS åœ¨ä¸»çº¿ç¨‹çš„ Runloop ä¸­æ³¨å†Œäº†ä¸¤ä¸ª Observerï¼š  
ç¬¬ä¸€ä¸ª Observer ç›‘å¬äº† `kCFRunLoopEntry` äº‹ä»¶ï¼Œä¼šè°ƒç”¨ `objc_autoreleasePoolPush()`ã€‚  
ç¬¬äºŒä¸ª Observer ç›‘å¬äº† `kCFRunLoopBeforeWaiting` äº‹ä»¶ï¼Œä¼šè°ƒç”¨ `objc_autoreleasePoolPop()`ã€`objc_autoreleasePoolPush()`ï¼Œç›‘å¬äº† `kCFRunLoopBeforeExit` äº‹ä»¶ï¼Œä¼šè°ƒç”¨ `objc_autoreleasePoolPop()`ã€‚

æ‰“å°å½“å‰çš„ RunLoopï¼ŒæŸ¥çœ‹ Observersï¼š
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    Person *person = [[[Person alloc] init] autorelease];
    NSLog(@"%s", __func__);
    
    NSLog(@"%@", [NSRunLoop currentRunLoop]);
}
@end
```

æ‰“å°ç»“æœé‡Œæœ‰å¾ˆå¤šå†…å®¹ï¼Œè¿™é‡Œæ˜¯æ‘˜å‡ºæ¥çš„è·Ÿ Autorelease ç›¸å…³çš„ä¸¤ä¸ª Observeï¼š
```
observers = (
    "<CFRunLoopObserver 0x6000009fc1e0 [0x7fff8062d750]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\n\t0 : <0x7fdaef00a048>\n)}}",

    "<CFRunLoopObserver 0x6000009fc280 [0x7fff8062d750]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\n\t0 : <0x7fdaef00a048>\n)}}"
),
```

`_wrapRunLoopWithAutoreleasePoolHandler` æ˜¯å›è°ƒæ–¹æ³•ï¼Œåœ¨æ”¶åˆ°æ¶ˆæ¯æ—¶ç”¨æ¥å¤„ç† Autorelease ç›¸å…³æ“ä½œã€‚

ç¬¬ä¸€ä¸ª observe çš„ `activities` æ˜¯ `0x1`ï¼Œç¬¬äºŒä¸ª observe çš„ `activities` æ˜¯ `0xa0`ã€‚

`activities` å¯¹åº”çš„æšä¸¾ï¼š
```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0),          // 1ï¼ˆåè¿›åˆ¶ï¼‰
    kCFRunLoopBeforeTimers = (1UL << 1),   // 2
    kCFRunLoopBeforeSources = (1UL << 2),  // 4
    kCFRunLoopBeforeWaiting = (1UL << 5),  // 32
    kCFRunLoopAfterWaiting = (1UL << 6),   // 64
    kCFRunLoopExit = (1UL << 7),           // 128
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
```

å› ä¸ºï¼š  
`0x1`ï¼ˆåå…­è¿›åˆ¶ï¼‰-> 1ï¼ˆåè¿›åˆ¶ï¼‰ 
`0xa0`ï¼ˆåå…­è¿›åˆ¶ï¼‰-> 160ï¼ˆåè¿›åˆ¶ï¼‰  
æ‰€ä»¥ï¼š    
```
0x1ï¼škCFRunLoopEntry
0xa0ï¼škCFRunLoopAfterWaiting | kCFRunLoopExit
```

æ‰€ä»¥ç¬¬ä¸€ä¸ª observe ç›‘å¬çš„çŠ¶æ€å°±æ˜¯ `kCFRunLoopEntry`ï¼Œç¬¬äºŒä¸ª observe ç›‘å¬çš„çŠ¶æ€å°±æ˜¯ `kCFRunLoopAfterWaiting` å’Œ `kCFRunLoopExit`ã€‚ 

![å†…å­˜ç®¡ç†20](å†…å­˜ç®¡ç†/å†…å­˜ç®¡ç†20.png)
* ç¬¬ä¸€æ¬¡å¾ªç¯ï¼š  
  01 çŠ¶æ€æ˜¯ `kCFRunLoopEntry`ï¼ŒRunLoop ä¼šè°ƒç”¨ `objc_autoreleasePoolPush()` æ–¹æ³•ï¼›  
  07 çŠ¶æ€æ˜¯ `kCFRunLoopAfterWaiting`ï¼ŒRunLoop ä¼šå…ˆè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ `objc_autoreleasePoolPush()` æ–¹æ³•ï¼› 
* éç¬¬ä¸€æ¬¡å¾ªç¯ï¼š
  10-1 å›åˆ° 02 ç»§ç»­å¾ªç¯è‡³ 07ï¼›  
  07 çŠ¶æ€æ˜¯ `kCFRunLoopAfterWaiting`ï¼ŒRunLoop ä¼šå…ˆè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ `objc_autoreleasePoolPush()` æ–¹æ³•ï¼› 
  10-1 å›åˆ° 02 ç»§ç»­å¾ªç¯è‡³ 07ï¼›  
* ç»“æŸå¾ªç¯ï¼š
  10-2 é€€å‡º RunLoopï¼›  
  11 çŠ¶æ€æ˜¯ `kCFRunLoopExit`ï¼ŒRunLoop ä¼šè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ã€‚

å› ä¸º 02 ä¼šå…ˆè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ `objc_autoreleasePoolPush()` æ–¹æ³•ï¼Œæ‰€ä»¥ `push()` å’Œ `pop()` å®ç°äº†ä¸€ä¸€å¯¹åº”çš„å…³ç³»ã€‚

åœ¨çœ‹æ‰“å°ç»“æœï¼š
```
-[ViewController viewDidLoad]
-[ViewController viewWillAppear:]
-[Person dealloc]
-[ViewController viewDidAppear:]
```

åœ¨ `viewWillAppear` æ‰§è¡Œå®Œæˆåï¼ŒRunLoop åˆ°äº† 02 çš„ä½ç½®ã€‚æ­¤æ—¶ RunLoop ç›‘å¬åˆ°äº† `kCFRunLoopAfterWaiting` çŠ¶æ€ï¼Œä¼šå…ˆè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ `objc_autoreleasePoolPush()` æ–¹æ³•ã€‚åœ¨è°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•æ—¶ï¼ŒAutorelease ä¸­çš„ person å¯¹è±¡å°±è¢«é‡Šæ”¾äº†ã€‚

å¦å¤–ï¼Œæ‰“å°ç»“æœä¹Ÿè¯´æ˜äº† `viewDidLoad` å’Œ `viewWillAppear` æ–¹æ³•æ˜¯åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­æ‰§è¡Œçš„ã€‚

### ARCç¯å¢ƒä¸‹çš„release
```
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    Person *person = [[Person alloc] init];
    NSLog(@"%s", __func__);
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    NSLog(@"%s", __func__);
}

- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    NSLog(@"%s", __func__);
}
@end
```

æ‰“å°ç»“æœï¼š
```
-[ViewController viewDidLoad]
-[Person dealloc]
-[ViewController viewWillAppear:]
-[ViewController viewDidAppear:]
```

ä»æ‰“å°ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œperson å¯¹è±¡åœ¨ `viewDidLoad` æ–¹æ³•æ‰§è¡Œå®Œå°±é‡Šæ”¾äº†ã€‚æ‰€ä»¥åœ¨ ARC ç¯å¢ƒä¸‹ï¼Œåœ¨æ–¹æ³•æœ€åç»“æŸå‰ï¼Œå¯¹æ–¹æ³•å†…éƒ¨çš„å±€éƒ¨å˜é‡è°ƒç”¨äº† release æ–¹æ³•ï¼š
```
- (void)viewDidLoad {
    [super viewDidLoad];
    Person *person = [[Person alloc] init];
    NSLog(@"%s", __func__);
    
    // [person release];
}
```

# æ€»ç»“
* ä½¿ç”¨ CADisplayLinkã€NSTimer æœ‰ä»€ä¹ˆæ³¨æ„ç‚¹ï¼Ÿ
  CADisplayLink å’Œ NSTimer ä¾èµ–äº RunLoopï¼Œå¦‚æœ RunLoop çš„ä»»åŠ¡è¿‡äºç¹é‡ï¼Œå¯èƒ½ä¼šå¯¼è‡´ CADisplayLink å’Œ NSTimer ä¸å‡†æ—¶ã€‚  
  CADisplayLink å’Œ NSTimer æœ‰å¯èƒ½ä¼šé€ æˆå¾ªç¯å¼•ç”¨é—®é¢˜ï¼ŒCADisplayLink å¯ä»¥é€šè¿‡ä½¿ç”¨ä»£ç†å¯¹è±¡ï¼ˆNSProxyï¼‰è§£å†³ï¼ŒNSTimer é™¤äº†å¯ä»¥é€šè¿‡ä½¿ç”¨ä»£ç†å¯¹è±¡ï¼ˆNSProxyï¼‰è§£å†³å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨å¸¦æœ‰ block å›è°ƒçš„åˆå§‹åŒ–æ–¹æ³•ã€‚  

* ä»‹ç»ä¸‹å†…å­˜çš„å‡ å¤§åŒºåŸŸ
  ä»£ç æ®µï¼šç¼–è¯‘ä¹‹åçš„ä»£ç   
  æ•°æ®æ®µï¼šå­—ç¬¦ä¸²å¸¸é‡ã€å·²åˆå§‹åŒ–æ•°æ®å’Œæœªåˆå§‹åŒ–æ•°æ®  
  æ ˆï¼šå‡½æ•°è°ƒç”¨å¼€é”€ï¼Œæ¯”å¦‚å±€éƒ¨å˜é‡ã€‚ï¼ˆåˆ†é…çš„å†…å­˜ç©ºé—´åœ°å€è¶Šæ¥è¶Šå°ï¼‰  
  å †ï¼šé€šè¿‡ allocã€mallocã€calloc ç­‰åŠ¨æ€åˆ†é…çš„ç©ºé—´ï¼Œåˆ†é…çš„å†…å­˜ç©ºé—´åœ°å€è¶Šæ¥è¶Šå¤§

* è®²ä¸€ä¸‹ä½ å¯¹ iOS å†…å­˜ç®¡ç†çš„ç†è§£
  åœ¨ iOS ä¸­ï¼Œä½¿ç”¨å¼•ç”¨è®¡æ•°æ¥ç®¡ç† OC å¯¹è±¡çš„å†…å­˜ã€‚  
  ä¸€ä¸ªæ–°åˆ›å»ºçš„ OC å¯¹è±¡å¼•ç”¨è®¡æ•°é»˜è®¤æ˜¯1ï¼Œå½“å¼•ç”¨è®¡æ•°å‡ä¸º0ï¼ŒOC å¯¹è±¡å°±ä¼šé”€æ¯ï¼Œé‡Šæ”¾å…¶å ç”¨çš„å†…å­˜ç©ºé—´ã€‚  
  è°ƒç”¨ retain ä¼šè®© OC å¯¹è±¡çš„å¼•ç”¨è®¡æ•°+1ï¼Œè°ƒç”¨ release ä¼šè®© OC å¯¹è±¡çš„å¼•ç”¨è®¡æ•°-1ã€‚  
  å†…å­˜ç®¡ç†çš„ç»éªŒæ€»ç»“ï¼š  
  å½“è°ƒç”¨ allocã€newã€copyã€mutableCopy æ–¹æ³•è¿”å›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨ä¸éœ€è¦è¿™ä¸ªå¯¹è±¡æ—¶ï¼Œè¦è°ƒç”¨ release æˆ–è€… autorelease æ¥é‡Šæ”¾å®ƒã€‚  
  æƒ³æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•°+1ï¼›ä¸æƒ³å†æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•°-1ã€‚  

* ARC éƒ½å¸®æˆ‘ä»¬åšäº†ä»€ä¹ˆï¼Ÿ(LLVM + Runtime)
  ARC æ˜¯ LLVM ç¼–è¯‘å™¨å’Œ Runtime åä½œåä½œå®ç°çš„ã€‚ARC åˆ©ç”¨ LLVM ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆ releaseã€retain å’Œ autorelease ç­‰å†…å­˜ç®¡ç†ç›¸å…³çš„ä»£ç ï¼Œåˆ©ç”¨ Runtime å®ç°åœ¨è¿è¡Œæ—¶å¯¹å¼±å¼•ç”¨çš„ç®¡ç†ï¼ˆæ·»åŠ å’Œæ¸…é™¤ï¼‰ã€‚

* weak æŒ‡é’ˆçš„å®ç°åŸç†
  å°†å¼±å¼•ç”¨å­˜å‚¨åœ¨ä¸€ä¸ªå¼±å¼•ç”¨è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰é‡Œé¢ï¼Œåœ¨å¯¹è±¡è¦é”€æ¯æ—¶ï¼Œå°±ä»¥å¯¹è±¡çš„åœ°å€å€¼ & mask å¾—åˆ°ä¸€ä¸ªç´¢å¼•å–å‡ºå¯¹åº”çš„å¼±å¼•ç”¨è¡¨ï¼Œå¹¶æŠŠå¼±å¼•ç”¨è¡¨é‡Œå­˜å‚¨çš„å¼±å¼•ç”¨éƒ½æ¸…é™¤æ‰ã€‚

* autorelease å¯¹è±¡åœ¨ä»€ä¹ˆæ—¶æœºä¼šè¢«è°ƒç”¨ releaseï¼Ÿ  
  autorelease å¯¹è±¡åœ¨ä»€ä¹ˆæ—¶å€™è°ƒç”¨ release æ˜¯ç”± RunLoop æ§åˆ¶çš„ï¼Œåœ¨ RunLoop ç›‘å¬åˆ° `kCFRunLoopAfterWaiting` æˆ– `kCFRunLoopExit` çŠ¶æ€æ—¶ä¼šè°ƒç”¨ `objc_autoreleasePoolPop()` æ–¹æ³•ï¼Œæ­¤æ—¶ autorelease å¯¹è±¡ä¼šè°ƒç”¨ releaseã€‚å³åœ¨ RunLoop è¿›å…¥ä¼‘çœ æˆ–è€…é€€å‡ºæ—¶è°ƒç”¨ releaseã€‚

* æ–¹æ³•é‡Œæœ‰å±€éƒ¨å¯¹è±¡ï¼Œ å‡ºäº†æ–¹æ³•åä¼šç«‹å³é‡Šæ”¾å—?
  ä¼šã€‚åœ¨æ–¹æ³•ç»“æŸå‰ï¼Œruntime ä¼šè‡ªåŠ¨ä¸ºæ–¹æ³•å†…éƒ¨çš„å±€éƒ¨å¯¹è±¡è°ƒç”¨ release æ–¹æ³•è¿›è¡Œé‡Šæ”¾ã€‚

ç›¸å…³é˜…è¯»ï¼š  
[æ·±å…¥ç†è§£ Tagged Pointer](https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/)



