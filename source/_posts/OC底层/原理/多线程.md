---
title: 多线程
date: 2020-07-14 16:31:01
tags: OC底层原理
---

思考：
* 你理解的多线程？
* iOS的多线程方案有哪几种？你更倾向于哪一种？
* 你在项目中用过 GCD 吗？
* GCD 的队列类型
* 说一下 OperationQueue 和 GCD 的区别，以及各自的优势
* 线程安全的处理手段有哪些？
* OC你了解的锁有哪些？在你回答基础上进行二次提问；  
追问一：自旋和互斥对比？  
追问二：使用以上锁需要注意哪些？  
追问三：用C/OC/C++，任选其一，实现自旋或互斥？
<!-- more -->
* 请问下面代码的打印结果是什么？
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        NSLog(@"1");
        [self performSelector:@selector(test) withObject:nil afterDelay:.0];
        NSLog(@"3");
    });
}

- (void)test
{
    NSLog(@"2");
}
@end
```

* 请问下面代码的打印结果是什么？
```
@implementation ViewController
- (void)test
{
    NSLog(@"2");
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"1");
    }];
    [thread start];
    
    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];
}
@end
```

# GCD

👉 [GCD源码](https://github.com/apple/swift-corelibs-libdispatch)

## iOS中的常见多线程方案

<!-- <style>
table th:nth-of-type(1){
    width: 20%;
}
table th:nth-of-type(2){
    width: 25%;
}
table th:nth-of-type(3){
    width: 20%;
}
table th:nth-of-type(4){
    width: 20%;
}
table th:nth-of-type(5){
    width: 15%;
}
</style> -->

| 技术方案 | 简介 | 语言 | 线程生命周期 | 使用频率 |
| :--: | :-------- | :--: | :--: | :--: |
| phread | 1.一套通用的多线程API；<br>2.适用于Unix\Linux\Windows等系统；<br>3.跨平台\可移植；<br>4.使用难度大；| C | 开发者管理 | 几乎不用 |
| NSThread | 1.使用更加面向对象；<br>2.简单易用，可直接操作线程对象； | OC | 开发者管理 | 偶尔使用 |
| GCD | 1.旨在替代NSThread等多线程技术； | C | 自动管理 | 经常使用 |
| NSOperation | 1.基于GCD（底层是GCD）；<br>2.比GCD多了一些更简单使用的功能；<br>3.使用更加面向对象； | OC | 自动管理 | 经常使用 |

phread 在实际开发中几乎不会用到，一般只会在加锁解锁的地方用到。另外，NSThead、GCD 和 NSOperation 底层都会用到 phread，比如创建线程等。NSThread 就是对 phread 的包装。

## GCD的常用函数

GCD 中有2个用来执行任务的函数：
* 用同步的方式执行任务（queue：队列；block：任务）  
```
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
```

* 用异步的方式执行任务  
```
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
```

队列相关函数：
* 获取主队列
```
dispatch_queue_t queue = dispatch_get_main_queue();
```

* 获取全局并发队列
```
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
```

* 手动创建并发队列
```
dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);
```

* 手动创建串行队列
```
dispatch_queue_t queue = dispatch_queue_create("mySerialQueue", DISPATCH_QUEUE_SERIAL);
```

* 手动创建队列组
```
dispatch_group_t group = dispatch_group_create();
```

## GCD的队列

GCD的队列可以分为2大类型
* 并发队列（Concurrent Dispatch Queue）  
可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）；  
并发功能只有在异步（dispatch_async）函数下才有效；

* 串行队列（Serial Dispatch Queue）  
让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）；

## 容易混淆的术语

有4个术语比较容易混淆：同步、异步、并发、串行
* 同步和异步主要影响：能不能开启新的线程  
同步：在当前线程中执行任务，不具备开启新线程的能力；  
异步：在新的线程中执行任务，具备开启新线程的能力；

* 并发和串行主要影响：任务的执行方式  
并发：多个任务并发（同时）执行；  
串行：一个任务执行完毕后，再执行下一个任务；

## 各种队列的执行效果

| &nbsp; | 并发队列 | 手动穿件的串行队列 | 主队列 |
| :--: | :--: | :--: | :--: |
| 同步（sync） | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |
| 异步（async） | 有开启新线程<br>并发执行任务 | 有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |

使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）。

主队列是一个特殊的串行队列，async 方法在主队列中添加任务不会开启新线程，并且是串行执行任务。

### 并发队列 & 异步执行（async）
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@"任务1 - %@", [NSThread currentThread]);
    
    ///全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    ///任务2
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务2 - %@", [NSThread currentThread]);
        }
    });
    ///任务3
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务3 - %@", [NSThread currentThread]);
        }
    });

    NSLog(@"任务4 - %@", [NSThread currentThread]);
    ///主线程睡1秒
    sleep(1);
    NSLog(@"任务5 - %@", [NSThread currentThread]);
}
```

打印结果：
```
任务1 - <NSThread: 0x600003595140>{number = 1, name = main}
任务4 - <NSThread: 0x600003595140>{number = 1, name = main}
执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}
执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}
执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}
执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}
执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}
执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}
执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}
执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}
执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}
执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}
任务5 - <NSThread: 0x600000434d40>{number = 1, name = main}
```

从打印结果可以看到，队列里任务的执行方式为：并发，创建新线程。
![多线程03](多线程/多线程03.png)

### 并发队列 & 同步执行（sync）
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@"任务1 - %@", [NSThread currentThread]);
    
    ///全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    ///任务2
    dispatch_sync(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务2 - %@", [NSThread currentThread]);
        }
    });
    ///任务3
    dispatch_sync(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务3 - %@", [NSThread currentThread]);
        }
    });
    
    NSLog(@"任务4 - %@", [NSThread currentThread]);
    ///主线程睡1秒
    sleep(1);
    NSLog(@"任务5 - %@", [NSThread currentThread]);
}
```

打印结果：
```
任务1 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
任务4 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
任务5 - <NSThread: 0x600002fa4d80>{number = 1, name = main}
```

从打印结果可以看到，队列里任务的执行方式为：串行，主线程。
![多线程04](多线程/多线程04.png)

### 串行队列 & 异步执行（async）
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@"任务1 - %@", [NSThread currentThread]);
    
    ///手动创建并发队列
    dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL);
    ///任务2
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务2 - %@", [NSThread currentThread]);
        }
    });
    ///任务3
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务3 - %@", [NSThread currentThread]);
        }
    });
    
    NSLog(@"任务4 - %@", [NSThread currentThread]);
    ///主线程睡1秒
    sleep(1);
    NSLog(@"任务5 - %@", [NSThread currentThread]);
}
```

打印结果：
```
任务1 - <NSThread: 0x6000004b0d40>{number = 1, name = main}
任务4 - <NSThread: 0x6000004b0d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}
任务5 - <NSThread: 0x6000004b0d40>{number = 1, name = main}
```

从打印结果可以看到，队列里任务的执行方式为：串行，创建新线程。
![多线程05](多线程/多线程05.png)

### 串行队列 & 同步执行（sync）
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@"任务1 - %@", [NSThread currentThread]);
    
    ///手动创建并发队列
    dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL);
    ///任务2
    dispatch_sync(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务2 - %@", [NSThread currentThread]);
        }
    });
    ///任务3
    dispatch_sync(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务3 - %@", [NSThread currentThread]);
        }
    });
    
    NSLog(@"任务4 - %@", [NSThread currentThread]);
    ///主线程睡1秒
    sleep(1);
    NSLog(@"任务5 - %@", [NSThread currentThread]);
}
```

打印结果：
```
任务1 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}
执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}
任务4 - <NSThread: 0x600001438d40>{number = 1, name = main}
任务5 - <NSThread: 0x600001438d40>{number = 1, name = main}
```

从打印结果可以看到，队列里任务的执行方式为：串行，主线程。
![多线程06](多线程/多线程06.png)

### 主队列 & 异步执行（async）
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@"任务1 - %@", [NSThread currentThread]);
    
    ///手动创建并发队列
    dispatch_queue_t queue = dispatch_get_main_queue();
    ///任务2
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务2 - %@", [NSThread currentThread]);
        }
    });
    ///任务3
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            NSLog(@"执行任务3 - %@", [NSThread currentThread]);
        }
    });
    
    NSLog(@"任务4 - %@", [NSThread currentThread]);
    ///主线程睡1秒
    sleep(1);
    NSLog(@"任务5 - %@", [NSThread currentThread]);
}
```

打印结果：
```
任务1 - <NSThread: 0x600002408d80>{number = 1, name = main}
任务4 - <NSThread: 0x600002408d80>{number = 1, name = main}
任务5 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}
执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}
```

从打印结果可以看到，队列里任务的执行方式为：串行，主线程。
![多线程07](多线程/多线程07.png)

### 主队列 & 同步执行（sync）-> 死锁

死锁一：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）：
![多线程01](多线程/多线程01.png)

问题分析：
![多线程02](多线程/多线程02.png)

`sync` 函数在这里的作用有两个，第一个是添加任务2，第二个是执行任务2。因为主队列是串行队列，所以遵循先进先出原则，只有在第一个任务 `viewDidLoad` 执行完成后才能执行任务2。但是第一个任务 `viewDidLoad` 要想执行完就必须执行完 `sync` 函数，而 `sync` 函数要想执行完就必须执行完任务2，而任务2要想执行完就必须执行完 `viewDidLoad` ... ... 产生死锁。

死锁二：
![多线程08](多线程/多线程08.png)

问题分析：
![多线程09](多线程/多线程09.png)

## performSelector:withObject:afterDelay:

在子线程里调用 `performSelector:withObject:afterDelay:` 方法：
```
- (void)test
{
    NSLog(@"执行任务2 - %@ - %@", [NSThread currentThread], [NSOperationQueue currentQueue]);
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        NSLog(@"1");
        [self performSelector:@selector(test) withObject:nil afterDelay:.0];
        NSLog(@"3");
    });
}
```

打印结果：
```
1
3
```

从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法并没有起作用。这是因为 `performSelector:withObject:afterDelay:` 方法内部使用了 timer，而子线程默认没有 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 TImer 无法调用。

解决方案 👉 手动添加 RunLoop：
```
- (void)test
{
    NSLog(@"执行任务2 - %@ - %@", [NSThread currentThread], [NSOperationQueue currentQueue]);
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        NSLog(@"1");
        [self performSelector:@selector(test) withObject:nil afterDelay:.0];
        NSLog(@"3");
        
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    });
}
```

打印结果：
```
1
执行任务2 - <NSThread: 0x600001ad0cc0>{number = 6, name = (null)} - (null)
3
```

从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法可以正常调用了。这是因为手动为子线程添加了 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 timer 可以正常运行了。

猜想：`performSelector:withObject:afterDelay:` 方法的本质是往 RunLoop 中添加定时器：
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        switch (activity) {
            case kCFRunLoopEntry:
                NSLog(@"kCFRunLoopEntry");
                break;
            case kCFRunLoopBeforeTimers:
                NSLog(@"kCFRunLoopBeforeTimers");
                break;
            case kCFRunLoopBeforeSources:
                NSLog(@"kCFRunLoopBeforeSources");
                break;
            case kCFRunLoopBeforeWaiting:
                NSLog(@"kCFRunLoopBeforeWaiting");
                break;
            case kCFRunLoopAfterWaiting:
                NSLog(@"kCFRunLoopAfterWaiting");
                break;
            case kCFRunLoopExit:
                NSLog(@"kCFRunLoopExit");
                break;
            default:
                break;
        }
    });
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);
    CFRelease(observer);
}

- (void)test
{
    NSLog(@"执行任务2 - %@ - %@", [NSThread currentThread], [NSOperationQueue currentQueue]);
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    NSLog(@"1");
    [self performSelector:@selector(test) withObject:nil afterDelay:.0];
    NSLog(@"3");
}
```

打印结果：
```
kCFRunLoopAfterWaiting
kCFRunLoopBeforeTimers
kCFRunLoopBeforeSources
1
3
kCFRunLoopBeforeTimers
kCFRunLoopBeforeSources
执行任务2 - <NSThread: 0x600000b5cd40>{number = 1, name = main} - <NSOperationQueue: 0x7fb3f0006020>{name = 'NSOperationQueue Main Queue'}
... ...
```

从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法的调用是一个 timers 事件：RunLoop 先处理了 Sources0 事件，再处理的 Timers。

### GNUstep

GNUstep 是 GNU 计划的项目之一，它将 Cocoa 的 OC 库重新开源实现了一遍。虽然 GNUstep 不是苹果官方源码，但还是具有一定的参考价值。👉 [源码地址](http://www.gnustep.org/resources/downloads.php)

找到 NSRunLoop.m 文件查看 `performSelector:withObject:afterDelay:` 方法源码：
```
- (void) performSelector: (SEL)aSelector
	      withObject: (id)argument
	      afterDelay: (NSTimeInterval)seconds
{
  NSRunLoop		*loop = [NSRunLoop currentRunLoop];
  GSTimedPerformer	*item;

  //根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。
  item = [[GSTimedPerformer alloc] initWithSelector: aSelector
					     target: self
					   argument: argument
					      delay: seconds];
  [[loop _timedPerformers] addObject: item];
  RELEASE(item);
  [loop addTimer: item->timer forMode: NSDefaultRunLoopMode];
}
```

通过源码可以得出结论：`performSelector:withObject:afterDelay:` 方法内部根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。

### performSelector:withObject:

`performSelector:withObject:` 方法跟 `performSelector:withObject:afterDelay:` 方法的实现原理不同，`performSelector:withObject:afterDelay:` 是定义在 RunLoop.h 文件里的 API，内部实现的本质是往 RunLoop 中添加定时器。而 `performSelector:withObject:` 方法的本质是调用 objc_msgSend() 方法。可以在 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 里看到具体实现，找到 NSObjec.m 文件：
```
- (id)performSelector:(SEL)sel withObject:(id)obj {
    if (!sel) [self doesNotRecognizeSelector:sel];
    return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);
}
```

## 队列组的使用

异步并发执行任务1、任务2，在任务1、任务2都执行完毕后，再回到主线程执行任务3：
```
- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        sleep(1);
        NSLog(@"任务1");
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务2");
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"任务3");
    });
}
```

打印结果：
```
任务2
任务1
任务3
```

任务3会等到任务1和任务2都执行完成之后再执行。

# GCD源码分析

## dispatch_async()

在 queue.h 文件找到 `dispatch_async()` 方法的定义
```
API_AVAILABLE(macos(10.6), ios(4.0))
DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
void
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
```

在 queue.c 文件找到 `dispatch_async()` 方法的实现：
```
void
dispatch_async(dispatch_queue_t dq, dispatch_block_t work)
{
    //将任务 work 打包成 dispatch_continuation_t 类型
	dispatch_continuation_t dc = _dispatch_continuation_alloc(); 
    //设置标志位
	uintptr_t dc_flags = DC_FLAG_CONSUME;
	dispatch_qos_t qos;

    //进行block初始化
	qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
	_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
}
```

在 inline_internal.h 文件找到 `_dispatch_continuation_async()` 方法的实现：
```
DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_continuation_async(dispatch_queue_class_t dqu,
		dispatch_continuation_t dc, dispatch_qos_t qos, uintptr_t dc_flags)
{
#if DISPATCH_INTROSPECTION
	if (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {
		_dispatch_trace_item_push(dqu, dc); //将任务添加到队列中
	}
#else
	(void)dc_flags;
#endif
	return dx_push(dqu._dq, dc, qos);
}
```

在 trace.h 文件找到 `_dispatch_trace_item_push` 方法的实现：
```
#define _dispatch_trace_item_push(dq, dou) \
		do { (void)(dq); (void)(dou); } while(0)
```

## dispatch_sync()

# 多线程的安全隐患

资源共享：1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件。

当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。

## 多线程安全隐患示例

### 卖票
```
@interface ViewController ()
@property (assign, nonatomic) int ticketsCount;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [self ticketTest];
}

- (void)ticketTest
{
    self.ticketsCount = 15;
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
             [self saleTicket];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self saleTicket];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self saleTicket];
        }
    });
}

//卖1张票
- (void)saleTicket
{
    int oldTicketsCount = self.ticketsCount;
    sleep(.2);
    oldTicketsCount--;
    self.ticketsCount = oldTicketsCount;
    
    NSLog(@"还剩%d张票 - %@", oldTicketsCount, [NSThread currentThread]);
}
@end
```

打印结果：
```
还剩14张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}
还剩14张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}
还剩14张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}
还剩13张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}
还剩12张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}
还剩11张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}
还剩10张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}
还剩9张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}
还剩9张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}
还剩8张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}
还剩7张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}
还剩6张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}
还剩5张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}
还剩4张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}
还剩3张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}
```

可以看到，刚开始三个线程都卖了1张票，结果还是下14张票。在三个线程走完后总共卖了15张票，但是最后还剩3张票。无论是在卖票过程中，还是最后剩余的票数都出现了异常。

![多线程10](多线程/多线程10.png)
总共15张票，两个线程同时卖票，每个线程都是拿15减1，得到的手势14张票。不同的线程拿到同一个变量进行修改，就会出现问题。

### 存钱取钱
```
@interface ViewController ()
@property (assign, nonatomic) int money;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self moneyTest];
}

- (void)moneyTest
{
    self.money = 100;
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            [self saveMoney];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            [self drawMoney];
        }
    });
}

//存钱
- (void)saveMoney
{
    int oldMoney = self.money;
    sleep(.2);
    oldMoney += 50;
    self.money = oldMoney;
    
    NSLog(@"存50，还剩%d元 - %@", oldMoney, [NSThread currentThread]);
}

//取钱
- (void)drawMoney
{
    int oldMoney = self.money;
    sleep(.2);
    oldMoney -= 20;
    self.money = oldMoney;
    
    NSLog(@"取20，还剩%d元 - %@", oldMoney, [NSThread currentThread]);
}
@end
```

打印结果：
```
存50，还剩150元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩80元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
取20，还剩110元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩130元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩90元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩140元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩120元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩170元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩150元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩200元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩180元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩230元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩210元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩260元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩240元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩290元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩270元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩320元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
取20，还剩300元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}
存50，还剩350元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}
```

从打印结果可以看到，最后还剩350。代码中，原本有100，存了500，取了200，所以结果应该是400。

![多线程11](多线程/多线程11.png)
总共100元，两个线程同时拿到100元，第一个线程存了50元后余额还剩150元，第二个线程去了20元余额还剩80元。不同的线程拿到同一个变量进行修改，就会出现问题。

## 多线程安全隐患分析

线程A先取到变量的值17，线程B后取到变量的值17。线程A对取到的值加一（17+1=18），线程B对取到的值加一（17+1=18）。线程A将处理后的值赋值给变量（18），线程B也将处理后的值赋值给变量（18）。虽然修改了两次变量（+1），但是结果都是18：
![多线程12](多线程/多线程12.png)

## 多线程安全隐患的解决方案
解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）。  
常见的线程同步技术是：加锁。
![多线程13](多线程/多线程13.png)

# iOS中的线程同步方案

| 同步方案 | 简介 |
| :-- | :-- |
| OSSpinLock | 自旋锁 |
| os_unfair_lock | 用于取代不安全的OSSpinLock |
| pthread_mutex | 互斥锁 |
| dispatch_semaphore | 信号量 |
| dispatch_queue(DISPATCH_QUEUE_SERIAL) | 串行队列 |
| NSLock | 对mutex普通锁的封装 |
| NSRecursiveLock | 对mutex递归锁的封装，API跟NSLock基本一致 |
| NSCondition | 对mutex和cond的封装 |
| NSConditionLock | 对NSCondition的进一步封装，可以设置具体的条件值 |
| @synchronized | 对mutex递归锁的封装 |

将卖票和存钱取钱测试代码封装起来：
```
@interface BaseLockDemo : NSObject
///存钱取钱
- (void)moneyTest;
///卖票
- (void)ticketTest;
#pragma mark - 暴露给子类去使用
- (void)__saveMoney;
- (void)__drawMoney;
- (void)__saleTicket;
@end

@interface BaseLockDemo()
@property (assign, nonatomic) int money;
@property (assign, nonatomic) int ticketsCount;
@end

@implementation BaseLockDemo
///------ 存钱、取钱演示 ------
- (void)moneyTest
{
    self.money = 100;
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            [self __saveMoney];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            [self __drawMoney];
        }
    });
}

///存钱
- (void)__saveMoney
{
    int oldMoney = self.money;
    sleep(.2);
    oldMoney += 50;
    self.money = oldMoney;
    
    NSLog(@"存50，还剩%d元 - %@", oldMoney, [NSThread currentThread]);
}

///取钱
- (void)__drawMoney
{
    int oldMoney = self.money;
    sleep(.2);
    oldMoney -= 20;
    self.money = oldMoney;
    
    NSLog(@"取20，还剩%d元 - %@", oldMoney, [NSThread currentThread]);
}

///------ 卖票演示 ------
- (void)ticketTest
{
    self.ticketsCount = 15;
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self __saleTicket];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self __saleTicket];
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self __saleTicket];
        }
    });
}

///卖1张票
- (void)__saleTicket
{
    int oldTicketsCount = self.ticketsCount;
    sleep(.2);
    oldTicketsCount--;
    self.ticketsCount = oldTicketsCount;
    NSLog(@"还剩%d张票 - %@", oldTicketsCount, [NSThread currentThread]);
}
@end
```

## OSSpinLock
`OSSpinLock` 叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源。目前已经不再安全，可能会出现优先级反转问题（如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁）。需要导入头文件 `#import <libkern/OSAtomic.h>`。

忙等状态可以理解为一个 do-while 循环，不停的监测着是否解锁，这个状态下的线程会一直占用着CPU资源。正因为是处于忙等状态，所以 `OSSpinLock` 的效率要其它锁都高，一旦解锁立刻就能监测到并继续执行。不在安全的原因是优先级较高的线程在等待锁时（忙等），CPU不再分配资源给其它线程，那么上锁的线程负责解锁，由于CPU没有分配资源也无法解锁，导致优先级较高的线程一直在这里等待。

* 线程调度
计算机通常只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配CPU的使用权。
* 时间片轮转调度
时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。

### 常用API
```
/// 初始化
OSSpinLock lock = OS_SPINLOCK_INIT;
/// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）
bool result = OSSpinLockTry(&lock);
/// 加锁
OSSpinLockLock(&lock);
/// 解锁
OSSpinLockUnlock(&lock);
```

### 解决卖票和存钱取钱问题
定义 OSSpinLockDemo 继承自 LockBaseDemo。
```
#import <libkern/OSAtomic.h>

@interface OSSpinLockDemo()
@property (assign, nonatomic) OSSpinLock moneyLock;
@property (assign, nonatomic) OSSpinLock ticketLock;
@end

@implementation OSSpinLockDemo

- (instancetype)init
{
    if (self = [super init]) {
        self.moneyLock = OS_SPINLOCK_INIT;
        self.ticketLock = OS_SPINLOCK_INIT;
    }
    return self;
}
///取钱
- (void)__drawMoney
{
    OSSpinLockLock(&_moneyLock);
    
    [super __drawMoney];
    
    OSSpinLockUnlock(&_moneyLock);
}
///存钱
- (void)__saveMoney
{
    OSSpinLockLock(&_moneyLock);
    
    [super __saveMoney];
    
    OSSpinLockUnlock(&_moneyLock);
}
///卖票
- (void)__saleTicket
{
    OSSpinLockLock(&_ticketLock);
    
    [super __saleTicket];
    
    OSSpinLockUnlock(&_ticketLock);
}
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    BaseLockDemo *demo = [[OSSpinLockDemo alloc] init];
    [demo ticketTest];
    [demo moneyTest];
}
@end
```

调用 `-(void)moneyTest` 打印结果：
```
存50，还剩150元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩200元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩250元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩300元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩350元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩400元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩450元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩500元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩550元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
存50，还剩600元 - <NSThread: 0x600000471080>{number = 4, name = (null)}
取20，还剩580元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩560元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩540元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩520元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩500元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩480元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩460元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩440元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩420元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
取20，还剩400元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}
```

调用 `-(void)ticketTest` 打印结果：
```
还剩14张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}
还剩13张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}
还剩12张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}
还剩11张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}
还剩10张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}
还剩9张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}
还剩8张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}
还剩7张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}
还剩6张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}
还剩5张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}
还剩4张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}
还剩3张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}
还剩2张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}
还剩1张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}
还剩0张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}
```

因为要修改的有两个变量，一个是存钱取钱里的余额，一个是卖票里的剩余票数，所以要有两把锁分别对应这两个变量。一旦有线程对 OSSpinLock 上锁后，其它线程再遇到 OSSpinLock 时会阻塞住，等待 OSSpinLock 解锁在继续向下执行。

上面👆的例子是将 OSSpinLock 锁对象放到了实例对象里，也可以将 OSSpinLock 锁对象放到类对象里：
```
static OSSpinLock moneyLock_;
+ (void)initialize
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        moneyLock_ = 0;
    });
}
```

类方法 `+ (void)initialize` 只会被系统调用一次，但是允许被开发者调用，所以使用 `dispatch_once` 保证类对象的 `moneyLock_` 锁只初始化一次。

或者：
```
- (void)__saleTicket
{
    static OSSpinLock ticketLock = OS_SPINLOCK_INIT;
    
    OSSpinLockLock(&ticketLock);
    
    [super __saleTicket];
    
    OSSpinLockUnlock(&ticketLock);
}
```

使用 static 关键字，将 `ticketLock` 锁保存在全局区，保证只初始化一次。

### OSSpinLock 汇编分析
* lldb 指令：
  jne：j 是 jump，ne 是条件。  
  callq：函数调用。  
  setp：执行一行OC代码。  
  stepi：stepinstruction 的简写，执行一行汇编代码，也可以简写为 si。  
  next：执行一行OC代码。
  nexti：执行一行汇编代码。
  stepi 和 nexti 的区别：在遇到函数调用是，stepi 会进入调用的函数，nexti 不会进入。  
  c：continue 的简写，继续执行。  

（重复敲回车会执行上一个 lldb 指令，如果敲的过快可能会出现异常）  

修改 LockBaseDemo 类里的 `- (void)__saleTicket` 方法，设置睡眠时间为 60s，这样可以有足够的时间查看第二次加锁时的汇编代码。修改 `- (void)ticketTest` 方法，设置调用10次 `- (void)__saleTicket` 方法：
```
///卖票演示
- (void)ticketTest
{
    self.ticketsCount = 15;
    
    for (int i=0; i<10; i++) {
        [[[NSThread alloc] initWithTarget:self selector:@selector(__saleTicket) object:nil] start]; 
    }
}

///卖票
- (void)__saleTicket
{
    int oldTicketsCount = self.ticketsCount;
    sleep(60.2);
    oldTicketsCount--;
    self.ticketsCount = oldTicketsCount;
    NSLog(@"还剩%d张票 - %@", oldTicketsCount, [NSThread currentThread]);
}
```

Debug -> Debug Workflow -> Always Show Disassembly 查看汇编代码：

可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 9 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 10，因为此时的自旋锁处于上锁状态，所以 Thread 10 处于等待锁的状态。重复执行 si 指令，到第11行时会调用 OSSpinLocklock 函数：
![多线程15](多线程/多线程15.png)
使用 si 指令进入到调用函数：
![多线程16](多线程/多线程16.png)
重复执行 si 指令，在第6行通过 jne 跳转到 _OSSpinLockLockSlow 函数：
![多线程17](多线程/多线程17.png)
_OSSpinLockLockSlow 函数是自旋锁的核心代码，从第6行到第19行是一个 while 循环（🔎自旋锁标志）。因为 Thread 9 已经加过锁并且还没有解锁，所以这里会一直循环执行，等待 Thread 9 解锁。可以看到第14行和第16行是跳出 while 循环的判断：
![多线程18](多线程/多线程18.png)


## os_unfair_lock
`OSSpinLock` 在以前算是性能最高的一种锁，但是由于不再安全（优先级反转问题），苹果已经不建议使用了，从 iOS10 开始推出了替代它的 `os_unfair_lock`。需要导入头文件 `#import <os/lock.h>`。

### 常用API
```
///初始化
os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;
///尝试加锁
os_unfair_lock_trylock(&lock);
///加锁
os_unfair_lock_lock(&lock);
///解锁
os_unfair_lock_unlock(&lock);
```

### 解决卖票和存钱取钱问题
定义 OSUnfairLockDemo 继承自 LockBaseDemo。
```
#import <libkern/OSAtomic.h>

@interface OSUnfairLockDemo()
@property (nonatomic, assign) os_unfair_lock moneyLock;
@property (nonatomic, assign) os_unfair_lock ticketLock;
@end

@implementation OSUnfairLockDemo

- (instancetype)init
{
    self = [super init];
    if (self) {
        self.moneyLock = OS_UNFAIR_LOCK_INIT;
        self.ticketLock = OS_UNFAIR_LOCK_INIT;
    }
    return self;
}

///取钱
- (void)__drawMoney
{
    os_unfair_lock_lock(&_moneyLock);
    
    [super __drawMoney];
    
    os_unfair_lock_unlock(&_moneyLock);
}

///存钱
- (void)__saveManey
{
    os_unfair_lock_lock(&_moneyLock);
    
    [super __saveManey];
    
    os_unfair_lock_unlock(&_moneyLock);
}

///卖票
- (void)__saleTicket
{
    os_unfair_lock_lock(&_ticketLock);
    
    [super __saleTicket];
    
    os_unfair_lock_unlock(&_ticketLock);
}
```

* 死锁  
如果加锁后没有解锁，其它线程就会进入等待，永远无法执行。这种由于没有解锁造成的其它线程的等待叫做死锁。

### os_unfair_lock 汇编分析

可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 8 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 15，因为此时的自旋锁处于上锁状态，所以 Thread 15 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `os_unfair_lock_lock` 函数：
![多线程26](多线程/多线程26.png)
使用 `si` 指令进入到 `os_unfair_lock_lock` 函数：
![多线程27](多线程/多线程27.png)
重复使用 `si` 指令，进入 `_os_unfair_lock_lock_slow` 函数：
![多线程28](多线程/多线程28.png)
使用 `si` 指令，第56行会调用 `__ulock_wait` 函数：
![多线程29](多线程/多线程29.png)
使用 `si` 指令，进入 `__ulock_wait`：
![多线程30](多线程/多线程30.png)
第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎互斥锁标志）：
![多线程31](多线程/多线程31.png)

从上面👆对 os_unfair_lock 的汇编分析，可以看出 os_unfair_lock 是一个互斥锁。在 os_unfair_lock 的头文件 lock.h 里的注释可以看到一个单词 Low-level（低级锁），低级锁的特点就是休眠。自旋锁 OSSpinLock 是一个高级锁。

## pthread_mutex

mutex 叫做”互斥锁”，等待锁的线程会处于休眠状态。需要导入头文件 `#import <pthread.h>`。

### 常用API
```
///初始化锁的属性
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
///初始化锁
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, &attr);
///尝试加锁
pthread_mutex_trylock(&mutex);
///加锁
pthread_mutex_lock(&mutex);
///解锁
pthread_mutex_unlock(&mutex);
///销毁相关资源
pthread_mutexattr_destroy(&attr);
pthread_mutex_destroy(&mutex);
```

锁定类型：
```
#define PTHREAD_MUTEX_NORMAL		0
#define PTHREAD_MUTEX_ERRORCHECK	1
#define PTHREAD_MUTEX_RECURSIVE		2
#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_NORMAL
```

### PTHREAD_MUTEX_INITIALIZER
```
/*
 * Mutex variables
 */
#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}
```

可以看到，PTHREAD_MUTEX_INITIALIZER 是一个结构体，在使用 PTHREAD_MUTEX_INITIALIZER 初始化锁时，由于结构体语法的问题，需要进行静态初始化：
```
- (instancetype)init
{
    self = [super init];
    if (self) {
        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    }
    return self;
}
```

如果使用 PTHREAD_MUTEX_INITIALIZER 动态初始化 pthread_mutex_t 会报错：
![多线程14](多线程/多线程14.png)

### pthread_mutexattr_t
初始化 pthread_mutex 锁： 
```
- (instancetype)init
{
    self = [super init];
    if (self) {
        ///初始化属性
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
        ///初始化锁
        pthread_mutex_init(&_moneyMutex, &attr);
        ///销毁属性
        pthread_mutexattr_destroy(&attr);
    }
    return self;
}
```

上面👆初始化锁的代码比较繁琐，一般使用 `pthread_mutex_init(&_moneyMutex, NULL)` 方法进行初始化。`pthread_mutex_init()` 方法的第二参数传 `NULL`，就相当于设置了 `PTHREAD_MUTEX_DEFAULT` 类型的 `pthread_mutexattr_t` 属性。

### 解决卖票和存钱取钱问题
定义 PthreadMutexDemo 继承自 LockBaseDemo。
```
#import <pthread.h>

@interface PthreadMutexDemo()
@property (nonatomic, assign) pthread_mutex_t moneyMutex;
@property (nonatomic, assign) pthread_mutex_t ticketMutex;
@end

@implementation PthreadMutexDemo

- (instancetype)init
{
    self = [super init];
    if (self) {
        pthread_mutex_init(&_moneyMutex, NULL);
        pthread_mutex_init(&_ticketMutex, NULL);
    }
    return self;
}

///取钱
- (void)__drawMoney
{
    pthread_mutex_lock(&_moneyMutex);
    
    [super __drawMoney];
    
    pthread_mutex_unlock(&_moneyMutex);
}

///存钱
- (void)__saveManey
{
    pthread_mutex_lock(&_moneyMutex);
    
    [super __saveManey];
    
    pthread_mutex_unlock(&_moneyMutex);
}

///卖票
- (void)__saleTicket
{
    pthread_mutex_lock(&_ticketMutex);
    
    [super __saleTicket];
    
    pthread_mutex_unlock(&_ticketMutex);
}

///销毁锁
- (void)dealloc
{
    pthread_mutex_destroy(&_moneyMutex);
    pthread_mutex_destroy(&_ticketMutex);
}

@end
```

相对于 `OSSpinLock` 和 `os_unfair_lock`，`pthread_mutex` 的 API 里提供了销毁方法 `pthread_mutex_destroy()`，所以需要在 `-(void)dealloc` 方法里对锁进行销毁。

### pthread_mutex 汇编分析

可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 10 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 14，因为此时的自旋锁处于上锁状态，所以 Thread 14 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `phread_mutex_lock` 函数：
![多线程19](多线程/多线程19.png)
使用 `si` 指令进入到 `phread_mutex_lock` 函数：
![多线程20](多线程/多线程20.png)
重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_slow` 函数：
![多线程21](多线程/多线程21.png)
重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_wait` 函数：
![多线程22](多线程/多线程22.png)
重复使用 `si` 指令，调用 `__psynch_mutexwait`：
![多线程23](多线程/多线程23.png)
使用 `si` 指令，进入 `__psynch_mutexwait` 函数：
![多线程23](多线程/多线程24.png)
第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎互斥锁标志）：
![多线程23](多线程/多线程25.png)

从上面👆对 pthread_mutex 的汇编分析，可以看出 pthread_mutex 是一个互斥锁，也是一个低级锁。

## pthread_mutex – 递归锁
初始化 pthread_mutex 递归锁：
```
- (instancetype)init
{
    self = [super init];
    if (self) {
        ///初始化属性
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
        ///初始化锁
        pthread_mutex_init(&_moneyMutex, &attr);
        ///销毁属性
        pthread_mutexattr_destroy(&attr);
    }
    return self;
}
```

用 PTHREAD_MUTEX_RECURSIVE 类型定义的属性创建出来的 pthread_mutex 锁就是 pthread_mutex 递归锁。

### 死锁
在使用锁时如果出现了递归调用，或者在加锁后调用了一个使用同一把锁的方法，就会出现死锁的情况。与上面👆提到过的死锁的概念相同。

定义 PthreadMutexRecursiveDemo：
```
@interface PthreadMutexRecursiveDemo : LockBaseDemo
- (void)recursiveMutexTest;
@end

@implementation PthreadMutexRecursiveDemo
- (void)recursiveMutexTest
{
    NSLog(@"%s", __func__);
    ///递归调用
    [self recursiveMutexTest];
}
@end
```

打印结果：
```
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
......
```

#### 死锁情况一：递归调用
```
@interface PthreadMutexRecursiveDemo : LockBaseDemo
- (void)recursiveMutexTest;
@end

@interface PthreadMutexRecursiveDemo()
@property (nonatomic, assign) pthread_mutex_t recursiveMutex;
@end

@implementation PthreadMutexRecursiveDemo
- (instancetype)init
{
    self = [super init];
    if (self) {
        pthread_mutex_init(&_recursiveMutex, NULL);
    }
    return self;
}

- (void)recursiveMutexTest
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    ///递归调用
    [self recursiveMutexTest];
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)dealloc
{
    pthread_mutex_destroy(&_recursiveMutex);
}
@end
```

打印结果：
```
-[PthreadMutexRecursiveDemo recursiveMutexTest]
```

可以看到打印结果里只有一条打印信息，这是因为加锁后再次调用 `-(void)recursiveMutexTest` 方法，会发现 `_recursiveMutex` 已经上锁了，进入休眠等待解锁。

#### 死锁情况二：函数间互相调用
```
@interface PthreadMutexRecursiveDemo : LockBaseDemo
- (void)recursiveMutexTest;
@end

@interface PthreadMutexRecursiveDemo()
@property (nonatomic, assign) pthread_mutex_t recursiveMutex;
@end

@implementation PthreadMutexRecursiveDemo
- (instancetype)init
{
    self = [super init];
    if (self) {
        pthread_mutex_init(&_recursiveMutex, NULL);
    }
    return self;
}

- (void)recursiveMutexTest
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    ///递归调用
    [self recursiveMutexTest2];
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)recursiveMutexTest2
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)dealloc
{
    pthread_mutex_destroy(&_recursiveMutex);
}
@end
```

打印结果：
```
-[PthreadMutexRecursiveDemo recursiveMutexTest]
```

可以看到打印结果里只有一条打印信息，这是因为两个方法使用的是同一把锁，在 `- (void)recursiveMutexTest` 方法加锁后再去调用 `- (void)recursiveMutexTest2` 方法时，会发现 _recursiveMutex 已经上锁了，进入休眠等待解锁。

### 递归锁

因为递归锁允许在同一个线程里重复加锁，所以递归锁可以解决上面出现的死锁情况。

#### 解决死锁情况一：递归调用
```
@interface PthreadMutexRecursiveDemo : LockBaseDemo
- (void)recursiveMutexTest;
@end

@interface PthreadMutexRecursiveDemo()
@property (nonatomic, assign) pthread_mutex_t recursiveMutex;
@end

@implementation PthreadMutexRecursiveDemo
- (void)initMutex:(pthread_mutex_t)mutex
{
    ///初始化属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    ///初始化锁
    pthread_mutex_init(&mutex, &attr);
    ///销毁属性
    pthread_mutexattr_destroy(&attr);
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        [self initMutex:_recursiveMutex];
    }
    return self;
}

- (void)recursiveMutexTest
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    ///递归调用
    [self recursiveMutexTest];
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)dealloc
{
    pthread_mutex_destroy(&_recursiveMutex);
}
@end
```

打印结果：
```
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest]
......
```

#### 解决死锁情况二：函数间互相调用 
```
@interface PthreadMutexRecursiveDemo : LockBaseDemo
- (void)recursiveMutexTest;
@end

@interface PthreadMutexRecursiveDemo()
@property (nonatomic, assign) pthread_mutex_t recursiveMutex;
@end

@implementation PthreadMutexRecursiveDemo
- (void)initMutex:(pthread_mutex_t)mutex
{
    ///初始化属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    ///初始化锁
    pthread_mutex_init(&mutex, &attr);
    ///销毁属性
    pthread_mutexattr_destroy(&attr);
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        [self initMutex:_recursiveMutex];
    }
    return self;
}


- (void)recursiveMutexTest
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    ///递归调用
    [self recursiveMutexTest2];
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)recursiveMutexTest2
{
    pthread_mutex_lock(&_recursiveMutex);
    
    NSLog(@"%s", __func__);
    
    pthread_mutex_unlock(&_recursiveMutex);
}

- (void)dealloc
{
    pthread_mutex_destroy(&_recursiveMutex);
}
@end
```

打印结果：
```
-[PthreadMutexRecursiveDemo recursiveMutexTest]
-[PthreadMutexRecursiveDemo recursiveMutexTest2]
```

使用递归锁后，死锁的问题不存在了。但是，加了递归锁后的打印结果跟没加锁一样，这样被加锁的代码块还安全吗？其实，递归锁只可以在当前线程重复加锁。也就是说，当前线程加锁后，在当前线程再次调用 `- (void)recursiveMutexTest` 方法还可以重复加锁，而其它线程在此时调用 `- (void)recursiveMutexTest` 方法时判断到已经加过锁了就不再加锁了，会进入休眠等待解锁。

## pthread_mutex – 条件

## NSLock、NSRecursiveLock

## NSCondition

## NSConditionLock

## dispatch_semaphore

## dispatch_queue

## @synchronized

## 自旋锁、互斥锁比较