---
title: 算法列表
date: 2022-09-29 11:05:18
tags: 2022打怪
---

![20220607_th](算法列表/20220607_th.jpeg)
<!-- more -->

# 算法列表

## 线性结构

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

[682. 棒球比赛](https://leetcode.cn/problems/baseball-game/)

## 排序算法

[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)

[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

## 二叉树

[112. 路径总和](https://leetcode.cn/problems/path-sum/)

[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

## 并查集

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

[959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

## 树形结构
[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

[264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

[1508. 子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/)

[947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

## 综合练习

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

[面试题40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/)

## 面试笔试算法（一）

[euler-1.3或5的倍数](http://pe-cn.github.io/1/)（时间复杂度）

[euler-2.偶斐波那契数](http://pe-cn.github.io/2/)（空间复杂度）

[euler-4.最大回文乘积](http://pe-cn.github.io/4/)（回文数）

[euler-36.双进制回文数](http://pe-cn.github.io/36/)（n进制回文数）

[euler-8.连续数字最大乘积](http://pe-cn.github.io/8/)（滑动窗口法）

[euler-11.方阵中的最大乘积](http://pe-cn.github.io/11/)（方向数组）

[euler-14.最长考拉兹序列](http://pe-cn.github.io/14/)（记忆化）

## 面试笔试算法（二）

[euler-13.大和](http://pe-cn.github.io/13/)（大整数加法）

[#78. 大整数加法](http://oj.haizeix.com/problem/78)（大整数加法）

[euler-25.1000位斐波那契数](http://pe-cn.github.io/25/)（大整数加法）

[#471. 大整数乘法](http://oj.haizeix.com/problem/471)

[euler-15.网格路径](http://pe-cn.github.io/15/)（动态规划、组合数）

[euler-18.最大路径和 I](http://pe-cn.github.io/18/)（动态规划）

## 双指针【滑动窗口】

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

[826. 安排工作以达到最大收益](https://leetcode.cn/problems/most-profit-assigning-work/)

[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)

[475. 供暖器](https://leetcode.cn/problems/heaters/)

## 二分专题（一）

[#388. 奇怪的刮刮乐](http://oj.haizeix.com/problem/388)（排序+二分查找）

[#386. 吃瓜群众](http://oj.haizeix.com/problem/386)（排序+二分查找）

[#387. 吃瓜群众升级版](http://oj.haizeix.com/problem/387)（排序+二分查找）

[#390. 原木切割](http://oj.haizeix.com/problem/390)（二分答案）

[#389. 暴躁的程序猿](http://oj.haizeix.com/problem/389)（二分答案）

[#393. 切绳子](http://oj.haizeix.com/problem/393)（二分答案）

[#391. 数列分段](http://oj.haizeix.com/problem/391)（二分答案）

## 二分专题（二）

[#82. 伐木](http://oj.haizeix.com/problem/82)

[#394. 跳石头](http://oj.haizeix.com/problem/394)

[#599. 两数之和1](http://oj.haizeix.com/problem/599)

[#600. 杨氏矩阵](http://oj.haizeix.com/problem/600)

[#485. 均分纸牌](http://oj.haizeix.com/problem/485)

[#504. 删数](http://oj.haizeix.com/problem/504)

[#505. 最大整数](http://oj.haizeix.com/problem/505)

[#519. 优雅数](http://oj.haizeix.com/problem/519)


## 真题

### 字节一面

* 实现语言：C

```
/**
 链表是否有环
*/
typedef struct ListNode {
	int data;
	struct ListNode *next;
} ListNode;

bool hasCycle(ListNode *head) {
	ListNode *fast = head, slow = head;
	while (fast && fast->next) {
		slow = slow->next;
		fast = fast->next->next;
		if (fast == slow) return ture;
	}
	return false;
}
```

### 字节二面

* 实现语言：OC
* 实现方案：递归

```c
/**
 打印 View 的所有子视图的 frame。
*/
- (void)func:(UIView *)view {
	NSLog(@"%@", NSStringFromCGRect(view.frame));
	
	for (UIView *subView in view.subviews) {
		[self func:subView];
	}
}
```

### 滴滴

* 实现语言：C  
* 实现方案：滑动窗口法

```c
/*
 实现1个函数，找出给定字符串中，最长的连续重复字符串子串。
 举例：
 给定字符串：
 abcdedfadasfasfafsssssdfasffwwwdfdswwweewerssss
 返回：sssss
 */
void func(string s) {
    int n = (int)s.size();
    int j = 0, idx = 0, mmax = 0;
    for (int i = 0; i < n; i++) {
        while (j < n && s[j] == s[i]) {
            j++;
        }
        if (mmax < j - i) {
            mmax = j - i;
            idx = i;
        }
        if (j > i) i = j - 1;
    }
    cout << s.substr(idx, mmax) << endl;
}
```

### 懂车帝一面

* 实现语言：C++
* 实现方案：层序遍历之逐层遍历

```c++
/**
 根据二叉树，输出一个数组，要数组的子元素是二叉树中某一层的所有元素的集合。
*/
vector<vector<int>> func(struct TreeNode* root) {
	if (!root) return nil;
	
	vector<vector<int>> ans;
	queue<struct TreeNode> que;
	que.push(root);

	while (!que.empty()) {
		vector<int> vec;
		for (int i = 0, I = que.size(); i < I; i++) {
			struct TreeNode *root = que.top();
			que.pop();
			vec.push_back(root->val);
			
			if (root->left) {
				que.push(root->left);
			}
			if (root->right) {
				que.push(root->right);
			}
		}
		ans.push_back(vec);
	}
	return ans;
}
```
