---
title: 二叉搜索树
date: 2020-11-18 14:29:12
tags: 数据结构与算法
---

[二叉搜索树（Binary Search Tree）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。

<!-- more -->

# 二叉搜索树

## 思考：在 n 个动态的整数中搜索某个整数（查看其是否存在）？

1. 使用动态数组，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n)；  
![二叉搜索树01](二叉搜索树/二叉搜索树01.png)
2. 使用有序的动态数组，使用二分搜索，最坏时间负载度：O(log(n))，但是添加和删除的平均时间复杂度是：O(n)；  
![二叉搜索树02](二叉搜索树/二叉搜索树02.png)
3. 使用二叉搜索树，添加、删除和搜索的最坏时间复杂度都是：O(log(n));

## 二叉搜索树特性
二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST。又被称为：二叉查找树、二叉排序树。二叉搜索树可以大大提高搜索数据的效率。  
1. 若它的左子树不空，则左子树上所有结点的值均<u>小于</u>它的根结点的值；  
2. 若它的右子树不空，则右子树上所有结点的值均<u>大于</u>它的根结点的值；  
3. 它的左、右子树也分别为<u>二叉搜索树</u>。

![二叉搜索树03](二叉搜索树/二叉搜索树03.png)
使用二叉搜索树需要注意：  
1. 存储的元素必须具备比较性，比如 `int`、`double` 等。
2. 如果是自定义类型，需要指定比较方式。
3. 存储的元素不可以是 `null`。

# 接口设计
```
/*
 * 元素的数量
 */
public int size() {}
/*
 * 是否为空
 */
public boolean isEmpty() {}
/*
 * 清空所有元素
 */
public void clear() {}
/*
 * 添加元素
 */
public void add(E element) {}
/*
 * 删除元素
 */
public void remove(E element) {}
/*
 * 是否包含某元素
 */
public void contains(E element) {}
```

## 添加节点
1. 找到要添加到的位置，即找到该位置的父节点 `parent`；  
2. 创建新节点 `node`；  
3. 加入到树中：`parent.left = node` 或者 `parent.right = node`。

注意：遇到值相等的元素可以覆盖旧值。

如添加 `12`、`1`，先找到父节点 `11`、`2`：
![二叉搜索树04](二叉搜索树/二叉搜索树04.png)
创建新节点 `node`，加入到树中：
![二叉搜索树05](二叉搜索树/二叉搜索树05.png)

代码实现：
```
public void add(E element) {
	if (root == null) {
		root = new Node<>(element, null);
		return;
	}
	
	Node<E> node = root;
	Node<E> parent = root;
	int cmp = 0;
	while (node != null) {
		parent = node;
		cmp = compare(element, node.element); // 返回值等于0：e1 == e2，大于0：e1 > e2，小于0：e1 < e2

		if (cmp > 0) {
			node = node.right;
		} else if (cmp < 0) {
			node = node.left;
		} else {
			node.element = element; // 考虑到不同名字的 person，相等就覆盖
			return;
		}
	}
	
	Node<E> newNode = new Node<>(element, parent);
	if (cmp > 0) {
		parent.right = newNode;
	} else {
		parent.left = newNode;
	}
	
	size++;
}
```

## 元素的比较方案设计
### 方案一
强制元素实现 `Comparable` 接口：
```
public class BinarySearchTree<E extends Comparable> {
    ...
}
```

添加 `extends Comparable` 后，要加入到二叉搜索树的元素都必须实现 `Comparable` 接口。

定义 Person 实现 `Comparable` 接口：
```
public class Person implements Comparable<Person> {
	private int age;
	
	// 生成 age 的 get、set 方法
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public int compareTo(Person e) {
		return age - e.age;
	}
	
	@Override
	public String toString() {
		return age + "";
	}
}
```

### 方案二
1. 允许外界传入一个 `Comparator` 自定义比较方案；
2. 如果没有传入 `Comparator`，强制认定元素实现了 `Comparable` 接口。
```
public class BinarySearchTree<E> {

	private Comparator<E> comparator;

	public BinarySearchTree() {
		this(null);
	}
	
	public BinarySearchTree(Comparator<E> comparator) {
		this.comparator = comparator;
	}
    
	private int compare(E e1, E e2) {
		if (comparator != null) {
			return comparator.compare(e1, e2);
		}
		return ((Comparable<E>)e1).compareTo(e2);
	}
}
```

## 打印器
使用 [BinaryTrees](https://github.com/CoderMJLee/BinaryTrees) 打印二叉搜索树。

1、实现 `BinaryTreeInfo` 接口
```
public class BinarySearchTree<E> implements BinaryTreeInfo {
	...

	@Override
	public Object root() {
		return root;
	}

	@Override
	public Object left(Object node) {
		return ((Node<E>)node).left;
	}

	@Override
	public Object right(Object node) {
		return ((Node<E>)node).right;
	}

	@Override
	public Object string(Object node) {
		return ((Node<E>)node).element;
	}
}
```

2、调用打印API `BinaryTrees.println(bst)`：
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);;
}
```

### Comparable
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
}
```

打印结果：
```
    ┌──7──┐
    │     │
  ┌─4─┐ ┌─9─┐
  │   │ │   │
┌─2─┐ 5 8   11─┐
│   │          │
1   3          12
```

### Comparator
```
public class Main {
	public static void main(String[] args) {
		Integer data[] = new Integer[] {
				7, 4, 9, 2, 5, 8, 11, 3, 12, 1
		};
		
		BinarySearchTree<Person> bst = new BinarySearchTree<>(new Comparator<Person>() {
			public int compare(Person o1, Person o2) {
				return o1.getAge() - o2.getAge();
			}
		});

		for (int i = 0; i < data.length; i++) {
			bst.add(new Person(data[i]));
		}
		
		BinaryTrees.println(bst);;
	}
}
```

修改 `BinarySearchTree` 的 `string` 方法，查看更详细的打印信息：
```
public Object string(Object node) {
	Node<E> myNode = (Node<E>)node;
	String parentString = "null";
	if (myNode.parent != null) {
		parentString = myNode.parent.element.toString();
	}
	return myNode.element + "_p(" + parentString + ")";
}
```

打印结果：
```
             ┌───7_p(null)───┐
             │               │
        ┌─4_p(7)─┐       ┌─9_p(7)─┐
        │        │       │        │
   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)─┐
   │        │                          │
1_p(2)    3_p(2)                    12_p(11)
```

ps：  
1. 二叉树绘图网站  
[520it](http://520it.com/binarytrees/)  
[Binary Tree Visualiser](http://btv.melezinek.cz/binary-search-tree.html)  
[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  
[B-Tree](https://yangez.github.io/btree-js/)

2. 国外教材的说法  
Full Binary Tree：完满二叉树（真二叉树）；  
Perfect Binary Tree：完美二叉树（满二叉树）；  
Complete Binary Tree：完全二叉树；

# 遍历
遍历是数据结构中的常见操作，线性数据结构（如：数组）的遍历比较简单，有两种：正序遍历和逆序遍历。二叉树的遍历方式有四种：  
1. 前序遍历（Preorder Traversal）
2. 中序遍历（Inorder Traversal）
3. 后序遍历（Postorder Traversal）
4. 层序遍历（Level Order Traversal）

## 前序遍历
访问顺序：
1. 根节点；
2. 前序遍历左子树；
3. 前序遍历右子树。
![二叉搜索树06](二叉搜索树/二叉搜索树06.png)

### 递归
<font color=#FF0000>7、</font><font color=#00BFF>4、2、1、3、5、</font><font color=#F0E68C>9、8、11、10、12</font>
![二叉搜索树10](二叉搜索树/二叉搜索树10.png)

代码实现：
```
public void preorderTraversal() {
	preorderTraversal(root);
}

private void preorderTraversal(Node<E> node) {
	if (node == null) return;
	
	System.out.println(node.element);
	preorderTraversal(node.left);
	preorderTraversal(node.right);
}
```

### 非递归

## 中序遍历
访问顺序（升序）：
1. 中序遍历左子树；
2. 根节点；
3. 中序遍历右子树。  
![二叉搜索树07](二叉搜索树/二叉搜索树07.png) 

访问顺序（降序）：
1. 中序遍历右子树；
2. 根节点；
3. 中序遍历左子树。
![二叉搜索树08](二叉搜索树/二叉搜索树08.png)

### 递归
<font color=#00BFF>1、2、3、4、5、</font><font color=#FF0000>7、</font><font color=#F0E68C>8、9、10、11、12</font>（升序）
![二叉搜索树11](二叉搜索树/二叉搜索树11.png)

代码实现：
```
public void inorderTraversal() {
	inorderTraversal(root);
}

private void inorderTraversal(Node<E> node) {
	if (node == null) return;
	
	inorderTraversal(node.left);
	System.out.println(node.element);
	inorderTraversal(node.right);
}
```

### 非递归

## 后序遍历
访问顺序：
1. 后序遍历左子树；
2. 后序遍历右子树；
3. 根节点。  
![二叉搜索树09](二叉搜索树/二叉搜索树09.png)

### 递归
<font color=#00BFF>1、3、2、5、4、</font><font color=#F0E68C>8、10、12、11、9、</font><font color=#FF0000>7</font>
![二叉搜索树12](二叉搜索树/二叉搜索树12.png)

代码实现：
```
public void postorderTraversal() {
	postorderTraversal(root);
}

private void postorderTraversal(Node<E> node) {
	if (node == null) return;
	
	postorderTraversal(node.left);
	postorderTraversal(node.right);
	System.out.println(node.element);
}
```

### 非递归

## 层序遍历
访问顺序：  
1. 从上到下、从左到右依次访问每一个几点。

<font color=#FF0000>7、</font><font color=#00BFF>4、9、</font><font color=#F0E68C>2、5、8、11、</font><font color=#32CD32>1、3、10、12</font>
![二叉搜索树13](二叉搜索树/二叉搜索树13.png)

代码实现：
```
public void levelOrderTraversal() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		System.out.println(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

# 遍历接口
## 前、中、后、层
遍历接口提供一个回调方法，将遍历到的元素传到方法调用处处理：
```
/*
 * 回调方法（相当于 OC 的 block）
 */
public static interface Visitor<E> {
	void visit(E element);
}
```

前序遍历、中序遍历、后序遍历和中序遍历：
```
/*
 * 前序遍历
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * 中序遍历
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	inorderTraversal(node.left, visitor);
	visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * 后序遍历
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	visitor.visit(node.element);
}

/*
 * 层序遍历（有回调）
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		visitor.visit(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

测试
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("前序遍历：");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("中序遍历：");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("后序遍历：");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("层序遍历：");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
}
```

打印结果：
```
             ┌───7_p(null)───┐
             │               │
        ┌─4_p(7)─┐       ┌─9_p(7)─┐
        │        │       │        │
   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐
   │        │                │         │
1_p(2)    3_p(2)         10_p(11)   12_p(11)

前序遍历：7 4 2 1 3 5 9 8 11 10 12 
中序遍历：1 2 3 4 5 7 8 9 10 11 12 
后序遍历：1 3 2 5 4 8 10 12 11 9 7 
层序遍历：7 4 9 2 5 8 11 1 3 10 12
```

## 遍历接口增强
实现当遍历到指定节点时，停止遍历。

### 层序遍历
程序遍历的修改比较简单，只需要：
1. 给 `Visitor.visit()` 方法增加返回值；
2. 在处理元素的位置添加判断即可。

```
/*
 * 层序遍历（有回调）
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		if (visitor.visit(node.element)) return; // 判断是否结束遍历
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}

/*
 * 回调方法（相当于 OC 的 block）
 * 返回值：true（停止遍历）/false（继续遍历）
 */
public static interface Visitor<E> {
	boolean visit(E element);
}
```

### 前、中、后
前序遍历、中序遍历和后序遍历实现方式相同：
1. Visitor 类中记录 isStop 变量（是否停止遍历的标签）；
2. 在遍历过程中，添加是否停止遍历的判断。
```
/*
 * 回调方法（相当于 OC 的 block）
 * 返回值：true（停止遍历）/false（继续遍历）
 */
public static abstract class Visitor<E> {
	public boolean isStop;
	public abstract boolean visit(E element);
}
```

前序遍历、中序遍历和后序遍历：
```
/*
 * 前序遍历
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	visitor.isStop = visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * 中序遍历
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	inorderTraversal(node.left, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * 后序遍历
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
}
```

测试：设置遍历到 8 时停止遍历。
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("前序遍历：");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("中序遍历：");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("后序遍历：");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("层序遍历：");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
}
```

打印结果：
```
             ┌───7_p(null)───┐
             │               │
        ┌─4_p(7)─┐       ┌─9_p(7)─┐
        │        │       │        │
   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐
   │        │                │         │
1_p(2)    3_p(2)         10_p(11)   12_p(11)

前序遍历：7 4 2 1 3 5 9 8 
中序遍历：1 2 3 4 5 7 8 
后序遍历：1 3 2 5 4 8 
层序遍历：7 4 9 2 5 8 
```

# 练习
## 树状打印二叉树
```
public String toString() {
	StringBuilder sb = new StringBuilder();
	toString(root, sb, "");
	return sb.toString();
}

private void toString(Node<E> node, StringBuilder sb, String prefix) {
	if (node == null) return;
	
	sb.append(prefix).append(node.element).append("\n");
	toString(node.left, sb, prefix + "L_");
	toString(node.right, sb, prefix + "R_");
}
```

测试：
```
static void test4() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	System.out.println(bst);
}
```

打印结果：
```
7
L_4
L_L_2
L_L_L_1
L_L_R_3
L_R_5
R_9
R_L_8
R_R_11
R_R_L_10
R_R_R_12
```

上面👆的打印是通过前序遍历实现的，同样的也可以使用中序遍历、后序遍历实现。

## 计算二叉树的高度

### 递归
```
public int height() {
	return height(root);
}

private int height(Node<E> node) {
	if (node == null) return 0; // 设置递归停止条件
	return 1 + Math.max(height(node.left), height(node.right)); // 取左右子树的高度中较大的一个加一
}
```

### 迭代
```
public int height() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	int levelSize = 1; // 标记某一层节点的个数，默认一个（第一层的root节点）
	int height = 0;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		levelSize--; 
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
		
		// 等于0时，表示这一层的节点全部遍历完成了
		if (levelSize == 0) {
			levelSize = queue.size(); // 开始记录下一层的节点个数
			height++; // 开始下一层遍历时，高度加一
		}
	}
	return height;
}
```

### 测试
```
static void test5() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	
	System.out.println("二叉树高度：" + bst.height());
}
```

打印结果：
```
             ┌───7_p(null)───┐
             │               │
        ┌─4_p(7)─┐       ┌─9_p(7)─┐
        │        │       │        │
   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐
   │        │                │         │
1_p(2)    3_p(2)         10_p(11)   12_p(11)
二叉树高度：4
```

## 完全二叉树的判断
使用层序遍历：
1. 如果树为空，返回 false；
2. 如果 node.left != null，将 node.left 入队；
3. 如果 node.left == null && node.right != null，返回 false；
4. 如果 node.right != null，将 node.right 入队；
5. 如果 node.right == null，则后边再遍历到的节点必须都是叶子节点，否则返回 false；
6. 遍历结束，返回 true；

```
public boolean isComplete() {
	
	if (root == null) return false;
	
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	boolean leaf = false;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		
		if (leaf && !node.isLeaf()) return false;
		
		if (node.left != null) {
			queue.offer(node.left);
		} else if (node.right != null) { // node.left == null && node.right != null
			return false;
		}
		
		if (node.right != null) {
			queue.offer(node.right);	
		} else { // node.right == null
			leaf = true;
		}
	}
	return true;
}
```

测试：
```
static void test6() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	System.out.println(bst.isComplete());
}
```

打印结果：
```
             ┌───7_p(null)───┐
             │               │
        ┌─4_p(7)─┐       ┌─9_p(7)─┐
        │        │       │        │
   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)
   │        │
1_p(2)    3_p(2)
true
```

## 翻转二叉树
[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)  
分别用前序遍历、中序遍历、后序遍历和层序遍历实现：
```
/*
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

/*
 * 前序遍历
 */
public TreeNode invertTree(TreeNode root) {
	if (root == null) return root;
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	invertTree(root.right);
	return root;
}

/*
 * 后序遍历
 */
public TreeNode invertTree2(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	invertTree(root.right);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	return root;
}

/*
 * 中序遍历
 */
public TreeNode invertTree3(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	return root;
}

/*
 * 层序遍历
 */
public TreeNode invertTree4(TreeNode root) {
	if (root == null) return root;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		
		TreeNode temp = node.left;
		node.left = node.right;
		node.right = temp;
		
		if (node.left != null) {
			queue.offer(node.left);
		}
		
		if (node.right != null) {
			queue.offer(node.right);
		}
	}
	
	return root;
}
```

