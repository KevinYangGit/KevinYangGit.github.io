---
title: äºŒå‰æœç´¢æ ‘
date: 2020-11-18 14:29:12
tags: æ•°æ®ç»“æ„ä¸ç®—æ³•
---

[äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)ä½œä¸ºä¸€ç§ç»å…¸çš„æ•°æ®ç»“æ„ï¼Œå®ƒæ—¢æœ‰é“¾è¡¨çš„å¿«é€Ÿæ’å…¥ä¸åˆ é™¤æ“ä½œçš„ç‰¹ç‚¹ï¼Œåˆæœ‰æ•°ç»„å¿«é€ŸæŸ¥æ‰¾çš„ä¼˜åŠ¿ï¼›æ‰€ä»¥åº”ç”¨ååˆ†å¹¿æ³›ï¼Œä¾‹å¦‚åœ¨æ–‡ä»¶ç³»ç»Ÿå’Œæ•°æ®åº“ç³»ç»Ÿä¸€èˆ¬ä¼šé‡‡ç”¨è¿™ç§æ•°æ®ç»“æ„è¿›è¡Œé«˜æ•ˆç‡çš„æ’åºä¸æ£€ç´¢æ“ä½œã€‚

<!-- more -->

# äºŒå‰æœç´¢æ ‘

## æ€è€ƒï¼šåœ¨ n ä¸ªåŠ¨æ€çš„æ•´æ•°ä¸­æœç´¢æŸä¸ªæ•´æ•°ï¼ˆæŸ¥çœ‹å…¶æ˜¯å¦å­˜åœ¨ï¼‰ï¼Ÿ

1. ä½¿ç”¨åŠ¨æ€æ•°ç»„ï¼Œä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹éå†æœç´¢ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼›  
![äºŒå‰æœç´¢æ ‘01](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘01.png)
2. ä½¿ç”¨æœ‰åºçš„åŠ¨æ€æ•°ç»„ï¼Œä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œæœ€åæ—¶é—´è´Ÿè½½åº¦ï¼šO(log(n))ï¼Œä½†æ˜¯æ·»åŠ å’Œåˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ï¼šO(n)ï¼›  
![äºŒå‰æœç´¢æ ‘02](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘02.png)
3. ä½¿ç”¨äºŒå‰æœç´¢æ ‘ï¼Œæ·»åŠ ã€åˆ é™¤å’Œæœç´¢çš„æœ€åæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ï¼šO(log(n));

## äºŒå‰æœç´¢æ ‘ç‰¹æ€§
äºŒå‰æœç´¢æ ‘æ˜¯äºŒå‰æ ‘çš„ä¸€ç§ï¼Œæ˜¯åº”ç”¨éå¸¸å¹¿æ³›çš„ä¸€ç§äºŒå‰æ ‘ï¼Œè‹±æ–‡ç®€ç§°ä¸º BSTã€‚åˆè¢«ç§°ä¸ºï¼šäºŒå‰æŸ¥æ‰¾æ ‘ã€äºŒå‰æ’åºæ ‘ã€‚äºŒå‰æœç´¢æ ‘å¯ä»¥å¤§å¤§æé«˜æœç´¢æ•°æ®çš„æ•ˆç‡ã€‚  
1. è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡<u>å°äº</u>å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›  
2. è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡<u>å¤§äº</u>å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›  
3. å®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸º<u>äºŒå‰æœç´¢æ ‘</u>ã€‚

![äºŒå‰æœç´¢æ ‘03](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘03.png)
ä½¿ç”¨äºŒå‰æœç´¢æ ‘éœ€è¦æ³¨æ„ï¼š  
1. å­˜å‚¨çš„å…ƒç´ å¿…é¡»å…·å¤‡æ¯”è¾ƒæ€§ï¼Œæ¯”å¦‚ `int`ã€`double` ç­‰ã€‚
2. å¦‚æœæ˜¯è‡ªå®šä¹‰ç±»å‹ï¼Œéœ€è¦æŒ‡å®šæ¯”è¾ƒæ–¹å¼ã€‚
3. å­˜å‚¨çš„å…ƒç´ ä¸å¯ä»¥æ˜¯ `null`ã€‚

# æ¥å£è®¾è®¡
```
/*
 * å…ƒç´ çš„æ•°é‡
 */
public int size() {}
/*
 * æ˜¯å¦ä¸ºç©º
 */
public boolean isEmpty() {}
/*
 * æ¸…ç©ºæ‰€æœ‰å…ƒç´ 
 */
public void clear() {}
/*
 * æ·»åŠ å…ƒç´ 
 */
public void add(E element) {}
/*
 * åˆ é™¤å…ƒç´ 
 */
public void remove(E element) {}
/*
 * æ˜¯å¦åŒ…å«æŸå…ƒç´ 
 */
public void contains(E element) {}
```

## æ·»åŠ èŠ‚ç‚¹
1. æ‰¾åˆ°è¦æ·»åŠ åˆ°çš„ä½ç½®ï¼Œå³æ‰¾åˆ°è¯¥ä½ç½®çš„çˆ¶èŠ‚ç‚¹ `parent`ï¼›  
2. åˆ›å»ºæ–°èŠ‚ç‚¹ `node`ï¼›  
3. åŠ å…¥åˆ°æ ‘ä¸­ï¼š`parent.left = node` æˆ–è€… `parent.right = node`ã€‚

æ³¨æ„ï¼šé‡åˆ°å€¼ç›¸ç­‰çš„å…ƒç´ å¯ä»¥è¦†ç›–æ—§å€¼ã€‚

å¦‚æ·»åŠ  `12`ã€`1`ï¼Œå…ˆæ‰¾åˆ°çˆ¶èŠ‚ç‚¹ `11`ã€`2`ï¼š
![äºŒå‰æœç´¢æ ‘04](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘04.png)
åˆ›å»ºæ–°èŠ‚ç‚¹ `node`ï¼ŒåŠ å…¥åˆ°æ ‘ä¸­ï¼š
![äºŒå‰æœç´¢æ ‘05](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘05.png)

ä»£ç å®ç°ï¼š
```
public void add(E element) {
	if (root == null) {
		root = new Node<>(element, null);
		return;
	}
	
	Node<E> node = root;
	Node<E> parent = root;
	int cmp = 0;
	while (node != null) {
		parent = node;
		cmp = compare(element, node.element); // è¿”å›å€¼ç­‰äº0ï¼še1 == e2ï¼Œå¤§äº0ï¼še1 > e2ï¼Œå°äº0ï¼še1 < e2

		if (cmp > 0) {
			node = node.right;
		} else if (cmp < 0) {
			node = node.left;
		} else {
			node.element = element; // è€ƒè™‘åˆ°ä¸åŒåå­—çš„ personï¼Œç›¸ç­‰å°±è¦†ç›–
			return;
		}
	}
	
	Node<E> newNode = new Node<>(element, parent);
	if (cmp > 0) {
		parent.right = newNode;
	} else {
		parent.left = newNode;
	}
	
	size++;
}
```

## å…ƒç´ çš„æ¯”è¾ƒæ–¹æ¡ˆè®¾è®¡
### æ–¹æ¡ˆä¸€
å¼ºåˆ¶å…ƒç´ å®ç° `Comparable` æ¥å£ï¼š
```
public class BinarySearchTree<E extends Comparable> {
    ...
}
```

æ·»åŠ  `extends Comparable` åï¼Œè¦åŠ å…¥åˆ°äºŒå‰æœç´¢æ ‘çš„å…ƒç´ éƒ½å¿…é¡»å®ç° `Comparable` æ¥å£ã€‚

å®šä¹‰ Person å®ç° `Comparable` æ¥å£ï¼š
```
public class Person implements Comparable<Person> {
	private int age;
	
	// ç”Ÿæˆ age çš„ getã€set æ–¹æ³•
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public int compareTo(Person e) {
		return age - e.age;
	}
	
	@Override
	public String toString() {
		return age + "";
	}
}
```

### æ–¹æ¡ˆäºŒ
1. å…è®¸å¤–ç•Œä¼ å…¥ä¸€ä¸ª `Comparator` è‡ªå®šä¹‰æ¯”è¾ƒæ–¹æ¡ˆï¼›
2. å¦‚æœæ²¡æœ‰ä¼ å…¥ `Comparator`ï¼Œå¼ºåˆ¶è®¤å®šå…ƒç´ å®ç°äº† `Comparable` æ¥å£ã€‚
```
public class BinarySearchTree<E> {

	private Comparator<E> comparator;

	public BinarySearchTree() {
		this(null);
	}
	
	public BinarySearchTree(Comparator<E> comparator) {
		this.comparator = comparator;
	}
    
	private int compare(E e1, E e2) {
		if (comparator != null) {
			return comparator.compare(e1, e2);
		}
		return ((Comparable<E>)e1).compareTo(e2);
	}
}
```

## æ‰“å°å™¨
ä½¿ç”¨ [BinaryTrees](https://github.com/CoderMJLee/BinaryTrees) æ‰“å°äºŒå‰æœç´¢æ ‘ã€‚

1ã€å®ç° `BinaryTreeInfo` æ¥å£
```
public class BinarySearchTree<E> implements BinaryTreeInfo {
	...

	@Override
	public Object root() {
		return root;
	}

	@Override
	public Object left(Object node) {
		return ((Node<E>)node).left;
	}

	@Override
	public Object right(Object node) {
		return ((Node<E>)node).right;
	}

	@Override
	public Object string(Object node) {
		return ((Node<E>)node).element;
	}
}
```

2ã€è°ƒç”¨æ‰“å°API `BinaryTrees.println(bst)`ï¼š
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);;
}
```

### Comparable
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
}
```

æ‰“å°ç»“æœï¼š
```
    â”Œâ”€â”€7â”€â”€â”
    â”‚     â”‚
  â”Œâ”€4â”€â” â”Œâ”€9â”€â”
  â”‚   â”‚ â”‚   â”‚
â”Œâ”€2â”€â” 5 8   11â”€â”
â”‚   â”‚          â”‚
1   3          12
```

### Comparator
```
public class Main {
	public static void main(String[] args) {
		Integer data[] = new Integer[] {
				7, 4, 9, 2, 5, 8, 11, 3, 12, 1
		};
		
		BinarySearchTree<Person> bst = new BinarySearchTree<>(new Comparator<Person>() {
			public int compare(Person o1, Person o2) {
				return o1.getAge() - o2.getAge();
			}
		});

		for (int i = 0; i < data.length; i++) {
			bst.add(new Person(data[i]));
		}
		
		BinaryTrees.println(bst);;
	}
}
```

ä¿®æ”¹ `BinarySearchTree` çš„ `string` æ–¹æ³•ï¼ŒæŸ¥çœ‹æ›´è¯¦ç»†çš„æ‰“å°ä¿¡æ¯ï¼š
```
public Object string(Object node) {
	Node<E> myNode = (Node<E>)node;
	String parentString = "null";
	if (myNode.parent != null) {
		parentString = myNode.parent.element.toString();
	}
	return myNode.element + "_p(" + parentString + ")";
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9)   11_p(9)â”€â”
   â”‚        â”‚                          â”‚
1_p(2)    3_p(2)                    12_p(11)
```

å›½å¤–æ•™æçš„è¯´æ³•  
Full Binary Treeï¼šå®Œæ»¡äºŒå‰æ ‘ï¼ˆçœŸäºŒå‰æ ‘ï¼‰ï¼›  
Perfect Binary Treeï¼šå®Œç¾äºŒå‰æ ‘ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰ï¼›  
Complete Binary Treeï¼šå®Œå…¨äºŒå‰æ ‘ï¼›

# éå†
éå†æ˜¯æ•°æ®ç»“æ„ä¸­çš„å¸¸è§æ“ä½œï¼Œçº¿æ€§æ•°æ®ç»“æ„ï¼ˆå¦‚ï¼šæ•°ç»„ï¼‰çš„éå†æ¯”è¾ƒç®€å•ï¼Œæœ‰ä¸¤ç§ï¼šæ­£åºéå†å’Œé€†åºéå†ã€‚äºŒå‰æ ‘çš„éå†æ–¹å¼æœ‰å››ç§ï¼š  
1. å‰åºéå†ï¼ˆPreorder Traversalï¼‰
2. ä¸­åºéå†ï¼ˆInorder Traversalï¼‰
3. ååºéå†ï¼ˆPostorder Traversalï¼‰
4. å±‚åºéå†ï¼ˆLevel Order Traversalï¼‰

## å‰åºéå†
è®¿é—®é¡ºåºï¼š
1. æ ¹èŠ‚ç‚¹ï¼›
2. å‰åºéå†å·¦å­æ ‘ï¼›
3. å‰åºéå†å³å­æ ‘ã€‚
![äºŒå‰æœç´¢æ ‘06](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘06.png)

### é€’å½’
<font color=#FF0000>7ã€</font><font color=#00BFF>4ã€2ã€1ã€3ã€5ã€</font><font color=#F0E68C>9ã€8ã€11ã€10ã€12</font>
![äºŒå‰æœç´¢æ ‘10](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘10.png)

ä»£ç å®ç°ï¼š
```
public void preorderTraversal() {
	preorderTraversal(root);
}

private void preorderTraversal(Node<E> node) {
	if (node == null) return;
	
	System.out.println(node.element);
	preorderTraversal(node.left);
	preorderTraversal(node.right);
}
```

### éé€’å½’

## ä¸­åºéå†
è®¿é—®é¡ºåºï¼ˆå‡åºï¼‰ï¼š
1. ä¸­åºéå†å·¦å­æ ‘ï¼›
2. æ ¹èŠ‚ç‚¹ï¼›
3. ä¸­åºéå†å³å­æ ‘ã€‚  
![äºŒå‰æœç´¢æ ‘07](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘07.png) 

è®¿é—®é¡ºåºï¼ˆé™åºï¼‰ï¼š
1. ä¸­åºéå†å³å­æ ‘ï¼›
2. æ ¹èŠ‚ç‚¹ï¼›
3. ä¸­åºéå†å·¦å­æ ‘ã€‚
![äºŒå‰æœç´¢æ ‘08](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘08.png)

### é€’å½’
<font color=#00BFF>1ã€2ã€3ã€4ã€5ã€</font><font color=#FF0000>7ã€</font><font color=#F0E68C>8ã€9ã€10ã€11ã€12</font>ï¼ˆå‡åºï¼‰
![äºŒå‰æœç´¢æ ‘11](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘11.png)

ä»£ç å®ç°ï¼š
```
public void inorderTraversal() {
	inorderTraversal(root);
}

private void inorderTraversal(Node<E> node) {
	if (node == null) return;
	
	inorderTraversal(node.left);
	System.out.println(node.element);
	inorderTraversal(node.right);
}
```

### éé€’å½’

## ååºéå†
è®¿é—®é¡ºåºï¼š
1. ååºéå†å·¦å­æ ‘ï¼›
2. ååºéå†å³å­æ ‘ï¼›
3. æ ¹èŠ‚ç‚¹ã€‚  
![äºŒå‰æœç´¢æ ‘09](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘09.png)

### é€’å½’
<font color=#00BFF>1ã€3ã€2ã€5ã€4ã€</font><font color=#F0E68C>8ã€10ã€12ã€11ã€9ã€</font><font color=#FF0000>7</font>
![äºŒå‰æœç´¢æ ‘12](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘12.png)

ä»£ç å®ç°ï¼š
```
public void postorderTraversal() {
	postorderTraversal(root);
}

private void postorderTraversal(Node<E> node) {
	if (node == null) return;
	
	postorderTraversal(node.left);
	postorderTraversal(node.right);
	System.out.println(node.element);
}
```

### éé€’å½’

## å±‚åºéå†
è®¿é—®é¡ºåºï¼š  
1. ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³ä¾æ¬¡è®¿é—®æ¯ä¸€ä¸ªå‡ ç‚¹ã€‚

<font color=#FF0000>7ã€</font><font color=#00BFF>4ã€9ã€</font><font color=#F0E68C>2ã€5ã€8ã€11ã€</font><font color=#32CD32>1ã€3ã€10ã€12</font>
![äºŒå‰æœç´¢æ ‘13](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘13.png)

ä»£ç å®ç°ï¼š
```
public void levelOrderTraversal() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		System.out.println(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

# éå†æ¥å£
## å‰ã€ä¸­ã€åã€å±‚
éå†æ¥å£æä¾›ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼Œå°†éå†åˆ°çš„å…ƒç´ ä¼ åˆ°æ–¹æ³•è°ƒç”¨å¤„å¤„ç†ï¼š
```
/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 */
public static interface Visitor<E> {
	void visit(E element);
}
```

å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†å’Œä¸­åºéå†ï¼š
```
/*
 * å‰åºéå†
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * ä¸­åºéå†
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	inorderTraversal(node.left, visitor);
	visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * ååºéå†
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	visitor.visit(node.element);
}

/*
 * å±‚åºéå†ï¼ˆæœ‰å›è°ƒï¼‰
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		visitor.visit(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

æµ‹è¯•
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("å‰åºéå†ï¼š");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("ä¸­åºéå†ï¼š");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("ååºéå†ï¼š");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("å±‚åºéå†ï¼š");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)

å‰åºéå†ï¼š7 4 2 1 3 5 9 8 11 10 12 
ä¸­åºéå†ï¼š1 2 3 4 5 7 8 9 10 11 12 
ååºéå†ï¼š1 3 2 5 4 8 10 12 11 9 7 
å±‚åºéå†ï¼š7 4 9 2 5 8 11 1 3 10 12
```

## éå†æ¥å£å¢å¼º
å®ç°å½“éå†åˆ°æŒ‡å®šèŠ‚ç‚¹æ—¶ï¼Œåœæ­¢éå†ã€‚

### å±‚åºéå†
ç¨‹åºéå†çš„ä¿®æ”¹æ¯”è¾ƒç®€å•ï¼Œåªéœ€è¦ï¼š
1. ç»™ `Visitor.visit()` æ–¹æ³•å¢åŠ è¿”å›å€¼ï¼›
2. åœ¨å¤„ç†å…ƒç´ çš„ä½ç½®æ·»åŠ åˆ¤æ–­å³å¯ã€‚

```
/*
 * å±‚åºéå†ï¼ˆæœ‰å›è°ƒï¼‰
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		if (visitor.visit(node.element)) return; // åˆ¤æ–­æ˜¯å¦ç»“æŸéå†
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}

/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 * è¿”å›å€¼ï¼štrueï¼ˆåœæ­¢éå†ï¼‰/falseï¼ˆç»§ç»­éå†ï¼‰
 */
public static interface Visitor<E> {
	boolean visit(E element);
}
```

### å‰ã€ä¸­ã€å
å‰åºéå†ã€ä¸­åºéå†å’Œååºéå†å®ç°æ–¹å¼ç›¸åŒï¼š
1. Visitor ç±»ä¸­è®°å½• isStop å˜é‡ï¼ˆæ˜¯å¦åœæ­¢éå†çš„æ ‡ç­¾ï¼‰ï¼›
2. åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œæ·»åŠ æ˜¯å¦åœæ­¢éå†çš„åˆ¤æ–­ã€‚
```
/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 * è¿”å›å€¼ï¼štrueï¼ˆåœæ­¢éå†ï¼‰/falseï¼ˆç»§ç»­éå†ï¼‰
 */
public static abstract class Visitor<E> {
	public boolean isStop;
	public abstract boolean visit(E element);
}
```

å‰åºéå†ã€ä¸­åºéå†å’Œååºéå†ï¼š
```
/*
 * å‰åºéå†
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	visitor.isStop = visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * ä¸­åºéå†
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	inorderTraversal(node.left, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * ååºéå†
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
}
```

æµ‹è¯•ï¼šè®¾ç½®éå†åˆ° 8 æ—¶åœæ­¢éå†ã€‚
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("å‰åºéå†ï¼š");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("ä¸­åºéå†ï¼š");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("ååºéå†ï¼š");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("å±‚åºéå†ï¼š");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)

å‰åºéå†ï¼š7 4 2 1 3 5 9 8 
ä¸­åºéå†ï¼š1 2 3 4 5 7 8 
ååºéå†ï¼š1 3 2 5 4 8 
å±‚åºéå†ï¼š7 4 9 2 5 8 
```
## éå†çš„åº”ç”¨
å‰åºéå†ï¼šæ ‘çŠ¶ç»“æ„å±•ç¤ºï¼ˆæ³¨æ„å·¦å³å­æ ‘çš„é¡ºåºï¼‰ï¼›  
ä¸­åºéå†ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æŒ‰å‡åºæˆ–é™åºå¤„ç†èŠ‚ç‚¹ï¼›  
ååºéå†ï¼šé€‚ç”¨äºä¸€äº›å…ˆå­åçˆ¶çš„æ“ä½œï¼›  
å±‚åºéå†ï¼šè®¡ç®—äºŒå‰æ ‘çš„é«˜åº¦ã€åˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼›

# ç»ƒä¹ â… 
## æ ‘çŠ¶æ‰“å°äºŒå‰æ ‘
```
public String toString() {
	StringBuilder sb = new StringBuilder();
	toString(root, sb, "");
	return sb.toString();
}

private void toString(Node<E> node, StringBuilder sb, String prefix) {
	if (node == null) return;
	
	sb.append(prefix).append(node.element).append("\n");
	toString(node.left, sb, prefix + "L_");
	toString(node.right, sb, prefix + "R_");
}
```

æµ‹è¯•ï¼š
```
static void test4() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	System.out.println(bst);
}
```

æ‰“å°ç»“æœï¼š
```
7
L_4
L_L_2
L_L_L_1
L_L_R_3
L_R_5
R_9
R_L_8
R_R_11
R_R_L_10
R_R_R_12
```

ä¸Šé¢ğŸ‘†çš„æ‰“å°æ˜¯é€šè¿‡å‰åºéå†å®ç°çš„ï¼ŒåŒæ ·çš„ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸­åºéå†ã€ååºéå†å®ç°ã€‚

## è®¡ç®—äºŒå‰æ ‘çš„é«˜åº¦

### é€’å½’
```
public int height() {
	return height(root);
}

private int height(Node<E> node) {
	if (node == null) return 0; // è®¾ç½®é€’å½’åœæ­¢æ¡ä»¶
	return 1 + Math.max(height(node.left), height(node.right)); // å–å·¦å³å­æ ‘çš„é«˜åº¦ä¸­è¾ƒå¤§çš„ä¸€ä¸ªåŠ ä¸€
}
```

### è¿­ä»£
```
public int height() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	int levelSize = 1; // æ ‡è®°æŸä¸€å±‚èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œé»˜è®¤ä¸€ä¸ªï¼ˆç¬¬ä¸€å±‚çš„rootèŠ‚ç‚¹ï¼‰
	int height = 0;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		levelSize--; 
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
		
		// ç­‰äº0æ—¶ï¼Œè¡¨ç¤ºè¿™ä¸€å±‚çš„èŠ‚ç‚¹å…¨éƒ¨éå†å®Œæˆäº†
		if (levelSize == 0) {
			levelSize = queue.size(); // å¼€å§‹è®°å½•ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ä¸ªæ•°
			height++; // å¼€å§‹ä¸‹ä¸€å±‚éå†æ—¶ï¼Œé«˜åº¦åŠ ä¸€
		}
	}
	return height;
}
```

### æµ‹è¯•
```
static void test5() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	
	System.out.println("äºŒå‰æ ‘é«˜åº¦ï¼š" + bst.height());
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)
äºŒå‰æ ‘é«˜åº¦ï¼š4
```

## å®Œå…¨äºŒå‰æ ‘çš„åˆ¤æ–­
ä½¿ç”¨å±‚åºéå†ï¼š
1. å¦‚æœæ ‘ä¸ºç©ºï¼Œè¿”å› falseï¼›
2. å¦‚æœ node.left != nullï¼Œå°† node.left å…¥é˜Ÿï¼›
3. å¦‚æœ node.left == null && node.right != nullï¼Œè¿”å› falseï¼›
4. å¦‚æœ node.right != nullï¼Œå°† node.right å…¥é˜Ÿï¼›
5. å¦‚æœ node.right == nullï¼Œåˆ™åè¾¹å†éå†åˆ°çš„èŠ‚ç‚¹å¿…é¡»éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å› falseï¼›
6. éå†ç»“æŸï¼Œè¿”å› trueï¼›

```
public boolean isComplete() {
	
	if (root == null) return false;
	
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	boolean leaf = false;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		
		if (leaf && !node.isLeaf()) return false;
		
		if (node.left != null) {
			queue.offer(node.left);
		} else if (node.right != null) { //å³ï¼šnode.left == null && node.right != null
			return false;
		}
		
		if (node.right != null) {
			queue.offer(node.right);	
		} else { // node.right == null
			leaf = true;
		}
	}
	return true;
}
```

æµ‹è¯•ï¼š
```
static void test6() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	System.out.println(bst.isComplete());
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9)   11_p(9)
   â”‚        â”‚
1_p(2)    3_p(2)
true
```

## ç¿»è½¬äºŒå‰æ ‘
[226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/)  
æ ¸å¿ƒä»£ç ï¼š
```
TreeNode temp = node.left;
node.left = node.right;
node.right = temp;
```

åˆ†åˆ«ç”¨å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†å’Œå±‚åºéå†å®ç°ï¼š
```
/*
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

/*
 * å‰åºéå†
 */
public TreeNode invertTree(TreeNode root) {
	if (root == null) return root;
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	invertTree(root.right);
	return root;
}

/*
 * ååºéå†
 */
public TreeNode invertTree2(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	invertTree(root.right);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	return root;
}

/*
 * ä¸­åºéå†
 */
public TreeNode invertTree3(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	return root;
}

/*
 * å±‚åºéå†
 */
public TreeNode invertTree4(TreeNode root) {
	if (root == null) return root;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		
		TreeNode temp = node.left;
		node.left = node.right;
		node.right = temp;
		
		if (node.left != null) {
			queue.offer(node.left);
		}
		
		if (node.right != null) {
			queue.offer(node.right);
		}
	}
	
	return root;
}
```

# é‡æ„äºŒå‰æ ‘
ä»¥ä¸‹ä¸¤ç§æ–¹å¼ï¼Œå¯ä»¥ä¿è¯é‡æ„å¤„å”¯ä¸€çš„ä¸€ä¸ªäºŒå‰æ ‘ã€‚é‡æ„çš„åŸç†æ˜¯é€šè¿‡ä¸¤ç§ä¸åŒçš„éå†æ–¹å¼æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå†ç”¨åŒæ ·çš„æ–¹å¼æ‰¾åˆ°æ¯æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ï¼š  
1. å‰åºéå† + ä¸­åºéå†ï¼š  
![äºŒå‰æœç´¢æ ‘14](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘14.png)  
2. ååºéå† + ä¸­åºéå†ï¼š  
![äºŒå‰æœç´¢æ ‘15](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘15.png)

å¦‚ï¼šå‰åºéå†ï¼š`4ã€2ã€1ã€3ã€6ã€5`ï¼Œä¸­åºéå†ï¼š`1ã€2ã€3ã€4ã€5ã€6`ã€‚  
1. å…ˆæ ¹æ®å‰åºéå†å¯ä»¥æ‰¾åˆ°è¿™æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `4`ï¼›  
2. å†ç»“åˆä¸­åºéå†å¯ä»¥æ‰¾åˆ°å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ `2`ï¼Œå³å­æ ‘çš„æ ¹èŠ‚ç‚¹ `6`ï¼›  
3. æœ€åæ ¹æ®ä¸­åºéå†å¯ä»¥çŸ¥é“ `2` çš„å·¦å­æ ‘æ˜¯ `1`ï¼Œå³å­æ ‘æ˜¯ `3`ï¼›`6` çš„å·¦å­æ ‘æ˜¯ `5`ã€‚  
![äºŒå‰æœç´¢æ ‘16](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘16.png)

â€œå‰åºéå† + ååºéå†â€è¿™ç§æƒ…å†µæ¯”è¾ƒç‰¹æ®Šï¼Œå­˜åœ¨ä¸¤ç§æƒ…å†µï¼š  
1. å¦‚æœæ˜¯ä¸€æ£µçœŸäºŒå‰æ ‘ï¼ˆProper Binary Treeï¼‰ï¼Œç»“æœæ˜¯å”¯ä¸€çš„ï¼›
![äºŒå‰æœç´¢æ ‘17](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘17.png)  
é‡æ„æ–¹å¼åŒä¸ŠğŸ‘†ã€‚
2. å¦åˆ™ä¸å”¯ä¸€ï¼›  
![äºŒå‰æœç´¢æ ‘18](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘18.png)  
å› ä¸ºåªæœ‰ä¸€æ£µå­æ ‘ï¼Œæ‰€ä»¥ä»éå†ç»“æœä¸èƒ½ç¡®å®šå­æ ‘ç©¶ç«Ÿæ˜¯å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ã€‚

# å‰é©±èŠ‚ç‚¹
å‰é©±èŠ‚ç‚¹ï¼šä¸­åºéå†æ—¶çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå‰é©±èŠ‚ç‚¹å°±æ˜¯å‰ä¸€ä¸ªæ¯”å®ƒå°çš„èŠ‚ç‚¹ã€‚

æŸ¥æ‰¾æ–¹å¼ï¼š
1. `node.left != null`ï¼›  
`predecessor = node.left.right.right.right...` ç»ˆæ­¢æ¡ä»¶ï¼š`right == null`ã€‚  
å¦‚ï¼š6ã€8ã€13
![äºŒå‰æœç´¢æ ‘19](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘19.png)  
2. `node.left == null && node.parent != null`;  
`predecessor = node.parent.parent.parent...` ç»ˆæ­¢æ¡ä»¶ï¼š`node` åœ¨ `parent` çš„å³å­æ ‘ä¸­ï¼ˆ`node == node.parent.right`ï¼‰ã€‚  
å¦‚ï¼š7ã€11ã€9ã€1
![äºŒå‰æœç´¢æ ‘20](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘20.png) 
3. `node.left == null && node.parent == null`ï¼Œæ²¡æœ‰å‰é©±èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰ã€‚

ä»£ç å®ç°ï¼š
```
public Node<E> predecessor(Node<E> node) {
	if (node == null) return node;
	
	Node<E> p = node.left;
	if (p != null) {
		while (p.right != null) {
			p = p.right;
		}
		return p;
	}
	
	while (node.parent != null && node == node.parent.left) {
		node = node.parent;
	}
	return node.parent;
}
```

# åç»§èŠ‚ç‚¹
åç»§èŠ‚ç‚¹ï¼šç»ˆé¡»éå†æ—¶çš„åä¸€ä¸ªå‡ ç‚¹ã€‚å¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œåç»§èŠ‚ç‚¹å°±æ˜¯åä¸€ä¸ªæ¯”å®ƒå¤§çš„èŠ‚ç‚¹ã€‚

1. `node.right != null`ï¼›  
`successor = node.right.left.left.left...` ç»ˆæ­¢æ¡ä»¶ï¼š`left == null`ã€‚  
å¦‚ï¼š1ã€8ã€4
![äºŒå‰æœç´¢æ ‘21](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘21.png) 
2. `node.right == null && node.parent != null`ï¼›  
`successor = node.parent.parent.parent...` ç»ˆæ­¢æ¡ä»¶ï¼š`node` åœ¨ `parent` çš„å·¦å­æ ‘ä¸­ï¼ˆ`node == node.parent.left`ï¼‰ã€‚  
å¦‚ï¼š7ã€6ã€3ã€11
![äºŒå‰æœç´¢æ ‘22](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘22.png) 
3. `node.right == null && node.parent == null`ï¼Œæ²¡æœ‰åç»§èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰ã€‚

ä»£ç å®ç°ï¼š
```
public Node<E> successor(Node<E> node) {
	if (node == null) return node;
	
	Node<E> p = node.right;
	if (p != null) {
		while (p.left != null) {
			p = p.left;
		}
		return p;
	}
	
	while (node.parent != null && node == node.parent.right) {
		node = node.parent;
	}
	return node.parent;
}
```

# åˆ é™¤

## åˆ é™¤-å¶å­èŠ‚ç‚¹
```
//å·¦å­èŠ‚ç‚¹
if (node == node.parent.left) {
	node.parent.left = null;
}

//å³å­èŠ‚ç‚¹
if (node == node.parent.right) {
	node.parent.right = node;
}

//åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆrootï¼‰
if (node.parent == null) {
	root = null;
}
```
![äºŒå‰æœç´¢æ ‘24](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘24.png)

## åˆ é™¤-åº¦ä¸º1çš„èŠ‚ç‚¹
ç”¨å­èŠ‚ç‚¹ä»£æ›¿åŸèŠ‚ç‚¹çš„ä½ç½®ï¼Œchild æ˜¯ node.left æˆ–è€… node.rightï¼š
```
//å¦‚æœnodeæ˜¯å·¦å­èŠ‚ç‚¹
if (node == node.parent.left) {
	child.parent = node.parent;
	node.parent.left = child;
}

//å¦‚æœnodeæ˜¯å³å­èŠ‚ç‚¹
if (node == node.parent.right) {
	child.parent = node.parent;
	node.parent.right = child;
}

//å¦‚æœnodeæ˜¯æ ¹èŠ‚ç‚¹
if (node.parent == null) {
	root = child;
	child.parent = null;
}
```
![äºŒå‰æœç´¢æ ‘25](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘25.png)

## åˆ é™¤-åº¦ä¸º2çš„èŠ‚ç‚¹
1. å…ˆç”¨å‰é©±æˆ–åç»§èŠ‚ç‚¹çš„å€¼è¦†ç›–åŸèŠ‚ç‚¹çš„å€¼ï¼›
2. å†åˆ é™¤ç›¸åº”çš„å‰é©±æˆ–åç»§èŠ‚ç‚¹ï¼›
3. å¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åº¦ä¸º2ï¼Œé‚£å®ƒçš„å‰é©±ã€åç»§èŠ‚ç‚¹çš„åº¦åªèƒ½æ˜¯1å’Œ0ï¼›  

![äºŒå‰æœç´¢æ ‘26](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘26.png)

## ä»£ç å®ç°
```
public void remove(E element) {
	remove(node(element));
}

private void remove(Node<E> node) {
	
	//åˆ é™¤åº¦ä¸º2çš„èŠ‚ç‚¹
	if (node.isHasTwoChildren()) {
		//æ‰¾åˆ°åç»§èŠ‚ç‚¹
		Node<E> s = successor(node);
		//ç”¨åç»§èŠ‚ç‚¹çš„å€¼è¦†ç›–åº¦ä¸º2çš„èŠ‚ç‚¹çš„å€¼
		node.element = s.element;
		//åˆ é™¤åç»§èŠ‚ç‚¹
		node = s;
	}
	
	//åˆ é™¤åº¦ä¸º1æˆ–0çš„èŠ‚ç‚¹
	Node<E> replacement = node.left != null ? node.left : node.right;
	
	if (replacement != null) { // nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹
		// æ›´æ”¹parent
		replacement.parent = node.parent;
		// æ›´æ”¹parentçš„leftã€rightçš„æŒ‡å‘
		if (node.parent == null) { //nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹
			root = replacement;
		} else if (node.parent.left == node) {
			node.parent.left = replacement;
		} else {
			node.parent.right = replacement;
		}
	} else if (node.parent == null) { // nodeæ˜¯å¶å­èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹
		root = null;
	} else { // nodeæ˜¯å¶å­èŠ‚ç‚¹ï¼Œä½†ä¸æ˜¯æ ¹èŠ‚ç‚¹
		if (node.parent.left == node) {
			node.parent.left = null;
		} else {
			node.parent.right = null;
		}
	}
}

/*
 * æ ¹æ®å…ƒç´ å†…å®¹è·å–èŠ‚ç‚¹
 */
private Node<E> node(E element) {
	Node<E> node = root;
	while (node != null) {
		int cmp = compare(element, node.element);
		if (cmp == 0) return node;
		if (cmp > 0) {
			node = node.right;
		} else {
			node = node.left;
		}
	}
	return node;
}
```

# ç»ƒä¹  â…¡
## äºŒå‰æ ‘çš„å‰åºéå†
[144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

é€’å½’ï¼š
```
public List<Integer> preorderTraversal(TreeNode root) {
	List<Integer> res = new ArrayList<Integer>();
	preorderTraversalRecursive(root, res);
	return res;
}

public void preorderTraversalRecursive(TreeNode root, List<Integer> res) {
	if (root == null) return;

	res.add(root.val);
	preorderTraversalRecursive(root.left, res);
	preorderTraversalRecursive(root.right, res);
}
```

è¿­ä»£ï¼š
```
public List<Integer> preorderTraversalIterative(TreeNode root) {
	List<Integer> res = new ArrayList<Integer>();
	if (root == null) return res;

	Deque<TreeNode> stack = new LinkedList<>();
	TreeNode node = root;
	while (!stack.isEmpty() || node != null) {
		while (node != null) {
			res.add(node.val);
			stack.push(node);
			node = node.left;
		}
		node = stack.pop();
		node = node.right;
	}
	return res;
}
```

## äºŒå‰æ ‘çš„ä¸­åºéå†
[94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

é€’å½’ï¼š
```
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    inorderTraversalRecursive(root, res);
    return res;
}

public void inorderTraversalRecursive(TreeNode root, List<Integer> res) {
	if (root == null) return;
	
	inorderTraversalRecursive(root.left, res);
	res.add(root.val);
	inorderTraversalRecursive(root.right, res);
}
```

è¿­ä»£ï¼š
```
public List<Integer> inorderTraversalIterative(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode node = root;
    while (!stack.isEmpty() || node != null) {
    	while (node != null) {
        	stack.push(node);
			node = node.left;
		}
    	node = stack.pop();
    	res.add(node.val);
    	node = node.right;
	}
    return res;
}
```

## äºŒå‰æ ‘çš„ååºéå†
[45. äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
é€’å½’ï¼š
```
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    postorderTraversalRecursive(root, res);
	return res; 
}

public void postorderTraversalRecursive(TreeNode root, List<Integer> res) {
    if (root == null) return;
    
	postorderTraversalRecursive(root.left, res);
	postorderTraversalRecursive(root.right, res);
	res.add(root.val);
}
```

è¿­ä»£ï¼š
```
public List<Integer> postorderTraversalIterative(TreeNode root) {
	List<Integer> res = new ArrayList<Integer>();
    if (root == null) return null;
    
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode node = root;
    TreeNode prev = null;
    while (!stack.isEmpty() || node != null) {
    	while (node != null) {
        	stack.push(node);
			node = node.left;
		}
    	node = stack.pop();
    	if (node.right == null || node.right == prev) {
			res.add(node.val);
			prev = node;
			node = null;
		} else {
			stack.push(node);
			node = node.right;
		}
	}
    
    return res;
}
```

## äºŒå‰æ ‘çš„å±‚åºéå†
[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
è¿­ä»£ï¼š
```
public List<List<Integer>> levelOrder(TreeNode root) {
	List<List<Integer>> res = new ArrayList<>();
	if (root == null) return res;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.add(root);
	int levelSize = 1;
	List<Integer> list = new ArrayList<Integer>();
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		levelSize--;
		list.add(node.val);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		
		if (node.right != null) {
			queue.add(node.right);
		}
		
		if (levelSize == 0) {
			res.add(list);
			levelSize = queue.size();
			list = new ArrayList<Integer>();
		}
	}
	return res;
}
```

## äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
é€’å½’ï¼š
```
/*
 * é€’å½’
 */
public int maxDepth(TreeNode root) {
	if (root == null) return 0;
	return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

è¿­ä»£ï¼š
```
lic int maxDepth(TreeNode root) {
	int height = 0;
	if (root == null) return height;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.add(root);
	int levelSize = 1;
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		levelSize--;
			
		if (node.left != null) {
			queue.add(node.left);
		}
			
		if (node.right != null) {
			queue.add(node.right);
		}
			
		if (levelSize == 0) {
			levelSize = queue.size();
			height++;
		}
	}
	
	return height;
}
```

## äºŒå‰æ ‘çš„å±‚æ¬¡éå† II
[107. äºŒå‰æ ‘çš„å±‚æ¬¡éå† II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
```
public List<List<Integer>> levelOrderBottom(TreeNode root) {
	List<List<Integer>> res = new ArrayList<>();
	if (root == null) return res;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	int levelSize = 1;
	List<Integer> list = new ArrayList<>();
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		levelSize--;
		list.add(node.val);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		
		if (node.right != null) {
			queue.add(node.right);
		}
		
		if (levelSize == 0) {
			levelSize = queue.size();
			res.add(0, list);
			list = new ArrayList<>();
		}
	}
	
	return res;
}
```

## äºŒå‰æ ‘æœ€å¤§å®½åº¦
[662. äºŒå‰æ ‘æœ€å¤§å®½åº¦](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)
```
public class _662_äºŒå‰æ ‘æœ€å¤§å®½åº¦ {
    public int widthOfBinaryTree(TreeNode root) {
    	if (root == null) return 0;
    	
    	Node node = new Node(root, 0, 0);
    	Queue<Node> queue = new LinkedList<>();
    	queue.offer(node);
    	int curDepth = 0, left = 0, ans = 0;
    	while (!queue.isEmpty()) {
    		node = queue.poll();
    		
    		if (node.treeNode != null) {
				queue.offer(new Node(node.treeNode.left, node.depth + 1, node.pos * 2));
				queue.offer(new Node(node.treeNode.right, node.depth + 1, node.pos * 2 + 1));
				
				//æ¯å¼€å§‹éå†æ–°çš„ä¸€å±‚ï¼Œè®°å½•æœ€å·¦è¾¹çš„pos
				if (curDepth != node.depth) {
					curDepth = node.depth;
					left = node.pos;
				}
				
				ans = Math.max(ans, node.pos - left + 1);
			}
    	}

    	return ans;
    }
}

//å› ä¸ºå·¦å³å­æ ‘å­˜åœ¨nullçš„æƒ…å†µï¼Œæ‰€ä»¥åˆ›å»ºæ–°çš„NodeåŒ…è£…TreeNodeï¼Œè¿™æ ·å°±å¯ä»¥å­˜å‚¨TreeNode==nullæƒ…å†µ
class Node {
	TreeNode treeNode;
	int depth, pos;
	public Node(TreeNode treeNode, int depth, int pos) {
		this.treeNode = treeNode;
		this.depth = depth;
		this.pos = pos;
	}
}
```

## Nå‰æ ‘çš„å‰åºéå†
[589. Nå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)
```
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

/*
 * é€’å½’
 */
public List<Integer> preorder(Node root) {
    List<Integer> res = new LinkedList<>();
	preorderTraversal(root, res);
	return res;
}

public void preorderTraversal(Node root, List<Integer> res) {
	if (root == null) return;
	
	res.add(root.val);
	if (root.children != null) {
		for (Node c : root.children) {
			preorderTraversal(c, res);
		}
	}
	return;
}

/*
 * è¿­ä»£
 */
public List<Integer> preorderIterative(Node root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) return res;
    
    Deque<Node> stack = new LinkedList<>();
    stack.push(root);
    while (!stack.isEmpty()) {
    	Node node = stack.pop();
    	res.add(node.val);
    	//åè½¬ä¸€ä¸ª Listï¼ˆ[v1, v2, v3] -> [v3, v2, v1]ï¼‰
    	Collections.reverse(node.children);
    	for (Node c : node.children) {
			stack.push(c);
		}
	}
	return res;
}
```

## Nå‰æ ‘çš„ååºéå†
[590. Nå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)
```
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

/*
 * é€’å½’
 */
public List<Integer> postorder(Node root) {
	List<Integer> res = new LinkedList<>();
	postorderTraversal(root, res);
    return res;
}

public void postorderTraversal(Node root, List<Integer> res) {
	if (root == null) return;
	
	if (root.children != null) {
		for (Node c : root.children) {
			postorderTraversal(c, res);
		}
	}
	
	res.add(root.val);
    return;
}

/*
 * è¿­ä»£
 */
public List<Integer> postorderIterative(Node root) {
	List<Integer> res = new LinkedList<>();
	if (root == null) return res;
	
	Deque<Node> stack = new LinkedList<>();
	stack.push(root);
	while (!stack.isEmpty()) {
		Node node = stack.poll();
		res.add(0, node.val);
		for (Node c : node.children) {
			stack.push(c);
		}
	}
	
    return res;
}
```

## Nå‰æ ‘çš„æœ€å¤§æ·±åº¦
[559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)
```
/*
 * é€’å½’
 */
public int maxDepth(Node root) {
	if (root == null) return 0;
	
	int result = 1;
	for (Node c : root.children) {
		result = Math.max(result, 1 + maxDepth(c));
	}
	return result;
}

/*
 * è¿­ä»£
 */
public int maxDepthIterative(Node root) {
	int height = 0;
	if (root == null) return height;
    
	Queue<Node> queue = new LinkedList<>();
	queue.offer(root);
	int levelSize = 1;
	while (!queue.isEmpty()) {
		Node node = queue.poll();
		levelSize--;
		if (node.children != null) {
			for (Node c : node.children) {
				queue.offer(c);
			}
		}
		if (levelSize == 0) {
			levelSize = queue.size();
			height++;
		}
	}
	return height;
}
```

## äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨
[114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
```
/*
 * æ–¹æ³•ä¸€ï¼šå‰åºéå†-é€’å½’
 */
public void flatten(TreeNode root) {
    List<TreeNode> list = new LinkedList<>();
    preorderTraversal(root, list);
    for (int i = 1; i < list.size(); i++) {
		TreeNode node1 = list.get(i-1);
		TreeNode node2 = list.get(i);
		node1.right = node2;
		node1.left = null;
	}
}

public void preorderTraversal(TreeNode root, List<TreeNode> list) {
    if (root == null) return;
    
    list.add(root);
    preorderTraversal(root.left, list);
    preorderTraversal(root.right, list);
}

/*
 * æ–¹æ³•ä¸€ï¼šå‰åºéå†-è¿­ä»£
 */
public void flattenIterative(TreeNode root) {
    
	List<TreeNode> list = new LinkedList<>();
	
	Deque<TreeNode> stack = new LinkedList<>();
	TreeNode node = root;
	while (!stack.isEmpty() || node != null) {
		while (node != null) {
			list.add(node);
			stack.push(node);
			node = node.left;
		}
		node = stack.poll();
		node = node.right;
	}
	for (int i = 1; i < list.size(); i++) {
		TreeNode node1 = list.get(i - 1);
		TreeNode node2 = list.get(i);
		node1.right = node2;
		node1.left = null;
	}
}
/*
 * æ–¹æ³•ä¸€ï¼šå‰åºéå†-è¿­ä»£2
 */
public void flattenIterative2(TreeNode root) {
    if (root == null) return;
	List<TreeNode> list = new LinkedList<>();
	
	Deque<TreeNode> stack = new LinkedList<>();
	stack.push(root);
	while (!stack.isEmpty()) {
		TreeNode node = stack.poll();
		list.add(node);
		
		if (node.right != null) {
			stack.push(node.right);
		}
		
		if (node.left != null) {
			stack.push(node.left);
		}
	}
	for (int i = 1; i < list.size(); i++) {
		TreeNode node1 = list.get(i - 1);
		TreeNode node2 = list.get(i);
		node1.right = node2;
		node1.left = null;
	}
}

/*
 * æ–¹æ³•äºŒï¼šå‰åºéå†å’Œå±•å¼€åŒæ­¥è¿›è¡Œ
 */
public void flattenIterative3(TreeNode root) {
	if (root == null) return;
	
	//å‰åºéå†
	Deque<TreeNode> stack = new LinkedList<>();
	stack.push(root);
	TreeNode prev = null;
	while (!stack.isEmpty()) {
		TreeNode curr = stack.poll();
		if (curr.right != null) {
			stack.push(curr.right);
		}
		if (curr.left != null) {
			stack.push(curr.left);
		}
		
		//å±•å¼€
		if (prev != null) {
			prev.right = curr;
			prev.left = null;	
		}
		prev = curr;
	}
}

/*
 * æ–¹æ³•ä¸‰ï¼šå¯»æ‰¾å‰é©±èŠ‚ç‚¹
 */
public void flattenIteraltive4(TreeNode root) {
	if (root == null) return;
	
	TreeNode curr = root;
	while (curr != null) {
		if (curr.left != null) {
			TreeNode next = curr.left;
			
			//å¯»æ‰¾å‰é©±èŠ‚ç‚¹
			TreeNode predecessor = curr.left;
			while (predecessor.right != null) {
				predecessor = predecessor.right;
			}
			
			//å±•å¼€
			predecessor.right = curr.right;
			curr.right = next;
			curr.left = null;
		}
		curr = curr.right; //next
	}
}
```

## ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```
/*
 * æ–¹æ³•ä¸€ï¼šé€’å½’
 */
int post_idx;
int[] inorder;
int[] postorder;
Map<Integer, Integer> idx_map = new HashMap<Integer, Integer>();

public TreeNode helper(int in_left, int in_right) {
	//æ²¡æœ‰èŠ‚ç‚¹
	if (in_left > in_right) return null;
	
	//ååºéå†ç»“æœä¸­ post_idx å¤„çš„èŠ‚ç‚¹ä½œä¸ºå½“å‰å­æ ‘çš„æ ¹èŠ‚ç‚¹
	int root_val = postorder[post_idx];
	TreeNode root = new TreeNode(root_val);
	
	//æ ¹æ® root æ‰€åœ¨ä½ç½®åˆ†æˆå·¦å³å­æ ‘
	int index = idx_map.get(root_val);
	
	//ä¸‹æ ‡å‡1ï¼ˆé€’å½’æ„å»ºå®Œå³å­æ ‘åï¼Œpost_idx-- < indexï¼‰
	post_idx--;
	
	//é€’å½’-æ„å»ºå³å­æ ‘
	root.right = helper(index + 1, in_right);
	
	//é€’å½’-æ„å»ºå·¦å­æ ‘
	root.left = helper(in_left, index - 1);
	
	return root;
}

public TreeNode buildTree(int[] inorder, int[] postorder) {
	this.inorder = inorder;
	this.postorder = postorder;
	
	post_idx = postorder.length - 1;
	
	int idx = 0;
	for (int val : inorder) {
		idx_map.put(val, idx++);
	}

	return helper(0, post_idx);
}

/*
 * æ–¹æ³•äºŒï¼šè¿­ä»£
 * 
 * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]
 * postorder = [15, 10, 9, 5, 4, 8, 7, 20, 3]
 */
public TreeNode buildTree2(int[] inorder, int[] postorder) {
	if (postorder == null || postorder.length == 0) {
		return null;
	}
	
	//ååºéå†çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯ root èŠ‚ç‚¹
	//è¿™äº›èŠ‚ç‚¹çš„é¡ºåºå’Œå®ƒä»¬åœ¨åå‘ä¸­åºéå†ï¼ˆåå‘éå†inorderï¼‰ä¸­å‡ºç°çš„é¡ºåºä¸€å®šæ˜¯ç›¸åçš„
	TreeNode root = new TreeNode(postorder[postorder.length - 1]);
	//ä½¿ç”¨æ ˆå­˜æ”¾ååºéå†ä¸­çš„èŠ‚ç‚¹
	Deque<TreeNode> stack = new LinkedList<>();
	stack.push(root);
	
	//ç”¨æ¥è®°å½•å­æ ‘é‡Œæœ€å³è¾¹çš„èŠ‚ç‚¹
	int inorderIndex = inorder.length - 1;
	//ä»ååºéå†çš„å€’æ•°ç¬¬äºŒä¸ªå‡ ç‚¹å¼€å§‹ï¼Œåå‘éå† postorder
	for (int i = postorder.length - 2; i >= 0; i--) {
		int postorderVal = postorder[i];
		//æ ˆé¡¶èŠ‚ç‚¹
		TreeNode node = stack.peek();
		if (node.val != inorder[inorderIndex]) {
			//node ä¸æ˜¯æœ€å³è¾¹çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ postorderVal æ˜¯ node çš„å³èŠ‚ç‚¹
			node.right = new TreeNode(postorderVal);
			stack.push(node.right);
		} else {
			//node æ˜¯æœ€å³è¾¹çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ postorderVal æ˜¯ node çš„å·¦èŠ‚ç‚¹
			//æ ˆé‡Œçš„è¿™äº›èŠ‚ç‚¹ï¼ˆå³èŠ‚ç‚¹ï¼‰çš„é¡ºåºå’Œå®ƒä»¬åœ¨åå‘ä¸­åºéå†ä¸­å‡ºç°çš„é¡ºåºä¸€å®šæ˜¯ç›¸åçš„
			while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
				node = stack.pop();
				inorderIndex--; //åå‘éå† inorder
			}
			//å› ä¸º postorderVal å‡ºç°åœ¨äº† node ä¸ node åœ¨æ ˆä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åå‘ä¸­åºéå†ä¹‹é—´ï¼Œå› æ­¤ postorderVal å°±æ˜¯ node çš„å·¦å„¿å­ã€‚
			node.left = new TreeNode(postorderVal);
			stack.push(node.left);
		}
	}
	
	return root;
}
```

## ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
![äºŒå‰æœç´¢æ ‘23](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘23.png)
```
/*
 * æ–¹æ³•ä¸€ï¼šé€’å½’
 * 
 * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]
 * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]
 */
int preorderIndex;
int[] preorder;
int[] inorder;
Map<Integer, Integer> idx_map = new HashMap<Integer, Integer>();
public TreeNode helper(int in_left, int in_right) {
	
	if (in_left > in_right) {
		return null;
	}
	
	TreeNode root = new TreeNode(preorder[preorderIndex]);
	int index = idx_map.get(root.val);
	
	preorderIndex++;
	
	//éå†åˆ›å»ºå·¦å­èŠ‚ç‚¹
	root.left = helper(in_left, index - 1);
	//éå†åˆ›å»ºå³å­èŠ‚ç‚¹
	root.right = helper(index + 1, in_right);
	
	return root;
}

public TreeNode buildTree(int[] preorder, int[] inorder) {
	this.preorder = preorder;
	this.inorder = inorder;
	
	for (int i = 0; i < inorder.length; i++) {
		idx_map.put(inorder[i], i);
	}
	
	return helper(0, preorder.length);
}

/*
 * æ–¹æ³•äºŒï¼šè¿­ä»£
 * 
 * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]
 * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]
 */
public TreeNode buildTree2(int[] preorder, int[] inorder) {
	if (preorder == null || preorder.length == 0) {
		return null;
	}
	//å‰åºéå†çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯rootèŠ‚ç‚¹
	TreeNode root = new TreeNode(preorder[0]);
	//ä¸­åºéå†çš„ç´¢å¼•
	int inorderIndex = 0;

	Deque<TreeNode> stack = new LinkedList<>();
	stack.push(root);
	
	//æ­£åºéå† preorder
	for (int i = 1; i < preorder.length; i++) {
		int preorderVal = preorder[i];
		TreeNode node = stack.peek();
		if (node.val != inorder[inorderIndex]) {
			// node ä¸æ˜¯æœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ postorderVal æ˜¯ node çš„å·¦èŠ‚ç‚¹
			node.left = new TreeNode(preorderVal);
			stack.push(node.left);
		} else {
			// node æ˜¯æœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ postorderVal æ˜¯ node çš„å³èŠ‚ç‚¹
			while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
				node = stack.pop();
				inorderIndex++;
			}
			node.right = new TreeNode(preorderVal);
			stack.push(node.right);
		}
	}
	
	return root;
}
```

## æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘
[889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
```
/*
 * æ–¹æ³•ä¸€ï¼šé€’å½’
 */
public TreeNode constructFromPrePost(int[] pre, int[] post) {
	int N = pre.length;
	if (N == 0) {
		return null;
	}
	TreeNode root = new TreeNode(pre[0]);
	if (N == 1) {
		return root;
	}
	
	//ä»¤å·¦åˆ†æ”¯æœ‰ L ä¸ªèŠ‚ç‚¹
	int L = 0;
	for (int i = 0; i < N; i++) {
		if (post[i] == pre[1]) {
			L = i + 1; //L = post.indexOf(pre[1]) + 1
		}
	}
	
	//copyOfRange(int[] original, int from, int to)ï¼šåŒ…æ‹¬ä¸‹æ ‡fromï¼Œä¸åŒ…æ‹¬ä¸Šæ ‡to
	//å·¦åˆ†æ”¯ç”± pre[1 : L+1] å’Œ post[0 : L] é‡æ–°åˆ†æ”¯
	root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1,	L + 1), Arrays.copyOfRange(post, 0, L));
	//å³åˆ†æ”¯å°†ç”± pre[L+1 : N] å’Œ post[L : N-1] é‡æ–°åˆ†æ”¯
	root.right = constructFromPrePost(Arrays.copyOfRange(pre, L + 1, N), Arrays.copyOfRange(post, L, N - 1));
	
	return root;
}
```

## å¯¹ç§°äºŒå‰æ ‘
[101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)
```
/*
 * æ–¹æ³•ä¸€ï¼šé€’å½’
 */
public boolean isSymmetric(TreeNode root) {
	return check(root, root);
}

public boolean check(TreeNode p, TreeNode q) {
	
	if (p == null && q == null) return true;
	
	if (p == null || q == null) return false;
	
	return (p.val == q.val && check(p.left, q.right) && check(p.right, q.left));
}

/*
 * æ–¹æ³•äºŒï¼šè¿­ä»£
 */
public boolean isSymmetric2(TreeNode root) {
	Queue<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		TreeNode p = queue.poll();
		TreeNode q = queue.poll();
		if (p == null && q == null) {
			continue;
		}
		
		if (p == null || q == null || p.val != q.val) {
			return false;
		}
		
		queue.offer(p.left);
		queue.offer(q.right);
		
		queue.offer(p.right);
		queue.offer(q.left);
	}
	
	return true;
}
```

# ç»ƒä¹  â…¢
## åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹
[450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
```
public int successor(TreeNode root) {
	root = root.right;
	while (root.left != null) {
		root = root.left;
	}
	return root.val;
}

public int predecessor(TreeNode root) {
	root = root.left;
	while (root.right != null) {
		root = root.right;
	}
	return root.val;
}

public TreeNode deleteNode(TreeNode root, int key) {
	if (root == null) return null;
	
	if (key > root.val) {
		//å‘åˆæŸ¥æ‰¾
		root.right = deleteNode(root.right, key);
	} else if (key < root.val) {
		//å‘å·¦æŸ¥æ‰¾
		root.left = deleteNode(root.left, key);
	} else {
		if (root.left == null && root.right == null) { //åˆ é™¤å¶å­èŠ‚ç‚¹
			root = null;
		} else if (root.right != null) { //åˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹
			root.val = successor(root);
			root.right = deleteNode(root.right, root.val);
		} else { //åˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹
			root.val = predecessor(root);
			root.left = deleteNode(root.left, root.val);
		}
	}
	return root;
}
```

## äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢
[700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)
```
public TreeNode searchBST(TreeNode root, int val) {
	if (root == null) return null;
	while (root != null) {
		if (val > root.val) {
			root = root.right;
		} else if (val < root.val) {
			root = root.left;
		} else {
			return root;
		}
	}
	return root;
}
```

## äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ
[701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)
```
public TreeNode insertIntoBST(TreeNode root, int val) {
	if (root == null) return new TreeNode(val);
	
	TreeNode node = root;
	TreeNode parent = root;
	int cmp = 0;
	while (node != null) {
		parent = node;
		if (val > node.val) {
			cmp = 1;
			node = node.right;
		} else {
			cmp = -1;
			node = node.left;
		}
	}
	
	if (cmp > 0) {
		parent.right = new TreeNode(val);
	} else {
		parent.left = new TreeNode(val);
	}
	
	return root;
}
```

## éªŒè¯äºŒå‰æœç´¢æ ‘
[98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)
```
/*
 * é€’å½’
 *
 * å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼›
 * å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼›
 * å®ƒçš„å·¦å³å­æ ‘ä¹Ÿä¸ºäºŒå‰æœç´¢æ ‘ã€‚
 */
public boolean isValidBST(TreeNode root) {
	return preorder(root, null, null);
}

public boolean preorder(TreeNode root, Integer lower, Integer upper) {
	if (root == null) return true;
	
	if (lower != null && lower >= root.val) return false;
	
	if (upper != null && upper <= root.val) return false;
	
	if (!preorder(root.left, lower, root.val)) return false;
	
	if (!preorder(root.right, root.val, upper)) return false;
	
	return true;
}

/*
 * è¿­ä»£
 * 
 * ã€Œä¸­åºéå†ã€å¾—åˆ°çš„å€¼æ„æˆçš„åºåˆ—ä¸€å®šæ˜¯å‡åºçš„
 */
public boolean isValidBST2(TreeNode root) {
	return inorder(root);
}

public boolean inorder(TreeNode root) {
	Deque<TreeNode> stack = new LinkedList<>();
	TreeNode node = root;
	TreeNode prev = null;
	while (!stack.isEmpty() || node != null) {
		while (node != null) {
			stack.push(node);
			node = node.left;
		}
		node = stack.pop();
		if (prev != null && prev.val >= node.val) {
			return false;
		}
		prev = node;
		node = node.right;
	}
	return true;
}
```

## äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
[530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)
```
TreeNode prev;
int ans;

public int getMinimumDifference(TreeNode root) {
	ans = Integer.MAX_VALUE;
	inorder(root);
	return ans;
}

public void inorder(TreeNode root) {
	if (root == null) return;
	
	inorder(root.left);
	
	if (prev == null) {
		prev = root;
	} else {
		int cha = root.val - prev.val;
		ans = ans > cha ? cha : ans;
		prev = root;
	}
	
	inorder(root.right);
}
```

## äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦»
[783. äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦»](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)
```
public class _783_äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦» {
	int preVal;
	int ans;
    public int minDiffInBST(TreeNode root) {
    	preVal = -1;
    	ans = Integer.MAX_VALUE;
    	inorder(root);
    	return ans;
    }
    
    public void inorder(TreeNode root) {
    	if (root == null) return;
    	
    	inorder(root.left);
    	
    	if (preVal != -1) {
    		ans = Math.min(ans, root.val - preVal);
		}
    	preVal = root.val;
    	
    	inorder(root.right);
    }
}
```

## å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
[108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
```
public TreeNode sortedArrayToBST(int[] nums) {
	return helper(nums, 0, nums.length-1);
}

public TreeNode helper(int[] nums, int left, int right) {
	if (left > right) return null;
	
	int mid = (left + right) / 2;
	
	TreeNode root = new TreeNode(nums[mid]);
	root.left = helper(nums, left, mid-1);
	root.right = helper(nums, mid+1, right);
	
	return root;
}
```

## äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ
[938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ](https://leetcode-cn.com/problems/range-sum-of-bst/)
```
int sum;

public int rangeSumBST(TreeNode root, int low, int high) {
	inorder(root, low, high);
	return sum;
}

public void inorder(TreeNode root, int low, int high) {
	if (root == null) return;
	
	rangeSumBST(root.left, low, high);

	if (root.val >= low && root.val <= high) {
		sum += root.val;
	}
	rangeSumBST(root.right, low, high);
}
```

## äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
[235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
```
/*
 * æ–¹æ³•ä¸€ï¼šä¸¤æ¬¡éå†
 */
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	List<TreeNode> path_p = path(root, p);
	List<TreeNode> path_q = path(root, q);
	
	TreeNode node = null;
	for (int i = 0; i < path_p.size() && i < path_q.size(); i++) {
		if (path_p.get(i) == path_q.get(i)) {
			node = path_p.get(i);
		}
	}
	return node;
}

public List<TreeNode> path(TreeNode root, TreeNode target) {
	List<TreeNode> path = new LinkedList<>();
	TreeNode node = root;
	while (node != target) {
		path.add(node);
		if (node.val > target.val) {
			node = node.left;
		} else if (node.val < target.val) {
			node = node.right;
		}
	}
	path.add(node);
	return path;
}

/*
 * æ–¹æ³•ä¸€ï¼šä¸€æ¬¡éå†
 */
public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {
	TreeNode node = root;
	
	while (node != null) {
		if (node.val > p.val && node.val > q.val) {
			node = node.left;
		} else if (node.val < p.val && node.val < q.val) {
			node = node.right;
		} else {
			break;
		}
	}
	
	return node;
}
```

## äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 
[230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
```
public class _230_äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´  {
	TreeNode targeTreeNode = null;
	int index = 0;
	/*
	 * è¿­ä»£
	 */
	public int kthSmallest(TreeNode root, int k) {

		if (root == null) return root.val;
		
		///é€’å½’
		//return inorder(root, k);
		
		///è¿­ä»£
		index = k;
		helper(root);
		return targeTreeNode.val;
    }
	
	public int inorder(TreeNode root, int k) {
		
		TreeNode targeTreeNode = root;
		Deque<TreeNode> stack = new LinkedList<>();
		TreeNode node = root;
		while (!stack.isEmpty() || node != null) {
			while (node != null) {
				stack.push(node);
				node = node.left;
			}
			node = stack.pop();
			k--;
			if (k == 0) {
				targeTreeNode = node;
				break;
			}
			node = node.right;
		}
		
		return targeTreeNode.val;
	}
	
	/*
	 * é€’å½’
	 */
	public void helper(TreeNode root) {
		if (root == null || targeTreeNode != null) return;
		
		helper(root.left);
		index--;
		if (index == 0 && targeTreeNode == null) {
			targeTreeNode = root;
			return;
		}
		helper(root.right);
	}
}
```

## äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨
[173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode-cn.com/problems/binary-search-tree-iterator/)
```
/*
 * è¿­ä»£
 */
class BSTIterator {
	Deque<TreeNode> stack;
	
    public BSTIterator(TreeNode root) {
    	stack = new LinkedList<>();
    	leftmostInorder(root);
    }
    
    public void leftmostInorder(TreeNode root) {
    	while (root != null) {
			stack.push(root);
			root = root.left;
		}
	}
    
    public int next() {
    	TreeNode node = stack.poll();
    	if (node.right != null) {
    		leftmostInorder(node.right);
		}
    	return node.val;
    }
    
    public boolean hasNext() {
    	return !stack.isEmpty();
    }
}
```

## æ¢å¤äºŒå‰æœç´¢æ ‘
[99. æ¢å¤äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/recover-binary-search-tree/)
```
public class _99_æ¢å¤äºŒå‰æœç´¢æ ‘ {

	/*
	 * æ–¹æ³•ä¸€ï¼šæ˜¾ç¤ºä¸­åºéå†
	 */
	public void recoverTree(TreeNode root) {
		List<Integer> res = new LinkedList<>();
		inorder(root, res);
		int[] swaped = findTwoSwaped(res);
		recover(root, 2, swaped[0], swaped[1]);
    }
	
	public void inorder(TreeNode root, List<Integer> res) {
		if (root == null) return;
		inorder(root.left, res);
		res.add(root.val);
		inorder(root.right, res);
	}
	
	public int[] findTwoSwaped(List<Integer> res) {
		int n = res.size();
		int x = -1, y = -1;
		for (int i = 0; i < n - 1; i++) {
			if (res.get(i) == res.get(i + 1)) { //æ‰¾åˆ°å¼‚å¸¸èŠ‚ç‚¹ï¼ˆå‰é¢ > åé¢ï¼‰
				y = res.get(i + 1);//å
				if (x == -1) {
					x = res.get(i);//å‰
				} else {
					break;	
				}
			}
		}
		return new int[]{x, y};
	}
	
	public void recover(TreeNode root, int count, int x, int y) {
		if (root != null) {
			if (root.val == x || root.val == y) {
				root.val = root.val == x ? y : x;
				if (--count == 0) {
					return;
				}
			}
			recover(root.left, count, x, y);
			recover(root.right, count, x, y);
		}
	}
	
	/*
	 * æ–¹æ³•äºŒï¼šéšå¼ä¸­åºéå†
	 */
	public void recoverTree1(TreeNode root) {
		Deque<TreeNode> stack = new LinkedList<>();
		TreeNode x = null, y = null, pred = null;
		while (!stack.isEmpty() || root != null) {
			while (root != null) {
				stack.push(root);
				root = root.left;
			}
			root = stack.pop();
			///ä¿å­˜ä¸¤ä¸ªè¢«äº¤æ¢çš„æ•°æ®
			if (pred != null && pred.val > root.val) { //æ‰¾åˆ°å¼‚å¸¸èŠ‚ç‚¹ï¼ˆå‰é¢ > åé¢ï¼‰
				y = root;//å
				if (x == null) {
					x = pred;//å‰
				} else {
					break;
				}
			}
			pred = root;
			root = root.right;
		}
		
        swap(x, y);
	}
	
	public void swap(TreeNode x, TreeNode y) {
		int temp = x.val;
		x.val = y.val;
		y.val = temp;
	}
	
	/*
	 * æ–¹æ³•ä¸‰ï¼šMorris ä¸­åºéå†
	 */
	public void recoverTree2(TreeNode root) {
		TreeNode x = null, y = null, pred = null;
		TreeNode cur = root;
		while (cur != null) {
			if (cur.left != null) {
				/*
				 * æ­¥éª¤1ï¼ˆå¯»æ‰¾å‰é©±èŠ‚ç‚¹ï¼‰
				 * 1>ä¸€ç›´å‘å³æ‰¾åˆ°æœ€å³ç«¯çš„èŠ‚ç‚¹å³ä¸ºå‰é©±èŠ‚ç‚¹ï¼Œåœæ­¢éå†
				 * 2>å¦‚æœæœ€å³ç«¯çš„èŠ‚ç‚¹æ˜¯ curï¼Œè¡¨ç¤ºä¸Šæ¬¡å¾ªç¯ç»å†è¿‡æ­¥éª¤2ï¼Œåœæ­¢éå†
				 */
				TreeNode precessoNode = cur.left;
				while (precessoNode.right != null && precessoNode.right != cur) {
					precessoNode = precessoNode.right;
				}
				
				if (precessoNode.right == null) {
					/*
					 * æ­¥éª¤2
					 * 1>è®©å‰é©±èŠ‚ç‚¹çš„ right æŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼ˆå®ç°æ­¥éª¤4 -> æ­¥éª¤1 -> æ­¥éª¤3ï¼‰
					 * 2>ç»§ç»­éå†å·¦å­æ ‘
					 */
					precessoNode.right = cur;
					cur = cur.left;
				} else {
					/*
					 * æ‰€æœ‰å³å­æ ‘çš„èŠ‚ç‚¹ï¼ˆåŒ…å« curï¼‰
					 */
					if (pred != null && pred.val > cur.val) { //æ‰¾åˆ°å¼‚å¸¸èŠ‚ç‚¹ï¼ˆå‰é¢ > åé¢ï¼‰
						y = cur; //å
						if (x == null) {
							x = pred; //å‰ 
						}
					}
					pred = cur;
					/* 
					 * æ­¥éª¤3ï¼ˆprecessoNode.right == curï¼Œä¸Šæ¬¡å¾ªç¯æ­¥éª¤2å¤„ç†çš„ç»“æœï¼‰
					 * 1>å»æ‰å‰é©±èŠ‚ç‚¹å’Œ cur çš„å…³è”ï¼ˆright = nullï¼‰
					 * 2>å¼€å§‹éå† cur çš„å³å­æ ‘
					 */
					precessoNode.right = null;
					cur = cur.right;
				}
			} else {
				/*
				 * æ‰€æœ‰å·¦å­æ ‘çš„èŠ‚ç‚¹
				 */
				if (pred != null && pred.val > cur.val) { //æ‰¾åˆ°å¼‚å¸¸èŠ‚ç‚¹ï¼ˆå‰é¢ > åé¢ï¼‰
					y = cur; //å
					if (x == null) {
						x = pred; //å‰ 
					}
				}
				pred = cur;
				/*
				 * æ­¥éª¤4éå†å³å­æ ‘
				 * ç¬¬ä¸€ç§æƒ…å†µï¼šéå†å³å­æ ‘
				 * ç¬¬äºŒç§æƒ…å†µï¼šå›åˆ°çˆ¶èŠ‚ç‚¹ï¼Œå»æ­¥éª¤3ï¼ˆå‘¼åº”æ­¥éª¤2ï¼‰
				 */
				cur = cur.right;
			}
		}
		
		swap(x, y);
	}	
}
```

psï¼š  
äºŒå‰æ ‘ç»˜å›¾ç½‘ç«™  
[520it](http://520it.com/binarytrees/)  
[Binary Tree Visualiser](http://btv.melezinek.cz/binary-search-tree.html)  
[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  
[B-Tree](https://yangez.github.io/btree-js/)
