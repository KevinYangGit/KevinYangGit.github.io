---
title: äºŒå‰æœç´¢æ ‘
date: 2020-11-18 14:29:12
tags: æ•°æ®ç»“æ„ä¸ç®—æ³•
---

[äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)ä½œä¸ºä¸€ç§ç»å…¸çš„æ•°æ®ç»“æ„ï¼Œå®ƒæ—¢æœ‰é“¾è¡¨çš„å¿«é€Ÿæ’å…¥ä¸åˆ é™¤æ“ä½œçš„ç‰¹ç‚¹ï¼Œåˆæœ‰æ•°ç»„å¿«é€ŸæŸ¥æ‰¾çš„ä¼˜åŠ¿ï¼›æ‰€ä»¥åº”ç”¨ååˆ†å¹¿æ³›ï¼Œä¾‹å¦‚åœ¨æ–‡ä»¶ç³»ç»Ÿå’Œæ•°æ®åº“ç³»ç»Ÿä¸€èˆ¬ä¼šé‡‡ç”¨è¿™ç§æ•°æ®ç»“æ„è¿›è¡Œé«˜æ•ˆç‡çš„æ’åºä¸æ£€ç´¢æ“ä½œã€‚

<!-- more -->

# äºŒå‰æœç´¢æ ‘

## æ€è€ƒï¼šåœ¨ n ä¸ªåŠ¨æ€çš„æ•´æ•°ä¸­æœç´¢æŸä¸ªæ•´æ•°ï¼ˆæŸ¥çœ‹å…¶æ˜¯å¦å­˜åœ¨ï¼‰ï¼Ÿ

1. ä½¿ç”¨åŠ¨æ€æ•°ç»„ï¼Œä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹éå†æœç´¢ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼›  
![äºŒå‰æœç´¢æ ‘01](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘01.png)
2. ä½¿ç”¨æœ‰åºçš„åŠ¨æ€æ•°ç»„ï¼Œä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œæœ€åæ—¶é—´è´Ÿè½½åº¦ï¼šO(log(n))ï¼Œä½†æ˜¯æ·»åŠ å’Œåˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ï¼šO(n)ï¼›  
![äºŒå‰æœç´¢æ ‘02](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘02.png)
3. ä½¿ç”¨äºŒå‰æœç´¢æ ‘ï¼Œæ·»åŠ ã€åˆ é™¤å’Œæœç´¢çš„æœ€åæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ï¼šO(log(n));

## äºŒå‰æœç´¢æ ‘ç‰¹æ€§
äºŒå‰æœç´¢æ ‘æ˜¯äºŒå‰æ ‘çš„ä¸€ç§ï¼Œæ˜¯åº”ç”¨éå¸¸å¹¿æ³›çš„ä¸€ç§äºŒå‰æ ‘ï¼Œè‹±æ–‡ç®€ç§°ä¸º BSTã€‚åˆè¢«ç§°ä¸ºï¼šäºŒå‰æŸ¥æ‰¾æ ‘ã€äºŒå‰æ’åºæ ‘ã€‚äºŒå‰æœç´¢æ ‘å¯ä»¥å¤§å¤§æé«˜æœç´¢æ•°æ®çš„æ•ˆç‡ã€‚  
1. è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡<u>å°äº</u>å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›  
2. è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡<u>å¤§äº</u>å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›  
3. å®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸º<u>äºŒå‰æœç´¢æ ‘</u>ã€‚

![äºŒå‰æœç´¢æ ‘03](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘03.png)
ä½¿ç”¨äºŒå‰æœç´¢æ ‘éœ€è¦æ³¨æ„ï¼š  
1. å­˜å‚¨çš„å…ƒç´ å¿…é¡»å…·å¤‡æ¯”è¾ƒæ€§ï¼Œæ¯”å¦‚ `int`ã€`double` ç­‰ã€‚
2. å¦‚æœæ˜¯è‡ªå®šä¹‰ç±»å‹ï¼Œéœ€è¦æŒ‡å®šæ¯”è¾ƒæ–¹å¼ã€‚
3. å­˜å‚¨çš„å…ƒç´ ä¸å¯ä»¥æ˜¯ `null`ã€‚

# æ¥å£è®¾è®¡
```
/*
 * å…ƒç´ çš„æ•°é‡
 */
public int size() {}
/*
 * æ˜¯å¦ä¸ºç©º
 */
public boolean isEmpty() {}
/*
 * æ¸…ç©ºæ‰€æœ‰å…ƒç´ 
 */
public void clear() {}
/*
 * æ·»åŠ å…ƒç´ 
 */
public void add(E element) {}
/*
 * åˆ é™¤å…ƒç´ 
 */
public void remove(E element) {}
/*
 * æ˜¯å¦åŒ…å«æŸå…ƒç´ 
 */
public void contains(E element) {}
```

## æ·»åŠ èŠ‚ç‚¹
1. æ‰¾åˆ°è¦æ·»åŠ åˆ°çš„ä½ç½®ï¼Œå³æ‰¾åˆ°è¯¥ä½ç½®çš„çˆ¶èŠ‚ç‚¹ `parent`ï¼›  
2. åˆ›å»ºæ–°èŠ‚ç‚¹ `node`ï¼›  
3. åŠ å…¥åˆ°æ ‘ä¸­ï¼š`parent.left = node` æˆ–è€… `parent.right = node`ã€‚

æ³¨æ„ï¼šé‡åˆ°å€¼ç›¸ç­‰çš„å…ƒç´ å¯ä»¥è¦†ç›–æ—§å€¼ã€‚

å¦‚æ·»åŠ  `12`ã€`1`ï¼Œå…ˆæ‰¾åˆ°çˆ¶èŠ‚ç‚¹ `11`ã€`2`ï¼š
![äºŒå‰æœç´¢æ ‘04](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘04.png)
åˆ›å»ºæ–°èŠ‚ç‚¹ `node`ï¼ŒåŠ å…¥åˆ°æ ‘ä¸­ï¼š
![äºŒå‰æœç´¢æ ‘05](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘05.png)

ä»£ç å®ç°ï¼š
```
public void add(E element) {
	if (root == null) {
		root = new Node<>(element, null);
		return;
	}
	
	Node<E> node = root;
	Node<E> parent = root;
	int cmp = 0;
	while (node != null) {
		parent = node;
		cmp = compare(element, node.element); // è¿”å›å€¼ç­‰äº0ï¼še1 == e2ï¼Œå¤§äº0ï¼še1 > e2ï¼Œå°äº0ï¼še1 < e2

		if (cmp > 0) {
			node = node.right;
		} else if (cmp < 0) {
			node = node.left;
		} else {
			node.element = element; // è€ƒè™‘åˆ°ä¸åŒåå­—çš„ personï¼Œç›¸ç­‰å°±è¦†ç›–
			return;
		}
	}
	
	Node<E> newNode = new Node<>(element, parent);
	if (cmp > 0) {
		parent.right = newNode;
	} else {
		parent.left = newNode;
	}
	
	size++;
}
```

## å…ƒç´ çš„æ¯”è¾ƒæ–¹æ¡ˆè®¾è®¡
### æ–¹æ¡ˆä¸€
å¼ºåˆ¶å…ƒç´ å®ç° `Comparable` æ¥å£ï¼š
```
public class BinarySearchTree<E extends Comparable> {
    ...
}
```

æ·»åŠ  `extends Comparable` åï¼Œè¦åŠ å…¥åˆ°äºŒå‰æœç´¢æ ‘çš„å…ƒç´ éƒ½å¿…é¡»å®ç° `Comparable` æ¥å£ã€‚

å®šä¹‰ Person å®ç° `Comparable` æ¥å£ï¼š
```
public class Person implements Comparable<Person> {
	private int age;
	
	// ç”Ÿæˆ age çš„ getã€set æ–¹æ³•
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public int compareTo(Person e) {
		return age - e.age;
	}
	
	@Override
	public String toString() {
		return age + "";
	}
}
```

### æ–¹æ¡ˆäºŒ
1. å…è®¸å¤–ç•Œä¼ å…¥ä¸€ä¸ª `Comparator` è‡ªå®šä¹‰æ¯”è¾ƒæ–¹æ¡ˆï¼›
2. å¦‚æœæ²¡æœ‰ä¼ å…¥ `Comparator`ï¼Œå¼ºåˆ¶è®¤å®šå…ƒç´ å®ç°äº† `Comparable` æ¥å£ã€‚
```
public class BinarySearchTree<E> {

	private Comparator<E> comparator;

	public BinarySearchTree() {
		this(null);
	}
	
	public BinarySearchTree(Comparator<E> comparator) {
		this.comparator = comparator;
	}
    
	private int compare(E e1, E e2) {
		if (comparator != null) {
			return comparator.compare(e1, e2);
		}
		return ((Comparable<E>)e1).compareTo(e2);
	}
}
```

## æ‰“å°å™¨
ä½¿ç”¨ [BinaryTrees](https://github.com/CoderMJLee/BinaryTrees) æ‰“å°äºŒå‰æœç´¢æ ‘ã€‚

1ã€å®ç° `BinaryTreeInfo` æ¥å£
```
public class BinarySearchTree<E> implements BinaryTreeInfo {
	...

	@Override
	public Object root() {
		return root;
	}

	@Override
	public Object left(Object node) {
		return ((Node<E>)node).left;
	}

	@Override
	public Object right(Object node) {
		return ((Node<E>)node).right;
	}

	@Override
	public Object string(Object node) {
		return ((Node<E>)node).element;
	}
}
```

2ã€è°ƒç”¨æ‰“å°API `BinaryTrees.println(bst)`ï¼š
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);;
}
```

### Comparable
```
static void test() {
	Integer data[] = new Integer[] {
			7, 4, 9, 2, 5, 8, 11, 3, 12, 1
	};
	
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
}
```

æ‰“å°ç»“æœï¼š
```
    â”Œâ”€â”€7â”€â”€â”
    â”‚     â”‚
  â”Œâ”€4â”€â” â”Œâ”€9â”€â”
  â”‚   â”‚ â”‚   â”‚
â”Œâ”€2â”€â” 5 8   11â”€â”
â”‚   â”‚          â”‚
1   3          12
```

### Comparator
```
public class Main {
	public static void main(String[] args) {
		Integer data[] = new Integer[] {
				7, 4, 9, 2, 5, 8, 11, 3, 12, 1
		};
		
		BinarySearchTree<Person> bst = new BinarySearchTree<>(new Comparator<Person>() {
			public int compare(Person o1, Person o2) {
				return o1.getAge() - o2.getAge();
			}
		});

		for (int i = 0; i < data.length; i++) {
			bst.add(new Person(data[i]));
		}
		
		BinaryTrees.println(bst);;
	}
}
```

ä¿®æ”¹ `BinarySearchTree` çš„ `string` æ–¹æ³•ï¼ŒæŸ¥çœ‹æ›´è¯¦ç»†çš„æ‰“å°ä¿¡æ¯ï¼š
```
public Object string(Object node) {
	Node<E> myNode = (Node<E>)node;
	String parentString = "null";
	if (myNode.parent != null) {
		parentString = myNode.parent.element.toString();
	}
	return myNode.element + "_p(" + parentString + ")";
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9)   11_p(9)â”€â”
   â”‚        â”‚                          â”‚
1_p(2)    3_p(2)                    12_p(11)
```

psï¼š  
1. äºŒå‰æ ‘ç»˜å›¾ç½‘ç«™  
[520it](http://520it.com/binarytrees/)  
[Binary Tree Visualiser](http://btv.melezinek.cz/binary-search-tree.html)  
[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  
[B-Tree](https://yangez.github.io/btree-js/)

2. å›½å¤–æ•™æçš„è¯´æ³•  
Full Binary Treeï¼šå®Œæ»¡äºŒå‰æ ‘ï¼ˆçœŸäºŒå‰æ ‘ï¼‰ï¼›  
Perfect Binary Treeï¼šå®Œç¾äºŒå‰æ ‘ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰ï¼›  
Complete Binary Treeï¼šå®Œå…¨äºŒå‰æ ‘ï¼›

# éå†
éå†æ˜¯æ•°æ®ç»“æ„ä¸­çš„å¸¸è§æ“ä½œï¼Œçº¿æ€§æ•°æ®ç»“æ„ï¼ˆå¦‚ï¼šæ•°ç»„ï¼‰çš„éå†æ¯”è¾ƒç®€å•ï¼Œæœ‰ä¸¤ç§ï¼šæ­£åºéå†å’Œé€†åºéå†ã€‚äºŒå‰æ ‘çš„éå†æ–¹å¼æœ‰å››ç§ï¼š  
1. å‰åºéå†ï¼ˆPreorder Traversalï¼‰
2. ä¸­åºéå†ï¼ˆInorder Traversalï¼‰
3. ååºéå†ï¼ˆPostorder Traversalï¼‰
4. å±‚åºéå†ï¼ˆLevel Order Traversalï¼‰

## å‰åºéå†
è®¿é—®é¡ºåºï¼š
1. æ ¹èŠ‚ç‚¹ï¼›
2. å‰åºéå†å·¦å­æ ‘ï¼›
3. å‰åºéå†å³å­æ ‘ã€‚
![äºŒå‰æœç´¢æ ‘06](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘06.png)

### é€’å½’
<font color=#FF0000>7ã€</font><font color=#00BFF>4ã€2ã€1ã€3ã€5ã€</font><font color=#F0E68C>9ã€8ã€11ã€10ã€12</font>
![äºŒå‰æœç´¢æ ‘10](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘10.png)

ä»£ç å®ç°ï¼š
```
public void preorderTraversal() {
	preorderTraversal(root);
}

private void preorderTraversal(Node<E> node) {
	if (node == null) return;
	
	System.out.println(node.element);
	preorderTraversal(node.left);
	preorderTraversal(node.right);
}
```

### éé€’å½’

## ä¸­åºéå†
è®¿é—®é¡ºåºï¼ˆå‡åºï¼‰ï¼š
1. ä¸­åºéå†å·¦å­æ ‘ï¼›
2. æ ¹èŠ‚ç‚¹ï¼›
3. ä¸­åºéå†å³å­æ ‘ã€‚  
![äºŒå‰æœç´¢æ ‘07](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘07.png) 

è®¿é—®é¡ºåºï¼ˆé™åºï¼‰ï¼š
1. ä¸­åºéå†å³å­æ ‘ï¼›
2. æ ¹èŠ‚ç‚¹ï¼›
3. ä¸­åºéå†å·¦å­æ ‘ã€‚
![äºŒå‰æœç´¢æ ‘08](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘08.png)

### é€’å½’
<font color=#00BFF>1ã€2ã€3ã€4ã€5ã€</font><font color=#FF0000>7ã€</font><font color=#F0E68C>8ã€9ã€10ã€11ã€12</font>ï¼ˆå‡åºï¼‰
![äºŒå‰æœç´¢æ ‘11](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘11.png)

ä»£ç å®ç°ï¼š
```
public void inorderTraversal() {
	inorderTraversal(root);
}

private void inorderTraversal(Node<E> node) {
	if (node == null) return;
	
	inorderTraversal(node.left);
	System.out.println(node.element);
	inorderTraversal(node.right);
}
```

### éé€’å½’

## ååºéå†
è®¿é—®é¡ºåºï¼š
1. ååºéå†å·¦å­æ ‘ï¼›
2. ååºéå†å³å­æ ‘ï¼›
3. æ ¹èŠ‚ç‚¹ã€‚  
![äºŒå‰æœç´¢æ ‘09](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘09.png)

### é€’å½’
<font color=#00BFF>1ã€3ã€2ã€5ã€4ã€</font><font color=#F0E68C>8ã€10ã€12ã€11ã€9ã€</font><font color=#FF0000>7</font>
![äºŒå‰æœç´¢æ ‘12](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘12.png)

ä»£ç å®ç°ï¼š
```
public void postorderTraversal() {
	postorderTraversal(root);
}

private void postorderTraversal(Node<E> node) {
	if (node == null) return;
	
	postorderTraversal(node.left);
	postorderTraversal(node.right);
	System.out.println(node.element);
}
```

### éé€’å½’

## å±‚åºéå†
è®¿é—®é¡ºåºï¼š  
1. ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³ä¾æ¬¡è®¿é—®æ¯ä¸€ä¸ªå‡ ç‚¹ã€‚

<font color=#FF0000>7ã€</font><font color=#00BFF>4ã€9ã€</font><font color=#F0E68C>2ã€5ã€8ã€11ã€</font><font color=#32CD32>1ã€3ã€10ã€12</font>
![äºŒå‰æœç´¢æ ‘13](äºŒå‰æœç´¢æ ‘/äºŒå‰æœç´¢æ ‘13.png)

ä»£ç å®ç°ï¼š
```
public void levelOrderTraversal() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		System.out.println(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

# éå†æ¥å£
## å‰ã€ä¸­ã€åã€å±‚
éå†æ¥å£æä¾›ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼Œå°†éå†åˆ°çš„å…ƒç´ ä¼ åˆ°æ–¹æ³•è°ƒç”¨å¤„å¤„ç†ï¼š
```
/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 */
public static interface Visitor<E> {
	void visit(E element);
}
```

å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†å’Œä¸­åºéå†ï¼š
```
/*
 * å‰åºéå†
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * ä¸­åºéå†
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	inorderTraversal(node.left, visitor);
	visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * ååºéå†
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	visitor.visit(node.element);
}

/*
 * å±‚åºéå†ï¼ˆæœ‰å›è°ƒï¼‰
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		visitor.visit(node.element);
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}
```

æµ‹è¯•
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("å‰åºéå†ï¼š");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("ä¸­åºéå†ï¼š");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("ååºéå†ï¼š");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
	System.out.println();
	
	System.out.print("å±‚åºéå†ï¼š");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public void visit(Integer element) {
			System.out.print(element + " ");
		}
	});
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)

å‰åºéå†ï¼š7 4 2 1 3 5 9 8 11 10 12 
ä¸­åºéå†ï¼š1 2 3 4 5 7 8 9 10 11 12 
ååºéå†ï¼š1 3 2 5 4 8 10 12 11 9 7 
å±‚åºéå†ï¼š7 4 9 2 5 8 11 1 3 10 12
```

## éå†æ¥å£å¢å¼º
å®ç°å½“éå†åˆ°æŒ‡å®šèŠ‚ç‚¹æ—¶ï¼Œåœæ­¢éå†ã€‚

### å±‚åºéå†
ç¨‹åºéå†çš„ä¿®æ”¹æ¯”è¾ƒç®€å•ï¼Œåªéœ€è¦ï¼š
1. ç»™ `Visitor.visit()` æ–¹æ³•å¢åŠ è¿”å›å€¼ï¼›
2. åœ¨å¤„ç†å…ƒç´ çš„ä½ç½®æ·»åŠ åˆ¤æ–­å³å¯ã€‚

```
/*
 * å±‚åºéå†ï¼ˆæœ‰å›è°ƒï¼‰
 */
public void levelOrder(Visitor<E> visitor) {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		if (visitor.visit(node.element)) return; // åˆ¤æ–­æ˜¯å¦ç»“æŸéå†
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
	}
}

/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 * è¿”å›å€¼ï¼štrueï¼ˆåœæ­¢éå†ï¼‰/falseï¼ˆç»§ç»­éå†ï¼‰
 */
public static interface Visitor<E> {
	boolean visit(E element);
}
```

### å‰ã€ä¸­ã€å
å‰åºéå†ã€ä¸­åºéå†å’Œååºéå†å®ç°æ–¹å¼ç›¸åŒï¼š
1. Visitor ç±»ä¸­è®°å½• isStop å˜é‡ï¼ˆæ˜¯å¦åœæ­¢éå†çš„æ ‡ç­¾ï¼‰ï¼›
2. åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œæ·»åŠ æ˜¯å¦åœæ­¢éå†çš„åˆ¤æ–­ã€‚
```
/*
 * å›è°ƒæ–¹æ³•ï¼ˆç›¸å½“äº OC çš„ blockï¼‰
 * è¿”å›å€¼ï¼štrueï¼ˆåœæ­¢éå†ï¼‰/falseï¼ˆç»§ç»­éå†ï¼‰
 */
public static abstract class Visitor<E> {
	public boolean isStop;
	public abstract boolean visit(E element);
}
```

å‰åºéå†ã€ä¸­åºéå†å’Œååºéå†ï¼š
```
/*
 * å‰åºéå†
 */
public void preorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	preorderTraversal(root, visitor);
}

private void preorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	visitor.isStop = visitor.visit(node.element);
	preorderTraversal(node.left, visitor);
	preorderTraversal(node.right, visitor);
}

/*
 * ä¸­åºéå†
 */
public void inorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	inorderTraversal(root, visitor);
}

private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	inorderTraversal(node.left, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
	inorderTraversal(node.right, visitor);
}

/*
 * ååºéå†
 */
public void postorderTraversal(Visitor<E> visitor) {
	if (visitor == null) return;
	postorderTraversal(root, visitor);
}

private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
	if (node == null || visitor.isStop) return;
	
	postorderTraversal(node.left, visitor);
	postorderTraversal(node.right, visitor);
	if (visitor.isStop) return;
	visitor.isStop = visitor.visit(node.element);
}
```

æµ‹è¯•ï¼šè®¾ç½®éå†åˆ° 8 æ—¶åœæ­¢éå†ã€‚
```
static void test3() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	BinaryTrees.println(bst);
	System.out.println();
	
	System.out.print("å‰åºéå†ï¼š");
	bst.preorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("ä¸­åºéå†ï¼š");
	bst.inorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("ååºéå†ï¼š");
	bst.postorderTraversal(new Visitor<Integer>() {
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
	System.out.println();
	
	System.out.print("å±‚åºéå†ï¼š");
	bst.levelOrder(new Visitor<Integer>() {			
		@Override
		public boolean visit(Integer element) {
			System.out.print(element + " ");
			return element == 8;
		}
	});
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)

å‰åºéå†ï¼š7 4 2 1 3 5 9 8 
ä¸­åºéå†ï¼š1 2 3 4 5 7 8 
ååºéå†ï¼š1 3 2 5 4 8 
å±‚åºéå†ï¼š7 4 9 2 5 8 
```

# ç»ƒä¹ 
## æ ‘çŠ¶æ‰“å°äºŒå‰æ ‘
```
public String toString() {
	StringBuilder sb = new StringBuilder();
	toString(root, sb, "");
	return sb.toString();
}

private void toString(Node<E> node, StringBuilder sb, String prefix) {
	if (node == null) return;
	
	sb.append(prefix).append(node.element).append("\n");
	toString(node.left, sb, prefix + "L_");
	toString(node.right, sb, prefix + "R_");
}
```

æµ‹è¯•ï¼š
```
static void test4() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	System.out.println(bst);
}
```

æ‰“å°ç»“æœï¼š
```
7
L_4
L_L_2
L_L_L_1
L_L_R_3
L_R_5
R_9
R_L_8
R_R_11
R_R_L_10
R_R_R_12
```

ä¸Šé¢ğŸ‘†çš„æ‰“å°æ˜¯é€šè¿‡å‰åºéå†å®ç°çš„ï¼ŒåŒæ ·çš„ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸­åºéå†ã€ååºéå†å®ç°ã€‚

## è®¡ç®—äºŒå‰æ ‘çš„é«˜åº¦

### é€’å½’
```
public int height() {
	return height(root);
}

private int height(Node<E> node) {
	if (node == null) return 0; // è®¾ç½®é€’å½’åœæ­¢æ¡ä»¶
	return 1 + Math.max(height(node.left), height(node.right)); // å–å·¦å³å­æ ‘çš„é«˜åº¦ä¸­è¾ƒå¤§çš„ä¸€ä¸ªåŠ ä¸€
}
```

### è¿­ä»£
```
public int height() {
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	int levelSize = 1; // æ ‡è®°æŸä¸€å±‚èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œé»˜è®¤ä¸€ä¸ªï¼ˆç¬¬ä¸€å±‚çš„rootèŠ‚ç‚¹ï¼‰
	int height = 0;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		levelSize--; 
		
		if (node.left != null) {
			queue.add(node.left);
		}
		if (node.right != null) {
			queue.add(node.right);
		}
		
		// ç­‰äº0æ—¶ï¼Œè¡¨ç¤ºè¿™ä¸€å±‚çš„èŠ‚ç‚¹å…¨éƒ¨éå†å®Œæˆäº†
		if (levelSize == 0) {
			levelSize = queue.size(); // å¼€å§‹è®°å½•ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ä¸ªæ•°
			height++; // å¼€å§‹ä¸‹ä¸€å±‚éå†æ—¶ï¼Œé«˜åº¦åŠ ä¸€
		}
	}
	return height;
}
```

### æµ‹è¯•
```
static void test5() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	
	System.out.println("äºŒå‰æ ‘é«˜åº¦ï¼š" + bst.height());
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9) â”Œâ”€11_p(9)â”€â”
   â”‚        â”‚                â”‚         â”‚
1_p(2)    3_p(2)         10_p(11)   12_p(11)
äºŒå‰æ ‘é«˜åº¦ï¼š4
```

## å®Œå…¨äºŒå‰æ ‘çš„åˆ¤æ–­
ä½¿ç”¨å±‚åºéå†ï¼š
1. å¦‚æœæ ‘ä¸ºç©ºï¼Œè¿”å› falseï¼›
2. å¦‚æœ node.left != nullï¼Œå°† node.left å…¥é˜Ÿï¼›
3. å¦‚æœ node.left == null && node.right != nullï¼Œè¿”å› falseï¼›
4. å¦‚æœ node.right != nullï¼Œå°† node.right å…¥é˜Ÿï¼›
5. å¦‚æœ node.right == nullï¼Œåˆ™åè¾¹å†éå†åˆ°çš„èŠ‚ç‚¹å¿…é¡»éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å› falseï¼›
6. éå†ç»“æŸï¼Œè¿”å› trueï¼›

```
public boolean isComplete() {
	
	if (root == null) return false;
	
	Queue<Node<E>> queue = new LinkedList<>();
	queue.offer(root);
	boolean leaf = false;
	
	while (!queue.isEmpty()) {
		Node<E> node = queue.poll();
		
		if (leaf && !node.isLeaf()) return false;
		
		if (node.left != null) {
			queue.offer(node.left);
		} else if (node.right != null) { // node.left == null && node.right != null
			return false;
		}
		
		if (node.right != null) {
			queue.offer(node.right);	
		} else { // node.right == null
			leaf = true;
		}
	}
	return true;
}
```

æµ‹è¯•ï¼š
```
static void test6() {
	Integer data[] = new Integer[] {
			7, 4, 2, 1, 3, 5, 9, 8, 11
	};
	BinarySearchTree<Integer> bst = new BinarySearchTree<>();
	for (int i = 0; i < data.length; i++) {
		bst.add(data[i]);
	}
	
	BinaryTrees.println(bst);
	System.out.println(bst.isComplete());
}
```

æ‰“å°ç»“æœï¼š
```
             â”Œâ”€â”€â”€7_p(null)â”€â”€â”€â”
             â”‚               â”‚
        â”Œâ”€4_p(7)â”€â”       â”Œâ”€9_p(7)â”€â”
        â”‚        â”‚       â”‚        â”‚
   â”Œâ”€2_p(4)â”€â”  5_p(4) 8_p(9)   11_p(9)
   â”‚        â”‚
1_p(2)    3_p(2)
true
```

## ç¿»è½¬äºŒå‰æ ‘
[226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/)  
åˆ†åˆ«ç”¨å‰åºéå†ã€ä¸­åºéå†ã€ååºéå†å’Œå±‚åºéå†å®ç°ï¼š
```
/*
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

/*
 * å‰åºéå†
 */
public TreeNode invertTree(TreeNode root) {
	if (root == null) return root;
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	invertTree(root.right);
	return root;
}

/*
 * ååºéå†
 */
public TreeNode invertTree2(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	invertTree(root.right);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	return root;
}

/*
 * ä¸­åºéå†
 */
public TreeNode invertTree3(TreeNode root) {
	if (root == null) return root;
	
	invertTree(root.left);
	
	TreeNode temp = root.left;
	root.left = root.right;
	root.right = temp;
	
	invertTree(root.left);
	return root;
}

/*
 * å±‚åºéå†
 */
public TreeNode invertTree4(TreeNode root) {
	if (root == null) return root;
	
	Queue<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	
	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();
		
		TreeNode temp = node.left;
		node.left = node.right;
		node.right = temp;
		
		if (node.left != null) {
			queue.offer(node.left);
		}
		
		if (node.right != null) {
			queue.offer(node.right);
		}
	}
	
	return root;
}
```

