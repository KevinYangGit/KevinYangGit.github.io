{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/myAvatar.gif","path":"images/myAvatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/md5.min.js","path":"js/src/md5.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"2d3024eacb02faa12c7326dbfda8d4efbfe65f78","modified":1705479235556},{"_id":"source/404.htm","hash":"d6b2506dc5ea40ace839fee3064354f3efcf6b89","modified":1692697933906},{"_id":"themes/next/.DS_Store","hash":"0907c08250c0612fdbe8f04ae1e7b3c2ec54d085","modified":1506587616000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1506508854000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1506508854000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1506508854000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1506508854000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1506508854000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1506508854000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1506508854000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1506508854000},{"_id":"themes/next/README.cn.md","hash":"6d9177e7dad87e6129760e4b559bd3f7a15429d7","modified":1506508854000},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1506508854000},{"_id":"themes/next/README.md","hash":"950ca6e9c0fa607d290a5b1fd883df44725b36b2","modified":1506508854000},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1506508854000},{"_id":"themes/next/_config.yml","hash":"a6a3bcc8e266498b74c4347e53e41a511c286f39","modified":1606122397604},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1506508854000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1506508854000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1506508854000},{"_id":"source/_posts/.DS_Store","hash":"87229e6236cac7f21a8cc2130a9fa702ac272cdd","modified":1700557864869},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1506508854000},{"_id":"source/tags/index.md","hash":"1769cc88d5b38c0ca6b34944ce348b9198cb52bd","modified":1692697934373},{"_id":"themes/next/.git/ORIG_HEAD","hash":"13d37f01583769457bc3fe358d073c15dca3c674","modified":1579327673034},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1506508854000},{"_id":"themes/next/.git/FETCH_HEAD","hash":"8449c89a1cc9c636ac0341d4be0b078137ed8042","modified":1679903065869},{"_id":"themes/next/.git/index","hash":"ae7e6ec5286834f14872554f07498526201e4b98","modified":1506508854000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1506508854000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"213d0f6c9c7ed9b035d84486b540a57e24869909","modified":1506508854000},{"_id":"themes/next/.git/packed-refs","hash":"a476816cb73522d446a264df704c6a632081c54a","modified":1506508854000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1506508572000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1506508854000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1506508854000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1506508854000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1506508854000},{"_id":"themes/next/languages/en.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1506508854000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1506508854000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1506508854000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1506508854000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1506508854000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1506508854000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1506508854000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1506508854000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1506508854000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b342544b715da19d982349017bd56c5aaca11f71","modified":1506508854000},{"_id":"themes/next/languages/zh-hk.yml","hash":"2ef272bcb1f325480f59f1e2ab95584de3c6b8da","modified":1506508854000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1506508854000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1506508854000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c53941a2eaac8e3a2f8dacc73ed555d3c6c5bd59","modified":1506508854000},{"_id":"themes/next/source/.DS_Store","hash":"52c41ffa161e382c15b78349665c2041a2915b8c","modified":1579351191053},{"_id":"themes/next/layout/_layout.swig","hash":"ada7ffc71cf05e7236a19e0648bce6d6d6cbc7dc","modified":1506508854000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1506508854000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1506508854000},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1506508854000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1506508854000},{"_id":"themes/next/layout/post.swig","hash":"f8221725bfe3fe52723405b524077973121f17ba","modified":1506508854000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1506508854000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1506508854000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1506508854000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1506508854000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1506508854000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"source/_posts/2022年打怪/.DS_Store","hash":"d89af0b93441db5e76815e2cd5dd4327dc2fc658","modified":1664432735516},{"_id":"source/_posts/2022年打怪/算法列表.md","hash":"f64c14d7ddda3794e565f01d5c6e9dfda32fcf17","modified":1692697933907},{"_id":"source/_posts/Flutter/.DS_Store","hash":"267a60a8d99af1b1276acc8b3a0dbc7dfdcc3d35","modified":1703338488344},{"_id":"source/_posts/Flutter/Flutter之Dart.md","hash":"8f7c894b6c5b96851788c10a14cb400a701d89cd","modified":1697785901824},{"_id":"source/_posts/Flutter/Flutter之初见.md","hash":"4217e3520d792a2533798f1a1cb3c7df5d245014","modified":1700563265821},{"_id":"source/_posts/Flutter/Flutter之布局.md","hash":"6e67d5c0a490e587eb633454d5779e6dc677fc3f","modified":1703337990932},{"_id":"source/_posts/Flutter/Flutter之环境搭建.md","hash":"8e654e25defd2f7399d08841439882f7f8e1bb48","modified":1698221256334},{"_id":"source/_posts/Github开源框架/Alamofire.md","hash":"4a8d80d59e5e5578e29ad86140684cb965bc9abf","modified":1703338088224},{"_id":"source/_posts/Github开源框架/.DS_Store","hash":"ef2be863627356dd78b70bfa571e5113d06c5c71","modified":1692265508969},{"_id":"source/_posts/Github开源框架/Masonry.md","hash":"d5707a059304f5f7d21a46cc7c1e8918fc13defd","modified":1692956912994},{"_id":"source/_posts/OC底层原理/.DS_Store","hash":"550b3a0c56d8199e5a4280093e21c6e2f122d764","modified":1614678981319},{"_id":"source/_posts/OC底层原理/Category的实现原理.md","hash":"5875f4b3c9ad8839e3e00d6dc53a02c7ebf56921","modified":1692697933920},{"_id":"source/_posts/OC底层原理/KVO.md","hash":"0e39f4a78c40c3d7258aa2f9ee5ce1d86e4a18e1","modified":1692697933922},{"_id":"source/_posts/OC底层原理/OC对象的分类.md","hash":"82187648b8c50e4b278b383ee2446dc3913bf7e8","modified":1692697933931},{"_id":"source/_posts/OC底层原理/OC对象的本质.md","hash":"08717143f77b48c7d6894792e4d32207f51af9af","modified":1692697933933},{"_id":"source/_posts/OC/.DS_Store","hash":"468152233b8fa2e987892d7f037d4f99bb411bf5","modified":1666172912857},{"_id":"source/_posts/OC底层原理/RunLoop.md","hash":"ddd435d84dd211679d2c416d76a8d0b92c8fdf4e","modified":1692697933937},{"_id":"source/_posts/OC底层原理/initialize方法.md","hash":"0e9ff75b7911af7c10220f7705bfbadd7017593b","modified":1692697933983},{"_id":"source/_posts/OC底层原理/isa和superclass.md","hash":"8706f764af9271b27ce92adfd16c3bc93ef2e95c","modified":1692697933984},{"_id":"source/_posts/OC底层原理/load的实现原理.md","hash":"16ac7a829aeac4835c02e59ef545941f61d2096c","modified":1692697933987},{"_id":"source/_posts/OC底层原理/关联对象.md","hash":"980d2a6481b34c12b162d871b40ab01014a16d5d","modified":1692697933988},{"_id":"source/_posts/OC底层原理/性能优化.md","hash":"9989afcc23e27db34f55cdd241c015facbc33add","modified":1692697934028},{"_id":"source/_posts/OC底层原理/架构设计.md","hash":"802e4423ae42d29b8d80d5b1157f17ecd487b204","modified":1692697934032},{"_id":"source/_posts/Other/.DS_Store","hash":"74933103b1a224ad16d4f84edd2e32f140dc1779","modified":1686302170870},{"_id":"source/_posts/Other/Hexo安装笔记.md","hash":"1d394d890931e5e4218b6aa0574d32b272123168","modified":1692697934047},{"_id":"source/_posts/Other/Apple官方文档阅读指南.md","hash":"617d60939508c6fbe94422c4240011f6b0560f35","modified":1692697934037},{"_id":"source/_posts/Other/Math.md","hash":"18a50f1f4d2576778bcbf4c61f0b78a247ace496","modified":1692697934049},{"_id":"source/_posts/Other/诗和远方.md","hash":"b8c444ed19f02754620ca510ae7184fcc032df55","modified":1692697934112},{"_id":"source/_posts/Swift/Swift简介.md","hash":"eca50844c0395d951db5c843494484ba22b869aa","modified":1692697934124},{"_id":"source/_posts/Swift/基本数据类型.md","hash":"fbb96da3050a6b4a73791a1f5721b8bd8f12ad14","modified":1692697934146},{"_id":"source/_posts/Swift/函数和闭包.md","hash":"50a5fddfc38f72b1c02b40ecd73b8579a19099e0","modified":1692697934140},{"_id":"source/_posts/Swift/流程控制.md","hash":"c6bd288a061b7ea36dc311e3ad8dce6de17c527e","modified":1692697934170},{"_id":"source/_posts/Swift/时间魔法Swift篇.md","hash":"f517123629abca1045f5dfee06c01fd0bd2b64f6","modified":1692697934169},{"_id":"source/_posts/Swift/运算符.md","hash":"f98794fe6c5004984ead8177b94129be57ff6742","modified":1692697934177},{"_id":"source/_posts/Swift/集合类.md","hash":"954ab435ff917ec76395f8bed8a32f5a30bc34b0","modified":1692697934185},{"_id":"source/_posts/iOS/GCD.md","hash":"34d40cf3a08fc9f3281717987b97ed91e1804f68","modified":1706871873136},{"_id":"source/_posts/iOS/.DS_Store","hash":"72a04e7a016cb463c7029b5b345e51ae10db4d02","modified":1706872061495},{"_id":"source/_posts/Swift/.DS_Store","hash":"c443f5d2e54711751d15509dc478a67cf468e98f","modified":1686550511642},{"_id":"source/_posts/iOS/UIBezierPath.md","hash":"72c613632a31e4cf3f9e389d6aeb6adba713c5ff","modified":1706871873137},{"_id":"source/_posts/iOS/iOS横竖屏.md","hash":"48f2eab41e0552b6c34b3065383deb9994465b93","modified":1706871873156},{"_id":"source/_posts/iOS/时间魔法.md","hash":"f4675fd4377563ee6655e9bb88cc49c838d88533","modified":1706871873160},{"_id":"source/_posts/数据结构与算法/AVL树.md","hash":"d96881cf1a391b47b669e0e10f87d3ff4a0ae7e3","modified":1692697934228},{"_id":"source/_posts/数据结构与算法/B树.md","hash":"9bcef134545339d6178f64108aa43774037b3d58","modified":1692697934249},{"_id":"source/_posts/数据结构与算法/二叉搜索树.md","hash":"875b2ff8448d56aac55d440f8a845aaa1c9310ac","modified":1692697934266},{"_id":"source/_posts/数据结构与算法/二叉树.md","hash":"e6827e14ace44a1bd20315f288d996e837711947","modified":1692697934281},{"_id":"source/_posts/数据结构与算法/动态数组.md","hash":"1953ce47746e16d866328eefcb69dce2c52edee6","modified":1692697934288},{"_id":"source/_posts/数据结构与算法/复杂度.md","hash":"ee948171b39c81f1dc1fc8c9c865b4815bfdfca2","modified":1692697934297},{"_id":"source/_posts/数据结构与算法/.DS_Store","hash":"501936b6c28bbbae3e274d7fd9e3961949919b8f","modified":1683168096459},{"_id":"source/_posts/数据结构与算法/栈.md","hash":"d3d95d2555a7b8ab8d60ecf5385a2835fb3e36c2","modified":1692697934304},{"_id":"source/_posts/数据结构与算法/环境搭建.md","hash":"101531bd6188b8979aa94b60b1aed99145777e28","modified":1692697934307},{"_id":"source/_posts/数据结构与算法/链表.md","hash":"b36c7364864337813f1889f2542f6e7e15cf775d","modified":1692697934337},{"_id":"source/_posts/数据结构与算法/队列.md","hash":"182ca4517fa2852723ba375ebe6621bf79c1b9b6","modified":1692697934368},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1506508572000},{"_id":"themes/next/.git/logs/HEAD","hash":"0ff8408c7091fe0afdc6993fb887a93b57242e85","modified":1506508854000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1506508572000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1506508572000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1506508572000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1506508572000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1506508572000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1506508572000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1506508572000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1506508572000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1506508572000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1506508854000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1506508854000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1506508854000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1506508854000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1506508854000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1506508854000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1506508854000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1506508854000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1506508854000},{"_id":"themes/next/source/css/.DS_Store","hash":"db57eca040b81c22da5bcac31c13ebbe8ddc026e","modified":1506587623000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1506508854000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1506508854000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1506508854000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1506508854000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1506508854000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1506508854000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1506508854000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1506508854000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1506508854000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1506508854000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1506508854000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1506508854000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1506508854000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1506508854000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1506508854000},{"_id":"themes/next/source/images/myAvatar.gif","hash":"68c098f4f5258f5fa8f7178c169c52c04d6bbc29","modified":1579336711418},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1506508854000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1506508854000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1506508854000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1506508854000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1506508854000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1506508854000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"fb02c81273d5897ebb98b50f4c10f7edc34f9240","modified":1506508854000},{"_id":"themes/next/layout/_macro/post.swig","hash":"767e1d5503ecce85f577c8fb673a3503b65484ce","modified":1506508854000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"80b3a5527c4bf7b19b1eaf4ccb3c3221cb8aec98","modified":1602325363236},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"3e01900762d889a04379abba37b419972e366698","modified":1506508854000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1506508854000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1506508854000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1506508854000},{"_id":"themes/next/layout/_partials/head.swig","hash":"2cbeae795c9929ec1966b8a1fb9c058a0b547fa9","modified":1506508854000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1506508854000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1506508854000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1506508854000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1506508854000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1506508854000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1506508854000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1506508854000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1506508854000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1506508854000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之基础Widget.md","hash":"8ef6b397130fdcb2882554b5556851e679c6c957","modified":1700557695805},{"_id":"source/_posts/OC底层原理/block.md","hash":"31409d992039f59e5792c61f7dcbcd3e025ec58f","modified":1692697933972},{"_id":"source/_posts/OC底层原理/内存管理.md","hash":"6552e6e557557d5391c9277fe739a1d64c4be121","modified":1692697933990},{"_id":"source/_posts/OC底层原理/多线程.md","hash":"50a720f9ca79e6d539505821679d684f3d40910a","modified":1692697933999},{"_id":"source/_posts/Other/微信小程序.md","hash":"421d9dffb0d0c92d6e0d1c2b3b5fc6c84b51d1f9","modified":1692697934055},{"_id":"source/_posts/Swift/面向对象编程.md","hash":"70148d3aa08955f5c6c4b870a3f23d854d8a9ea2","modified":1692697934209},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之Dart/01.png","hash":"33085cd65c7ab3f0d7e3ceba8683d6d91766e825","modified":1697416970000},{"_id":"source/_posts/Flutter/Flutter之Dart/02.png","hash":"ebe6d820275c2fa31b1b06ebeb2a180afb070dfd","modified":1697416970000},{"_id":"source/_posts/Flutter/Flutter之Dart/04.png","hash":"fa5fc9cd8d663c51ff5ea23b46a985c0fad45398","modified":1697416970000},{"_id":"source/_posts/Flutter/Flutter之Dart/03.png","hash":"08250329bb73a98879078568c709b1331e1c929a","modified":1697416970000},{"_id":"source/_posts/Flutter/Flutter之Dart/05.png","hash":"d988f7a65e5e4c930bd1020fe45bc419db1d309d","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/06.png","hash":"f25478c994ebf19fed94373a05552219d36a1b89","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/07.png","hash":"faaecfd56b826ad01d4cd807812991377f2b56dc","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/08.png","hash":"1e5398c49321865428626cce1c33205afb55b0cc","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/10.png","hash":"c3bb4fc6da15fe8646c4527fe5d4e740324d9195","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/09.png","hash":"56bfd8e4cc74d561e888b73e4edd2065c194a7ca","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/11.png","hash":"d9284a51ab3635001724305a09e23fd9995c515d","modified":1697651488000},{"_id":"source/_posts/Flutter/Flutter之Dart/12.png","hash":"1bb5bfda538083e18bdd107c752edb5fd01cbe84","modified":1697651488000},{"_id":"source/_posts/2022年打怪/算法列表/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1664432773769},{"_id":"source/_posts/Flutter/Flutter之初见/01.png","hash":"60542bc2fc8ae9f49403f166a481b5319751af10","modified":1698197734000},{"_id":"source/_posts/Flutter/Flutter之初见/03.png","hash":"76462c7da8127aa759f8cdadddf74d69bd301504","modified":1698197734000},{"_id":"source/_posts/Flutter/Flutter之初见/02.png","hash":"1bdcd97985d6f65ff43bfebc4f57aa177f18a3df","modified":1698197734000},{"_id":"source/_posts/Flutter/Flutter之初见/04.png","hash":"45c05415de5111e7e36ea59591b19a4f12a3c3eb","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/07.png","hash":"d2a1d2accac28b8a47e8bb36a2122753e70ce20b","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/06.png","hash":"db6cbc6ee8ea8950bdfd11457e831b15411586e6","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/09.png","hash":"53e2c8957b136c285b7aac61d98fe8c8e5c609a9","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/11.png","hash":"f8d6ac21d90832ae1a999ffb13a8ac77043e7a44","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/10.png","hash":"179eb28818e511785e4d1b3a5445a893fa941ae0","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/12.png","hash":"ad7d1d18c8ea5dc3ea20089a5998e807d03acf64","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/18.png","hash":"126432274ac5b551abac3acebccde505d97b7fd7","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/19.png","hash":"4461a547d6b8901647b8348f9b172c7b111f02ba","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/20.png","hash":"628b41bb62cf69d49575c3007767426eaea62e9d","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/01.png","hash":"7c31a869fed5ada017f2f4543dcf1ee545aa6c69","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/02.png","hash":"e4cbeed1e59585139287eb1fe540375ef393c65a","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/03.png","hash":"8855dcfb38dfe7dcb4370094e433adfcebfb1b0a","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/05.png","hash":"d6efaa9a664e43692362678085942a2ecacc35ec","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/04.png","hash":"a21e3a957e50ccf2fd89b0c788e4b17c9114eb9b","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/06.png","hash":"a863727e341a82dade379ea96883f23de0cd55c1","modified":1699580828000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/07.png","hash":"536af180a56f2af731de1b99cd44831ff473783d","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/08.png","hash":"8c57e3c4fa52a7300c63631d3a6e6f78ac97cc1e","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/09.png","hash":"253ad03773019d3ef0b89033efac11dc37030cd1","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/11.png","hash":"6da01fe1c2e34e53fc54bc6ade7b5dc0f8c79091","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/10.png","hash":"9e8ea438353cbb9ecdcf8cb75bc97520f06b5c57","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/12.png","hash":"1f0d671dcadba83537a18dcec20aad63778602b5","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之布局/04.png","hash":"be902867267461ff33302670b97ef6e979fda66f","modified":1701076173732},{"_id":"source/_posts/Flutter/Flutter之布局/02.png","hash":"37dae9d0fdcb35c8ecd9bb6aff98d58af25ebc9c","modified":1701076173768},{"_id":"source/_posts/Flutter/Flutter之布局/03.png","hash":"740cb486ddb090e23ef487bb17a877860edf9fe5","modified":1701076173751},{"_id":"source/_posts/Flutter/Flutter之布局/01.png","hash":"67a3ce00078c89d0fdfd6425d8a87f3d6d963c97","modified":1701076173804},{"_id":"source/_posts/Flutter/Flutter之布局/07.png","hash":"6d225a1ca0b78daf468d38b3c5fcad19d7fb9e3b","modified":1701076173686},{"_id":"source/_posts/Flutter/Flutter之布局/06.png","hash":"4ef26aa49033cc23d412858f3231ce1cb82abf56","modified":1701076173703},{"_id":"source/_posts/Flutter/Flutter之布局/09.png","hash":"3642ec2eabae4ff52799d402185b294b7240539f","modified":1701076173649},{"_id":"source/_posts/Flutter/Flutter之布局/08.png","hash":"05a60bb6f37a013ccf2b3d766f401ba9452bf8cd","modified":1701076173668},{"_id":"source/_posts/Flutter/Flutter之环境搭建/04.png","hash":"9e65b4faebf09cbec4915f97e2f5675acbd9a70e","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/05.png","hash":"9b58a22a3fac1ad03ec318aeebd592f7f0f069d0","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/07.png","hash":"080fed64fc6e9390127bc70a33e9061697293ed5","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/09.png","hash":"c4884ec446e4890b61f857794072e9da040f884a","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/10.png","hash":"1aa1817c1b8dd30e385ab9199a14da1edcf10a32","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/12.png","hash":"79fa6ac78c4466cc0d762239554ed82bf136c305","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/15.png","hash":"86cdd3090e649c8cfae79b711b077fcc492a054b","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/18.png","hash":"75eed52704b5a4f061f76730caa09334c54822a8","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/19.png","hash":"82f3e05ff77eb298d50161a91a0301e097d88aa1","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/20.png","hash":"f98b0a4dac53ec3fd2b50fb284201d9caab599f1","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/21.png","hash":"45bc67dcc9dfe364a388016ae7129d3aa03a0fc5","modified":1697067506000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/24.png","hash":"b2a50e8bcc8925c296fecc52d1e00b7a35d29589","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/25.png","hash":"9dd98de7cd571415e7f60fd403d5aa4101b1cbbd","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/26.png","hash":"672a8ec9ba8471893232588ba66732cdac0c2d06","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/27.png","hash":"555dbdf92cb55383f0cdb0f152ee5425a6680f6b","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/28.png","hash":"e9f4e9c4ebd3012972830833599de3003dbd7801","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/36.png","hash":"e0f8030b9cb7d5da599c9074a57b6fc7155921af","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/37.png","hash":"30658f0cbe22110102307aacc3dec374d4d49964","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/42.png","hash":"413388ba8878a891d26a9efbf8895418b17a1531","modified":1697097980281},{"_id":"source/_posts/Github开源框架/Alamofire/01.png","hash":"166fc330548f74803b7974506ce495902b79b762","modified":1692697933910},{"_id":"source/_posts/Github开源框架/Alamofire/02.png","hash":"3a5f1d483baebfc3c451fb33489a88c571b1bb72","modified":1692697933910},{"_id":"source/_posts/Github开源框架/Alamofire/03.png","hash":"7233d6a61c418fd70fb32de3460a1d8dfd8f4b4b","modified":1692697933910},{"_id":"source/_posts/Github开源框架/Alamofire/04.png","hash":"400ac39098377cfdd8633a4050bf1c8a4fb3e1e7","modified":1692697933911},{"_id":"source/_posts/Github开源框架/Alamofire/05.png","hash":"43816dab43deb791b7fb7651086f7ed445e9e60a","modified":1692697933911},{"_id":"source/_posts/Github开源框架/Alamofire/06.png","hash":"5a84f9ebf6b28e596ab1f2b67a5b36696ccdf2e9","modified":1692697933911},{"_id":"source/_posts/Github开源框架/Alamofire/07.png","hash":"dc33af2157ced10879fd4b6c675b95c0f34b6e8d","modified":1692697933911},{"_id":"source/_posts/Github开源框架/Alamofire/08.png","hash":"cd8d753dec5e8d0924522adabd2ac441d5758773","modified":1692697933911},{"_id":"source/_posts/Github开源框架/Alamofire/09.png","hash":"77ee0388f4345863d9903ea05e82634f2c420721","modified":1692697933912},{"_id":"source/_posts/Github开源框架/Masonry/02.png","hash":"ad01995aab1ffb12ea06ee08e37e512dfcc3f6a1","modified":1692697933914},{"_id":"source/_posts/OC/AFHTTPSessionManager/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1588831349626},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理01.png","hash":"0f39d7e9ce3588445b47a4371deb4f25880d0201","modified":1692697933920},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理02.png","hash":"cba457e40d0d62e60e298de61682ebcc485783bf","modified":1692697933920},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理03.png","hash":"74637b816b2c30de7cf49024259ce23b1b9daeec","modified":1692697933921},{"_id":"source/_posts/OC/iOS横竖屏/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1666253784090},{"_id":"source/_posts/OC底层原理/Category的实现原理/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1589903296849},{"_id":"source/_posts/OC底层原理/KVO/KVO01.png","hash":"d372b652ec98a8f5a8ded2e80429544e9718b547","modified":1692697933922},{"_id":"source/_posts/OC底层原理/KVO/KVO04.png","hash":"771715038cebcf7150a06f248c9d58e649d9eb54","modified":1692697933925},{"_id":"source/_posts/OC底层原理/KVO/KVO05.png","hash":"808d7787b41d392f72c6ecb4be2c2ef5f65357a9","modified":1692697933925},{"_id":"source/_posts/OC底层原理/KVO/KVO06.png","hash":"db8772b56624b375660c0f35006efe465d2e1feb","modified":1692697933925},{"_id":"source/_posts/OC底层原理/KVO/KVO07.png","hash":"9fc5a3e79b07ec5dcb400f130f71baf02d9298f1","modified":1692697933926},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_03.png","hash":"c3f11330dba09ddbd9dd2241cf3ec6cf7c3b3cfc","modified":1692697933927},{"_id":"source/_posts/OC底层原理/KVO/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1591951440489},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类01.png","hash":"5c19befd827b7179814ef1781f907e219952a3e6","modified":1692697933931},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类02.png","hash":"b218f0cbe3ac57774ebc56abe2c1c3adba66464b","modified":1692697933931},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类03.png","hash":"7ef6861b68d2d804f7e7386d2cb6b86b058f3a3b","modified":1692697933932},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质.png","hash":"f26b037aa6d2d42f5de29e3046f08c9a2be4525c","modified":1692697933933},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质02.png","hash":"6ad4368e9e2381a0fcb362ef23b1305ebebd25cb","modified":1692697933934},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质03.png","hash":"ea5236b8a1e4379052ad5e97aa3603350c0d6fae","modified":1692697933934},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶01.png","hash":"a5776dfe684bf5b31e6111e56a4e5d959d0c9c12","modified":1692697933934},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶02.png","hash":"f4e3b2920ecf8ced5da7370e0d1bbe33d3b4172c","modified":1692697933935},{"_id":"source/_posts/OC底层原理/OC对象的分类/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1589079490755},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶03.png","hash":"daefbf696f3d8d79760d1f0fcd9f9951db2ccd41","modified":1692697933935},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶05.png","hash":"f6937a61be45582d79c0612735f2b4c9f5851d9c","modified":1692697933935},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶04.png","hash":"9cf652902340ccd5cdd9e0a094bc6f2f68cb034f","modified":1692697933935},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶06.png","hash":"1d9f7be90372b4cfe400cbf6dbc61bf7c9adacbd","modified":1692697933936},{"_id":"source/_posts/OC底层原理/OC对象的本质/ObjectiveC_C_C++_汇编语言_机器语言.png","hash":"78906c3ae470c1eac34f75c86e89bf9efd9e08ec","modified":1692697933936},{"_id":"source/_posts/OC底层原理/OC对象的本质/取消编译main_arm64_cpp.png","hash":"0c77042f8d921614d98718946aede80aae7e6880","modified":1692697933936},{"_id":"source/_posts/OC底层原理/OC对象的本质/.DS_Store","hash":"809984b6f257b79a08bd65db30c2daf5b83d0e82","modified":1602299883088},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop01.png","hash":"e45a63156e8ceb93aa13dc58d2576313928ce141","modified":1692697933937},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop04.png","hash":"9f4ec25f93eeebcf29e91a1bc8d83ba346090671","modified":1692697933939},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop16.png","hash":"06f5873080c6bc38ed217e9a920ecbfbc110c759","modified":1692697933954},{"_id":"source/_posts/OC底层原理/RunLoop/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1594302102957},{"_id":"source/_posts/OC底层原理/Runtime/Runtime01.png","hash":"3f33c580d8b3e94f176a425fd56716c7863cf3f6","modified":1692697933955},{"_id":"source/_posts/OC底层原理/Runtime/Runtime02.png","hash":"868b5c2a3a40e6a6554f74ba6d193a9b2e33a89c","modified":1692697933955},{"_id":"source/_posts/OC底层原理/Runtime/Runtime04.png","hash":"05ef97612870c0a91bd17231a442719255b75592","modified":1692697933956},{"_id":"source/_posts/OC底层原理/Runtime/Runtime05.png","hash":"da5802c9ed0fd6698119f723967a80abe8b02463","modified":1692697933956},{"_id":"source/_posts/OC底层原理/Runtime/Runtime07.png","hash":"e7fda5d5ee42da8884acbca29727f4cb707774f9","modified":1692697933957},{"_id":"source/_posts/OC底层原理/Runtime/Runtime11.png","hash":"7a55dc1e33e5a42481ab55fab94b260ac774348a","modified":1692697933959},{"_id":"source/_posts/OC底层原理/Runtime/Runtime09.png","hash":"51ae01820195e09828035a16f892a0ccf4e007a3","modified":1692697933959},{"_id":"source/_posts/OC底层原理/Runtime/Runtime10.png","hash":"cb6afa1ad1f9936f988bf71c29a6bc58634fbf5c","modified":1692697933959},{"_id":"source/_posts/OC底层原理/Runtime/Runtime12.png","hash":"fea92805e49312e885363d5edc3510638cfb2df9","modified":1692697933960},{"_id":"source/_posts/OC底层原理/Runtime/Runtime14.png","hash":"22b2f55395736f0cc3ae5f9d6b2f88c58d01b079","modified":1692697933960},{"_id":"source/_posts/OC底层原理/Runtime/Runtime13.png","hash":"a404fd1b0e08836ddad0a1f4765afa27ff7a0a53","modified":1692697933960},{"_id":"source/_posts/OC底层原理/Runtime/Runtime15.png","hash":"043451da2f37a1bf74b280d03ae87d671fe6e9da","modified":1692697933960},{"_id":"source/_posts/OC底层原理/Runtime/.DS_Store","hash":"3ce20e6e839b6cb9332858d996fc82e8d3e3c4b8","modified":1593572306441},{"_id":"source/_posts/OC底层原理/Runtime/Runtime16.png","hash":"73428f73644fbb4f17893b311b573ef22105d966","modified":1692697933960},{"_id":"source/_posts/OC底层原理/Runtime/Runtime20.png","hash":"8836123e4724c439b5bfc325b8d0fa84be5a0ec9","modified":1692697933962},{"_id":"source/_posts/OC底层原理/Runtime/Runtime19.png","hash":"756bc64e351893c3970b769959f14d08a81abb4d","modified":1692697933962},{"_id":"source/_posts/OC底层原理/Runtime/Runtime21.png","hash":"3b18bd523820dafd555b05cea306aafe2a5d5c37","modified":1692697933962},{"_id":"source/_posts/OC底层原理/Runtime/Runtime22.png","hash":"393edb6ab843c6a1c007a25faea7433dd5b34896","modified":1692697933963},{"_id":"source/_posts/OC底层原理/Runtime/Runtime24.png","hash":"2d782b816339f7c30f70541df9a5dbe01b89c1e3","modified":1692697933964},{"_id":"source/_posts/OC底层原理/Runtime/Runtime25.png","hash":"4d4079b75bfd961b350c616cde547c9218a362fe","modified":1692697933964},{"_id":"source/_posts/OC底层原理/Runtime/Runtime26.png","hash":"f330cca05617e5e187727076cc9b79862b23856d","modified":1692697933965},{"_id":"source/_posts/OC底层原理/Runtime/Runtime28.png","hash":"5be1c54899b6e7e4c0bf204fe798842b3843d38f","modified":1692697933965},{"_id":"source/_posts/OC底层原理/Runtime/Runtime29.png","hash":"32f081dbc177a0fb25c3a08bf855b5dd56b8d516","modified":1692697933966},{"_id":"source/_posts/OC底层原理/Runtime/Runtime27.png","hash":"958911cd143e4e6516a92d41fdeb0af4ed07b79b","modified":1692697933965},{"_id":"source/_posts/OC底层原理/Runtime/Runtime30.png","hash":"2987620545f22a3a2c9e7af43cadbfb0169bbf7a","modified":1692697933966},{"_id":"source/_posts/OC底层原理/Runtime/Runtime32.png","hash":"0a96f898f20ec2ee080fb7fa71ef56127b4e86dc","modified":1692697933968},{"_id":"source/_posts/OC底层原理/Runtime/Runtime33.png","hash":"2a4b79f582446be902d754fcfde7914b2f0ce5de","modified":1692697933968},{"_id":"source/_posts/OC底层原理/Runtime/Runtime34.png","hash":"f0c8f86cc7c6d318ae89c17dc7563f99c8448828","modified":1692697933968},{"_id":"source/_posts/OC底层原理/Runtime/Runtime35.png","hash":"78891d2b21c2a12929c258ed99b76114e8b9c3a8","modified":1692697933969},{"_id":"source/_posts/OC底层原理/Runtime/Runtime36.png","hash":"46040f9905e68075914fdddb8791d5b5f7ceadca","modified":1692697933969},{"_id":"source/_posts/OC底层原理/Runtime/Runtime37.png","hash":"f9b91fc508ba9d411bbd4200d3d27e3d129c1606","modified":1692697933970},{"_id":"source/_posts/OC底层原理/Runtime/Runtime38.png","hash":"7780f2caf926d7978680cc448950e669080bd514","modified":1692697933970},{"_id":"source/_posts/OC底层原理/Runtime/Runtime39.png","hash":"42a17a0b869f50a1659a49d20de5eb7633f4f91b","modified":1692697933971},{"_id":"source/_posts/OC底层原理/block/block01.png","hash":"7f4bd88bbb2eb31fae16b7b958837d223a547a31","modified":1692697933972},{"_id":"source/_posts/OC底层原理/block/block03.png","hash":"4cc7f29fb3f4f5beeb18ec569210a1ba243513bd","modified":1692697933973},{"_id":"source/_posts/OC底层原理/block/block02.png","hash":"bd54a75c15af81504d4d16691baa4fbb676a9e85","modified":1692697933973},{"_id":"source/_posts/OC底层原理/block/block04.png","hash":"bf3e5a88cc03d13993cfa3e794792097840c7cd7","modified":1692697933974},{"_id":"source/_posts/OC底层原理/block/block05.png","hash":"bcf180d4e00b5cb372e9cfc4bfa734fc053a3428","modified":1692697933974},{"_id":"source/_posts/OC底层原理/block/block06.png","hash":"1cec1319d22dcafe04f654edc19860b2e77badd7","modified":1692697933974},{"_id":"source/_posts/OC底层原理/block/block08.png","hash":"bfdef8e57be3fd0d1ffa0d06f4ae4cd603c8c00c","modified":1692697933975},{"_id":"source/_posts/OC底层原理/block/block07.png","hash":"e8be0e524794596ee5c03499b20db95d96397e72","modified":1692697933975},{"_id":"source/_posts/OC底层原理/block/block10.png","hash":"a0bf6b3eb76128379a886f7b961308a6ebf1f3df","modified":1692697933976},{"_id":"source/_posts/OC底层原理/block/block09.png","hash":"f1e96c781dd46f8e005e2431cef152f97f980878","modified":1692697933975},{"_id":"source/_posts/OC底层原理/block/block12.png","hash":"5df12ffaf934c0de212cbb8a61519d6809ecd5ed","modified":1692697933976},{"_id":"source/_posts/OC底层原理/block/block11.png","hash":"0638ad4b3b7174b55e2f1a392a9c706c6d132dee","modified":1692697933976},{"_id":"source/_posts/OC底层原理/block/block13.png","hash":"d5328c90a646d167e5b03b6ad8755a64cf74a927","modified":1692697933977},{"_id":"source/_posts/OC底层原理/block/block15.png","hash":"82bfff22047a69fe1c683b87be5e04b9c6dc4ac5","modified":1692697933977},{"_id":"source/_posts/OC底层原理/block/block14.png","hash":"a60793fcc5101dc8e60ff95b3c81e46cdad41873","modified":1692697933977},{"_id":"source/_posts/OC底层原理/block/block19.png","hash":"d56f749234c5a501130971fcf942261169b4e9a4","modified":1692697933980},{"_id":"source/_posts/OC底层原理/block/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1591783757173},{"_id":"source/_posts/OC底层原理/Runtime.md","hash":"110e113583074250418937f09b35eee2101c8129","modified":1692697933955},{"_id":"source/_posts/OC底层原理/block/block22.png","hash":"818851ecf3fd76d7c0514c55a36e5195b9a92dbf","modified":1692697933981},{"_id":"source/_posts/OC底层原理/block/block23.png","hash":"d44d1461a1881330867e9d52eb59ba2ce3d1b0db","modified":1692697933981},{"_id":"source/_posts/OC底层原理/block/block24.png","hash":"a56addb31994fc0ab0358007db1e8a8fb9925e6f","modified":1692697933982},{"_id":"source/_posts/OC底层原理/block/block26.png","hash":"b471191a562138ad38f692e0d313e664f8e947e4","modified":1692697933982},{"_id":"source/_posts/OC底层原理/block/block27.png","hash":"3437f16ee4f46be9acddb19abefae05578c42d6e","modified":1692697933982},{"_id":"source/_posts/OC底层原理/block/block28.png","hash":"f59c0eca6886b4139a38650ecd9231afa8025044","modified":1692697933983},{"_id":"source/_posts/OC底层原理/initialize方法/initialize方法01.png","hash":"a85a57b674e02a399ca86c38c29ce8d4ba048f07","modified":1692697933983},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass01.png","hash":"d343f837c6a768bca6c575e6d0a792cbc87ede34","modified":1692697933984},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass02.png","hash":"e79c185d1319188e6a3defbde59a166bdb1cc690","modified":1692697933984},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass03.png","hash":"0f74c46b282da91884312923cdbe59e1fa9f28cc","modified":1692697933984},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass04.png","hash":"52423fb0e495240187fffbe7dca42f31863421cc","modified":1692697933985},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass05.png","hash":"7337da6c4538fd5d2b0b492cf4d4b94847b195a2","modified":1692697933985},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass06.png","hash":"76b8a7833d6e4e7ab8d4df51d01558236ea12c5a","modified":1692697933985},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass07.png","hash":"224f82b020cb235a6c0b88936fab7b54a15acf7c","modified":1692697933985},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass09.png","hash":"3579788d106bf27dbb1f19849f270847a186edc9","modified":1692697933986},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass10.png","hash":"ed5c772440b18187a1803cc2aabd0e96984403ff","modified":1692697933986},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass08.png","hash":"df2c5d403f69cc4a97eab30dbde5b989abc2c0be","modified":1692697933986},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass12.png","hash":"36860f8b376270314a8166be549dbcea8b5b9ddf","modified":1692697933986},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass11.png","hash":"c8e441475247599b567d288941519e913e0ca087","modified":1692697933986},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass13.png","hash":"032a3c3c17d03d8b8637e1a6325987c26961fc8c","modified":1692697933987},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass14.png","hash":"98f1ec3524fcbc231e3c63dfed358fe5f1887852","modified":1692697933987},{"_id":"source/_posts/OC底层原理/load的实现原理/load的实现原理01.png","hash":"b1de605adc0d774c0187245bac1596dc0bf7701f","modified":1692697933988},{"_id":"source/_posts/OC底层原理/isa和superclass/.DS_Store","hash":"14754969fb12fa7b3cc1d7c3d6c663de0097bbaf","modified":1589341287577},{"_id":"source/_posts/OC底层原理/load的实现原理/load的实现原理02.png","hash":"a85a57b674e02a399ca86c38c29ce8d4ba048f07","modified":1692697933988},{"_id":"source/_posts/OC底层原理/关联对象/关联对象01.png","hash":"05e81c3fa21e85e7e5fc9f2bdec06aef64ae1e5f","modified":1692697933988},{"_id":"source/_posts/OC底层原理/关联对象/关联对象02.png","hash":"cba3fd4dde605512e0728b37dcf5632e0f434c8c","modified":1692697933989},{"_id":"source/_posts/OC底层原理/load的实现原理/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1590118182695},{"_id":"source/_posts/OC底层原理/关联对象/关联对象05.png","hash":"2bc406329a820840c2c530f14bb7fcd41a587f04","modified":1692697933990},{"_id":"source/_posts/OC底层原理/关联对象/关联对象04.png","hash":"47f60adbba87babe7c3dd706410ba08a8066cf17","modified":1692697933989},{"_id":"source/_posts/OC底层原理/内存管理/内存管理01.png","hash":"872a4b70176dfc4a9cd63c5b4d2e75e1dfea96e6","modified":1692697933991},{"_id":"source/_posts/OC底层原理/内存管理/内存管理02.png","hash":"e6c81a3a3685e95607fca947eb2aa852278f9768","modified":1692697933991},{"_id":"source/_posts/OC底层原理/内存管理/内存管理03.png","hash":"505dffb33b4554fc1c310f5037112afcb80047d2","modified":1692697933992},{"_id":"source/_posts/OC底层原理/关联对象/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1590857848484},{"_id":"source/_posts/OC底层原理/内存管理/内存管理04.png","hash":"9733f164b504ebe5ae143cee0088210e27699f78","modified":1692697933992},{"_id":"source/_posts/OC底层原理/内存管理/内存管理06.png","hash":"96ca78349bb28065f735b12a48bacf5901f9a6c5","modified":1692697933994},{"_id":"source/_posts/OC底层原理/内存管理/内存管理07.png","hash":"0b38e74b7cc9469a7af39829872e2ec9eac6fa27","modified":1692697933994},{"_id":"source/_posts/OC底层原理/内存管理/内存管理08.png","hash":"082362932b5b3c9fb2f8a082e161692775a871fd","modified":1692697933994},{"_id":"source/_posts/OC底层原理/内存管理/内存管理09.png","hash":"1c6a910c83d61e8d08909ca7313301ca757a7611","modified":1692697933994},{"_id":"source/_posts/OC底层原理/内存管理/内存管理10.png","hash":"ce6298b0f8562093b98410b85ba69452185ed20f","modified":1692697933995},{"_id":"source/_posts/OC底层原理/内存管理/内存管理11.png","hash":"cd8150c55ee87266fa23e63ddcb5c0580931deaa","modified":1692697933995},{"_id":"source/_posts/OC底层原理/内存管理/内存管理12.png","hash":"f156f0d8e3b720576900c1b37f77d9436df5f5c1","modified":1692697933995},{"_id":"source/_posts/OC底层原理/内存管理/内存管理13.png","hash":"ca18409f4d4156fe9a7d9e882087f9f86d18d1d7","modified":1692697933996},{"_id":"source/_posts/OC底层原理/内存管理/内存管理14.png","hash":"62f43e7b06f818b268696bf50a039b1dc312d73f","modified":1692697933996},{"_id":"source/_posts/OC底层原理/内存管理/内存管理15.png","hash":"6ca3774b9aee453ef38dbd715c82ba0e1325e58d","modified":1692697933996},{"_id":"source/_posts/OC底层原理/内存管理/内存管理17.png","hash":"3983b5db48ba7caa766fb2077f376a71d4e6a398","modified":1692697933997},{"_id":"source/_posts/OC底层原理/内存管理/内存管理16.png","hash":"68a016d4d7f28b78f0f9e47b5a6dad0ce2073ee5","modified":1692697933997},{"_id":"source/_posts/OC底层原理/内存管理/内存管理18.png","hash":"8c16fa2ad254b8f8d020d070ae214e92c649eed5","modified":1692697933997},{"_id":"source/_posts/OC底层原理/内存管理/内存管理19.png","hash":"93b3e9cd3f03c6d0917adc537f6139486316c3ec","modified":1692697933998},{"_id":"source/_posts/OC底层原理/多线程/多线程01.png","hash":"ec010897955961eaccb863b898073ef430c98dc6","modified":1692697934000},{"_id":"source/_posts/OC底层原理/多线程/多线程10.png","hash":"ea06c46f1799056fc9a8dfa6b02eac2093d16d30","modified":1692697934006},{"_id":"source/_posts/OC底层原理/多线程/多线程12.png","hash":"5ed1b6217ad97b86b59fb1a7ef7466bdd9f471cb","modified":1692697934007},{"_id":"source/_posts/OC底层原理/多线程/多线程13.png","hash":"2720508326066057375cd9eeb55294a367ae7d6e","modified":1692697934007},{"_id":"source/_posts/OC底层原理/多线程/多线程14.png","hash":"dbe1b81d8a8de89addc7fa0c1c14b4e4afcfb294","modified":1692697934007},{"_id":"source/_posts/OC底层原理/多线程/多线程16.png","hash":"4b4b7321a7e86acc2ae053c3591fe942e82902c9","modified":1692697934008},{"_id":"source/_posts/OC底层原理/多线程/多线程17.png","hash":"7bb830e3b51e0a1a5cdab7040d3aeba0bc1ebc02","modified":1692697934009},{"_id":"source/_posts/OC底层原理/多线程/多线程20.png","hash":"0086e56a9140a7cb95519eb7e45fb63c89b78689","modified":1692697934011},{"_id":"source/_posts/OC底层原理/多线程/多线程24.png","hash":"23da8b8f961252722c21c2e140230c1537615f97","modified":1692697934014},{"_id":"source/_posts/OC底层原理/多线程/多线程25.png","hash":"e0dc366fce74c0fb880635bbfc2d1da7fb6d7d17","modified":1692697934015},{"_id":"source/_posts/OC底层原理/多线程/多线程27.png","hash":"1d5b1b8651c18f60c015482fa3e568ba8d2f3c9e","modified":1692697934016},{"_id":"source/_posts/OC底层原理/多线程/多线程28.png","hash":"032c5adef66b3aabc447ee6643fc33d7a0ce912c","modified":1692697934017},{"_id":"source/_posts/OC底层原理/多线程/多线程30.png","hash":"457820259fbd4b4d0bed1c9305d6d3ab97a6bbb1","modified":1692697934019},{"_id":"source/_posts/OC底层原理/多线程/多线程31.png","hash":"d6426b9e769cb457b4fa296adc54b1c8fb9e830d","modified":1692697934019},{"_id":"source/_posts/OC底层原理/多线程/多线程34.png","hash":"8ca2c816f519f7c419b488db52c8f139fd5ea754","modified":1692697934022},{"_id":"source/_posts/OC底层原理/多线程/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1595820262197},{"_id":"source/_posts/OC底层原理/多线程/多线程35.png","hash":"bc7daef0b31fae476b8142ab65ededbd5d654770","modified":1692697934023},{"_id":"source/_posts/OC底层原理/多线程/多线程38.png","hash":"ed703eddf4a0c26384d5859eca5c933068ad8b50","modified":1692697934025},{"_id":"source/_posts/OC底层原理/多线程/多线程39.png","hash":"0b185345d7e2d5e74ed8b60e701d8fdb1f69619e","modified":1692697934026},{"_id":"source/_posts/OC底层原理/多线程/多线程40.png","hash":"2e984810422e967dab0036f3b58b6a9109483b50","modified":1692697934027},{"_id":"source/_posts/OC底层原理/性能优化/性能优化01.png","hash":"f13ce7f2e2bec9cc209519c03d96c998eb2a8ccc","modified":1692697934028},{"_id":"source/_posts/OC底层原理/性能优化/性能优化02.png","hash":"79453f4d25c0b15ff433ae8f0ce01ec192be97f5","modified":1692697934029},{"_id":"source/_posts/OC底层原理/性能优化/性能优化03.png","hash":"7898c48d97abb34b3066a2297de3e6e49c9310f5","modified":1692697934029},{"_id":"source/_posts/OC底层原理/性能优化/性能优化04.png","hash":"94fa85ac5cd5d42f77e40edebc158bacb2282388","modified":1692697934029},{"_id":"source/_posts/OC底层原理/性能优化/性能优化05.png","hash":"3676b56bc74afd4923090b61fb3289d2c29f2a60","modified":1692697934030},{"_id":"source/_posts/OC底层原理/性能优化/性能优化06.png","hash":"01368c60c7b3660df84b4ebe57ebba152849d2c8","modified":1692697934030},{"_id":"source/_posts/OC底层原理/性能优化/性能优化07.png","hash":"dc6b41cc06b1a583585f83014f70b7990d20e0d7","modified":1692697934030},{"_id":"source/_posts/OC底层原理/性能优化/性能优化08.png","hash":"d076690560682b281a1fd50059142209798cc4a2","modified":1692697934031},{"_id":"source/_posts/OC底层原理/性能优化/性能优化10.png","hash":"53d9cf952a01d59cb886697069a29057fd2f4cf1","modified":1692697934031},{"_id":"source/_posts/OC底层原理/性能优化/性能优化11.png","hash":"64fba0b5d93c431b6f2f3cec2ed1242eeb48d028","modified":1692697934032},{"_id":"source/_posts/OC底层原理/性能优化/性能优化12.png","hash":"179400820d77e920fd5a5311ab5b5bc6750afc1a","modified":1692697934032},{"_id":"source/_posts/OC底层原理/架构设计/架构设计01.png","hash":"c178f440db76b7c2503ed32c776d73e3b9359823","modified":1692697934033},{"_id":"source/_posts/OC底层原理/架构设计/架构设计02.png","hash":"422f0b1ad8c72f98232b3fd37b576c1f735d3ef6","modified":1692697934033},{"_id":"source/_posts/OC底层原理/架构设计/架构设计03.png","hash":"eeec1e2335ce11fd790233e3f2eb98cf2b936e6a","modified":1692697934033},{"_id":"source/_posts/OC底层原理/架构设计/架构设计04.png","hash":"82385462614a194c436e3747fdda8d9029a60f6c","modified":1692697934033},{"_id":"source/_posts/OC底层原理/架构设计/架构设计05.png","hash":"45f04e6269f314d165cf319274630133234ec45d","modified":1692697934034},{"_id":"source/_posts/OC底层原理/架构设计/架构设计06.png","hash":"b122f60d04f055a383f9d89f765b7467e600f153","modified":1692697934034},{"_id":"source/_posts/OC底层原理/架构设计/架构设计07.png","hash":"aed73d6a3895b771a2c05ee3a4b4e771f4924f94","modified":1692697934034},{"_id":"source/_posts/OC底层原理/架构设计/架构设计10.png","hash":"c5988c9b4b50a9b9f7ab6d09c2d9d32ab8abbb53","modified":1692697934035},{"_id":"source/_posts/OC底层原理/架构设计/架构设计11.png","hash":"256e814234d2d6190a308d3b2c78e3881c2c7f94","modified":1692697934036},{"_id":"source/_posts/Other/Apple官方文档阅读指南/03.png","hash":"f6326cb55f4c5b3a15806d8132851f1648fecb3d","modified":1692697934040},{"_id":"source/_posts/Other/Apple官方文档阅读指南/05.png","hash":"504646784b14ece8af1c0699aa4bdb33c56c8da6","modified":1692697934040},{"_id":"source/_posts/Other/Apple官方文档阅读指南/06.png","hash":"11a7cdfd1d1ea46775e63de4e14e7d79e401297c","modified":1692697934041},{"_id":"source/_posts/OC底层原理/架构设计/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599546271708},{"_id":"source/_posts/Other/Apple官方文档阅读指南/22.png","hash":"208fea826785e5debe2d95884876ae4d6fe784ff","modified":1692697934044},{"_id":"source/_posts/Other/Apple官方文档阅读指南/23.png","hash":"b1baf4c45d60a323330f98141fb9613656020a66","modified":1692697934044},{"_id":"source/_posts/Other/Apple官方文档阅读指南/24.png","hash":"4d116a18213c82d4eaf10cdaa6a3efdb426507d3","modified":1692697934045},{"_id":"source/_posts/Other/Apple官方文档阅读指南/25.png","hash":"5c0348f2754cbe4a23ef5dc818c42ca32d2017e0","modified":1692697934045},{"_id":"source/_posts/Other/Apple官方文档阅读指南/26.png","hash":"9d969c4c55738c11b149e0c60a4f9600f1ea0517","modified":1692697934045},{"_id":"source/_posts/Other/Apple官方文档阅读指南/27.png","hash":"2f4434a776ac254d4ac220d4492377fdeeaa9dd6","modified":1692697934045},{"_id":"source/_posts/Other/Apple官方文档阅读指南/28.png","hash":"cf0e40c598af4e1c923d60510ace2b2ea6f2926d","modified":1692697934045},{"_id":"source/_posts/Other/Hexo安装笔记/Hexo安装笔记02.png","hash":"f53701ed005cb216371c732eb4257f4781581938","modified":1692697934048},{"_id":"source/_posts/Other/Apple官方文档阅读指南/29.png","hash":"cab00774e6fa079c61edd623c940d3869052f9d9","modified":1692697934046},{"_id":"source/_posts/Other/Hexo安装笔记/Hexo安装笔记01.png","hash":"ac679f31f7d46acbb756eaa9f22d587a906f6992","modified":1692697934047},{"_id":"source/_posts/Other/Personal blog/gitalk.md","hash":"92f13aa6c044189b5ee2fcca5efd9970bf0860d4","modified":1692697934050},{"_id":"source/_posts/Other/Personal blog/.DS_Store","hash":"9461b1a3d48c0e4389cb722da2c042a5deb6af4c","modified":1602379712237},{"_id":"source/_posts/Other/不二医疗/不二医疗技术支持网址.md","hash":"b414d175c19447e0dd4ba14789577de9a7e51ed1","modified":1692697934053},{"_id":"source/_posts/Other/不二医疗/不二医疗隐私政策.md","hash":"3e57c9727a8e12fe2570c5e99f7679fdb81c5c0b","modified":1692697934053},{"_id":"source/_posts/Other/微信小程序/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1618282331941},{"_id":"source/_posts/Swift/Swift简介/18.png","hash":"06515febbb4c1c127d960a43e9227674d8e73a88","modified":1692697934131},{"_id":"source/_posts/Swift/Swift简介/Swift01.png","hash":"b27a59bcc4f1768d2a94f545f5e35e07bdd6c4e5","modified":1692697934132},{"_id":"source/_posts/Swift/Swift简介/Swift03.png","hash":"1341f1efc0bb964d9e009d1b90618178cd512204","modified":1692697934133},{"_id":"source/_posts/Swift/Swift简介/Swift04.png","hash":"0bffd084b7b1dbc2454f27e8867d1a03944af4b4","modified":1692697934133},{"_id":"source/_posts/Swift/Swift简介/Swift09.png","hash":"72087527ec711622e86a8125b90ecb403090cd64","modified":1692697934137},{"_id":"source/_posts/Swift/Swift简介/Swift11.png","hash":"0bab883e4244011f007fa98d961c307a1b4a9f9f","modified":1692697934138},{"_id":"source/_posts/Swift/函数和闭包/05.png","hash":"913c9d3c1c1fa687e750b7e46942268a7de01101","modified":1692697934143},{"_id":"source/_posts/Swift/函数和闭包/06.png","hash":"db559f0d071e3355d43314c381949a6f3ff16529","modified":1692697934144},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType01.png","hash":"b96ee5b905251fc6f848a7e566cf0ce7d8398eef","modified":1692697934147},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType02.png","hash":"381d0e6f08e946d6d534ada2a297d7787e9913b2","modified":1692697934147},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType03.png","hash":"c927baebdd594a530997869920de7ec446b35d2f","modified":1692697934148},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType04.png","hash":"df31351a84ad90d2435335a7dcda8677a03e4a15","modified":1692697934148},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType06.png","hash":"1ffa411b5103d7db92d5a01ec3173dc9fc5c03da","modified":1692697934149},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType07.png","hash":"92fc517f386ad97e976fafb8d0e45eff0cf889fe","modified":1692697934149},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType08.png","hash":"0d2f2a0bd80a7e48f6913e1ee6f05ceea41ecea7","modified":1692697934150},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType09.png","hash":"6619410412012db47a8d7e6211c25feabb8413a3","modified":1692697934151},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType10.png","hash":"06829cc2b40f8d839851e8601b8ef96e4c411f04","modified":1692697934151},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType11.png","hash":"18f5954c10a029e3362de0cc2704d4bc434fd01c","modified":1692697934151},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType12.png","hash":"b547da053cdb1eed4fe224bd789e296c340c504b","modified":1692697934152},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType13.png","hash":"f319a954315049fd0ef0a9c32a2414e4fed13144","modified":1692697934152},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType15.png","hash":"6f27e3610d75068b8d0812a8694e998475a60ad7","modified":1692697934154},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType16.png","hash":"45ade830eaa6bff89989cee80fda0950fdfce77b","modified":1692697934154},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType17.png","hash":"f365ede125a81a55acb0a06a39d26ee5696cbda3","modified":1692697934154},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType18.png","hash":"cf087385ad14c6a829d84fd4b67c3e0e021f723b","modified":1692697934155},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType19.png","hash":"b6bc72449a18c648ddd07014c799220ac8fbd8b5","modified":1692697934155},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType20.png","hash":"88109152f8769ca7c2dce0383ff67a39f745f3ff","modified":1692697934156},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType21.png","hash":"e9f8b5d346538972b55527c1f6fb8091e3643edb","modified":1692697934156},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType24.png","hash":"99785b2ff6bb5969b654e44892ae8fa2be69bbdf","modified":1692697934158},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType30.png","hash":"b3a7b933f48da2331dcd751d675b1b3ab25efc63","modified":1692697934162},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType29.png","hash":"a735b8c48dd7533cf6e2ff7b8077629c73fec9d6","modified":1692697934162},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType31.png","hash":"27aaea6d8b6e8b7ed4cbf2579ef2d5a62665a5b6","modified":1692697934162},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType32.png","hash":"32154f6c9875f5dc6d09a69c2911dfece308382b","modified":1692697934163},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType33.png","hash":"17e9e22989704235af264ccbfde1b1b84ab41fc7","modified":1692697934163},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType37.png","hash":"44da73edbc4f8067375fe61cde7ad085158d4376","modified":1692697934167},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType38.png","hash":"4e4cc132e87b966d727e093be20040a6275c5a86","modified":1692697934168},{"_id":"source/_posts/Swift/流程控制/01.png","hash":"ebe4ee565237d08540ea7585223d03f61cacef99","modified":1692697934171},{"_id":"source/_posts/Swift/流程控制/02.png","hash":"182f06dc61b199c7c4f1814d3eee2ecf27aa254b","modified":1692697934171},{"_id":"source/_posts/Swift/流程控制/03.png","hash":"34baffa0574b2670e084078578020a65c76c3eac","modified":1692697934172},{"_id":"source/_posts/Swift/流程控制/04.png","hash":"e8c6ab367b89d6311e92b4eefc8cbd5ea4b90a82","modified":1692697934173},{"_id":"source/_posts/Swift/流程控制/06.png","hash":"75db2dd433567e312dd3e8f4202a9b633d89e424","modified":1692697934175},{"_id":"source/_posts/Swift/运算符/02.png","hash":"e63ff373799073259bee1c171d1736acaa03eb9f","modified":1692697934179},{"_id":"source/_posts/Swift/运算符/03.png","hash":"5456d7fb67c817217e1cfd93bed7fa10e785e8ef","modified":1692697934179},{"_id":"source/_posts/Swift/运算符/04.png","hash":"e5a1ea197246ebcbf25d24b959a7ec10287f545d","modified":1692697934180},{"_id":"source/_posts/Swift/运算符/05.png","hash":"53990934a4f029c3809a3a064cec97778face6c2","modified":1692697934180},{"_id":"source/_posts/Swift/运算符/06.png","hash":"6ad9b1cd25082a06d84573d04494fab68e24812e","modified":1692697934180},{"_id":"source/_posts/Swift/运算符/07.png","hash":"fc755d7d341d2750e9356addfd7000bc35141b7b","modified":1692697934181},{"_id":"source/_posts/Swift/运算符/08.png","hash":"fb756a7bede6c26aa389b352b87692b133ca47c8","modified":1692697934181},{"_id":"source/_posts/Swift/运算符/09.png","hash":"e4226ee3b2438338eecaae6ec751fc04b04aa0db","modified":1692697934182},{"_id":"source/_posts/Swift/运算符/10.png","hash":"c275858ebccd9eb30cfcda5dedc7483016c69520","modified":1692697934182},{"_id":"source/_posts/Swift/运算符/12.png","hash":"3a0538ccc623df17667b35468c7c677d468cf33b","modified":1692697934183},{"_id":"source/_posts/Swift/运算符/14.png","hash":"8795800d81380bffcdb82c4d8cfcfb19d452e8a4","modified":1692697934184},{"_id":"source/_posts/Swift/运算符/11.png","hash":"60f36c8669d42c8aa3a23cd25d6624220f20ac8c","modified":1692697934182},{"_id":"source/_posts/Swift/运算符/13.png","hash":"08c9aaa689ba23b7626c3ea0e8e51b665c872cf8","modified":1692697934183},{"_id":"source/_posts/Swift/运算符/15.png","hash":"f926b8f124d55183b1c335cd68377a71098bb14c","modified":1692697934184},{"_id":"source/_posts/Swift/运算符/16.png","hash":"11a1ac7998537968eeff8dd8164c482d11f69e72","modified":1692697934184},{"_id":"source/_posts/Swift/运算符/17.png","hash":"1d790a42a00522ccd1793faab692218ffbcec793","modified":1692697934185},{"_id":"source/_posts/Swift/集合类/01.png","hash":"8b9a2e2cd1e616bff42ceccd6f036d6683f35557","modified":1692697934186},{"_id":"source/_posts/Swift/集合类/02.png","hash":"aed490a3217ae69a5f565a3622e08c0810aeb368","modified":1692697934186},{"_id":"source/_posts/Swift/集合类/03.png","hash":"b62d81c00846dc261073a6c939f9ebc37dcad047","modified":1692697934186},{"_id":"source/_posts/Swift/集合类/04.png","hash":"9e0568d47ae781a0fdda1825a273e4ba6fac2790","modified":1692697934186},{"_id":"source/_posts/Swift/集合类/05.png","hash":"b3f57ffa67a54dac01b3be947a839c2ab827f639","modified":1692697934187},{"_id":"source/_posts/Swift/集合类/18.png","hash":"d5994b565874f0388f95641e425b5f788d25595b","modified":1692697934197},{"_id":"source/_posts/Swift/集合类/19.png","hash":"4d51ee1019e9ae242863f06ba9be0e8d67cc36e6","modified":1692697934197},{"_id":"source/_posts/Swift/集合类/20.png","hash":"f7e2f9cc34204f68c3d6f844db348b73280133d0","modified":1692697934197},{"_id":"source/_posts/Swift/面向对象编程/01.png","hash":"54cba89ad3d7477c8c07b8ff2510a5fb3e061ef8","modified":1692697934210},{"_id":"source/_posts/Swift/面向对象编程/02.png","hash":"a5b82be3d68ce5020ba40f9b8adf854e197e4bd8","modified":1692697934210},{"_id":"source/_posts/Swift/面向对象编程/05.png","hash":"01c29df0e76839f7a0e7f774437c0589eb0dc71c","modified":1692697934212},{"_id":"source/_posts/Swift/面向对象编程/04.png","hash":"fce2bed850a137b38db9d6e2839142b80b6a4347","modified":1692697934211},{"_id":"source/_posts/Swift/面向对象编程/06.png","hash":"8b866a39004d26450217e2f44f277a554f6de29b","modified":1692697934212},{"_id":"source/_posts/Swift/面向对象编程/07.png","hash":"84569e817f73a25a0b972eec6bfb7d462ac5cc44","modified":1692697934213},{"_id":"source/_posts/Swift/面向对象编程/08.png","hash":"c50260c91896714545524277097684aa6a843fc6","modified":1692697934213},{"_id":"source/_posts/Swift/面向对象编程/09.png","hash":"83d6a2cb44bbc43fd5afcd317f6fc0f045b38230","modified":1692697934214},{"_id":"source/_posts/Swift/面向对象编程/10.png","hash":"745472bbb9d25eb5c6d2c277600d8b747f06d566","modified":1692697934215},{"_id":"source/_posts/Swift/面向对象编程/12.png","hash":"707514816087abf9649ae7ff4c169372c281567f","modified":1692697934216},{"_id":"source/_posts/Swift/面向对象编程/13.png","hash":"179bf9ae3f69a823a106c4b2262435e186574207","modified":1692697934217},{"_id":"source/_posts/Swift/面向对象编程/17.png","hash":"e8008ea92ab650d40147661a2f492e069b860f93","modified":1692697934220},{"_id":"source/_posts/Swift/面向对象编程/16.png","hash":"9b3a5eebb4d8b2395bbcb5d39260c8e4a8c68044","modified":1692697934220},{"_id":"source/_posts/Swift/面向对象编程/15.png","hash":"239bf910491845d8a1b78308c401b62564c433b1","modified":1692697934219},{"_id":"source/_posts/Swift/面向对象编程/18.png","hash":"522d445f22295d381e6b2de930b2a983dae9cdfa","modified":1692697934221},{"_id":"source/_posts/Swift/面向对象编程/19.png","hash":"25f044664daf14954506dc7742fa5e0314222bf5","modified":1692697934221},{"_id":"source/_posts/Swift/面向对象编程/21.png","hash":"7b3b9fb9dbc7f44453124ab7ae5b451a2311a69f","modified":1692697934223},{"_id":"source/_posts/Swift/面向对象编程/22.png","hash":"dd789603c7f2f44ffa6533f3146a714db72b8ae3","modified":1692697934224},{"_id":"source/_posts/iOS/AFHTTPSessionManager/AFHTTPSessionManager.md","hash":"9167dab1c3dc4c76b43e8a608b0b17f4a6d1c2fd","modified":1706871873134},{"_id":"source/_posts/iOS/UIBezierPath/01.png","hash":"e47dd88520a58a1217c38d0632dabbfea50f7327","modified":1706843252000},{"_id":"source/_posts/Swift/面向对象编程/23.png","hash":"c169e8133a092d761bcec6772f90317a015feb84","modified":1692697934225},{"_id":"source/_posts/iOS/UIBezierPath/02.png","hash":"bea331bf7c85b1872fc978d73d22d32a6245b9b0","modified":1706843252000},{"_id":"source/_posts/iOS/UIBezierPath/03.png","hash":"cd52c00495f2b05f3c0a08deb75e2d0ac8a5ad1a","modified":1706843252000},{"_id":"source/_posts/iOS/UIBezierPath/04.png","hash":"423089b0a485325b33bb6349035aee282ad9c9d7","modified":1706843252000},{"_id":"source/_posts/iOS/UIBezierPath/05.png","hash":"46e2c50ffbdc3c65fa19f9b1e48243183189a1ef","modified":1706843252000},{"_id":"source/_posts/iOS/UIBezierPath/06.png","hash":"97593abb66eb9265d728dcd7e848c3832ecb4b27","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/07.png","hash":"61b79a399b409bbc8b6711d138d8797828db8cf6","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/08.png","hash":"1c7da951c7a09a21abb03902cd0110013587ac69","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/09.png","hash":"165f669f61479371c7ddb9a05179704ef7676350","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/10.png","hash":"3aaf43aa2b547196ec8e2f85d57bc7dc9668f759","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/11.png","hash":"56f50553243e5c863d68f8b4fc11bc713c759122","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/12.png","hash":"ebb94c1aa62bafa2be2d3e88cb89f666195cbb5e","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/13.png","hash":"4a2c9f64e349f6dc860f6ce847bc511ef3fe4c84","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/14.png","hash":"ca5f0f8f7246395391c171f1fe4a427ec312737a","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/15.png","hash":"9895cdd395be3c4c3a58aeddd6e741f4984c07a4","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/16.png","hash":"886ce001d648b1a84bdc0e43efa4783aa328a873","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/17.png","hash":"c36fbdf117055307205af3d69e973799d41fc42e","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/19.png","hash":"12b614ebf6b2086b12fedadbcec16f109840103e","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/18.png","hash":"36e74faabc031815c8ab6c5a6a85b9fa20c3fdf6","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/20.png","hash":"e7903234cbe229174b487caf78ef6c8792d503fd","modified":1706843254000},{"_id":"source/_posts/iOS/UIBezierPath/22.png","hash":"d479ff5c9209159f789f65abd9f44043960aaf68","modified":1706843292000},{"_id":"source/_posts/iOS/UIBezierPath/21.png","hash":"c144f70c526e6bdc9ab0e8b36d1990a41364ffce","modified":1706843292000},{"_id":"source/_posts/iOS/UIBezierPath/23.png","hash":"deca52b974a147a40cfc5e576964ab8b063a1988","modified":1706843292000},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation02.png","hash":"0b38b67c0c14e45cbc46aceef7a712e577022079","modified":1706871873159},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation03.png","hash":"62222622ab50842eff8e91cf1f9e3ab9b5d22e1e","modified":1706871873159},{"_id":"source/_posts/Swift/面向对象编程/24.png","hash":"738c0ba68dfc5cd79eaac33b379e6c00eb675e0f","modified":1692697934226},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树01.png","hash":"4377eac7bfae1575a5fb57d980ab94f054827568","modified":1692697934229},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树07.png","hash":"4e0987154f82d5e4b804dbd3e41ed64c649e343d","modified":1692697934233},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树08.png","hash":"ce1e75ac83530601633412bc6ac7cf6e4bc33be2","modified":1692697934234},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树12.png","hash":"725e311093a6a1da8899670c87842df28d9a7d6c","modified":1692697934236},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树15.png","hash":"32b8dd0d83e1bb58e645e931726558edc873e343","modified":1692697934238},{"_id":"source/_posts/数据结构与算法/AVL树/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1611653919550},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树18.png","hash":"f763dda91062f0b358e35a329b7d096e8847e9eb","modified":1692697934241},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树21.png","hash":"fc1270a68fe5a3e642e126cb42d0e2460c67e184","modified":1692697934243},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树24.png","hash":"4ebcaaecf53ceef50ac928e3505a3b0979cd4731","modified":1692697934246},{"_id":"source/_posts/数据结构与算法/B树/B树09.png","hash":"a62d8ffb4f8093f1f36ec71eeea65bc29ee87427","modified":1692697934253},{"_id":"source/_posts/数据结构与算法/B树/B树10.png","hash":"0e75908b01c394e88da97f76d52279e5b4b5a6d7","modified":1692697934253},{"_id":"source/_posts/数据结构与算法/B树/B树11.png","hash":"f63525a8f5f379dde26f78b38ceade3adb18c6b6","modified":1692697934254},{"_id":"source/_posts/数据结构与算法/B树/.DS_Store","hash":"67e8516298a2229d23252284b873196812aff655","modified":1614671425295},{"_id":"source/_posts/数据结构与算法/B树/B树17.png","hash":"de1aaf1ae342788bfda6a07d111906e871ce482b","modified":1692697934256},{"_id":"source/_posts/数据结构与算法/B树/B树18.png","hash":"b70204f0facebcf779706290bc255b9e19dc080c","modified":1692697934256},{"_id":"source/_posts/数据结构与算法/B树/B树19.png","hash":"104df4adf5af7694283070a30e9b560d48aa4161","modified":1692697934256},{"_id":"source/_posts/数据结构与算法/B树/B树20.png","hash":"75384f50c5fb964628a74c5c45f7875c5507d539","modified":1692697934257},{"_id":"source/_posts/数据结构与算法/B树/B树21.png","hash":"295874a3220391cb1e35096ec4910681d518442f","modified":1692697934257},{"_id":"source/_posts/数据结构与算法/B树/B树25.png","hash":"0f175e2c59cbb470036d50c1610102c5cf31c86e","modified":1692697934259},{"_id":"source/_posts/数据结构与算法/B树/B树26.png","hash":"76bea47e1d379cf6d511fd9ab46affd4ccb11377","modified":1692697934259},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树01.png","hash":"8bce7bbd384d7c88c4e83bb8375fb2e45e6f56c8","modified":1692697934266},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树02.png","hash":"d918137fb702777730387e424f351b9ebd1954b5","modified":1692697934267},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树07.png","hash":"47c9f900273c778534026784e68e670560d040a0","modified":1692697934270},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树06.png","hash":"f320a1ce14226c2b52642b2909b88110354d393e","modified":1692697934270},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树08.png","hash":"334dfba8faff4b1d29c5eaede297041e5d8f139a","modified":1692697934271},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树09.png","hash":"98faee0c2c03481f0f8b5d5cd9340de8930b8202","modified":1692697934271},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树10.png","hash":"5dd750004dcaed676632443c12058496ed8876ad","modified":1692697934271},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树14.png","hash":"c5dc0e7b8e4e0457f7fa34280b2916a184e01e07","modified":1692697934275},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树15.png","hash":"2a341859162faea16bb270e9347ed7b208959bc3","modified":1692697934275},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树16.png","hash":"7aeb26c30d1fd16d0e6edd501e957da40011eab8","modified":1692697934276},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树18.png","hash":"ed5e135c39cdd926939f06df998eb9f91d5a1adf","modified":1692697934277},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树17.png","hash":"dc16243c9cdee857f7b5c48468d68a9caddde1f5","modified":1692697934276},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树19.png","hash":"4dcbaf93964cd3d090c5564237be6abe47dbc015","modified":1692697934277},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树20.png","hash":"e45a2df06dbe7cb071cee15ca926a434e0a6b1e3","modified":1692697934277},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树21.png","hash":"0c254b10a0d447d8a82b5e47cac724c1634ab3a7","modified":1692697934278},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树22.png","hash":"dafcfd7ee5f276671dde4aa07ff2e7a013de8e2a","modified":1692697934279},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树24.png","hash":"a01f2d7da5d240ef6d25272b8a4b22107b068c35","modified":1692697934280},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树25.png","hash":"bfe3d3410839bb1e89d789c2aefab8a0759637b1","modified":1692697934280},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树23.png","hash":"9c606a7b89e4cccb02a54916a94ea80ec5876e9d","modified":1692697934279},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树26.png","hash":"66e1887e84d3ca7e3a9f292cb51fce217b2c0ee5","modified":1692697934280},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树01.png","hash":"7af6ae6453d7787d80da685c6752c8085ee7023f","modified":1692697934281},{"_id":"source/_posts/数据结构与算法/二叉树/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1605521273635},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树06.png","hash":"8fc3722ac0c66333bede52f88d34e21dc974ab6b","modified":1692697934283},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树10.png","hash":"ac2d0b6d73b5056618aedb11807367cda8faa139","modified":1692697934285},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树09.png","hash":"69239c5003f2c1bb1653e800c6763a77c074973c","modified":1692697934285},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组01.png","hash":"6cb3ea026bf172407a35cb5aa870541cf6a8f846","modified":1692697934289},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组03.png","hash":"dea89eaa0295493b4221462bbf943eb5b9080e1f","modified":1692697934290},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组05.png","hash":"a797d888b850792365d633673b8b7f283a995877","modified":1692697934291},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组06.png","hash":"f18c60e187dfdcb1ca0fd3e9a8233c2049156ca0","modified":1692697934291},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组07.png","hash":"6ce232885c758c6d502446f07c3d5b16c4b339dc","modified":1692697934292},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组08.png","hash":"7c9594cc82e5761823fff099c700a7218b4021df","modified":1692697934292},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组09.png","hash":"5bfe8fcc58dd3acb9f3ed1c78460b128f6667e11","modified":1692697934293},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度03.png","hash":"7c43cf7595acad3866a15fd160b7dad80c59d7e6","modified":1692697934300},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度05.png","hash":"5c2a598c0fd4cc35c1919cad1f569cb3596c1a93","modified":1692697934303},{"_id":"source/_posts/数据结构与算法/栈/栈03.png","hash":"d612856d9ed3a0d63db2def37b4c6e7008d59f7d","modified":1692697934305},{"_id":"source/_posts/数据结构与算法/栈/栈02.png","hash":"c9811d6d9c1084c0437ef7c8aa0564fd1e131825","modified":1692697934305},{"_id":"source/_posts/数据结构与算法/栈/栈04.png","hash":"6cdc4f18b725c826ed7bc5d901cc282071c1ada8","modified":1692697934305},{"_id":"source/_posts/数据结构与算法/栈/栈05.png","hash":"facb534f2567e65c1034877dfcd5ed099bda1a1a","modified":1692697934306},{"_id":"source/_posts/数据结构与算法/栈/栈06.png","hash":"fc6620094c0ab882d32a46a19f72765a8ed4b1f7","modified":1692697934306},{"_id":"source/_posts/数据结构与算法/栈/栈07.png","hash":"65654c3ef043992606e4ef796b3be821620531ca","modified":1692697934306},{"_id":"source/_posts/数据结构与算法/栈/栈08.png","hash":"fa97bdc4d6c54c3d1d1b7fb97e8cf6efec3e6d6b","modified":1692697934306},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建01.png","hash":"5224006d09147f2cf982b0687a9de03d81e52210","modified":1692697934307},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建02.png","hash":"51d26ac427ff0fb73179969fbcf6c49990431b50","modified":1692697934307},{"_id":"source/_posts/数据结构与算法/栈/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1604041405191},{"_id":"source/_posts/数据结构与算法/复杂度/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1602577071012},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建03.png","hash":"5b8d2c990587dd9c0c26108a29051746262ab62c","modified":1692697934307},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建05.png","hash":"0281f42ff527a950e9f7d8be25ee8709e7f9b2f3","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建04.png","hash":"ed4ddec819ecb0773b6d3da075e35f6f5ed93aaf","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建07.png","hash":"7a36df32be821fcf301f5c8077c4064a38eea8b9","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建06.png","hash":"a38fcf4c46c6b082e314fc63921834ce5a86efd4","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建08.png","hash":"eb1ccb8de354cd3a84fc2d347ada402c49bf27b9","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建09.png","hash":"fbb2b0ef5e8c670d12fa24c95c6921224f3687de","modified":1692697934308},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建10.png","hash":"5ff870dbdf8cba7c938b8411b7cc06b7974c9ad9","modified":1692697934309},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建11.png","hash":"a8f5bac4395b5251ae41a27ea6b77dc12a16f033","modified":1692697934309},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建12.png","hash":"05bdb6c2cf418854edce08f2d2478d31af4b94b0","modified":1692697934309},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建13.png","hash":"3ee869def6c3f549c14683b45e2f952302b4d0b7","modified":1692697934310},{"_id":"source/_posts/数据结构与算法/环境搭建/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1601374127102},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建26.png","hash":"7491ca9733c82ed189167864985610711cf63f9a","modified":1692697934330},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建29.png","hash":"e13ad3ce5ec384f562357359f0b1ee0c05b1374c","modified":1692697934333},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建30.png","hash":"df87c45cc134ff375b37a22bccea366ed933b1ba","modified":1692697934333},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建31.png","hash":"c8bc99cbdf9ce5ecad51676464dd6a6d92d5a0ff","modified":1692697934334},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建32.png","hash":"dd6c92d7c8d5a87f90e6073f5339b99ca7bfe5fc","modified":1692697934334},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建33.png","hash":"5fc6e1f0d920b17ef940aa595a7fbbc9959d428c","modified":1692697934334},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建34.png","hash":"c119fedaef1ba00c1267e2e7b59f90d0582e8b68","modified":1692697934334},{"_id":"source/_posts/数据结构与算法/链表/链表04.png","hash":"a5acbdb5491c098dbf47599137d104b20044b622","modified":1692697934340},{"_id":"source/_posts/数据结构与算法/链表/链表11.png","hash":"1251952f0c175a9ebbafa48ea4a5225bcaf8a9a9","modified":1692697934344},{"_id":"source/_posts/数据结构与算法/链表/链表17.png","hash":"61013a1cdc682adf3b733e67c2875f48e00ae9e0","modified":1692697934349},{"_id":"source/_posts/数据结构与算法/链表/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1603952924637},{"_id":"source/_posts/数据结构与算法/链表/链表19.png","hash":"6268e971e2084c566e2bfc3ddec823cc83a3d7d6","modified":1692697934350},{"_id":"source/_posts/数据结构与算法/链表/链表23.png","hash":"b774bce9d00ce48ec4e9baf97427e0e87af5ce7d","modified":1692697934353},{"_id":"source/_posts/数据结构与算法/链表/链表30.png","hash":"55d3a0ddc365570c4d35563e55d14c0aa0e33a1f","modified":1692697934358},{"_id":"source/_posts/数据结构与算法/链表/链表32.png","hash":"dbcb47b6f05b67ff587678650a01f3a1adcbb117","modified":1692697934359},{"_id":"source/_posts/数据结构与算法/链表/链表33.png","hash":"973eec839782e5b9824621727d0b42660b5183b6","modified":1692697934360},{"_id":"source/_posts/数据结构与算法/链表/链表34.png","hash":"2db197da1b219ba23897fa4eb624c6672e1fd82f","modified":1692697934360},{"_id":"source/_posts/数据结构与算法/链表/链表35.png","hash":"a9e51919ddc24fbefc9cbd783fd451ff114dd538","modified":1692697934360},{"_id":"source/_posts/数据结构与算法/队列/队列01.png","hash":"c7fc5de11d7658760cf6dc94f1bace3fffc92162","modified":1692697934369},{"_id":"source/_posts/数据结构与算法/队列/队列02.png","hash":"7b83e24bf7fe90ce90c91ddc11128cad45681d29","modified":1692697934369},{"_id":"source/_posts/数据结构与算法/队列/队列03.png","hash":"24b0eff715d2a050aebb7a120411ed852a0415d4","modified":1692697934370},{"_id":"source/_posts/数据结构与算法/队列/队列04.png","hash":"16ff7cbcd8086b0abda898028a15974c12e0a9d3","modified":1692697934370},{"_id":"source/_posts/数据结构与算法/队列/队列06.png","hash":"185f2314baee49229b258b463616714fd11376d4","modified":1692697934371},{"_id":"source/_posts/数据结构与算法/队列/队列05.png","hash":"2da354a7bd3251787b6f1a4198d2a0605968a666","modified":1692697934371},{"_id":"source/_posts/数据结构与算法/队列/队列07.png","hash":"970c403e29ce5f52b5c8ccee0f576ae94a642313","modified":1692697934372},{"_id":"source/_posts/数据结构与算法/队列/队列08.png","hash":"1895c667158597bd25baca817fccdc859230a67c","modified":1692697934372},{"_id":"source/_posts/数据结构与算法/队列/队列09.png","hash":"ae93d45512cbf9c0a5481413d8588dc7fc2842c5","modified":1692697934372},{"_id":"themes/next/.git/objects/c9/091cb3a1443bc6b79f41617f80a7c3b61cc931","hash":"346b8b052b87ce5fdd70dbe7171289b3c927df31","modified":1679887307931},{"_id":"themes/next/.git/objects/33/8ae65b0b4ebd06f628c13cba624158baebbddc","hash":"5f83ad6ee2c97827b036ff1064e99c6952972154","modified":1679887307932},{"_id":"themes/next/.git/objects/f9/d899a74fb83511858e1766d2fd1a845d9ec1f5","hash":"5a80bab3f9379b267dbac7e14ab312826b8f152a","modified":1679887307933},{"_id":"themes/next/.git/objects/pack/pack-2fa19a2eea8e092a2b695a31d08f62770ed8b196.idx","hash":"719d762a75f5eb556114b28cf8e693a8135d99b6","modified":1579327672989},{"_id":"themes/next/.git/refs/heads/master","hash":"13d37f01583769457bc3fe358d073c15dca3c674","modified":1506508854000},{"_id":"themes/next/.git/objects/66/ca1aa9e02618f354d401107cc5bf0d209be4a2","hash":"7b2ed3fa0ec4af6d4b0ea2b7e78dabd9a42d85dd","modified":1679887307931},{"_id":"themes/next/.git/objects/9c/8cea69bf0d4f91c07779d71b01814b27bbb6a1","hash":"89ab85747b40158a89befb98886d47b4157e3704","modified":1679887307930},{"_id":"themes/next/.git/refs/tags/v5.1.4","hash":"66e8b5048a20ce41a8a240072e535d725d62aef4","modified":1579327673021},{"_id":"themes/next/.git/refs/tags/v5.1.3","hash":"5eec1427a836e6e34c81dc784bafb33c2ccf48f9","modified":1579327673021},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1506508854000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1506508854000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1506508854000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1506508854000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"6359c84aaa02c90be60b22abe638b737ddd69c9c","modified":1506508854000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1506508854000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1506508854000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1506508854000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1506508854000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"eaa4b101c5884e466705ce5bc02c50e718a43629","modified":1506587770000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1506508854000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1506508854000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1506508854000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1506508854000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1506508854000},{"_id":"themes/next/source/js/src/motion.js","hash":"da146caf488078a634d961debf2a71ce4106018c","modified":1506508854000},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1506508854000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1506508854000},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1506508854000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1506508854000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1506508854000},{"_id":"themes/next/source/js/src/md5.min.js","hash":"82b78f37f1d00a802faab4d2fa8d0ac19d5ea073","modified":1602377918214},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1506508854000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1506508854000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1506508854000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1506508854000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1506508854000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1506508854000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1506508854000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1506508854000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1506508854000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1506508854000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1506508854000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1506508854000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1506508854000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1506508854000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1506508854000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1506508854000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1506508854000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1506508854000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1506508854000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1506508854000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1506508854000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1506508854000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1506508854000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1506508854000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"069b3e919e883465f3f89665df6e5c360501c19b","modified":1579351483992},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"9f4ed36c73e890909b8ebbe601fb60e13d048288","modified":1506508854000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1506508854000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1506508854000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1506508854000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"a28fa39dde1526098e3685e599d796fdb372a3c4","modified":1602378636121},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之初见/08.png","hash":"6356356a75e74b824c7f2e0479cda6ed4d35fc8e","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/21.png","hash":"e7cd8ed875af605312a0e4a8d9958cc08753a1f0","modified":1698197762000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/17.png","hash":"1c481ebde537d06f427ae2f29a972b1bf031aa60","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/18.png","hash":"39ae64cfdc5713e38c182a315269e886c14ba940","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/16.png","hash":"5a03ce4760a701ebf65ee907a09030a137b5c8b8","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/19.png","hash":"1c6e7154e6cb9c3eef275239621ecc90f2da8e70","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/20.png","hash":"351d0f3177e2b692370d438943c92189bbb8a5cc","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之布局/05.png","hash":"34d115106337f1a78a54b43c9052a9849bd5cf81","modified":1701076173717},{"_id":"source/_posts/Flutter/Flutter之环境搭建/01.png","hash":"445c1dfe468150f5fc900384032948527e4506ca","modified":1697067104000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/06.png","hash":"d38e7b6e76cc814658e9cd1812c1c9d14c7578f1","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/08.png","hash":"ad7c5b7d95c1871004b7ef511fb58bb5c550af7b","modified":1697067106000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/11.png","hash":"53918663c5ab548090b7e6cd4e14368b6c77e1a6","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/14.png","hash":"f0b046056291a02a72021dd0b9c3de4951939d47","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/13.png","hash":"6b82da5e15f523e0399d24d55b86e3c03f1211d5","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/16.png","hash":"f0e235d29f4238cb7e3725bb1bcccb2963dfeb43","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/17.png","hash":"267f5577af22f7a69fc17fefba8f2628c225c64b","modified":1697067460000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/22.png","hash":"dfa032a9c98e148f28f3d4a27c74d3134a2a299a","modified":1697067506000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/23.png","hash":"8db5ba57ec2dbaf33d157da7d5b0c788761cd519","modified":1697067506000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/35.png","hash":"0226d0caa4323a4627031a631e59778e9877cf1f","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/38.png","hash":"6c73927a7006fa689d90133894080825a7ff418a","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/40.png","hash":"d24bdea006aac765680b1782827acc8e512ca66d","modified":1697097895536},{"_id":"source/_posts/Github开源框架/Masonry/01.png","hash":"54750a23ace84a306009d198786247dc715bde1a","modified":1692697933913},{"_id":"source/_posts/Github开源框架/Masonry/04.png","hash":"ec143e549936e0cefb0d1e5de363861e3939bda9","modified":1692956860365},{"_id":"source/_posts/Github开源框架/Masonry/05.png","hash":"3a410d4ecb0b298f47a161f6dd5911b310a25ddc","modified":1692956860377},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理04.png","hash":"e097f6fc59f284dfa9a78bf48bb5e7b73856b3a2","modified":1692697933921},{"_id":"source/_posts/Github开源框架/Masonry/06.png","hash":"b4696d073396fedd0b6e19725a881d4203a24c7b","modified":1692956860385},{"_id":"source/_posts/OC底层原理/KVO/KVO02.png","hash":"532a081cad82e87c6ab8a853a4136117ce290c26","modified":1692697933923},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_01.png","hash":"7bc96c613cf2a870c1d81a7341ed8129e6d0b277","modified":1692697933926},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_04.png","hash":"465d466c8771c7d2c16c9f5be5738b4975dc63eb","modified":1692697933927},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_05.png","hash":"954fdf0aad7cecd5ba00b4eb48fadfc23c78d8d0","modified":1692697933928},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_07.png","hash":"7adcbbbb6fc885ca6a542b6248020131ac9f656e","modified":1692697933929},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_08.png","hash":"647ca28f0dfb3a4569290ee0a8a93ebca0b17079","modified":1692697933930},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_09.png","hash":"190dea4043af021b49268baad80ecf285575bd70","modified":1692697933930},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop02.png","hash":"7a5a0763941dc9a6c6bce768a100c0e94798b822","modified":1692697933938},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop03.png","hash":"a7d3f45091291a0c793f6f9d985bda6e7fd2c201","modified":1692697933939},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop13.png","hash":"9c87aa5ece13d3f3c12febbb3304139b3cdd1fb7","modified":1692697933951},{"_id":"source/_posts/OC底层原理/Runtime/Runtime03.png","hash":"4132fe67770b2cc71192d2b7624d0c5b212b27ac","modified":1692697933956},{"_id":"source/_posts/OC底层原理/Runtime/Runtime18.png","hash":"7050cd9fbb1a98872ef7313f45eb4bbeb486c06c","modified":1692697933961},{"_id":"source/_posts/OC底层原理/Runtime/Runtime17.png","hash":"ab3f6749c6f40ef63b0e7f0fee6664928e40d199","modified":1692697933961},{"_id":"source/_posts/OC底层原理/Runtime/Runtime23.png","hash":"09765c84c906a4b271080c579f5ca881f1a7ce41","modified":1692697933963},{"_id":"source/_posts/OC底层原理/Runtime/Runtime31.png","hash":"63afda1cb5be1b893f3c91e3a242b5093e90797e","modified":1692697933967},{"_id":"source/_posts/OC底层原理/block/block20.png","hash":"209bb1b9abe0d15180e82b749ed948bf18dd6ef5","modified":1692697933980},{"_id":"source/_posts/OC底层原理/block/block21.png","hash":"45478758b5adfdcbd6364adccf21c44532be2252","modified":1692697933981},{"_id":"source/_posts/OC底层原理/block/block25.png","hash":"2900c436962fc49e6509510454a2ebf0047f57a3","modified":1692697933982},{"_id":"source/_posts/OC底层原理/关联对象/关联对象03.png","hash":"3a1d4f638ff7aba3be0177591575c8228e042429","modified":1692697933989},{"_id":"source/_posts/OC底层原理/多线程/多线程02.png","hash":"3d712b2665e9996619020a8d9c2a96234735d891","modified":1692697934000},{"_id":"source/_posts/OC底层原理/内存管理/内存管理20.png","hash":"4c091e06dc7c824287b41c2aba6c98f9e97b206c","modified":1692697933999},{"_id":"source/_posts/OC底层原理/多线程/多线程04.png","hash":"4d1c7577a2b5022638a75ee7dcf1da29c0d150e9","modified":1692697934002},{"_id":"source/_posts/OC底层原理/多线程/多线程06.png","hash":"13457ab1d918c335a9289f4de8143408ea4bf240","modified":1692697934004},{"_id":"source/_posts/OC底层原理/多线程/多线程07.png","hash":"c75d3099f9e1bae1838a4990c50159a90db113ba","modified":1692697934004},{"_id":"source/_posts/OC底层原理/多线程/多线程08.png","hash":"5b383469615fd6f33b7ec20dceffc3a099cbd6d8","modified":1692697934005},{"_id":"source/_posts/OC底层原理/多线程/多线程09.png","hash":"4f8f44f15ee0d4e1c678057f5c981cd34434b9e7","modified":1692697934005},{"_id":"source/_posts/OC底层原理/多线程/多线程11.png","hash":"5879aebe5b6ad1040bb5b6e8d99f36cf92b42200","modified":1692697934006},{"_id":"source/_posts/OC底层原理/多线程/多线程19.png","hash":"cdeb4292f103e8a708d9c5d6b0a8ec1449bc1572","modified":1692697934010},{"_id":"source/_posts/OC底层原理/多线程/多线程21.png","hash":"4149545d89dc8c5b9bb31f572f53141105312e00","modified":1692697934011},{"_id":"source/_posts/OC底层原理/多线程/多线程22.png","hash":"dd383193e32d46a3502bcac841afd720fb145997","modified":1692697934012},{"_id":"source/_posts/OC底层原理/多线程/多线程26.png","hash":"5d233a95727197e99e14066083d7ab0bca20e52b","modified":1692697934016},{"_id":"source/_posts/OC底层原理/多线程/多线程29.png","hash":"2a68b1e873465c03317874179dbf5fb44bc5b561","modified":1692697934018},{"_id":"source/_posts/OC底层原理/多线程/多线程32.png","hash":"cf6cd70f1b4b326fec394e1085335967853203a0","modified":1692697934021},{"_id":"source/_posts/OC底层原理/多线程/多线程33.png","hash":"d12169eb217836756a5e754e0bb521a201d68f7e","modified":1692697934022},{"_id":"source/_posts/OC底层原理/多线程/多线程37.png","hash":"a7af9af48d9731023d30da984b353d92cee6de9b","modified":1692697934025},{"_id":"source/_posts/OC底层原理/多线程/多线程36.png","hash":"2ffcc3de35555f7f24047b6b6aae01340f1ff0b5","modified":1692697934024},{"_id":"source/_posts/OC底层原理/多线程/多线程41.png","hash":"931f79cf400d8953371838eafef8330a6b5006e6","modified":1692697934027},{"_id":"source/_posts/OC底层原理/性能优化/性能优化09.png","hash":"656130b13cf2e323dd694c34f837a3e205e3305b","modified":1692697934031},{"_id":"source/_posts/OC底层原理/架构设计/架构设计08.png","hash":"2819fb36abce443dd0915a373e5cc3202f6cdad5","modified":1692697934035},{"_id":"source/_posts/OC底层原理/架构设计/架构设计09.png","hash":"e521c60be586f442bf639db209ca604dcee3974a","modified":1692697934035},{"_id":"source/_posts/OC底层原理/架构设计/架构设计12.png","hash":"99adf1d431fd40b79153a616e96cb2a199198931","modified":1692697934036},{"_id":"source/_posts/Other/Apple官方文档阅读指南/02.png","hash":"2f127fb641f809fe3ee084377cc16b0b1573ef40","modified":1692697934039},{"_id":"source/_posts/Other/Apple官方文档阅读指南/04.png","hash":"18a6d541e87bc7f8ccde3127805b82a148ba9642","modified":1692697934040},{"_id":"source/_posts/Other/Apple官方文档阅读指南/21.png","hash":"4c49c1a75bb51678aab3a7393cae1165850b296b","modified":1692697934044},{"_id":"source/_posts/Other/Apple官方文档阅读指南/08.png","hash":"30b16409961848fbf772325c8ae09830b8431639","modified":1692697934043},{"_id":"source/_posts/Other/微信小程序/微信小程序13.png","hash":"ead533b888fdeeb6588894ee40be2060c01d0cba","modified":1692697934084},{"_id":"source/_posts/Other/微信小程序/微信小程序32.png","hash":"666522293d591fb9f19b7cd9b7ea285bbea772bb","modified":1692697934103},{"_id":"source/_posts/Swift/Swift简介/17.png","hash":"8c0fc71bcff5c24c6e92ca75142380294859115b","modified":1692697934131},{"_id":"source/_posts/Swift/Swift简介/16.png","hash":"e2d9fb41a70f445e88b7db5c1d77efd151eb7759","modified":1692697934130},{"_id":"source/_posts/Swift/Swift简介/Swift05.png","hash":"58e711889d0f9d92f80e21d333cad94c78d94a88","modified":1692697934134},{"_id":"source/_posts/Swift/Swift简介/Swift07.png","hash":"3a7e991eed9034ffbba097713cf432e7ad0d1952","modified":1692697934135},{"_id":"source/_posts/Swift/Swift简介/Swift06.png","hash":"e99d8f8a5739af5f2ba7fe7b19a7c075f7ab515b","modified":1692697934134},{"_id":"source/_posts/Swift/Swift简介/Swift10.png","hash":"3b333eee328c1a7ca711a6c6553a954510801992","modified":1692697934137},{"_id":"source/_posts/Swift/函数和闭包/01.png","hash":"e79707da84a4d8f6a0d50c8a02eb0e38c09d5f8e","modified":1692697934141},{"_id":"source/_posts/Swift/函数和闭包/02.png","hash":"96d50ac37c66a481a931c993a910d6ec9f7f22b5","modified":1692697934141},{"_id":"source/_posts/Swift/函数和闭包/03.png","hash":"2db7f96f9c5b58e680c0411a082f0e7ec0b35ade","modified":1692697934142},{"_id":"source/_posts/Swift/函数和闭包/04.png","hash":"b118bd20be7fef938e41be80c069d2d0f80e8c86","modified":1692697934143},{"_id":"source/_posts/Swift/函数和闭包/07.png","hash":"94eb5c03e54b636997d9ca64c4f9e3a850d8420c","modified":1692697934144},{"_id":"source/_posts/Swift/函数和闭包/08.png","hash":"f9412504e0f84289f2679a8091f671efb6bcb755","modified":1692697934145},{"_id":"source/_posts/Swift/函数和闭包/09.png","hash":"c1feeaf5808382238c670f306fb1e5ee648ff5a9","modified":1692697934146},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType14.png","hash":"c7d54b55b779daa7f731118bf790c4711bce8f67","modified":1692697934153},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType23.png","hash":"11d57d9219ca3cab5cdfebba34dbc1308ec26cfb","modified":1692697934158},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType22.png","hash":"43811793961235d06bb48fc9fdd3224fae241b70","modified":1692697934157},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType25.png","hash":"39b7a5ee6a8aa8d2276d7b417393f4df44b37036","modified":1692697934159},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType26.png","hash":"24b32777dd9a8697899aab9706aa90d062308eda","modified":1692697934159},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType27.png","hash":"95f654efde18612cfda65cf75db5e97f34588d2c","modified":1692697934160},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType28.png","hash":"48560c8e05d0008ded153c805b3091ff34873024","modified":1692697934161},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType35.png","hash":"0bcff24de26b525ff63ce5abbffa2125bb0abc07","modified":1692697934165},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType34.png","hash":"9c0f3f2b111cf68df28c4fc7bbc31f598381e521","modified":1692697934164},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType36.png","hash":"236ac24b1b22d30e8992d5efe949ebbd1a605fed","modified":1692697934166},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType39.png","hash":"7fee8cbd2756d8bcc1861a62a67c5dbd9e095885","modified":1692697934169},{"_id":"source/_posts/Swift/运算符/01.png","hash":"9e12654944979a93dcb662a73b15d0abc5681363","modified":1692697934178},{"_id":"source/_posts/Swift/集合类/07.png","hash":"b25913be3d84599b2d5278cde6784c1e385634ba","modified":1692697934188},{"_id":"source/_posts/Swift/集合类/11.png","hash":"6ff43b3956f861a39fef91b576a0f2a1a77424b2","modified":1692697934192},{"_id":"source/_posts/Swift/集合类/13.png","hash":"c98a4d05d25223edfbca8e18d3febff0ef2785e9","modified":1692697934194},{"_id":"source/_posts/Swift/集合类/14.png","hash":"1d4ab01fb5a2b0ae6cab3f7253bcff93161659ce","modified":1692697934194},{"_id":"source/_posts/Swift/集合类/15.png","hash":"4663ae619c81f2a49b8445fe71824c0881d9bbd3","modified":1692697934195},{"_id":"source/_posts/Swift/集合类/17.png","hash":"c9a08ccad67da3628b208654bb61ad9109fabc5b","modified":1692697934196},{"_id":"source/_posts/Swift/集合类/21.png","hash":"087fe718e801bd597732cf6e4a5867e3d0e62d25","modified":1692697934198},{"_id":"source/_posts/Swift/集合类/23.png","hash":"9d73b8c1c72e21e349ea3061117fe4eb4f881136","modified":1692697934199},{"_id":"source/_posts/Swift/集合类/22.png","hash":"0962bb7f1499b489e8dcb9cd0ecafb79a577016e","modified":1692697934199},{"_id":"source/_posts/Swift/集合类/26.png","hash":"a6cd03f127a609cda93243041ebf69a2fcdb87b9","modified":1692697934201},{"_id":"source/_posts/Swift/集合类/28.png","hash":"6f3dad66805575a9dc1fed005f8cf6ada98fdd7c","modified":1692697934203},{"_id":"source/_posts/Swift/集合类/29.png","hash":"05478b231082564dff040816410406f062f95756","modified":1692697934204},{"_id":"source/_posts/Swift/集合类/30.png","hash":"046488184604c3cea8df590cebc741e1b2ca5f55","modified":1692697934205},{"_id":"source/_posts/Swift/集合类/31.png","hash":"3d052b4a4b4ae271c284e6acd51e5d94c715355e","modified":1692697934205},{"_id":"source/_posts/Swift/集合类/32.png","hash":"6eccdb8cc287b54fc505e0da9bece1474d32d26e","modified":1692697934206},{"_id":"source/_posts/Swift/集合类/33.png","hash":"80c060d0d1c12a70750a6d0ac7e7791973767b0f","modified":1692697934207},{"_id":"source/_posts/Swift/集合类/35.png","hash":"76b502cc4b061c059586c56750707273f2cd6c54","modified":1692697934208},{"_id":"source/_posts/Swift/面向对象编程/03.png","hash":"7817153b684a22f410c8c7519c75cbc873eda160","modified":1692697934211},{"_id":"source/_posts/Swift/面向对象编程/11.png","hash":"f21371f61db6ff88c3ab0ba5cf27630ceba6c7d4","modified":1692697934216},{"_id":"source/_posts/Swift/面向对象编程/14.png","hash":"c7d9e23d567a61465caffb25df7ed91199e91282","modified":1692697934218},{"_id":"source/_posts/Swift/面向对象编程/20.png","hash":"0bc0e9a6809d6a5607655868a67322465f4d07bf","modified":1692697934222},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation01.png","hash":"02026890feba667a3ef55e6ceca29ce0bbd7c6c3","modified":1706871873158},{"_id":"source/_posts/iOS/UIBezierPath/24.png","hash":"a0b8462f59b60819c574e6cfc255c192f1c18ff5","modified":1706843292000},{"_id":"source/_posts/Swift/面向对象编程/25.png","hash":"b27337733243c1181ae66a76d2aae67eb7e9e9a6","modified":1692697934227},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树03.png","hash":"1f057585e028a9c0083cb7b0bfa3ecc951b2e0ca","modified":1692697934230},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树02.png","hash":"cb0627c60b452c3a2c988e4957f68b3dda8d235e","modified":1692697934229},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树04.png","hash":"4084e5f0583d397337208b825d02c2de671f5bac","modified":1692697934231},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树05.png","hash":"e85a699fbd6768a8b4e45736231b507d6ae6f130","modified":1692697934232},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树06.png","hash":"80fd6caea8d2d8684d832a86ce0efe77878eed60","modified":1692697934233},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树09.png","hash":"ac2ef8218996daf3652973cf417a55b19b9a9d2a","modified":1692697934234},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树10.png","hash":"12f431762cdaa3e5fb34c1ecc96c850c6f649242","modified":1692697934235},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树11.png","hash":"28fb8dd3f7884494190343137cb81ba8cb34bd5d","modified":1692697934236},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树14.png","hash":"2466d4186e70d869a12d338209724f2a25e61f1f","modified":1692697934238},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树16.png","hash":"346fde169fcccea6f11a301009ce49ef280bdfde","modified":1692697934239},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树17.png","hash":"376835e8624bb3c6a7e6e66b1c3edb88e003d2a8","modified":1692697934240},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树19.png","hash":"48941ec80b7ba58c489c3f339c8faae4cac708c7","modified":1692697934241},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树20.png","hash":"9b93c207cd9e3839334a27311ba85a7e8a6ab58d","modified":1692697934242},{"_id":"source/_posts/数据结构与算法/B树/B树01.png","hash":"f9c98104b2f75e9d15e1a98124dd8cc2798dc140","modified":1692697934250},{"_id":"source/_posts/数据结构与算法/B树/B树02.png","hash":"c69e2b7470f6e77d995d49bc96224fd1e451b988","modified":1692697934250},{"_id":"source/_posts/数据结构与算法/B树/B树04.png","hash":"1e2631ea2ab348115307234e58fd5950bb9a1040","modified":1692697934251},{"_id":"source/_posts/数据结构与算法/B树/B树03.png","hash":"fd7e2837c2a458adb5e1d64ad78f24ea91d4ee14","modified":1692697934250},{"_id":"source/_posts/数据结构与算法/B树/B树07.png","hash":"4466ec5d23b2b06ebeea6f14669567a028b2bc31","modified":1692697934252},{"_id":"source/_posts/数据结构与算法/B树/B树08.png","hash":"58da17f7e6c367fbcb285f466336106861be1acc","modified":1692697934253},{"_id":"source/_posts/数据结构与算法/B树/B树12.png","hash":"633000a6fc08ae09f6c7bce4552971c59bd227d5","modified":1692697934254},{"_id":"source/_posts/数据结构与算法/B树/B树13.png","hash":"a2d3459a8a27d75d715991a12f3ad0df25193a1e","modified":1692697934254},{"_id":"source/_posts/数据结构与算法/B树/B树14.png","hash":"4120213324b43a31c395d681c9ca860c09820207","modified":1692697934255},{"_id":"source/_posts/数据结构与算法/B树/B树15.png","hash":"bc737e0fa500efe3610d6e777e0877eefd8ad649","modified":1692697934255},{"_id":"source/_posts/数据结构与算法/B树/B树16.png","hash":"44dea1d40ab7f6424690dcf73b34b2c293aea65e","modified":1692697934255},{"_id":"source/_posts/数据结构与算法/B树/B树24.png","hash":"f73ac6e9f712239bb48c5b722274e37fc2488581","modified":1692697934258},{"_id":"source/_posts/数据结构与算法/B树/B树22.png","hash":"f0ea7c6d3da0cd736530f17908499691aee034f6","modified":1692697934257},{"_id":"source/_posts/数据结构与算法/B树/B树23.png","hash":"d215e2237e62e76f1a46b1d45b8e9deaa213dec2","modified":1692697934257},{"_id":"source/_posts/数据结构与算法/B树/B树27.gif","hash":"324f9f3f5b823dccdf7c42bf1a938268959e25ee","modified":1692697934261},{"_id":"source/_posts/数据结构与算法/B树/B树28.gif","hash":"c8a7acfa63a0bd6ce8888cc7db0508a1d468eede","modified":1692697934262},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树03.png","hash":"669570d0a666269ae1b68ed96e195cde4a8732c0","modified":1692697934268},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树04.png","hash":"3a932e7b1e86f31db100bd47662f8c7ccc925e99","modified":1692697934269},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树05.png","hash":"c700ddd338279dba0416b0562b622d4c0f1cc1ce","modified":1692697934270},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树02.png","hash":"95d0b840f99c7a1ce6352ca5cce5f53a681abe7f","modified":1692697934282},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树03.png","hash":"3891a24ef729f386149067a09a193bbc6cebedd8","modified":1692697934282},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树04.png","hash":"63deb0fd759f09d97949c45bd6a8dbaabf03b633","modified":1692697934282},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树07.png","hash":"1c3c8f3db8ffa4d185d349ba7a630187f09f1623","modified":1692697934284},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树11.png","hash":"cfa6d974258bd1877f044264c7793bc14403c000","modified":1692697934285},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树12.png","hash":"8d47fd5897c41f17141b760b4fa6ec5bd15b4a20","modified":1692697934286},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树13.png","hash":"635cbea292732376bee0d7492939781a340924be","modified":1692697934286},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组04.png","hash":"f3bfed9b5db771f702b469ea10cd2d49575b6773","modified":1692697934291},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组13.png","hash":"2db00a513e30ef60b426ab2b49fe9591fd0f809c","modified":1692697934296},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度02.png","hash":"98b77593910111ebcf6dfcfd13b873ad647fe3e1","modified":1692697934299},{"_id":"source/_posts/数据结构与算法/栈/栈01.png","hash":"042517012a7e453f98350b094f3de775e5c47645","modified":1692697934304},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度06.png","hash":"b7add8b7ce1dc3f9e8c4d14d988d74060675c567","modified":1692697934304},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建15.png","hash":"19c3bc905ceffbde25ab5fa729ebbc0ae768e256","modified":1692697934313},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建20.png","hash":"e650c7abe8ee984ea0fd91fcd60e2b10a4038504","modified":1692697934323},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建22.png","hash":"6a11d6ad7dfce595d4cf0b9b6a43d65c8532417e","modified":1692697934325},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建35.png","hash":"6af2eea156df718dfa85895649a69d5ea5565cc5","modified":1692697934335},{"_id":"source/_posts/数据结构与算法/链表/链表01.png","hash":"7b7af4323bd6aced1dffeacff201c256b4593772","modified":1692697934338},{"_id":"source/_posts/数据结构与算法/链表/链表02.png","hash":"a40563ec54496e916de3d09748c0ae4b7aeefb6f","modified":1692697934338},{"_id":"source/_posts/数据结构与算法/链表/链表05.png","hash":"8b51e69b7e165d40b6846fb7b35e679931525fd5","modified":1692697934340},{"_id":"source/_posts/数据结构与算法/链表/链表06.png","hash":"d1c18d91a963200452ff72a6c15f2e2a9212ffca","modified":1692697934341},{"_id":"source/_posts/数据结构与算法/链表/链表07.png","hash":"a9da0cff0c0d1ced480d54736a5a61c33054b50c","modified":1692697934342},{"_id":"source/_posts/数据结构与算法/链表/链表08.png","hash":"164f8bf5dd8923917beb7a97e92583d047ac067a","modified":1692697934343},{"_id":"source/_posts/数据结构与算法/链表/链表10.png","hash":"c259c4fd6ed615e2067bbfe3e6e6c87011904e5c","modified":1692697934344},{"_id":"source/_posts/数据结构与算法/链表/链表09.png","hash":"54f883176cddf9e48ff638e119b12b1b77e6afb5","modified":1692697934343},{"_id":"source/_posts/数据结构与算法/链表/链表12.png","hash":"025cc581446e7ec2429adb4e703654047fbb678b","modified":1692697934345},{"_id":"source/_posts/数据结构与算法/链表/链表15.png","hash":"bfeb141dee0c9df445a5aab4384dc9c68a2c46e4","modified":1692697934348},{"_id":"source/_posts/数据结构与算法/链表/链表16.png","hash":"5fbd8251b511c6e6e44f51464a7ee30ba9ae9b08","modified":1692697934349},{"_id":"source/_posts/数据结构与算法/链表/链表21.png","hash":"dba45f866ecf6d739a381e199514db1ee730ad5d","modified":1692697934352},{"_id":"source/_posts/数据结构与算法/链表/链表22.png","hash":"045d41cbdc503a2affef9c19da1171788a35e02c","modified":1692697934353},{"_id":"source/_posts/数据结构与算法/链表/链表24.png","hash":"b86f12dec3733e682d015fd489f899dc346d1e8f","modified":1692697934354},{"_id":"source/_posts/数据结构与算法/链表/链表25.png","hash":"d1fbe49d925fbdc05e6f8cbf01ade880c5380b9f","modified":1692697934355},{"_id":"source/_posts/数据结构与算法/链表/链表27.png","hash":"93920ee13d0f9200b56e2cb294180247d112417f","modified":1692697934356},{"_id":"source/_posts/数据结构与算法/链表/链表26.png","hash":"0b323a8b77ef4bb25b75f48613d12f6b857e0d06","modified":1692697934356},{"_id":"source/_posts/数据结构与算法/链表/链表28.png","hash":"9d06c7d3e09765a004aca68005bf48f5315ae510","modified":1692697934357},{"_id":"source/_posts/数据结构与算法/链表/链表29.png","hash":"eb9214eb706e59c906bc69dbf02751597b3a8674","modified":1692697934358},{"_id":"source/_posts/数据结构与算法/链表/链表37.png","hash":"b8d8cbc7361ad4a196794200d00f474f8a882b83","modified":1692697934361},{"_id":"source/_posts/数据结构与算法/链表/链表38.png","hash":"86d2ceb45b15b7bbf8782c7cc0f27838e57f77b7","modified":1692697934362},{"_id":"source/_posts/数据结构与算法/链表/链表39.png","hash":"2444b6e8a0c38028f06d934427a13e5d640f4a22","modified":1692697934363},{"_id":"source/_posts/数据结构与算法/链表/链表36.png","hash":"4e2e932ad6bb83e0ddc05c29d8514cd2dfa443db","modified":1692697934361},{"_id":"source/_posts/数据结构与算法/链表/链表41.png","hash":"d362838b91eafa169867b95b7ed616e98fcdbcb1","modified":1692697934364},{"_id":"source/_posts/数据结构与算法/链表/链表40.png","hash":"14e028baf4f5184301efa2c3887390dd25ba5348","modified":1692697934363},{"_id":"source/_posts/数据结构与算法/链表/链表43.png","hash":"48ae02fe138a3274b1d08918e29ae6abccf2570f","modified":1692697934366},{"_id":"source/_posts/数据结构与算法/链表/链表42.png","hash":"2458489c2fc8f754cc7c2b65cb9736151f84af06","modified":1692697934365},{"_id":"source/_posts/数据结构与算法/链表/链表44.png","hash":"76b208d176e999acb1c5ebe9e12a5fc749bfe091","modified":1692697934368},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之初见/05.png","hash":"c20574e6661df5356c9340da49df9464c31a40be","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/13.png","hash":"67005bc8bd31e6fdea3baf3e0d49239dbad55218","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/41.png","hash":"d7e8646814a051b7915758ed47bf8c9789510d94","modified":1697097922787},{"_id":"source/_posts/Github开源框架/Masonry/03.png","hash":"397b2b819d2e2722321a98441b79c4d570969b68","modified":1692697933915},{"_id":"source/_posts/OC/AFHTTPSessionManager/AFHTTPSessionManager/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1588831386846},{"_id":"source/_posts/OC底层原理/KVO/KVO03.png","hash":"e376f61a0fdc8a64eb50eb15fc5c93dc5af3bbfb","modified":1692697933924},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_02.png","hash":"1891501af3bb7eb75c0632a01f3784f1d6593e6b","modified":1692697933927},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_06.png","hash":"158ad93bcd1862d844c32dd62d3978fd09edf8ff","modified":1692697933928},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop06.png","hash":"72cf252e12339d1570e82d8ca325702848ba9641","modified":1692697933941},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop09.png","hash":"8773aca0873210eacbd944f52dc830c80e8fc746","modified":1692697933947},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop10.png","hash":"8c982d38dcb4e7d43ef4af7d38d971bdd6df5790","modified":1692697933948},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop11.png","hash":"eff0a60f01e29c32f73bd7a6f1595fc95d611bd0","modified":1692697933949},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop14.png","hash":"e1e1b4c02b13dc1535cf6c0ec5f4e5ab9c1887e1","modified":1692697933952},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop15.png","hash":"0d9c765b7d37847d068967505f6fa84ae049c758","modified":1692697933953},{"_id":"source/_posts/OC底层原理/Runtime/Runtime08.png","hash":"e3d59adc2b173a6d718af0349be30d49f4fc8bdf","modified":1692697933958},{"_id":"source/_posts/OC底层原理/内存管理/内存管理05.png","hash":"3001b0a3873bb5cd9ee1c00146df0e654f33972a","modified":1692697933993},{"_id":"source/_posts/OC底层原理/多线程/多线程03.png","hash":"8ab2a55f9d99eea92b6ed049a713f493637903cc","modified":1692697934001},{"_id":"source/_posts/OC底层原理/多线程/多线程05.png","hash":"214e5abae047ff8e08d6756a57bd0222f964aabb","modified":1692697934003},{"_id":"source/_posts/OC底层原理/多线程/多线程23.png","hash":"8c46c60d9dddd92f6c189cef5411f44fc14b0fcd","modified":1692697934013},{"_id":"source/_posts/Other/Apple官方文档阅读指南/01.png","hash":"a909db3a32adf52c0691f4ecc743fb11a38b1f78","modified":1692697934038},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk05.png","hash":"40b05136cd410dc695ce1724ce2f0c9f3442afd1","modified":1692697934052},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk01.png","hash":"0791835533508bd1edc29dc100e8b00a56bd30e9","modified":1692697934050},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk03.png","hash":"53586d27889c0c17a7224a71cd3a0aa7c505c5fe","modified":1692697934052},{"_id":"source/_posts/Other/Personal blog/gitalk/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1602380839147},{"_id":"source/_posts/Other/微信小程序/微信小程序18.png","hash":"7bef886470927e01578e28798347a020909aebc3","modified":1692697934091},{"_id":"source/_posts/Other/微信小程序/微信小程序21.png","hash":"ce1182d3dce99c931517a44763b40246a8ef6387","modified":1692697934094},{"_id":"source/_posts/Other/微信小程序/微信小程序20.png","hash":"14336459671924b93f1163346252ef164cc92dd5","modified":1692697934093},{"_id":"source/_posts/Other/微信小程序/微信小程序30.png","hash":"45b446445f3008c5ca4e39aaa1966cb842475edc","modified":1692697934102},{"_id":"source/_posts/Other/微信小程序/微信小程序29.png","hash":"0cef857db898d8cb4c35b98e0d20c15a4aca1498","modified":1692697934101},{"_id":"source/_posts/Other/微信小程序/微信小程序31.png","hash":"c949fbfbaea17f5ce33825c12d39a73f47bcf36d","modified":1692697934102},{"_id":"source/_posts/Swift/Swift简介/13.png","hash":"db5fec2fee28457937e4366dae8cd757c7ebcc4d","modified":1692697934127},{"_id":"source/_posts/Swift/Swift简介/14.png","hash":"31066117a3f6cee505859235efc094436d934488","modified":1692697934128},{"_id":"source/_posts/Swift/Swift简介/Swift02.png","hash":"3723834a446c5b05b86fc93125e65e00cfcd4272","modified":1692697934133},{"_id":"source/_posts/Swift/流程控制/05.png","hash":"cc91feab7b8dc28cb0e3bbfae82e62d7e8a3a1b9","modified":1692697934174},{"_id":"source/_posts/Swift/集合类/06.png","hash":"3c5e994807c1c2d9c77c8c1ecf360f7e55a34dba","modified":1692697934188},{"_id":"source/_posts/Swift/集合类/08.png","hash":"01b0bb7bd73b2b5b78492afdf0bc0721d4f1a448","modified":1692697934189},{"_id":"source/_posts/Swift/集合类/09.png","hash":"35213d541e2d9ae75eba7090e4bb9c241a904e0f","modified":1692697934190},{"_id":"source/_posts/Swift/集合类/10.png","hash":"b93960e6ed9607017e272132166f7219155f8d96","modified":1692697934191},{"_id":"source/_posts/Swift/集合类/12.png","hash":"eeea5a0f50c4dfadc2ce7c65d1fe8b8af8b7dbb4","modified":1692697934193},{"_id":"source/_posts/Swift/集合类/24.png","hash":"dc8e07d48271491c887c29b67ac7f6f33444a157","modified":1692697934200},{"_id":"source/_posts/Swift/集合类/34.png","hash":"313836d68c4ef5511bf16209138e26feeedcca98","modified":1692697934207},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树22.png","hash":"2e66de85a395b101d825d5cab6a0fa6d5f58d42e","modified":1692697934244},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树23.png","hash":"944a1a8607be3c213131c365d2abd44be26f112c","modified":1692697934245},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树25.png","hash":"bcb14aa8b78352ceddd426c0ff37a01b50fc29d7","modified":1692697934247},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树26.png","hash":"45c2471454e1fad9bd31492f0d52ccb87a84d259","modified":1692697934248},{"_id":"source/_posts/数据结构与算法/B树/B树06.png","hash":"c091b6bf8c86813f4fbcf5d29600190c7e28644c","modified":1692697934252},{"_id":"source/_posts/数据结构与算法/B树/B树29.gif","hash":"fb1e99b599eea200510baaff44413906c59453e3","modified":1692697934263},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树12.png","hash":"847e27bb3547c4565796a09892bad1f97fbd7a0d","modified":1692697934274},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树11.png","hash":"512a50cd4ffe1cdd481a48e97c4819a64303b222","modified":1692697934273},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树13.png","hash":"05312be8ad775cc8f80759a218b5a80a5ce62405","modified":1692697934275},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树05.png","hash":"610c2201f3bc94cc69896ba19bb69d0ef8f930ad","modified":1692697934283},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树08.png","hash":"6fdb2f111a2daa76eac4b893e38dd61c76ef6bde","modified":1692697934284},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组10.png","hash":"a9863189e280a0061cc4c7011f9f8756bc44dddd","modified":1692697934294},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组12.png","hash":"09f84854f1b4f33fd900d16ede879b041b6232c5","modified":1692697934296},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建19.png","hash":"0b44c9613da4fa4d6683d34f69185115b20a95bc","modified":1692697934322},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建23.png","hash":"70d6d0d36265497154608565771e8bbc969230bf","modified":1692697934326},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建25.png","hash":"9b5eb8394e4716818e404f107f3c30eb017e8495","modified":1692697934329},{"_id":"source/_posts/数据结构与算法/链表/链表14.png","hash":"807bf5db50d5654fcf2eefc0a7833c8a99b69453","modified":1692697934347},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"0ff8408c7091fe0afdc6993fb887a93b57242e85","modified":1506508854000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1506508854000},{"_id":"themes/next/.git/refs/remotes/origin/dev","hash":"c9abcffd1f03a6a76afa09334100c5003cf895a0","modified":1579327673010},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"fde0697e3e19aa7426f55fa0e66db96fd65052be","modified":1679887307948},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1506508854000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1506508854000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"5e6c9f8a730b78c7ce5572d327c2a7311c3609b9","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"264a52c0a7877381f9a6a87d495757a0ba7e29d6","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1506508854000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1506508854000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1506508854000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1506508854000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1506508854000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1506508854000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1506508854000},{"_id":"source/_posts/2022年打怪/算法列表/20220607_th.jpeg","hash":"78471c180080c1363d0ababd14a1a8ace2d43a76","modified":1692697933908},{"_id":"source/_posts/Flutter/Flutter之基础Widget/14.png","hash":"ab5ffc7ea9f114ca2ffa126c09244b277e9bd22a","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/15.png","hash":"b1234544bf647a73d4b34cbe6b0d344f193590da","modified":1699580830000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/22.png","hash":"0d55eeae2e97a110cdf4ebfedb2ff38e02565253","modified":1699581100000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/24.png","hash":"dcb6dbe232b2fc22b5f606c792b9aa7d512692f4","modified":1699581100000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/23.png","hash":"48f8953870af0d924ba8a7b59c0c0e6755a5aeba","modified":1699581100000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/25.png","hash":"add18b0e7d903cbdcc80ef582f1a8e5c313f842d","modified":1699581100000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/26.png","hash":"d20996912c901394eeab4f5d26f38bd152014dfa","modified":1699581100000},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop05.png","hash":"9920b63ee2b7d8996fc7b424704b5e99958e7506","modified":1692697933940},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop12.png","hash":"8d2f1525e2b3e5cfaac040a75a11c178c6897dfc","modified":1692697933951},{"_id":"source/_posts/OC底层原理/block/block16.png","hash":"6ab7ed020b930529068b90fe97b629f9e405f9c4","modified":1692697933978},{"_id":"source/_posts/OC底层原理/多线程/多线程15.png","hash":"a326da98f65f450ed4644a8472d2826d7ff5f3c3","modified":1692697934008},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk04.png","hash":"4de4243dc70f351cfe627253807cc7ead19ebc09","modified":1692697934052},{"_id":"source/_posts/Other/微信小程序/微信小程序11.png","hash":"2f1ceb205e26e1ecad8cafb17579eae8ba0e9aa0","modified":1692697934082},{"_id":"source/_posts/Other/微信小程序/微信小程序19.png","hash":"b0b6ec373fbfe2edb1ea94099d0b0be3e3210b0b","modified":1692697934092},{"_id":"source/_posts/Other/微信小程序/微信小程序22.png","hash":"7bef886470927e01578e28798347a020909aebc3","modified":1692697934095},{"_id":"source/_posts/Other/微信小程序/微信小程序27.png","hash":"d937cdc4a65a15c41db952bdfe0230dd727ff209","modified":1692697934099},{"_id":"source/_posts/Other/微信小程序/微信小程序35.png","hash":"e562deb44fbda40b1e8abad39db82491c355714f","modified":1692697934107},{"_id":"source/_posts/Other/微信小程序/微信小程序36.png","hash":"be3faa0a82780da673b030b098f1fc56d0ceaf66","modified":1692697934108},{"_id":"source/_posts/Swift/Swift简介/15.png","hash":"c8b79572b4619a5615a798e540c3a695fa41b8a7","modified":1692697934129},{"_id":"source/_posts/Swift/集合类/25.png","hash":"a7344b6c8b265fa7764dc137129d489f423c9509","modified":1692697934201},{"_id":"source/_posts/数据结构与算法/B树/B树05.png","hash":"7198aa75d7709dcf5a906e63674fc72d83cd7ee7","modified":1692697934252},{"_id":"source/_posts/数据结构与算法/B树/B树30.gif","hash":"00f0de2bc601126e75b6fab6d5b71e4829cd7853","modified":1692697934264},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树15.png","hash":"9db22a617d0875f21b7f1d4342af2dd3351830aa","modified":1692697934287},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组02.png","hash":"9bbeb98d64e2d3a8437a071017accda50f0aa02a","modified":1692697934290},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建21.png","hash":"ac0ba8497cd11af7acadffdba501cbc22be46014","modified":1692697934324},{"_id":"source/_posts/数据结构与算法/链表/链表13.png","hash":"2159f22f79416c5252aa4bd84d1645cb9ec8faf5","modified":1692697934346},{"_id":"source/_posts/数据结构与算法/链表/链表18.png","hash":"3a67938dde44a59626d2e1609b9bb0a87b904520","modified":1692697934350},{"_id":"source/_posts/数据结构与算法/链表/链表20.png","hash":"7de6ce41fa0a9472288d34eb114a49506c6ef3cd","modified":1692697934351},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之基础Widget/21.png","hash":"c8fde3a792b9a6039974c7366fc3da7b4a713c62","modified":1699581100000},{"_id":"source/_posts/OC底层原理/block/block17.png","hash":"74704b3a1f8e7d1e624f2e804cc4d1f4e4665046","modified":1692697933979},{"_id":"source/_posts/OC底层原理/block/block18.png","hash":"b0c627f82a7da46d6fceb61361610ab74ff4c318","modified":1692697933979},{"_id":"source/_posts/OC底层原理/多线程/多线程18.png","hash":"9294973b586b5559ee2132f1063d8eddc0e23677","modified":1692697934009},{"_id":"source/_posts/Other/微信小程序/微信小程序12.png","hash":"29ebdbff1382ef96b38807e7408ecdc9ba8eeb8c","modified":1692697934083},{"_id":"source/_posts/Other/微信小程序/微信小程序28.png","hash":"54692f5da0f26255c575fba3ca9bcc74b17dc9de","modified":1692697934100},{"_id":"source/_posts/Other/微信小程序/微信小程序26.png","hash":"69fe689ec6db3998638fa3dce3a3ecd100ece724","modified":1692697934098},{"_id":"source/_posts/Swift/Swift简介/Swift08.png","hash":"ceca79f09e9f2afbc0aa4b8942b9297a17eaaa2f","modified":1692697934136},{"_id":"source/_posts/Swift/集合类/27.png","hash":"fd94657a3e6c03ba7b3790e427d6b566971da097","modified":1692697934203},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树14.png","hash":"17cff4e975f3450f14f7cdcfbd8e2cdcb5559088","modified":1692697934287},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"0ff8408c7091fe0afdc6993fb887a93b57242e85","modified":1506508854000},{"_id":"themes/next/.git/logs/refs/remotes/origin/dev","hash":"6c73a1e60a0c3e202d282fad71b0e95f1abe4db2","modified":1579327673010},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"284ed972a70cfecfc6b2166b97a06bc7688f3a8e","modified":1679887307949},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"8bb08dcb8e5c5dcc5044ef1d8981d8dc16ec6036","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8c15f9a179c47c3f61e56577ece63fa8c9393ac6","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1506508854000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"8c26b70de80a258897663f0653a2cbd855b11d4a","modified":1584167596799},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1579403252264},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1506508854000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1506508854000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1506508854000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1506508854000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/39.png","hash":"909a745e4d31603cecd60707ae7086a9d88e2e72","modified":1697097806404},{"_id":"source/_posts/OC底层原理/Runtime/Runtime06.png","hash":"77142e5e9b9762727c861a7799353dc51f9e3bec","modified":1692697933957},{"_id":"source/_posts/Other/Apple官方文档阅读指南/07.png","hash":"3ffb40adac9e075bf03e93442a9fb35b3719f3a9","modified":1692697934042},{"_id":"source/_posts/Other/微信小程序/微信小程序05.png","hash":"97bc703893f207eed2331bd3769b9127b186144c","modified":1692697934066},{"_id":"source/_posts/Other/微信小程序/微信小程序10.png","hash":"1915b63777903ab7c443a070c3f1df3343183a33","modified":1692697934081},{"_id":"source/_posts/Other/微信小程序/微信小程序23.png","hash":"bc11bb0c5a617826830e18daf071bf053459ee44","modified":1692697934095},{"_id":"source/_posts/Other/微信小程序/微信小程序24.png","hash":"fe4a6edeb88b2ddf527037aafb7683ecdcd2a197","modified":1692697934097},{"_id":"source/_posts/Other/微信小程序/微信小程序25.png","hash":"bc54a1d5de6d80c88420a2f7454718470d2adfd9","modified":1692697934098},{"_id":"source/_posts/Other/微信小程序/微信小程序34.png","hash":"66b6c2211669cb75b97f96e84f27ef81c1762b4d","modified":1692697934106},{"_id":"source/_posts/iOS/AFHTTPSessionManager/AFHTTPSessionManager/AFHTTPSessionManager.jpeg","hash":"49f6b6c3fa36e04beb3a53dc432ea751fd673107","modified":1706871873136},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建17.png","hash":"980d23bf1f43928cdda19fee9609375c0de12bba","modified":1692697934316},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建16.png","hash":"d69846c58a642eb78031086555a72e53609e663d","modified":1692697934315},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建28.png","hash":"bbdc3c90eada7216024e139993abf9ae81c636f4","modified":1692697934333},{"_id":"source/_posts/数据结构与算法/链表/链表03.png","hash":"3f0fc374f64533375aa4edaab6a127c905a4130c","modified":1692697934339},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1506508854000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/02.png","hash":"c0a08c04bd2dc43e31363b236649d0b63a408b15","modified":1697067104000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/29.png","hash":"1f2d88c438d96c2d86d7d6645c3ca13e036b0cca","modified":1697067508000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/30.png","hash":"7349bb75399945e8c52a0fc6f1ac757f16d717a5","modified":1697067508000},{"_id":"source/_posts/Other/微信小程序/微信小程序16.png","hash":"9b7f21d734e625f615cb4170d43be3d19fca80a3","modified":1692697934090},{"_id":"source/_posts/Other/微信小程序/微信小程序17.png","hash":"43e2088b64c0c33c2f2e8edc7bc67d62050939e4","modified":1692697934090},{"_id":"source/_posts/Other/微信小程序/微信小程序38.png","hash":"2e96beb90b620dfee74c2f437894498f65cc6a66","modified":1692697934111},{"_id":"source/_posts/Other/诗和远方/20230608_th.jpeg","hash":"68f0af597cbb83733af4da75d2f21839b4a57026","modified":1692697934123},{"_id":"source/_posts/Other/诗和远方/20221115_th.jpeg","hash":"55a0cfadb414dd388977e94ed8cab7cbcb15ad84","modified":1692697934121},{"_id":"source/_posts/Other/诗和远方/20221018_th.jpeg","hash":"35945ec8a3c5327e270b0ec501b5e507b8604712","modified":1692697934112},{"_id":"source/_posts/Swift/Swift简介/12.png","hash":"f24972c4360580da5ddd48e77086ecb86e1921ab","modified":1692697934125},{"_id":"source/_posts/Swift/集合类/16.png","hash":"94d213f86be9e1e6e74bdf3ac44f87facf2d6471","modified":1692697934196},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建14.png","hash":"d51a87fcabd9a1079738f4b138fcb6269be53256","modified":1692697934312},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建24.png","hash":"4bc76c13e74930393c6e0fd71dfa3b06b517b086","modified":1692697934328},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建36.png","hash":"ff3e4e903bddf86c029b0ff08eb43aa172d1bd78","modified":1692697934336},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建27.png","hash":"b2bfdb59574531dc1d4f74d1a534d0a82e37ba4d","modified":1692697934332},{"_id":"source/_posts/数据结构与算法/链表/链表31.png","hash":"8e9be07ebbe25fc627f08bdada8730ff181bc612","modified":1692697934359},{"_id":"source/_posts/Flutter/Flutter之初见/17.png","hash":"17ee81c83cd9ab03543daa49e82caa366e3ff878","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/31.png","hash":"015569daccd366d8c806415618a8b48506998747","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/33.png","hash":"a7eec36779cba044afa0942b72bb3830d509f6a2","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/34.png","hash":"13e98c20dc7595b8800ffeb06244d9a85848e06a","modified":1697067562000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/43.png","hash":"50df91898e3130c7f1a359e22e127316d48e51a1","modified":1697098142986},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk02.png","hash":"a39d4d7916d902812c12aeaa23ffdb802cb4c98e","modified":1692697934051},{"_id":"source/_posts/Other/微信小程序/微信小程序06.png","hash":"ae63eab2cf10188fe641a562fcd3703b93bad3bb","modified":1692697934069},{"_id":"source/_posts/Other/微信小程序/微信小程序07.png","hash":"5d30744fada320c898e12bf17817aa33cbf1aaf5","modified":1692697934072},{"_id":"source/_posts/Other/微信小程序/微信小程序04.png","hash":"5792f48707e26cb7e6e50b7debec4b46f38e846d","modified":1692697934065},{"_id":"source/_posts/Other/微信小程序/微信小程序09.png","hash":"6bbe949a82a95ce341dd75b162dcf23dead3cccd","modified":1692697934079},{"_id":"source/_posts/Other/诗和远方/20221103_th.jpeg","hash":"ce238ebf8bf36d919d17fb63d01da2114ebad10a","modified":1692697934117},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树13.png","hash":"a51339b54b052f4d878957de0016713a6802b2ee","modified":1692697934238},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建18.png","hash":"d2f38e46389b1d27b7ffd9ebce25aba8b2b22c32","modified":1692697934319},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之初见/14.png","hash":"5401e8ecc8e5663c8102460a62d1f60022b135a1","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之环境搭建/03.png","hash":"3e5152cf49b7f80d58ab7d98d8cfabd3076557fd","modified":1697067104000},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop08.png","hash":"84e036fb3a462afc9a182e70b1d9b644cb4d80fc","modified":1692697933946},{"_id":"source/_posts/Other/诗和远方/20221106_th.jpeg","hash":"1ac1620c7d7fb9481dc87bf08d24941ece9fee9d","modified":1692697934119},{"_id":"source/_posts/Other/诗和远方/20221101_th.jpeg","hash":"02ef18e00ef4a41216fa63d96f636f8b1e238820","modified":1692697934114},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度01.png","hash":"afcf800d8d28a8b1f890ed42a36da75e59252e58","modified":1692697934299},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"87dcb7fae8defe020ca3f15f3ca9d4a56d101497","modified":1605240014650},{"_id":"themes/next/.git/objects/pack/pack-9cd1cbc0f9c9c0b1b4b9becee91b151145312118.idx","hash":"f84443ef4f2d75ad1dd31ed9f60fb45556aa5136","modified":1506508854000},{"_id":"source/_posts/Flutter/Flutter之初见/22.png","hash":"3ee7f7debd8c3e9c4ded9e97b5cd53a28ab6ee94","modified":1698978001158},{"_id":"source/_posts/Flutter/Flutter之环境搭建/32.png","hash":"a8bcfbfcd0f9d4e68f2321e11c44d6507005ba6f","modified":1697067562000},{"_id":"source/_posts/Other/微信小程序/微信小程序02.png","hash":"45a2d0640313aa009192d4d26359d8c8aeba3623","modified":1692697934060},{"_id":"source/_posts/Other/微信小程序/微信小程序15.png","hash":"e415793749fbf23753ad268dc15d55a59bc80ac1","modified":1692697934089},{"_id":"source/_posts/Flutter/Flutter之初见/15.png","hash":"a1910ca8878da54adc0793a7c42c871cd3d76bd9","modified":1698197736000},{"_id":"source/_posts/Flutter/Flutter之初见/16.png","hash":"c0f43390051f3222b17be6d3c03dbf15b8843e5e","modified":1698197736000},{"_id":"source/_posts/Other/微信小程序/微信小程序33.png","hash":"bf5463084599c999cf4b576934f8bb77ad279550","modified":1692697934105},{"_id":"source/_posts/Other/微信小程序/微信小程序37.png","hash":"2f1026cfbc8699583b9bf365dbdfcae47c29107f","modified":1692697934109},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组11.png","hash":"c145b5f1701c86c601d1f21ad8dfe20ae4a956d0","modified":1692697934295},{"_id":"source/_posts/Flutter/Flutter之初见/13.png","hash":"5684b5401e05d19caa2c2835197f7ab7c3e0b018","modified":1698197736000},{"_id":"source/_posts/Other/微信小程序/微信小程序03.png","hash":"72192b06d63c60d078cf17e52fb3895ef7268a78","modified":1692697934062},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop07.png","hash":"cb23ba3c4ade2bf1593f1da7068fc1a17871c5fb","modified":1692697933944},{"_id":"source/_posts/Other/微信小程序/微信小程序08.png","hash":"d5e3ad79f8b35b7c86fe63cc6a3c9e952ccce8cd","modified":1692697934076},{"_id":"source/_posts/Other/微信小程序/微信小程序01.png","hash":"87aa06ed00d4775c7aa26439810054cd65a166de","modified":1692697934058},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度04.png","hash":"6c7c2383c09e6b37d161dc63c5ba59e7bfcdfdf6","modified":1692697934303},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1506508854000},{"_id":"themes/next/.git/objects/pack/pack-2fa19a2eea8e092a2b695a31d08f62770ed8b196.pack","hash":"130d2377f6a98c25878f136aebe05f0c33897310","modified":1579327672988},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1506508854000},{"_id":"source/_posts/Other/微信小程序/微信小程序14.png","hash":"0ad31d22cea9822bdd3391d558f1f6f7cc9657b3","modified":1692697934087},{"_id":"themes/next/.git/objects/pack/pack-9cd1cbc0f9c9c0b1b4b9becee91b151145312118.pack","hash":"a678da08e6d3af400e24781b42e2704f700d2bc6","modified":1506508854000}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html>\n    <head>\n        <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n        <meta name=\"robots\" content=\"all\" />\n        <meta name=\"robots\" content=\"index,follow\"/>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n    </head>\n    <body>\n        <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n            charset=\"utf-8\" homePageUrl=\"/\"\n            homePageName=\"回到我的主页\">\n            </script>\n        <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n        <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n","source":"404.htm","raw":"<!DOCTYPE html>\n<html>\n    <head>\n        <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n        <meta name=\"robots\" content=\"all\" />\n        <meta name=\"robots\" content=\"index,follow\"/>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n    </head>\n    <body>\n        <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n            charset=\"utf-8\" homePageUrl=\"/\"\n            homePageName=\"回到我的主页\">\n            </script>\n        <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n        <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n","date":"2023-08-22T09:52:13.906Z","updated":"2023-08-22T09:52:13.906Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cls4jmgci0000aq7kkblqychs"},{"title":"tags","date":"2016-05-19T01:50:26.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-05-19 09:50:26\ntype: \"tags\"\ncomments: false\n---\n","updated":"2023-08-22T09:52:14.373Z","path":"tags/index.html","layout":"page","_id":"cls4jmgoq0001aq7klviidu3m"}],"Post":[{"title":"Flutter之Dart","date":"2023-10-13T06:42:05.000Z","_content":"\n1. Dart 语言的入口是 `main` 函数，并且必须显式定义。Dart 语言的 `main` 函数没有返回值。传递给 `main` 函数的命令行参数，是通过 `List<String>` 完成的。`List` 是集合类型，每一个 `String` 都表示一个参数。\n2. Dart 语言中打印信息使用 `print` 函数。\n3. Dart 语言中定义字符串可以使用单引号或双引号。\n4. Dart 语言中每行代码必须使用分号结尾。\n5. 编写 Dart 语言创建的文件是 `.dart` 文件。\n\n<!-- more -->\n\nDart源码：安装过 Flutter 后，可以在 `/Applications/flutter/bin/cache/dart-sdk/lib/core/` 找到 Dart 的源码。\n\n## 环境搭建\n\n![01](Flutter之Dart/01.png)\n\n## 基本语法\n\n1. `main` 函数是 Dart 入口；\n2. Dart 中打印使用 `print`；\n\n`main` 函数的返回值是空 `void`，在 Dart 中返回值可以省略，由系统自动进行类型判断。\n\n```dart\nvoid main(List<String> args) {\n  print(\"hello dart\");\n}\n```\n\n### 声明变量\n\n1、明确的声明\n\n* 变量类型 变量名 = 赋值;\n\n```dart\nString name = \"Tom\";\n```\n\n2、类型推导\n\n`var` 用于定义变量，`final`、`const` 用于定义常量。使用他们定义变量或常量时，虽然没有明确指定变量的类型，但是在编译时变量可以明确自己的类型。\n\n使用 `var` 定义变量：\n\n```dart\nvar age = 20;\nage = 30\n// age = \"Tom\" ❌\n```\n\n使用 `final` 定义常量：\n\n```dart\nfinal height = 180;\n```\n\n使用 `const` 定义常量：\n\n```dart\nconst address = \"beijing\"\n```\n\n`final` 和 `const` 的区别：\n\n1. `const` 在赋值时，赋值的内容必须在**编译期间**就确定下来。\n2. `final` 在赋值时，可以动态获取，如通过计算、函数返回等方式获取一个值，在**运行期间**来确定一个值。\n\n可以通过函数给 final 赋值：\n\n```dart\nfinal date1 = DateTime.now();\n// const date2 = DateTime.now(); ❌\n```\n\n`final` 可以定义两个相同类型的常量。\n\n```dart\nvoid main(List<String> args) {\n  final p1 = Person(\"Tom\");\n  final p2 = Person(\"Tom\");\n  print(identical(p1, p2));\n  // Prints \"false\"\n}\n\nclass Person {\n  final String name;\n  Person(this.name);\n}\n```\n\n`const` 可以让一个类型只创建一个常量。\n\n```dart\nvoid main(List<String> args) {\n  const p1 = const Person(\"Tom\");\n  const p2 = const Person(\"Tom\");\n  print(identical(p1, p2));\n  // Prints \"True\"\n}\n\nclass Person {\n  final String name;\n  const Person(this.name);\n}\n```\n\n在日常开发中定义常量多使用 `final`。\n\n可以使用 `runtimeType` 获取变量当前的类型：\n\n```dart\nvar age = 20;\nprint(age.runtimeType);\n// Prints \"Int\"\n```\n\n### 布尔类型\n\nDart 中不能判断非零即真，或者非空即真。Bool 类型必须是一个确定的实体。\n\n```dart\nvoid main(List<String> args) {\n  var flag = \"abc\"\n  // if (flag) { ❌\n  //   print(\"hello dart\");\n  // }\n  if (flag != null) {\n    print(\"hellp dart\");\n  }\n}\n```\n\n### 字符串类型\n\nDart 字符串是 UTF-16 编码单元的序列，可以使用单引号或双引号创建一个字符串：\n\n```dart\nvoid main(List<String> args) {\n  var str1 = 'abc';\n  var str2 = \"abc\";\n\n  print(str1);\n  // Prints \"abc\"\n  print(str2);\n  // prints \"abc\"\n}\n```\n\n可以使用三个单引号或者双引号表示多行字符串\n\n```dart\nvoid main(List<String> args) {\n  var str3 = \"\"\"\nabc\ncba\nnba\n  \"\"\";\n  var str4 = '''\n  abc\n  cba\n  nba\n  ''';\n\n  print(str3);\n  print(str4);\n}\n  \n```\n\n打印结果：\n\n```js\nabc\ncba\nnba\n  \n abc\n cba\n nba\n```\n\n* 字符串的拼接\n\n字符串和其他变量或表达式拼接时，使用`${expression}`表达式，如果 expression 是一个标识符，那么 `{}` 可以省略：\n\n```dart\nvoid main(List<String> args) {\n  var name = \"Tom\";\n  var age = 18;\n  var height = 180;\n\n  var desc1 = \"name is ${name}, age is ${age}, height is ${height}。\";\n  var desc2 = \"name is $name, age is $age, height is $height。\";\n  print(desc1);\n  // Prints \"name is Tom, age is 18, height is 180。\"\n  print(desc2);\n  // Prints \"name is Tom, age is 18, height is 180。\"\n}\n```\n\n如果不是一个标识符，则不可以省略 `{}`：\n\n```dart\nvoid main(List<String> args) {\n  var name = \"Tom\";\n  var age = 18;\n  var height = 180;\n\n  var desc3 = \"name is $name.runtimeType, age is $age, height is $height。\";\n  var desc4 = \"name is ${name.runtimeType}, age is $age, height is $height。\";\n  print(desc3);\n  // Prints \"name is Tom.runtimeType, age is 18, height is 180。\"\n  print(desc4);\n  // Prints \"name is String, age is 18, height is 180。\"\n}\n```\n\n数字转字符串：\n\n```dart\nvoid main(List<String> args) {\n  int age = 18; // int\n\n  double height = 1.88; // double\n\n  var ageString = age.toString(); // 18 String\n\n  var heightString = height.toString(); // 1.88 String\n}\n```\n\n字符串转数字：\n\n```dart\nvoid main(List<String> args) {\n  int age = 18; // int\n\n  double height = 1.88; // double\n\n  var ageString = age.toString(); // 18 String\n\n  var heightString = height.toString(); // 1.88 String\n\n  print(int.parse(ageString));\n  // Prints \"18\"\n  print(double.parse(heightString));\n  // Priints \"1.88\"\n}\n```\n\n### 集合\n\n1、列表List：`[]`\n\n```dart\nvoid main(List<String> args) {\n  var names = [\"abc\", \"cba\", \"nba\"];\n  // 添加元素\n  names.add(\"mba\");\n  print('$names ${names.runtimeType}');\n  // Prints \"[abc, cba, nba, mba] List<String>\"\n\n  // 指定类型\n  List<String> stringNames = [\"abc\", \"cba\", \"nba\"];\n  print('$stringNames ${stringNames.runtimeType}');\n  // Prints \"[abc, cba, nba] List<String>\"\n}\n```\n\n2、集合Set：`{}`\n\n```dart\nvoid main(List<String> args) {\n  var numbers = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"1\"};\n  print('$numbers ${numbers.runtimeType}');\n  // Prints \"{1, 2, 3, 4, 5, 6} _Set<String>\"\n\n  // 指定类型\n  Set<String> sixNumbers = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"1\"};\n  print('$sixNumbers ${sixNumbers.runtimeType}');\n  // Prints \"{1, 2, 3, 4, 5, 6} _Set<String>\"\n}\n```\n\n3、映射Map\n\n```dart\nvoid main(List<String> args) {\n  var info = {\"name\": \"Tom\", \"age\": 18};\n  print('$info ${info.runtimeType}');\n  // Prints \"{name: Tom, age: 18} _Map<String, Object>\"\n\n  // 指定类型\n  Map<String, Object> userInfo = {\"name\": \"Tom\", \"age\": 18};\n  print('$userInfo ${userInfo.runtimeType}');\n  // Prints \"{name: Tom, age: 18} _Map<String, Object>\"\n}\n```\n\n#### 增删改查\n\n1、列表 List\n\n```dart\nvoid main(List<String> args) {\n  var numbersList = [1, 2, 3, 4, 5, 6];\n\n  numbersList.add(7);\n  print(numbersList);\n  // Prints \"[1, 2, 3, 4, 5, 6, 7]\"\n\n  numbersList.remove(3);\n  print(numbersList);\n  // Prints \"[1, 2, 4, 5, 6, 7]\"\n\n  print(numbersList.contains(6));\n  // Prints \"true\"\n\n  print(numbersList.removeAt(1));\n  // Prints \"2\"\n  print(numbersList);\n  // Prints \"[1, 4, 5, 6, 7]\"\n}\n```\n\n2、集合 Set\n\n```dart\nvoid main(List<String> args) {\n  var numbersSet = {1, 2, 3, 4, 5, 6};\n\n  numbersSet.add(7);\n  print(numbersSet);\n  // Prints \"{1, 2, 3, 4, 5, 6, 7}\"\n\n  numbersSet.remove(3);\n  print(numbersSet);\n  // Prints \"{1, 2, 4, 5, 6, 7}\"\n\n  print(numbersSet.contains(6));\n  // Prints \"true\"\n}\n```\n\n3、映射 Map\n\n```dart\nvoid main(List<String> args) {\n  var infoMap = {\"name\": \"Tom\", \"age\": 18};\n  print(infoMap['name']);\n  // Prints \"Tom\"\n\n  print('${infoMap.entries}');\n  // Prints \"(MapEntry(name: Tom), MapEntry(age: 18))\"\n\n  print('${infoMap.values} ${infoMap.values.runtimeType}');\n  // Prints \"(Tom, 18) _CompactIterable<Object>\"\n\n  print('${infoMap.keys} ${infoMap.keys.runtimeType}');\n  // Prints \"(name, age) _CompactIterable<String>\"\n\n  print('${infoMap.containsKey('age')}');\n  // Prints \"true\"\n\n  infoMap.remove('age');\n  print(infoMap);\n  // Prints \"{name: Tom}\"\n}\n```\n\n## 函数\n\n### 基本使用\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\n// 参数：int，int\n// 返回值：int\nint sum(int num1, int num2) {\n  return num1 + num2;\n}\n```\n\n`sum` 函数的参数和返回值都是 `int` 类型，其中返回值类型可以省略，由 Dart 自动推断：\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\nsum(int num1, int num2) {\n  return num1 + num2;\n}\n```\n\n* 如果函数中只有一个表达式，可以使用箭头语法（arrow syntax）`=>`\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\nsum(int num1, int num2) => num1 + num2;\n```\n\n### 可选参数\n\n在 Dart 中没有函数重载。参数类型分为三类：\n\n1. 必选参数；\n2. 位置可选参数；\n3. 命名可选参数；\n\n#### 必选参数\n\n```dart\nvoid main(List<String> args) {\n  sayHello(\"Tom\");\n}\n\nvoid sayHello(String name) {\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n可选参数有两种：\n\n1. 位置可选参数：[param1, param2, ...]；\n2. 命名可选参数：{param1, param2, ...}；\n\n#### 命名可选参数\n\n* 命名可选参数：{param1, param2, ...}；\n\n位置不确定，但是形参必须要写。\n\n```dart\nvoid main(List<String> args) {\n\n  sayHello3(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n  sayHello3(\"Tom\", age: 18);\n  // Prints \"name=Tom age=18 height=0.0\"\n  sayHello3(\"Tom\", height: 180);\n  // Prints \"name=Tom age=0 height=180.0\"\n  sayHello3(\"Tom\", age: 18, height: 180);\n  // Prints \"name=Tom age=18 height=180.0\"\n}\n\nvoid sayHello3(String name, {int age = 0, double height = 0}) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n#### 位置可选参数\n\n* 位置可选参数：[param1, param2, ...]；\n\n不需要写名形参，实参和形参在进行匹配时，是根据位置的匹配。\n\n```dart\nvoid main(List<String> args) {\n  sayHello2(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n  sayHello2(\"Tom\", 18);\n  // Prints \"name=Tom age=18 height=0.0\"\n  sayHello2(\"Tom\", 18, 180);\n  // Prints \"name=Tom age=18 height=180.0\"\n}\n\nvoid sayHello2(String name, [int age = 0, double height = 0]) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n### 参数默认值\n\n在不传参数的情况下，使用默认值。\n\n```dart\nvoid main(List<String> args) {\n\n  sayHello3(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n}\n\nvoid sayHello3(String name, {int age = 0, double height = 0}) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n### 函数是一等公民\n\n函数作为一等公民，即可以赋值给一个变量，也可以作为另一个函数的参数或这返回值。\n\n1、将函数赋值给一个变量：\n\n```dart\nvoid main(List<String> args) {\n  var hello = sayHello;\n  print(hello);\n  // Prints \"Closure: (String) => dynamic from Function 'sayHello': static.\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n```\n\n可以看到 `hello` 是一个 `Closure: (String) => dynamic` 的类型的函数。\n\n2、将函数作为另一个函数的参数：\n\n```dart\nvoid main(List<String> args) {\n  tom(sayHello);\n  // Prints \"hello Tom\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n\n// 2、将函数作为另一个函数的参数\ntom(Function func) {\n  func(\"Tom\");\n}\n```\n\n3、将函数作为另一个函数的返回值：\n\n```dart\nvoid main(List<String> args) {\n  var persion = getPersion();\n  persion(sayHello);\n  // Prints \"hello Tom\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n\n// 2、将函数作为另一个函数的参数\ntom(Function func) {\n  func(\"Tom\");\n}\n\n// 3、将函数作为另一个函数的返回值\ngetPersion() {\n  return tom;\n}\n```\n\n4、自定义函数类型\n\n```dart\ntypedef Calculate = void Function(int num1, int num2);\n\nvoid main(List<String> args) {\n  sum((num1, num2) {\n    print('$num1 + $num2 = ${num1 + num2}');\n  });\n}\n\nvoid sum(Calculate calc) {\n  calc(20, 30);\n}\n```\n\n### 匿名函数\n\n匿名闭包（anonymous function），也叫作 lambda 或 闭包（closure）。定义一个没有名字的函数，作为函数的参数或返回值，提高编码效率。\n\n```dart\nvoid main(List<String> args) {\n  say((String text) {\n    print(text);\n  });\n  // Prints \"hello\"\n}\n\nvoid say(Function func) {\n  func(\"hello\");\n}\n```\n\n`say` 函数的返回值为 `void`，参数是一个函数，该函数的参数是 `String` 类型，函数体是一个打印方法：\n\n```dart\n(String text) {\n  print(text);\n}\n```\n\n示例二：使用 `forEach` 遍历\n\n```dart\nvoid main(List<String> args) {\n  var array = [1, 2, 3, 4, 5, 6];\n  // 1、匿名函数\n  array.forEach((element) {\n    print(element);\n  });\n  // array.forEach((element) => print(element));\n\n  // 2、有名字的函数\n  printElement(element) {\n    print(element);\n  }\n  array.forEach(printElement);\n}\n```\n\n打印结果：\n\n```js\n1\n2\n3\n4\n5\n6\n1\n2\n3\n4\n5\n6\n```\n\n### 词法作用域\n\n优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  void say() {\n    print(name);\n    // Prints \"Tom\"\n  }\n\n  say();\n}\n```\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  var name = 'Tom 1';\n  void say() {\n    print(name);\n    // Prints \"Tom 1\"\n  }\n\n  say();\n}\n```\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  var name = 'Tom 1';\n  void say() {\n    var name = 'Tom 2';\n    print(name);\n    // Prints \"Tom 2\"\n  }\n\n  say();\n}\n```\n\n### 词法闭包\n\n```dart\nvoid main(List<String> args) {\n  createMaker(num addBy) {\n    // 返回一个闭包\n    return (num i) {\n      return i + addBy;\n    };\n  }\n\n  var adder = createMaker(1);\n  print(adder(1));\n  // Prints \"2\"\n  print(adder(2));\n  // Prints \"3\"\n}\n```\n\n创建出来的 `adder` 记住了创建时传入的 2。\n\n### 隐式返回\n\n所有函数都有一个返回值。如果没有指定返回值，则默认返回 `null`。\n\n```dart\nvoid main(List<String> args) {\n  print(method());\n  // Prints \"null\"\n}\n\nmethod() {\n  print('function');\n}\n```\n\n## 特殊运算符\n\n* `??` 空值合并运算符\n\n```dart\nvoid main(List<String> args) {\n  var name = null;\n  name = name ?? \"Tom\";\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n* `??=` 空值赋值运算符\n\n```dart\nvoid main(List<String> args) {\n  var name = null;\n  name ??= 'Tom';\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n* `..` 级联运算符\n\n```dart\nvoid main(List<String> args) {\n  var p = Persion()\n    ..name = 'Tom'\n    ..eat()\n    ..run();\n}\n\nclass Persion {\n  String name;\n\n  Persion({this.name = ''});\n\n  void run() {\n    print('$name is running');\n  }\n\n  void eat() {\n    print('$name is eating');\n  }\n}\n```\n\n打印信息：\n\n```js\nTom is eating\nTom is running\n```\n\n* `for` 循环\n\n```dart\nvoid main(List<String> args) {\n  for (var i = 0; i < 6; i++) {\n    print(i);\n  }\n\n  var numbers = [1, 2, 3, 4, 5, 6];\n  for (var i = 0; i < numbers.length; i++) {\n    print(numbers[i]);\n  }\n}\n```\n\n* `for-in` 循环\n\n```dart\nvoid main(List<String> args) {\n  var numbers = [1, 2, 3, 4, 5, 6];\n  for (var number in numbers) {\n    print(number);\n  }\n}\n```\n\n## Dart之面向对象\n\n### 类的定义\n\n```dart\nvoid main(List<String> args) {\n  // var p = new Person(\"Tom\", 18);\n  var p = Person(\"Tom\", 18);\n  print(p);\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age';\n  }\n}\n```\n\n1、初始化类时，类名前的 `new` 可以省略：\n\n```dart\n// var p = new Person(\"Tom\", 18);\nvar p = Person(\"Tom\", 18);\n```\n\n2、Dart 语言要求类的成员变量，在类初始化前要有确定的值。如果没有在初始化时给成员变量赋值，就会报错：\n\n![02](Flutter之Dart/02.png)\n\n### 类的构造函数\n\n```dart\nvoid main(List<String> args) {\n  var p1 = Person('Tom', 18);\n  var p2 = Person.custom('Jack', 18, 180);\n  print(p1);\n  // Prints \"name is Tom, age is 18, height is 0.0\"\n  print(p2);\n  // Prints \"name is Jack, age is 18, height is 180.0\"\n}\n\nclass Person {\n  String name;\n  int age;\n  double height = 0;\n\n  Person(this.name, this.age);\n  // 等同\n  //Person(String name, int age) {\n  //  this.name = name;\n  //  this.age = age;\n  //}\n\n  Person.custom(this.name, this.age, this.height);\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age, height is $height';\n  }\n}\n```\n\n使用 json 初始化类：\n\n```dart\nvoid main(List<String> args) {\n  var p3 = Person.fromMap({'name': 'Tom', 'age': 18, 'height': 180.0});\n  print(p3);\n  // Prints \"name is Tom, age is 18, height is 180.0\"\n}\n\nclass Person {\n  late String name;\n  late int age;\n  double height = 0;\n\n  Person.fromMap(Map<String, dynamic> map) {\n    this.name = map['name'];\n    this.age = map['age'];\n    this.height = map['height'];\n  }\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age, height is $height';\n  }\n}\n```\n\n### 初始化列表\n\n* 初始化列表会在构造函数前执行，常用于设置 `final` 变量的值，使用逗号`,`分隔初始化表达式。\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom', age: 18);\n  print(p);\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  final String name;\n  final int age;\n\n  Person(this.name, {int? age}) : this.age = age ?? 0 {}\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age';\n  }\n}\n```\n\n在创建对象时，可以选择传或不传 `age`，不传使用默认值：\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  print(p);\n  // Prints \"name is Tom, age is 0\"\n}\n```\n\nDart 3.0 后，使用 `?` 表示 `age` 可能为 `null`，在可选参数列表中使用 `??` 判断 `age` 是否有值。\n\n![05](Flutter之Dart/05.png)\n\n`widget` 中 `container` 的相关源码（路径`/Applications/flutter/packages/flutter/lib/src/widgets/container.dart`）：\n\n```dart\nContainer({\n    super.key,\n    this.alignment,\n    this.padding,\n    this.color,\n    this.decoration,\n    this.foregroundDecoration,\n    double? width,\n    double? height,\n    BoxConstraints? constraints,\n    this.margin,\n    this.transform,\n    this.transformAlignment,\n    this.child,\n    this.clipBehavior = Clip.none,\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n```\n\n### 重定向构造方法\n\n因为 Dart 不支持方法重载，所以对于有多个成员变量的类，不能写多个不同的构造方法：\n\n![06](Flutter之Dart/06.png)\n\n可以使用**构造函数重定向**来实现这种场景：\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('name');\n  print(p.age);\n  // Prints \"0\"\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(String name) : this._internal(name, 0);\n\n  Person._internal(this.name, this.age);\n}\n```\n\n### 工厂构造方法\n\n普通的构造函数会自动返回创建出来的对象，不能手动返回：\n\n```dart\nvoid main(List<String> args) {\n  final p3 = Person('Jack', 'brown');\n  final p4 = Person('Jack', 'brown');\n  print(identical(p3, p4));\n  // Pritns \"false\"\n}\n\nclass Person {\n  String name;\n  String color;\n\n  Person(this.name, this.color);\n}\n```\n\n工厂构造函数最大的特点是**可以手动返回一个对象**：\n\n```dart\nvoid main(List<String> args) {\n  final p1 = Person.withName('Tom');\n  final p2 = Person.withName('Tom');\n  print(identical(p1, p2));\n  // Prints \"true\"\n}\n\nclass Person {\n  String name;\n  String color;\n\n  Person(this.name, this.color);\n\n  static final Map<String, Person> _nameCache = {};\n  static final Map<String, Person> _colorCache = {};\n\n  factory Person.withName(String name) {\n    if (_nameCache.containsKey(name)) {\n      return _nameCache[name]!;\n    } else {\n      final p = Person(name, 'default');\n      _nameCache[name] = p;\n      return p;\n    }\n  }\n\n  factory Person.withColor(String color) {\n    if (_colorCache.containsKey(color)) {\n      return _colorCache[color]!;\n    } else {\n      final p = Person('default', color);\n      _colorCache[color] = p;\n      return p;\n    }\n  }\n}\n```\n\n📢注意：这里的 `_nameCache[name]!` 加了 `!`，表明一定不为 `null`。这是 Dart 3.0 增加的能力-[空安全类型系统](https://dart.cn/codelabs/null-safety)。\n\n### setter 和 getter\n\n```dart\nvoid main(List<String> args) {\n  final p = Person();\n\n  p.name = 'Tom';\n  print(p.name);\n  // Prints \"Tom\"\n\n  p.setName = 'Jack';\n  print(p.name);\n  // Prints \"Jack\"\n  print(p.getName);\n  // Prints \"Jack\"\n}\n\nclass Person {\n  String name;\n\n  Person({String? name}) : this.name = name ?? \"\";\n\n  // Setter\n  set setName(String name) => this.name = name;\n  // Getter\n  String get getName => name;\n}\n```\n\n### 类的继承\n\n1. 使用 `extends` 表示继承关系；\n2. 子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。\n3. 如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过`super`显式调用父类的某个构造方法。\n\n```dart\nvoid main(List<String> args) {\n  var t = Teacher(18, 'Tom');\n  print('name is ${t.name}, age is ${t.age}');\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  String name;\n  Person(this.name);\n}\n\nclass Teacher extends Person {\n  int age;\n\n  Teacher(this.age, String name) : super(name);\n}\n```\n\n\n\n### Object 和 dynamic 的区别\n\nDart 中所有类型都是 Object 的子类，包括 Function 和 Null。\n\n* dynamic 与 Object 声明的变量都可以赋值任意对象，且后期可以改变赋值的类型。\n\n![03](Flutter之Dart/03.png)\n\n* Object 对象使用的属性和方法若不存在，**编译时会报错**。\n\n* dynamic 对象使用的属性和方法若不存在，**编译时不会报错，运行时会报错**。\n\n![04](Flutter之Dart/04.png)\n\n### 抽象类的使用\n\n📢注意一：继承自抽象类后，必须实现抽象类中没有实现的方法。\n\n![07](Flutter之Dart/07.png)\n\n📢注意二：抽象类不能实例化。\n\n![08](Flutter之Dart/08.png)\n\n必须实现抽象类中没有实现的方法：\n\n```dart\nvoid main(List<String> args) {\n  final t = Teacher();\n  print('name is ${t.getName()}, age is ${t.getAge()}');\n  // Prints \"name is 名字, age is 18\"\n}\n\nabstract class Person {\n  int getAge();\n  String getName() {\n    return '名字';\n  }\n}\n\nclass Teacher extends Person {\n  @override\n  int getAge() {\n    return 18;\n  }\n}\n```\n\n可以重写抽象类中有实现的方法：\n\n```dart\nvoid main(List<String> args) {\n  final t = Teacher();\n  print('name is ${t.getName()}, age is ${t.getAge()}');\n  // Prints \"name is Tom, age is 18\"\n}\n\nabstract class Person {\n  int getAge();\n  String getName() {\n    return '名字';\n  }\n}\n\nclass Teacher extends Person {\n  @override\n  int getAge() {\n    return 18;\n  }\n\n  @override\n  String getName() {\n    return 'Tom';\n  }\n}\n```\n\n### 隐式接口\n\nDart 默认情况下所有的类都是隐式接口。在将一个类作为接口使用时，实现接口的类，必须实现这个接口中所有方法。通常将用于给别人实现的类声明为抽象类。\n\n定义一个 `Tom` 类，继承自 `Person`，使用 `Run`、`Swim` 类作为接口：\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n}\n\nabstract class Run {\n  void running() {}\n}\n\nabstract class Swim {\n  void swimming() {}\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n}\n\nclass Tom extends Person implements Run, Swim {\n  Tom() : super('Tom', 18);\n\n  @override\n  void running() {\n    print('Tom is good at running');\n  }\n\n  @override\n  void swimming() {\n    print('Tom is good at swimming');\n  }\n}\n```\n\n![09](Flutter之Dart/09.png)\n\n通过 `implements` 实现某个类时，必须重新实现类定义的所有方法(无论这个类是否已经对方法实现)。如果想要直接复用之前类的原有实现方案，则可以使用 `mixin`混入。\n\n### mixin混入的使用\n\n想要直接复用之前类的原有实现方案，一般采取继承。但是因为 Dart 只支持单继承，所以无法直接复用多个类原有的实现方案。\n\n想要**直接复用多个类原有的实现方案**，可以采用 Mixin 混入的方式：\n\n1. 使用 `mixin` 关键字定义一个类；\n2. 使用 `with` 关键字来实现混入；\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n  // Prints \"running\"\n  t.swimming();\n  // Prints \"swimming\"\n}\n\n/**\n1、使用 mixin 关键字定义类\n*/\nmixin Run {\n  void running() {\n    print('running');\n  }\n}\n\nmixin Swim {\n  void swimming() {\n    print('swimming');\n  }\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  // 父类实现隐式接口\n  void running() {\n    print('running');\n  }\n}\n\n/**\n2、使用 with 实现混入，不需要重写方法\n*/\nclass Tom extends Person with Run, Swim {\n  Tom() : super('Tom', 18);\n}\n```\n\n如果要类比的话，`mixin` 混入和 Swift 的协议有异曲同工之妙。\n\n`implements` 和 `with` 关键字一起使用时，`implements` 要放最后：\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n}\n\nabstract class Run {\n  void running() {\n    print('running');\n  }\n}\n\nmixin Swim {\n  void swimming() {\n    print('swimming');\n  }\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  // 父类实现隐式接口\n  void running() {\n    print('running');\n  }\n}\n\nclass Tom extends Person with Swim implements Run {\n  Tom() : super('Tom', 18);\n}\n```\n\n### 类属性\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  Person.age = 18;\n}\n\nclass Person {\n  String name;\n\n  static int age = 0;\n\n  Person(this.name);\n}\n```\n\n### 类方法\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  p.talkName();\n  // Prints \"Tom\"\n\n  Person.age = 18;\n  Person.tallAge();\n  // Prints \"18\"\n}\n\nclass Person {\n  String name;\n\n  static int age = 0;\n\n  Person(this.name);\n\n  void talkName() {\n    print(name);\n  }\n\n  static void tallAge() {\n    print(age);\n  }\n}\n```\n\n### 枚举\n\n选择器必须覆盖枚举类型的全部情况，否则会报错：\n\n![10](Flutter之Dart/10.png)\n\n```dart\nvoid main(List<String> args) {\n  final color = Colors.red;\n\n  switch (color) {\n    case Colors.red:\n      print('红色');\n      break;\n    case Colors.blue:\n      print('蓝色');\n      break;\n    default:\n      print('绿色');\n      break;\n  }\n  // Prints \"红色\"\n}\n\nenum Colors { red, blue, green }\n```\n\n## Dart中库的使用\n\n### 一、使用系统库\n\n使用 `import '库的url'` 的形式导入一个库。\n\n```dart\nimport 'dart:math';\n\nvoid main(List<String> args) {\n  final num1 = 20;\n  final num2 = 30;\n  print(min(num1, num2));\n  // Prints \"50\"\n}\n```\n\n库url有三种方式：\n\n1、使用 `dart:` 表示 dart 标准库，\n\n```dart\nimport 'dart:io';\nimport 'dart:math';\nimport 'dart:html';\n```\n\n2、使用相对路径，导入项目中自定义的 .dart 文件：\n\n```dart\nimport 'utils/math_utils.dart'\n```\n\n3、Pub包管理系统中的库，使用前缀 `package:`：\n\n```dart\nimport 'package:http/http.dart'\n```\n\n### 二、使用自定义库\n\n![11](Flutter之Dart/11.png)\n\n1、`as` 关键字给库起别名。\n\n当各个库有命名冲突的时候，可以使用 `as` 关键字来使用命名空间：\n\n```dart\nimport 'utils/math_utils.dart' as mUtils;\n```\n\n2、默认情况下，导入一个库时就是导入这个库中所有的内容。\n\n`show`：执行要导入的内容。\n\n```dart\nimport \"utils/math_utils.dart\" show sum, mul;\n```\n\n`hide`：隐藏某个要导入的内容，导入其它内容。\n\n```dart\nimport \"utils/math_utils.dart\" hide mul;\n```\n\n3、将需要导入的库，使用 `export` 抽取到公共的 dart 文件\n\n![12](Flutter之Dart/12.png)\n\n```dart\nimport \"utils/utils.dart\";\n\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n  print(min(10, 11));\n  // Prints \"10\"\n}\n```\n\n### 使用第三方库\n\n```dart\nimport 'package:http/http.dart' as http;\n\nmain(List<String> args) async {\n  var url = 'http://123.207.32.32:8000/home/multidata';\n  var response = await http.get(url);\n  print('Response status: ${response.statusCode}');\n  print('Response body: ${response.body}');\n}\n```\n\n参考 [http 1.1.0 ](https://pub.dev/packages/http/install)","source":"_posts/Flutter/Flutter之Dart.md","raw":"---\ntitle: Flutter之Dart\ndate: 2023-10-13 14:42:05\ntags: Flutter\n---\n\n1. Dart 语言的入口是 `main` 函数，并且必须显式定义。Dart 语言的 `main` 函数没有返回值。传递给 `main` 函数的命令行参数，是通过 `List<String>` 完成的。`List` 是集合类型，每一个 `String` 都表示一个参数。\n2. Dart 语言中打印信息使用 `print` 函数。\n3. Dart 语言中定义字符串可以使用单引号或双引号。\n4. Dart 语言中每行代码必须使用分号结尾。\n5. 编写 Dart 语言创建的文件是 `.dart` 文件。\n\n<!-- more -->\n\nDart源码：安装过 Flutter 后，可以在 `/Applications/flutter/bin/cache/dart-sdk/lib/core/` 找到 Dart 的源码。\n\n## 环境搭建\n\n![01](Flutter之Dart/01.png)\n\n## 基本语法\n\n1. `main` 函数是 Dart 入口；\n2. Dart 中打印使用 `print`；\n\n`main` 函数的返回值是空 `void`，在 Dart 中返回值可以省略，由系统自动进行类型判断。\n\n```dart\nvoid main(List<String> args) {\n  print(\"hello dart\");\n}\n```\n\n### 声明变量\n\n1、明确的声明\n\n* 变量类型 变量名 = 赋值;\n\n```dart\nString name = \"Tom\";\n```\n\n2、类型推导\n\n`var` 用于定义变量，`final`、`const` 用于定义常量。使用他们定义变量或常量时，虽然没有明确指定变量的类型，但是在编译时变量可以明确自己的类型。\n\n使用 `var` 定义变量：\n\n```dart\nvar age = 20;\nage = 30\n// age = \"Tom\" ❌\n```\n\n使用 `final` 定义常量：\n\n```dart\nfinal height = 180;\n```\n\n使用 `const` 定义常量：\n\n```dart\nconst address = \"beijing\"\n```\n\n`final` 和 `const` 的区别：\n\n1. `const` 在赋值时，赋值的内容必须在**编译期间**就确定下来。\n2. `final` 在赋值时，可以动态获取，如通过计算、函数返回等方式获取一个值，在**运行期间**来确定一个值。\n\n可以通过函数给 final 赋值：\n\n```dart\nfinal date1 = DateTime.now();\n// const date2 = DateTime.now(); ❌\n```\n\n`final` 可以定义两个相同类型的常量。\n\n```dart\nvoid main(List<String> args) {\n  final p1 = Person(\"Tom\");\n  final p2 = Person(\"Tom\");\n  print(identical(p1, p2));\n  // Prints \"false\"\n}\n\nclass Person {\n  final String name;\n  Person(this.name);\n}\n```\n\n`const` 可以让一个类型只创建一个常量。\n\n```dart\nvoid main(List<String> args) {\n  const p1 = const Person(\"Tom\");\n  const p2 = const Person(\"Tom\");\n  print(identical(p1, p2));\n  // Prints \"True\"\n}\n\nclass Person {\n  final String name;\n  const Person(this.name);\n}\n```\n\n在日常开发中定义常量多使用 `final`。\n\n可以使用 `runtimeType` 获取变量当前的类型：\n\n```dart\nvar age = 20;\nprint(age.runtimeType);\n// Prints \"Int\"\n```\n\n### 布尔类型\n\nDart 中不能判断非零即真，或者非空即真。Bool 类型必须是一个确定的实体。\n\n```dart\nvoid main(List<String> args) {\n  var flag = \"abc\"\n  // if (flag) { ❌\n  //   print(\"hello dart\");\n  // }\n  if (flag != null) {\n    print(\"hellp dart\");\n  }\n}\n```\n\n### 字符串类型\n\nDart 字符串是 UTF-16 编码单元的序列，可以使用单引号或双引号创建一个字符串：\n\n```dart\nvoid main(List<String> args) {\n  var str1 = 'abc';\n  var str2 = \"abc\";\n\n  print(str1);\n  // Prints \"abc\"\n  print(str2);\n  // prints \"abc\"\n}\n```\n\n可以使用三个单引号或者双引号表示多行字符串\n\n```dart\nvoid main(List<String> args) {\n  var str3 = \"\"\"\nabc\ncba\nnba\n  \"\"\";\n  var str4 = '''\n  abc\n  cba\n  nba\n  ''';\n\n  print(str3);\n  print(str4);\n}\n  \n```\n\n打印结果：\n\n```js\nabc\ncba\nnba\n  \n abc\n cba\n nba\n```\n\n* 字符串的拼接\n\n字符串和其他变量或表达式拼接时，使用`${expression}`表达式，如果 expression 是一个标识符，那么 `{}` 可以省略：\n\n```dart\nvoid main(List<String> args) {\n  var name = \"Tom\";\n  var age = 18;\n  var height = 180;\n\n  var desc1 = \"name is ${name}, age is ${age}, height is ${height}。\";\n  var desc2 = \"name is $name, age is $age, height is $height。\";\n  print(desc1);\n  // Prints \"name is Tom, age is 18, height is 180。\"\n  print(desc2);\n  // Prints \"name is Tom, age is 18, height is 180。\"\n}\n```\n\n如果不是一个标识符，则不可以省略 `{}`：\n\n```dart\nvoid main(List<String> args) {\n  var name = \"Tom\";\n  var age = 18;\n  var height = 180;\n\n  var desc3 = \"name is $name.runtimeType, age is $age, height is $height。\";\n  var desc4 = \"name is ${name.runtimeType}, age is $age, height is $height。\";\n  print(desc3);\n  // Prints \"name is Tom.runtimeType, age is 18, height is 180。\"\n  print(desc4);\n  // Prints \"name is String, age is 18, height is 180。\"\n}\n```\n\n数字转字符串：\n\n```dart\nvoid main(List<String> args) {\n  int age = 18; // int\n\n  double height = 1.88; // double\n\n  var ageString = age.toString(); // 18 String\n\n  var heightString = height.toString(); // 1.88 String\n}\n```\n\n字符串转数字：\n\n```dart\nvoid main(List<String> args) {\n  int age = 18; // int\n\n  double height = 1.88; // double\n\n  var ageString = age.toString(); // 18 String\n\n  var heightString = height.toString(); // 1.88 String\n\n  print(int.parse(ageString));\n  // Prints \"18\"\n  print(double.parse(heightString));\n  // Priints \"1.88\"\n}\n```\n\n### 集合\n\n1、列表List：`[]`\n\n```dart\nvoid main(List<String> args) {\n  var names = [\"abc\", \"cba\", \"nba\"];\n  // 添加元素\n  names.add(\"mba\");\n  print('$names ${names.runtimeType}');\n  // Prints \"[abc, cba, nba, mba] List<String>\"\n\n  // 指定类型\n  List<String> stringNames = [\"abc\", \"cba\", \"nba\"];\n  print('$stringNames ${stringNames.runtimeType}');\n  // Prints \"[abc, cba, nba] List<String>\"\n}\n```\n\n2、集合Set：`{}`\n\n```dart\nvoid main(List<String> args) {\n  var numbers = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"1\"};\n  print('$numbers ${numbers.runtimeType}');\n  // Prints \"{1, 2, 3, 4, 5, 6} _Set<String>\"\n\n  // 指定类型\n  Set<String> sixNumbers = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"1\"};\n  print('$sixNumbers ${sixNumbers.runtimeType}');\n  // Prints \"{1, 2, 3, 4, 5, 6} _Set<String>\"\n}\n```\n\n3、映射Map\n\n```dart\nvoid main(List<String> args) {\n  var info = {\"name\": \"Tom\", \"age\": 18};\n  print('$info ${info.runtimeType}');\n  // Prints \"{name: Tom, age: 18} _Map<String, Object>\"\n\n  // 指定类型\n  Map<String, Object> userInfo = {\"name\": \"Tom\", \"age\": 18};\n  print('$userInfo ${userInfo.runtimeType}');\n  // Prints \"{name: Tom, age: 18} _Map<String, Object>\"\n}\n```\n\n#### 增删改查\n\n1、列表 List\n\n```dart\nvoid main(List<String> args) {\n  var numbersList = [1, 2, 3, 4, 5, 6];\n\n  numbersList.add(7);\n  print(numbersList);\n  // Prints \"[1, 2, 3, 4, 5, 6, 7]\"\n\n  numbersList.remove(3);\n  print(numbersList);\n  // Prints \"[1, 2, 4, 5, 6, 7]\"\n\n  print(numbersList.contains(6));\n  // Prints \"true\"\n\n  print(numbersList.removeAt(1));\n  // Prints \"2\"\n  print(numbersList);\n  // Prints \"[1, 4, 5, 6, 7]\"\n}\n```\n\n2、集合 Set\n\n```dart\nvoid main(List<String> args) {\n  var numbersSet = {1, 2, 3, 4, 5, 6};\n\n  numbersSet.add(7);\n  print(numbersSet);\n  // Prints \"{1, 2, 3, 4, 5, 6, 7}\"\n\n  numbersSet.remove(3);\n  print(numbersSet);\n  // Prints \"{1, 2, 4, 5, 6, 7}\"\n\n  print(numbersSet.contains(6));\n  // Prints \"true\"\n}\n```\n\n3、映射 Map\n\n```dart\nvoid main(List<String> args) {\n  var infoMap = {\"name\": \"Tom\", \"age\": 18};\n  print(infoMap['name']);\n  // Prints \"Tom\"\n\n  print('${infoMap.entries}');\n  // Prints \"(MapEntry(name: Tom), MapEntry(age: 18))\"\n\n  print('${infoMap.values} ${infoMap.values.runtimeType}');\n  // Prints \"(Tom, 18) _CompactIterable<Object>\"\n\n  print('${infoMap.keys} ${infoMap.keys.runtimeType}');\n  // Prints \"(name, age) _CompactIterable<String>\"\n\n  print('${infoMap.containsKey('age')}');\n  // Prints \"true\"\n\n  infoMap.remove('age');\n  print(infoMap);\n  // Prints \"{name: Tom}\"\n}\n```\n\n## 函数\n\n### 基本使用\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\n// 参数：int，int\n// 返回值：int\nint sum(int num1, int num2) {\n  return num1 + num2;\n}\n```\n\n`sum` 函数的参数和返回值都是 `int` 类型，其中返回值类型可以省略，由 Dart 自动推断：\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\nsum(int num1, int num2) {\n  return num1 + num2;\n}\n```\n\n* 如果函数中只有一个表达式，可以使用箭头语法（arrow syntax）`=>`\n\n```dart\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n}\n\nsum(int num1, int num2) => num1 + num2;\n```\n\n### 可选参数\n\n在 Dart 中没有函数重载。参数类型分为三类：\n\n1. 必选参数；\n2. 位置可选参数；\n3. 命名可选参数；\n\n#### 必选参数\n\n```dart\nvoid main(List<String> args) {\n  sayHello(\"Tom\");\n}\n\nvoid sayHello(String name) {\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n可选参数有两种：\n\n1. 位置可选参数：[param1, param2, ...]；\n2. 命名可选参数：{param1, param2, ...}；\n\n#### 命名可选参数\n\n* 命名可选参数：{param1, param2, ...}；\n\n位置不确定，但是形参必须要写。\n\n```dart\nvoid main(List<String> args) {\n\n  sayHello3(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n  sayHello3(\"Tom\", age: 18);\n  // Prints \"name=Tom age=18 height=0.0\"\n  sayHello3(\"Tom\", height: 180);\n  // Prints \"name=Tom age=0 height=180.0\"\n  sayHello3(\"Tom\", age: 18, height: 180);\n  // Prints \"name=Tom age=18 height=180.0\"\n}\n\nvoid sayHello3(String name, {int age = 0, double height = 0}) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n#### 位置可选参数\n\n* 位置可选参数：[param1, param2, ...]；\n\n不需要写名形参，实参和形参在进行匹配时，是根据位置的匹配。\n\n```dart\nvoid main(List<String> args) {\n  sayHello2(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n  sayHello2(\"Tom\", 18);\n  // Prints \"name=Tom age=18 height=0.0\"\n  sayHello2(\"Tom\", 18, 180);\n  // Prints \"name=Tom age=18 height=180.0\"\n}\n\nvoid sayHello2(String name, [int age = 0, double height = 0]) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n### 参数默认值\n\n在不传参数的情况下，使用默认值。\n\n```dart\nvoid main(List<String> args) {\n\n  sayHello3(\"Tom\");\n  // Prints \"name=Tom age=0 height=0.0\"\n}\n\nvoid sayHello3(String name, {int age = 0, double height = 0}) {\n  print('name=$age age=$age height=$height');\n}\n```\n\n### 函数是一等公民\n\n函数作为一等公民，即可以赋值给一个变量，也可以作为另一个函数的参数或这返回值。\n\n1、将函数赋值给一个变量：\n\n```dart\nvoid main(List<String> args) {\n  var hello = sayHello;\n  print(hello);\n  // Prints \"Closure: (String) => dynamic from Function 'sayHello': static.\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n```\n\n可以看到 `hello` 是一个 `Closure: (String) => dynamic` 的类型的函数。\n\n2、将函数作为另一个函数的参数：\n\n```dart\nvoid main(List<String> args) {\n  tom(sayHello);\n  // Prints \"hello Tom\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n\n// 2、将函数作为另一个函数的参数\ntom(Function func) {\n  func(\"Tom\");\n}\n```\n\n3、将函数作为另一个函数的返回值：\n\n```dart\nvoid main(List<String> args) {\n  var persion = getPersion();\n  persion(sayHello);\n  // Prints \"hello Tom\"\n}\n\n// 1、定义一个函数\nsayHello(String name) {\n  print(\"hello $name\");\n}\n\n// 2、将函数作为另一个函数的参数\ntom(Function func) {\n  func(\"Tom\");\n}\n\n// 3、将函数作为另一个函数的返回值\ngetPersion() {\n  return tom;\n}\n```\n\n4、自定义函数类型\n\n```dart\ntypedef Calculate = void Function(int num1, int num2);\n\nvoid main(List<String> args) {\n  sum((num1, num2) {\n    print('$num1 + $num2 = ${num1 + num2}');\n  });\n}\n\nvoid sum(Calculate calc) {\n  calc(20, 30);\n}\n```\n\n### 匿名函数\n\n匿名闭包（anonymous function），也叫作 lambda 或 闭包（closure）。定义一个没有名字的函数，作为函数的参数或返回值，提高编码效率。\n\n```dart\nvoid main(List<String> args) {\n  say((String text) {\n    print(text);\n  });\n  // Prints \"hello\"\n}\n\nvoid say(Function func) {\n  func(\"hello\");\n}\n```\n\n`say` 函数的返回值为 `void`，参数是一个函数，该函数的参数是 `String` 类型，函数体是一个打印方法：\n\n```dart\n(String text) {\n  print(text);\n}\n```\n\n示例二：使用 `forEach` 遍历\n\n```dart\nvoid main(List<String> args) {\n  var array = [1, 2, 3, 4, 5, 6];\n  // 1、匿名函数\n  array.forEach((element) {\n    print(element);\n  });\n  // array.forEach((element) => print(element));\n\n  // 2、有名字的函数\n  printElement(element) {\n    print(element);\n  }\n  array.forEach(printElement);\n}\n```\n\n打印结果：\n\n```js\n1\n2\n3\n4\n5\n6\n1\n2\n3\n4\n5\n6\n```\n\n### 词法作用域\n\n优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  void say() {\n    print(name);\n    // Prints \"Tom\"\n  }\n\n  say();\n}\n```\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  var name = 'Tom 1';\n  void say() {\n    print(name);\n    // Prints \"Tom 1\"\n  }\n\n  say();\n}\n```\n\n```dart\nvar name = 'Tom';\nvoid main(List<String> args) {\n  var name = 'Tom 1';\n  void say() {\n    var name = 'Tom 2';\n    print(name);\n    // Prints \"Tom 2\"\n  }\n\n  say();\n}\n```\n\n### 词法闭包\n\n```dart\nvoid main(List<String> args) {\n  createMaker(num addBy) {\n    // 返回一个闭包\n    return (num i) {\n      return i + addBy;\n    };\n  }\n\n  var adder = createMaker(1);\n  print(adder(1));\n  // Prints \"2\"\n  print(adder(2));\n  // Prints \"3\"\n}\n```\n\n创建出来的 `adder` 记住了创建时传入的 2。\n\n### 隐式返回\n\n所有函数都有一个返回值。如果没有指定返回值，则默认返回 `null`。\n\n```dart\nvoid main(List<String> args) {\n  print(method());\n  // Prints \"null\"\n}\n\nmethod() {\n  print('function');\n}\n```\n\n## 特殊运算符\n\n* `??` 空值合并运算符\n\n```dart\nvoid main(List<String> args) {\n  var name = null;\n  name = name ?? \"Tom\";\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n* `??=` 空值赋值运算符\n\n```dart\nvoid main(List<String> args) {\n  var name = null;\n  name ??= 'Tom';\n  print(name);\n  // Prints \"Tom\"\n}\n```\n\n* `..` 级联运算符\n\n```dart\nvoid main(List<String> args) {\n  var p = Persion()\n    ..name = 'Tom'\n    ..eat()\n    ..run();\n}\n\nclass Persion {\n  String name;\n\n  Persion({this.name = ''});\n\n  void run() {\n    print('$name is running');\n  }\n\n  void eat() {\n    print('$name is eating');\n  }\n}\n```\n\n打印信息：\n\n```js\nTom is eating\nTom is running\n```\n\n* `for` 循环\n\n```dart\nvoid main(List<String> args) {\n  for (var i = 0; i < 6; i++) {\n    print(i);\n  }\n\n  var numbers = [1, 2, 3, 4, 5, 6];\n  for (var i = 0; i < numbers.length; i++) {\n    print(numbers[i]);\n  }\n}\n```\n\n* `for-in` 循环\n\n```dart\nvoid main(List<String> args) {\n  var numbers = [1, 2, 3, 4, 5, 6];\n  for (var number in numbers) {\n    print(number);\n  }\n}\n```\n\n## Dart之面向对象\n\n### 类的定义\n\n```dart\nvoid main(List<String> args) {\n  // var p = new Person(\"Tom\", 18);\n  var p = Person(\"Tom\", 18);\n  print(p);\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age';\n  }\n}\n```\n\n1、初始化类时，类名前的 `new` 可以省略：\n\n```dart\n// var p = new Person(\"Tom\", 18);\nvar p = Person(\"Tom\", 18);\n```\n\n2、Dart 语言要求类的成员变量，在类初始化前要有确定的值。如果没有在初始化时给成员变量赋值，就会报错：\n\n![02](Flutter之Dart/02.png)\n\n### 类的构造函数\n\n```dart\nvoid main(List<String> args) {\n  var p1 = Person('Tom', 18);\n  var p2 = Person.custom('Jack', 18, 180);\n  print(p1);\n  // Prints \"name is Tom, age is 18, height is 0.0\"\n  print(p2);\n  // Prints \"name is Jack, age is 18, height is 180.0\"\n}\n\nclass Person {\n  String name;\n  int age;\n  double height = 0;\n\n  Person(this.name, this.age);\n  // 等同\n  //Person(String name, int age) {\n  //  this.name = name;\n  //  this.age = age;\n  //}\n\n  Person.custom(this.name, this.age, this.height);\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age, height is $height';\n  }\n}\n```\n\n使用 json 初始化类：\n\n```dart\nvoid main(List<String> args) {\n  var p3 = Person.fromMap({'name': 'Tom', 'age': 18, 'height': 180.0});\n  print(p3);\n  // Prints \"name is Tom, age is 18, height is 180.0\"\n}\n\nclass Person {\n  late String name;\n  late int age;\n  double height = 0;\n\n  Person.fromMap(Map<String, dynamic> map) {\n    this.name = map['name'];\n    this.age = map['age'];\n    this.height = map['height'];\n  }\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age, height is $height';\n  }\n}\n```\n\n### 初始化列表\n\n* 初始化列表会在构造函数前执行，常用于设置 `final` 变量的值，使用逗号`,`分隔初始化表达式。\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom', age: 18);\n  print(p);\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  final String name;\n  final int age;\n\n  Person(this.name, {int? age}) : this.age = age ?? 0 {}\n\n  @override\n  String toString() {\n    return 'name is $name, age is $age';\n  }\n}\n```\n\n在创建对象时，可以选择传或不传 `age`，不传使用默认值：\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  print(p);\n  // Prints \"name is Tom, age is 0\"\n}\n```\n\nDart 3.0 后，使用 `?` 表示 `age` 可能为 `null`，在可选参数列表中使用 `??` 判断 `age` 是否有值。\n\n![05](Flutter之Dart/05.png)\n\n`widget` 中 `container` 的相关源码（路径`/Applications/flutter/packages/flutter/lib/src/widgets/container.dart`）：\n\n```dart\nContainer({\n    super.key,\n    this.alignment,\n    this.padding,\n    this.color,\n    this.decoration,\n    this.foregroundDecoration,\n    double? width,\n    double? height,\n    BoxConstraints? constraints,\n    this.margin,\n    this.transform,\n    this.transformAlignment,\n    this.child,\n    this.clipBehavior = Clip.none,\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n```\n\n### 重定向构造方法\n\n因为 Dart 不支持方法重载，所以对于有多个成员变量的类，不能写多个不同的构造方法：\n\n![06](Flutter之Dart/06.png)\n\n可以使用**构造函数重定向**来实现这种场景：\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('name');\n  print(p.age);\n  // Prints \"0\"\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(String name) : this._internal(name, 0);\n\n  Person._internal(this.name, this.age);\n}\n```\n\n### 工厂构造方法\n\n普通的构造函数会自动返回创建出来的对象，不能手动返回：\n\n```dart\nvoid main(List<String> args) {\n  final p3 = Person('Jack', 'brown');\n  final p4 = Person('Jack', 'brown');\n  print(identical(p3, p4));\n  // Pritns \"false\"\n}\n\nclass Person {\n  String name;\n  String color;\n\n  Person(this.name, this.color);\n}\n```\n\n工厂构造函数最大的特点是**可以手动返回一个对象**：\n\n```dart\nvoid main(List<String> args) {\n  final p1 = Person.withName('Tom');\n  final p2 = Person.withName('Tom');\n  print(identical(p1, p2));\n  // Prints \"true\"\n}\n\nclass Person {\n  String name;\n  String color;\n\n  Person(this.name, this.color);\n\n  static final Map<String, Person> _nameCache = {};\n  static final Map<String, Person> _colorCache = {};\n\n  factory Person.withName(String name) {\n    if (_nameCache.containsKey(name)) {\n      return _nameCache[name]!;\n    } else {\n      final p = Person(name, 'default');\n      _nameCache[name] = p;\n      return p;\n    }\n  }\n\n  factory Person.withColor(String color) {\n    if (_colorCache.containsKey(color)) {\n      return _colorCache[color]!;\n    } else {\n      final p = Person('default', color);\n      _colorCache[color] = p;\n      return p;\n    }\n  }\n}\n```\n\n📢注意：这里的 `_nameCache[name]!` 加了 `!`，表明一定不为 `null`。这是 Dart 3.0 增加的能力-[空安全类型系统](https://dart.cn/codelabs/null-safety)。\n\n### setter 和 getter\n\n```dart\nvoid main(List<String> args) {\n  final p = Person();\n\n  p.name = 'Tom';\n  print(p.name);\n  // Prints \"Tom\"\n\n  p.setName = 'Jack';\n  print(p.name);\n  // Prints \"Jack\"\n  print(p.getName);\n  // Prints \"Jack\"\n}\n\nclass Person {\n  String name;\n\n  Person({String? name}) : this.name = name ?? \"\";\n\n  // Setter\n  set setName(String name) => this.name = name;\n  // Getter\n  String get getName => name;\n}\n```\n\n### 类的继承\n\n1. 使用 `extends` 表示继承关系；\n2. 子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。\n3. 如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过`super`显式调用父类的某个构造方法。\n\n```dart\nvoid main(List<String> args) {\n  var t = Teacher(18, 'Tom');\n  print('name is ${t.name}, age is ${t.age}');\n  // Prints \"name is Tom, age is 18\"\n}\n\nclass Person {\n  String name;\n  Person(this.name);\n}\n\nclass Teacher extends Person {\n  int age;\n\n  Teacher(this.age, String name) : super(name);\n}\n```\n\n\n\n### Object 和 dynamic 的区别\n\nDart 中所有类型都是 Object 的子类，包括 Function 和 Null。\n\n* dynamic 与 Object 声明的变量都可以赋值任意对象，且后期可以改变赋值的类型。\n\n![03](Flutter之Dart/03.png)\n\n* Object 对象使用的属性和方法若不存在，**编译时会报错**。\n\n* dynamic 对象使用的属性和方法若不存在，**编译时不会报错，运行时会报错**。\n\n![04](Flutter之Dart/04.png)\n\n### 抽象类的使用\n\n📢注意一：继承自抽象类后，必须实现抽象类中没有实现的方法。\n\n![07](Flutter之Dart/07.png)\n\n📢注意二：抽象类不能实例化。\n\n![08](Flutter之Dart/08.png)\n\n必须实现抽象类中没有实现的方法：\n\n```dart\nvoid main(List<String> args) {\n  final t = Teacher();\n  print('name is ${t.getName()}, age is ${t.getAge()}');\n  // Prints \"name is 名字, age is 18\"\n}\n\nabstract class Person {\n  int getAge();\n  String getName() {\n    return '名字';\n  }\n}\n\nclass Teacher extends Person {\n  @override\n  int getAge() {\n    return 18;\n  }\n}\n```\n\n可以重写抽象类中有实现的方法：\n\n```dart\nvoid main(List<String> args) {\n  final t = Teacher();\n  print('name is ${t.getName()}, age is ${t.getAge()}');\n  // Prints \"name is Tom, age is 18\"\n}\n\nabstract class Person {\n  int getAge();\n  String getName() {\n    return '名字';\n  }\n}\n\nclass Teacher extends Person {\n  @override\n  int getAge() {\n    return 18;\n  }\n\n  @override\n  String getName() {\n    return 'Tom';\n  }\n}\n```\n\n### 隐式接口\n\nDart 默认情况下所有的类都是隐式接口。在将一个类作为接口使用时，实现接口的类，必须实现这个接口中所有方法。通常将用于给别人实现的类声明为抽象类。\n\n定义一个 `Tom` 类，继承自 `Person`，使用 `Run`、`Swim` 类作为接口：\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n}\n\nabstract class Run {\n  void running() {}\n}\n\nabstract class Swim {\n  void swimming() {}\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n}\n\nclass Tom extends Person implements Run, Swim {\n  Tom() : super('Tom', 18);\n\n  @override\n  void running() {\n    print('Tom is good at running');\n  }\n\n  @override\n  void swimming() {\n    print('Tom is good at swimming');\n  }\n}\n```\n\n![09](Flutter之Dart/09.png)\n\n通过 `implements` 实现某个类时，必须重新实现类定义的所有方法(无论这个类是否已经对方法实现)。如果想要直接复用之前类的原有实现方案，则可以使用 `mixin`混入。\n\n### mixin混入的使用\n\n想要直接复用之前类的原有实现方案，一般采取继承。但是因为 Dart 只支持单继承，所以无法直接复用多个类原有的实现方案。\n\n想要**直接复用多个类原有的实现方案**，可以采用 Mixin 混入的方式：\n\n1. 使用 `mixin` 关键字定义一个类；\n2. 使用 `with` 关键字来实现混入；\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n  // Prints \"running\"\n  t.swimming();\n  // Prints \"swimming\"\n}\n\n/**\n1、使用 mixin 关键字定义类\n*/\nmixin Run {\n  void running() {\n    print('running');\n  }\n}\n\nmixin Swim {\n  void swimming() {\n    print('swimming');\n  }\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  // 父类实现隐式接口\n  void running() {\n    print('running');\n  }\n}\n\n/**\n2、使用 with 实现混入，不需要重写方法\n*/\nclass Tom extends Person with Run, Swim {\n  Tom() : super('Tom', 18);\n}\n```\n\n如果要类比的话，`mixin` 混入和 Swift 的协议有异曲同工之妙。\n\n`implements` 和 `with` 关键字一起使用时，`implements` 要放最后：\n\n```dart\nvoid main(List<String> args) {\n  var t = Tom();\n  t.running();\n}\n\nabstract class Run {\n  void running() {\n    print('running');\n  }\n}\n\nmixin Swim {\n  void swimming() {\n    print('swimming');\n  }\n}\n\nclass Person {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  // 父类实现隐式接口\n  void running() {\n    print('running');\n  }\n}\n\nclass Tom extends Person with Swim implements Run {\n  Tom() : super('Tom', 18);\n}\n```\n\n### 类属性\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  Person.age = 18;\n}\n\nclass Person {\n  String name;\n\n  static int age = 0;\n\n  Person(this.name);\n}\n```\n\n### 类方法\n\n```dart\nvoid main(List<String> args) {\n  var p = Person('Tom');\n  p.talkName();\n  // Prints \"Tom\"\n\n  Person.age = 18;\n  Person.tallAge();\n  // Prints \"18\"\n}\n\nclass Person {\n  String name;\n\n  static int age = 0;\n\n  Person(this.name);\n\n  void talkName() {\n    print(name);\n  }\n\n  static void tallAge() {\n    print(age);\n  }\n}\n```\n\n### 枚举\n\n选择器必须覆盖枚举类型的全部情况，否则会报错：\n\n![10](Flutter之Dart/10.png)\n\n```dart\nvoid main(List<String> args) {\n  final color = Colors.red;\n\n  switch (color) {\n    case Colors.red:\n      print('红色');\n      break;\n    case Colors.blue:\n      print('蓝色');\n      break;\n    default:\n      print('绿色');\n      break;\n  }\n  // Prints \"红色\"\n}\n\nenum Colors { red, blue, green }\n```\n\n## Dart中库的使用\n\n### 一、使用系统库\n\n使用 `import '库的url'` 的形式导入一个库。\n\n```dart\nimport 'dart:math';\n\nvoid main(List<String> args) {\n  final num1 = 20;\n  final num2 = 30;\n  print(min(num1, num2));\n  // Prints \"50\"\n}\n```\n\n库url有三种方式：\n\n1、使用 `dart:` 表示 dart 标准库，\n\n```dart\nimport 'dart:io';\nimport 'dart:math';\nimport 'dart:html';\n```\n\n2、使用相对路径，导入项目中自定义的 .dart 文件：\n\n```dart\nimport 'utils/math_utils.dart'\n```\n\n3、Pub包管理系统中的库，使用前缀 `package:`：\n\n```dart\nimport 'package:http/http.dart'\n```\n\n### 二、使用自定义库\n\n![11](Flutter之Dart/11.png)\n\n1、`as` 关键字给库起别名。\n\n当各个库有命名冲突的时候，可以使用 `as` 关键字来使用命名空间：\n\n```dart\nimport 'utils/math_utils.dart' as mUtils;\n```\n\n2、默认情况下，导入一个库时就是导入这个库中所有的内容。\n\n`show`：执行要导入的内容。\n\n```dart\nimport \"utils/math_utils.dart\" show sum, mul;\n```\n\n`hide`：隐藏某个要导入的内容，导入其它内容。\n\n```dart\nimport \"utils/math_utils.dart\" hide mul;\n```\n\n3、将需要导入的库，使用 `export` 抽取到公共的 dart 文件\n\n![12](Flutter之Dart/12.png)\n\n```dart\nimport \"utils/utils.dart\";\n\nvoid main(List<String> args) {\n  print(sum(20, 30));\n  // Prints \"50\"\n  print(min(10, 11));\n  // Prints \"10\"\n}\n```\n\n### 使用第三方库\n\n```dart\nimport 'package:http/http.dart' as http;\n\nmain(List<String> args) async {\n  var url = 'http://123.207.32.32:8000/home/multidata';\n  var response = await http.get(url);\n  print('Response status: ${response.statusCode}');\n  print('Response body: ${response.body}');\n}\n```\n\n参考 [http 1.1.0 ](https://pub.dev/packages/http/install)","slug":"Flutter/Flutter之Dart","published":1,"updated":"2023-10-20T07:11:41.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgr70002aq7kq7qlbf1v"},{"title":"算法列表","date":"2022-09-29T03:05:18.000Z","_content":"\n* 线性结构\n\n* 排序算法\n\n* 二叉树\n\n* 并查集\n\n* 树形结构\n\n* 回文数\n\n* 方向数组\n\n* 记忆化\n\n* 大整数加法\n\n* 动态规划\n\n* 双指针（滑动窗口）\n\n* 二分专题\n\n<!-- more -->\n\n![20220607_th](算法列表/20220607_th.jpeg)\n\n# 算法列表\n\n## 线性结构\n\n[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)\n\n[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)\n\n[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\n\n[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)\n\n[682. 棒球比赛](https://leetcode.cn/problems/baseball-game/)\n\n## 排序算法\n\n[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)\n\n[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)\n\n[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n## 二叉树\n\n[112. 路径总和](https://leetcode.cn/problems/path-sum/)\n\n[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n\n[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)\n\n[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\n\n[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n## 并查集\n\n[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n[959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)\n\n## 树形结构\n[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n[264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)\n\n[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n[1508. 子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/)\n\n[947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)\n\n[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)\n\n## 综合练习\n\n[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n\n[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\n\n[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)\n\n[面试题40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)\n\n[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n\n[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n\n[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)\n\n[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)\n\n[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/)\n\n## 面试笔试算法（一）\n\n[euler-1.3或5的倍数](http://pe-cn.github.io/1/)（时间复杂度）\n\n[euler-2.偶斐波那契数](http://pe-cn.github.io/2/)（空间复杂度）\n\n[euler-4.最大回文乘积](http://pe-cn.github.io/4/)（回文数）\n\n[euler-36.双进制回文数](http://pe-cn.github.io/36/)（n进制回文数）\n\n[euler-8.连续数字最大乘积](http://pe-cn.github.io/8/)（滑动窗口法）\n\n[euler-11.方阵中的最大乘积](http://pe-cn.github.io/11/)（方向数组）\n\n[euler-14.最长考拉兹序列](http://pe-cn.github.io/14/)（记忆化）\n\n## 面试笔试算法（二）\n\n[euler-13.大和](http://pe-cn.github.io/13/)（大整数加法）\n\n[#78. 大整数加法](http://oj.haizeix.com/problem/78)（大整数加法）\n\n[euler-25.1000位斐波那契数](http://pe-cn.github.io/25/)（大整数加法）\n\n[#471. 大整数乘法](http://oj.haizeix.com/problem/471)\n\n[euler-15.网格路径](http://pe-cn.github.io/15/)（动态规划、组合数）\n\n[euler-18.最大路径和 I](http://pe-cn.github.io/18/)（动态规划）\n\n## 双指针【滑动窗口】\n\n[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)\n\n[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)\n\n[826. 安排工作以达到最大收益](https://leetcode.cn/problems/most-profit-assigning-work/)\n\n[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)\n\n[475. 供暖器](https://leetcode.cn/problems/heaters/)\n\n## 二分专题（一）\n\n[#388. 奇怪的刮刮乐](http://oj.haizeix.com/problem/388)（排序+二分查找）\n\n[#386. 吃瓜群众](http://oj.haizeix.com/problem/386)（排序+二分查找）\n\n[#387. 吃瓜群众升级版](http://oj.haizeix.com/problem/387)（排序+二分查找）\n\n[#390. 原木切割](http://oj.haizeix.com/problem/390)（二分答案）\n\n[#389. 暴躁的程序猿](http://oj.haizeix.com/problem/389)（二分答案）\n\n[#393. 切绳子](http://oj.haizeix.com/problem/393)（二分答案）\n\n[#391. 数列分段](http://oj.haizeix.com/problem/391)（二分答案）\n\n## 二分专题（二）\n\n[#82. 伐木](http://oj.haizeix.com/problem/82)\n\n[#394. 跳石头](http://oj.haizeix.com/problem/394)\n\n[#599. 两数之和1](http://oj.haizeix.com/problem/599)\n\n[#600. 杨氏矩阵](http://oj.haizeix.com/problem/600)\n\n[#485. 均分纸牌](http://oj.haizeix.com/problem/485)\n\n[#504. 删数](http://oj.haizeix.com/problem/504)\n\n[#505. 最大整数](http://oj.haizeix.com/problem/505)\n\n[#519. 优雅数](http://oj.haizeix.com/problem/519)\n\n\n## 真题\n\n### 字节一面\n\n* 实现语言：C\n\n```\n/**\n 链表是否有环\n*/\ntypedef struct ListNode {\n\tint data;\n\tstruct ListNode *next;\n} ListNode;\n\nbool hasCycle(ListNode *head) {\n\tListNode *fast = head, slow = head;\n\twhile (fast && fast->next) {\n\t\tslow = slow->next;\n\t\tfast = fast->next->next;\n\t\tif (fast == slow) return ture;\n\t}\n\treturn false;\n}\n```\n\n### 字节二面\n\n* 实现语言：OC\n* 实现方案：递归\n\n```c\n/**\n 打印 View 的所有子视图的 frame。\n*/\n- (void)func:(UIView *)view {\n\tNSLog(@\"%@\", NSStringFromCGRect(view.frame));\n\t\n\tfor (UIView *subView in view.subviews) {\n\t\t[self func:subView];\n\t}\n}\n```\n\n### 滴滴\n\n* 实现语言：C  \n* 实现方案：滑动窗口法\n\n```c\n/*\n 实现1个函数，找出给定字符串中，最长的连续重复字符串子串。\n 举例：\n 给定字符串：\n abcdedfadasfasfafsssssdfasffwwwdfdswwweewerssss\n 返回：sssss\n */\nvoid func(string s) {\n    int n = (int)s.size();\n    int j = 0, idx = 0, mmax = 0;\n    for (int i = 0; i < n; i++) {\n        while (j < n && s[j] == s[i]) {\n            j++;\n        }\n        if (mmax < j - i) {\n            mmax = j - i;\n            idx = i;\n        }\n        if (j > i) i = j - 1;\n    }\n    cout << s.substr(idx, mmax) << endl;\n}\n```\n\n### 懂车帝一面\n\n* 实现语言：C++\n* 实现方案：层序遍历之逐层遍历\n\n```c++\n/**\n 根据二叉树，输出一个数组，要数组的子元素是二叉树中某一层的所有元素的集合。\n*/\nvector<vector<int>> func(struct TreeNode* root) {\n\tif (!root) return nil;\n\t\n\tvector<vector<int>> ans;\n\tqueue<struct TreeNode> que;\n\tque.push(root);\n\n\twhile (!que.empty()) {\n\t\tvector<int> vec;\n\t\tfor (int i = 0, I = que.size(); i < I; i++) {\n\t\t\tstruct TreeNode *root = que.top();\n\t\t\tque.pop();\n\t\t\tvec.push_back(root->val);\n\t\t\t\n\t\t\tif (root->left) {\n\t\t\t\tque.push(root->left);\n\t\t\t}\n\t\t\tif (root->right) {\n\t\t\t\tque.push(root->right);\n\t\t\t}\n\t\t}\n\t\tans.push_back(vec);\n\t}\n\treturn ans;\n}\n```\n","source":"_posts/2022年打怪/算法列表.md","raw":"---\ntitle: 算法列表\ndate: 2022-09-29 11:05:18\ntags: 2022打怪\n---\n\n* 线性结构\n\n* 排序算法\n\n* 二叉树\n\n* 并查集\n\n* 树形结构\n\n* 回文数\n\n* 方向数组\n\n* 记忆化\n\n* 大整数加法\n\n* 动态规划\n\n* 双指针（滑动窗口）\n\n* 二分专题\n\n<!-- more -->\n\n![20220607_th](算法列表/20220607_th.jpeg)\n\n# 算法列表\n\n## 线性结构\n\n[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)\n\n[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)\n\n[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\n\n[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)\n\n[682. 棒球比赛](https://leetcode.cn/problems/baseball-game/)\n\n## 排序算法\n\n[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)\n\n[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)\n\n[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n## 二叉树\n\n[112. 路径总和](https://leetcode.cn/problems/path-sum/)\n\n[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n\n[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)\n\n[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\n\n[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n## 并查集\n\n[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n[959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)\n\n## 树形结构\n[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n[264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)\n\n[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n[1508. 子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/)\n\n[947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)\n\n[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)\n\n## 综合练习\n\n[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n\n[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\n\n[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)\n\n[面试题40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)\n\n[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n\n[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n\n[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)\n\n[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)\n\n[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/)\n\n## 面试笔试算法（一）\n\n[euler-1.3或5的倍数](http://pe-cn.github.io/1/)（时间复杂度）\n\n[euler-2.偶斐波那契数](http://pe-cn.github.io/2/)（空间复杂度）\n\n[euler-4.最大回文乘积](http://pe-cn.github.io/4/)（回文数）\n\n[euler-36.双进制回文数](http://pe-cn.github.io/36/)（n进制回文数）\n\n[euler-8.连续数字最大乘积](http://pe-cn.github.io/8/)（滑动窗口法）\n\n[euler-11.方阵中的最大乘积](http://pe-cn.github.io/11/)（方向数组）\n\n[euler-14.最长考拉兹序列](http://pe-cn.github.io/14/)（记忆化）\n\n## 面试笔试算法（二）\n\n[euler-13.大和](http://pe-cn.github.io/13/)（大整数加法）\n\n[#78. 大整数加法](http://oj.haizeix.com/problem/78)（大整数加法）\n\n[euler-25.1000位斐波那契数](http://pe-cn.github.io/25/)（大整数加法）\n\n[#471. 大整数乘法](http://oj.haizeix.com/problem/471)\n\n[euler-15.网格路径](http://pe-cn.github.io/15/)（动态规划、组合数）\n\n[euler-18.最大路径和 I](http://pe-cn.github.io/18/)（动态规划）\n\n## 双指针【滑动窗口】\n\n[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)\n\n[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)\n\n[826. 安排工作以达到最大收益](https://leetcode.cn/problems/most-profit-assigning-work/)\n\n[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)\n\n[475. 供暖器](https://leetcode.cn/problems/heaters/)\n\n## 二分专题（一）\n\n[#388. 奇怪的刮刮乐](http://oj.haizeix.com/problem/388)（排序+二分查找）\n\n[#386. 吃瓜群众](http://oj.haizeix.com/problem/386)（排序+二分查找）\n\n[#387. 吃瓜群众升级版](http://oj.haizeix.com/problem/387)（排序+二分查找）\n\n[#390. 原木切割](http://oj.haizeix.com/problem/390)（二分答案）\n\n[#389. 暴躁的程序猿](http://oj.haizeix.com/problem/389)（二分答案）\n\n[#393. 切绳子](http://oj.haizeix.com/problem/393)（二分答案）\n\n[#391. 数列分段](http://oj.haizeix.com/problem/391)（二分答案）\n\n## 二分专题（二）\n\n[#82. 伐木](http://oj.haizeix.com/problem/82)\n\n[#394. 跳石头](http://oj.haizeix.com/problem/394)\n\n[#599. 两数之和1](http://oj.haizeix.com/problem/599)\n\n[#600. 杨氏矩阵](http://oj.haizeix.com/problem/600)\n\n[#485. 均分纸牌](http://oj.haizeix.com/problem/485)\n\n[#504. 删数](http://oj.haizeix.com/problem/504)\n\n[#505. 最大整数](http://oj.haizeix.com/problem/505)\n\n[#519. 优雅数](http://oj.haizeix.com/problem/519)\n\n\n## 真题\n\n### 字节一面\n\n* 实现语言：C\n\n```\n/**\n 链表是否有环\n*/\ntypedef struct ListNode {\n\tint data;\n\tstruct ListNode *next;\n} ListNode;\n\nbool hasCycle(ListNode *head) {\n\tListNode *fast = head, slow = head;\n\twhile (fast && fast->next) {\n\t\tslow = slow->next;\n\t\tfast = fast->next->next;\n\t\tif (fast == slow) return ture;\n\t}\n\treturn false;\n}\n```\n\n### 字节二面\n\n* 实现语言：OC\n* 实现方案：递归\n\n```c\n/**\n 打印 View 的所有子视图的 frame。\n*/\n- (void)func:(UIView *)view {\n\tNSLog(@\"%@\", NSStringFromCGRect(view.frame));\n\t\n\tfor (UIView *subView in view.subviews) {\n\t\t[self func:subView];\n\t}\n}\n```\n\n### 滴滴\n\n* 实现语言：C  \n* 实现方案：滑动窗口法\n\n```c\n/*\n 实现1个函数，找出给定字符串中，最长的连续重复字符串子串。\n 举例：\n 给定字符串：\n abcdedfadasfasfafsssssdfasffwwwdfdswwweewerssss\n 返回：sssss\n */\nvoid func(string s) {\n    int n = (int)s.size();\n    int j = 0, idx = 0, mmax = 0;\n    for (int i = 0; i < n; i++) {\n        while (j < n && s[j] == s[i]) {\n            j++;\n        }\n        if (mmax < j - i) {\n            mmax = j - i;\n            idx = i;\n        }\n        if (j > i) i = j - 1;\n    }\n    cout << s.substr(idx, mmax) << endl;\n}\n```\n\n### 懂车帝一面\n\n* 实现语言：C++\n* 实现方案：层序遍历之逐层遍历\n\n```c++\n/**\n 根据二叉树，输出一个数组，要数组的子元素是二叉树中某一层的所有元素的集合。\n*/\nvector<vector<int>> func(struct TreeNode* root) {\n\tif (!root) return nil;\n\t\n\tvector<vector<int>> ans;\n\tqueue<struct TreeNode> que;\n\tque.push(root);\n\n\twhile (!que.empty()) {\n\t\tvector<int> vec;\n\t\tfor (int i = 0, I = que.size(); i < I; i++) {\n\t\t\tstruct TreeNode *root = que.top();\n\t\t\tque.pop();\n\t\t\tvec.push_back(root->val);\n\t\t\t\n\t\t\tif (root->left) {\n\t\t\t\tque.push(root->left);\n\t\t\t}\n\t\t\tif (root->right) {\n\t\t\t\tque.push(root->right);\n\t\t\t}\n\t\t}\n\t\tans.push_back(vec);\n\t}\n\treturn ans;\n}\n```\n","slug":"2022年打怪/算法列表","published":1,"updated":"2023-08-22T09:52:13.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrb0003aq7kf8tjnh0c"},{"title":"Flutter之环境搭建","date":"2023-10-10T07:18:42.000Z","_content":"\n参考文档\n\n[flutter 环境搭建](https://blog.csdn.net/woyebuzhidao321/article/details/128413281)（推荐）\n\n[fultter安装配置](https://blog.csdn.net/Milan__Kundera/article/details/125780788)\n\n[flutter doctor --android-licenses 【报错】Exception in thread “main“ Android sdkmanager tool was foun](https://blog.csdn.net/weixin_45862329/article/details/129861888)\n\n[Flutter(二)之环境搭建](https://juejin.cn/post/6844903935132581902)\n\n[Android项目仓库配置国内加速阿里云镜像](https://blog.csdn.net/aa390481978/article/details/123823571)\n\n[Flutter SDK archive](https://docs.flutter.dev/release/archive?tab=macos)\n\n<!-- more -->\n\n## 环境搭建整体流程\n\n1. 选择操作系统（macOS）\n2. 安装 [Flutter SDK](https://flutter.dev/docs/development/tools/sdk/releases)\n3. 配置环境变量\n4. 安装模拟器（iOS和Android）\n5. 安装开发工具（Android Studio）\n6. 创建 Flutter 项目\n\n## 选择操作系统\n\n* 操作系统 macOS\n* 处理器 Intel\n\n## 安装 Flutter SDK\n\n[下载 Flutter SDK](https://docs.flutter.dev/release/archive?tab=macos#macos)\n\n![01](Flutter之环境搭建/01.png)\n\n1. 选择自己的操作系统和最新稳定的版本（Stable版本）\n2. mac 安装包有 arm64 和 x64，处理器是 Intel 选 x64 下载，如果是 Apple M1 就选 arm64 下载。\n\n此次下载的是第一个 3.13.6（x64）。\n\n安装：\n\n1. 解压下载好的 SDK\n2. 将 flutter 文件拖到应用程序中（/Applications/flutter）\n\n## 配置环境变量\n\n因为后面需要使用命令行执行 Flutter 命令，所以需要配置对应的环境变量。\n\n一、前往文件：`~/.bath_profile`\n二、配置环境变量\n\n```js\n# 确定 flutter 文件路径\nexport FLUTTER_HOME=/Applications/flutter\n# 配置 Flutter 环境变量\nexport PATH=$PATH:$FLUTTER_HOME/bin\n# 配置 Dart 环境变量\nexport PATH=$PATH:$FLUTTER_HOME/bin/cache/dart-sdk/bin\n```\n\n执行 `source ~/.bash_profile` 命令，使其生效。\n\n后续打开终端第一次运行 flutter 命令前，需要先执行以下 `source ~/.bash_profile` 命令：\n\n```js\n% source ~/.bash_profile\n% flutter doctor \n```\n\n三、检查是否安装成功\n\n使用 `flutter --version` 命令查看 flutter 版本，检查是否安装成功。\n\n```js\n % flutter --version\nFlutter 3.13.6 • channel stable • https://github.com/flutter/flutter.git\nFramework • revision ead455963c (13 days ago) • 2023-09-26 18:28:17 -0700\nEngine • revision a794cf2681\nTools • Dart 3.1.3 • DevTools 2.25.0\n\n  ╔════════════════════════════════════════════════════════════════════════════╗\n  ║                 Welcome to Flutter! - https://flutter.dev                  ║\n  ║                                                                            ║\n  ║ The Flutter tool uses Google Analytics to anonymously report feature usage ║\n  ║ statistics and basic crash reports. This data is used to help improve      ║\n  ║ Flutter tools over time.                                                   ║\n  ║                                                                            ║\n  ║ Flutter tool analytics are not sent on the very first run. To disable      ║\n  ║ reporting, type 'flutter config --no-analytics'. To display the current    ║\n  ║ setting, type 'flutter config'. If you opt out of analytics, an opt-out    ║\n  ║ event will be sent, and then no further information will be sent by the    ║\n  ║ Flutter tool.                                                              ║\n  ║                                                                            ║\n  ║ By downloading the Flutter SDK, you agree to the Google Terms of Service.  ║\n  ║ Note: The Google Privacy Policy describes how data is handled in this      ║\n  ║ service.                                                                   ║\n  ║                                                                            ║\n  ║ Moreover, Flutter includes the Dart SDK, which may send usage metrics and  ║\n  ║ crash reports to Google.                                                   ║\n  ║                                                                            ║\n  ║ Read about data we send with crash reports:                                ║\n  ║ https://flutter.dev/docs/reference/crash-reporting                         ║\n  ║                                                                            ║\n  ║ See Google's privacy policy:                                               ║\n  ║ https://policies.google.com/privacy                                        ║\n  ╚════════════════════════════════════════════════════════════════════════════╝\n\n\nThe Flutter CLI developer tool uses Google Analytics to report usage and\ndiagnostic data\nalong with package dependencies, and crash reporting to send basic crash\nreports.\nThis data is used to help improve the Dart platform, Flutter framework, and\nrelated tools.\n\nTelemetry is not sent on the very first run.\nTo disable reporting of telemetry, run this terminal command:\n\nflutter --disable-telemetry.\nIf you opt out of telemetry, an opt-out event will be sent,\nand then no further information will be sent.\nThis data is collected in accordance with the\nGoogle Privacy Policy (https://policies.google.com/privacy).\n\nYou have received two consent messages because the flutter tool is migrating to\na new analytics system. Disabling analytics collection will disable both the\nlegacy and new analytics collection systems. You can disable analytics reporting\nby running `flutter --disable-telemetry`\n```\n\n四、配置镜像\n\nflutter 项目有很多依赖，在国内下载这些依赖比较慢，可以将他们的安装源换成国内的。\n\n编辑 `~/.bash_profile` 文件：\n\n```js\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL= https://storage.flutter-io.cn\n```\n\n执行 `source ~/.bash_profile` 命令，使其生效。\n\n## 配置 iOS 环境\n\n1. 前往 Appstore 下载 Xcode。\n\n2. 打开 Xcode，点击左上角 Xcode - Open Developer Tool - Simulator 打开模拟器\n\n3. 模拟器被打开后，点击 Hardware - Device 选择需要的模拟器\n\n![02](Flutter之环境搭建/02.png)\n\n![03](Flutter之环境搭建/03.png)\n\n## 配置 Android 环境\n\n一、下载安装 Android Studio\n\n1. 下载 [Android Studio](https://developer.android.com/studio?utm_source=android-studio&hl=zh-cn)\n2. 下载完成后，双击安装包开始安装。\n3. 「下一步」。\n4. 安装完成后，在终端输入 `java -version` 验证是否安装成功。\n\n```js\n% java -version\njava version \"14.0.2\" 2020-07-14\nJava(TM) SE Runtime Environment (build 14.0.2+12-46)\nJava HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)\n```\n\n二、设置显示选项\n\n![04](Flutter之环境搭建/04.png)\n\n三、打开模拟器\n\n![05](Flutter之环境搭建/05.png)\n\n添加设备：【Create device】-【Phone】-【Pixel 3】-【Next】\n\n![06](Flutter之环境搭建/06.png)\n\n运行模拟器：\n\n![07](Flutter之环境搭建/07.png)\n\n![08](Flutter之环境搭建/08.png)\n\n四、配置flutter环境\n\n1、创建一个新项目，点击【New Project】\n\n![09](Flutter之环境搭建/09.png)\n\n2、设置项目信息，点击 【finish】\n\n![10](Flutter之环境搭建/10.png)\n\n3、创建完成\n\n![11](Flutter之环境搭建/11.png)\n\n4、打开设置页面，点击【Android Studio】-【Settings】\n\n![12](Flutter之环境搭建/12.png)\n\n5、下载安装 flutter，点击【Pluglns】- 搜索“flutter” - 点击【Install】开始下载，下载完成后点击【Restart IDE】重启 Android Studio。\n\n![13](Flutter之环境搭建/13.png)\n\n重启后打开【Pluglns】可以看到 Flutter、Dart 都已经下载安装好了。\n\n![14](Flutter之环境搭建/14.png)\n\n五、安装 Android SDK\n\nAndroid SDK 是针对安卓开发的套件，如果最新的 Android SDK 存在兼容性问题，可以单独安装指定版本的 Android SDK。如添加 Android SDK Platform 29：\n\n1、打开【Tools】-【SDK Manager】（或点击【Android Studio】-【Settings】）\n\n![15](Flutter之环境搭建/15.png)\n\n2、点击【Appearance & Behavior】-【System Settings】-【Android SDK】，添加 Android SDK Platform 29\n\n【SDK Platforms】-【SDK Tools】-【Show Package Details】-【29.0.2】\n\n![17](Flutter之环境搭建/17.png)\n\n【SDK Platforms】-【Show Package Details】-【Android SDK Platform 29】，最后点击【OK】\n\n![16](Flutter之环境搭建/16.png)\n\n![18](Flutter之环境搭建/18.png)\n\n下载完成点击【Finish】\n\n![19](Flutter之环境搭建/19.png)\n\n六、管理设备\n\n1、点击【Tools】-【Device Manager】\n\n![20](Flutter之环境搭建/20.png)\n\n2、点击【Create Device】\n\n![21](Flutter之环境搭建/21.png)\n\n3、创建新的设备\n\n![22](Flutter之环境搭建/22.png)\n\n![23](Flutter之环境搭建/23.png)\n\n![24](Flutter之环境搭建/24.png)\n\n![25](Flutter之环境搭建/25.png)\n\n4、创建成功\n\n![26](Flutter之环境搭建/26.png)\n\n七、执行 `flutter doctor` 命令检查当前 Flutter 环境\n\n如果是第一次运行 flutter，需要先执行 `source ~/.bash_profile`，在执行 `flutter doctor`。\n\n![27](Flutter之环境搭建/27.png)\n\n按照提示，执行 `flutter doctor --android-licenses`\n\n![28](Flutter之环境搭建/28.png)\n\n然后，一路输入 `y` + 回车\n\n![29](Flutter之环境搭建/29.png)\n\n![30](Flutter之环境搭建/30.png)\n\n![31](Flutter之环境搭建/31.png)\n\n![32](Flutter之环境搭建/32.png)\n\n![33](Flutter之环境搭建/33.png)\n\n最后再次执行 `flutter doctor`，成功 ✌🏻\n\n![34](Flutter之环境搭建/34.png)\n\n## 遇到的问题\n\n第一次下载 Android SDK 时选择的是最新版本\n\n![35](Flutter之环境搭建/35.png)\n\n执行 `flutter doctor` 报错\n\n![36](Flutter之环境搭建/36.png)\n\n这个时候，执行 `flutter doctor --android-licenses` 就会报错：\n\n![37](Flutter之环境搭建/37.png)\n\n参考文档：[记坑：flutter doctor --android-licenses 【报错】Exception in thread “main“ Android sdkmanager tool was foun](https://blog.csdn.net/weixin_45862329/article/details/129861888)\n\n解决方法：将Android Studio ->Android SDK ->SDK Tools处，勾选版本为8.0 的Android SDK Command-line Tools，并取消勾选版本为9.0 的Android SDK Command-line Tools.\n\n![38](Flutter之环境搭建/38.png)\n\n安装成功后，在执行 `flutter doctor --android-licenses` 就不会报错了。\n\n## 创建 Flutter 项目\n\n### 使用 Android Studio 创建\n\n点击【File】-【New】-【New Flutter Project】\n\n![39](Flutter之环境搭建/39.png)\n\n![40](Flutter之环境搭建/40.png)\n\n![41](Flutter之环境搭建/41.png)\n\n打开一个新的窗口【New Window】\n\n![42](Flutter之环境搭建/42.png)\n\n运行项目\n\n1. 选择设备\n2. 运行项目\n3. 停止运行\n\n![43](Flutter之环境搭建/43.png)\n\n### 使用终端创建\n\n1. 进入到需要创建项目的目录\n2. 使用 `flutter create helloflutter` 命令创建（注意：后面的名称不能由特殊符号，也不能由大写）\n\n```js\n % cd /Users/xx/Desktop/Flutter/HelloFlutter \n % flutter create helloflutter\nSigning iOS app for device deployment using developer identity: \"iPhone\nDeveloper: Xiaoshuo Li (SH8N382R65)\"\nCreating project helloflutter...\nResolving dependencies in helloflutter... \nGot dependencies in helloflutter.\nWrote 129 files.\n\nAll done!\nYou can find general documentation for Flutter at: https://docs.flutter.dev/\nDetailed API documentation is available at: https://api.flutter.dev/\nIf you prefer video documentation, consider:\nhttps://www.youtube.com/c/flutterdev\n\nIn order to run your application, type:\n\n  $ cd helloflutter\n  $ flutter run\n\nYour application code is in helloflutter/lib/main.dart.\n\n```\n","source":"_posts/Flutter/Flutter之环境搭建.md","raw":"---\ntitle: Flutter之环境搭建\ndate: 2023-10-10 15:18:42\ntags: Flutter\n---\n\n参考文档\n\n[flutter 环境搭建](https://blog.csdn.net/woyebuzhidao321/article/details/128413281)（推荐）\n\n[fultter安装配置](https://blog.csdn.net/Milan__Kundera/article/details/125780788)\n\n[flutter doctor --android-licenses 【报错】Exception in thread “main“ Android sdkmanager tool was foun](https://blog.csdn.net/weixin_45862329/article/details/129861888)\n\n[Flutter(二)之环境搭建](https://juejin.cn/post/6844903935132581902)\n\n[Android项目仓库配置国内加速阿里云镜像](https://blog.csdn.net/aa390481978/article/details/123823571)\n\n[Flutter SDK archive](https://docs.flutter.dev/release/archive?tab=macos)\n\n<!-- more -->\n\n## 环境搭建整体流程\n\n1. 选择操作系统（macOS）\n2. 安装 [Flutter SDK](https://flutter.dev/docs/development/tools/sdk/releases)\n3. 配置环境变量\n4. 安装模拟器（iOS和Android）\n5. 安装开发工具（Android Studio）\n6. 创建 Flutter 项目\n\n## 选择操作系统\n\n* 操作系统 macOS\n* 处理器 Intel\n\n## 安装 Flutter SDK\n\n[下载 Flutter SDK](https://docs.flutter.dev/release/archive?tab=macos#macos)\n\n![01](Flutter之环境搭建/01.png)\n\n1. 选择自己的操作系统和最新稳定的版本（Stable版本）\n2. mac 安装包有 arm64 和 x64，处理器是 Intel 选 x64 下载，如果是 Apple M1 就选 arm64 下载。\n\n此次下载的是第一个 3.13.6（x64）。\n\n安装：\n\n1. 解压下载好的 SDK\n2. 将 flutter 文件拖到应用程序中（/Applications/flutter）\n\n## 配置环境变量\n\n因为后面需要使用命令行执行 Flutter 命令，所以需要配置对应的环境变量。\n\n一、前往文件：`~/.bath_profile`\n二、配置环境变量\n\n```js\n# 确定 flutter 文件路径\nexport FLUTTER_HOME=/Applications/flutter\n# 配置 Flutter 环境变量\nexport PATH=$PATH:$FLUTTER_HOME/bin\n# 配置 Dart 环境变量\nexport PATH=$PATH:$FLUTTER_HOME/bin/cache/dart-sdk/bin\n```\n\n执行 `source ~/.bash_profile` 命令，使其生效。\n\n后续打开终端第一次运行 flutter 命令前，需要先执行以下 `source ~/.bash_profile` 命令：\n\n```js\n% source ~/.bash_profile\n% flutter doctor \n```\n\n三、检查是否安装成功\n\n使用 `flutter --version` 命令查看 flutter 版本，检查是否安装成功。\n\n```js\n % flutter --version\nFlutter 3.13.6 • channel stable • https://github.com/flutter/flutter.git\nFramework • revision ead455963c (13 days ago) • 2023-09-26 18:28:17 -0700\nEngine • revision a794cf2681\nTools • Dart 3.1.3 • DevTools 2.25.0\n\n  ╔════════════════════════════════════════════════════════════════════════════╗\n  ║                 Welcome to Flutter! - https://flutter.dev                  ║\n  ║                                                                            ║\n  ║ The Flutter tool uses Google Analytics to anonymously report feature usage ║\n  ║ statistics and basic crash reports. This data is used to help improve      ║\n  ║ Flutter tools over time.                                                   ║\n  ║                                                                            ║\n  ║ Flutter tool analytics are not sent on the very first run. To disable      ║\n  ║ reporting, type 'flutter config --no-analytics'. To display the current    ║\n  ║ setting, type 'flutter config'. If you opt out of analytics, an opt-out    ║\n  ║ event will be sent, and then no further information will be sent by the    ║\n  ║ Flutter tool.                                                              ║\n  ║                                                                            ║\n  ║ By downloading the Flutter SDK, you agree to the Google Terms of Service.  ║\n  ║ Note: The Google Privacy Policy describes how data is handled in this      ║\n  ║ service.                                                                   ║\n  ║                                                                            ║\n  ║ Moreover, Flutter includes the Dart SDK, which may send usage metrics and  ║\n  ║ crash reports to Google.                                                   ║\n  ║                                                                            ║\n  ║ Read about data we send with crash reports:                                ║\n  ║ https://flutter.dev/docs/reference/crash-reporting                         ║\n  ║                                                                            ║\n  ║ See Google's privacy policy:                                               ║\n  ║ https://policies.google.com/privacy                                        ║\n  ╚════════════════════════════════════════════════════════════════════════════╝\n\n\nThe Flutter CLI developer tool uses Google Analytics to report usage and\ndiagnostic data\nalong with package dependencies, and crash reporting to send basic crash\nreports.\nThis data is used to help improve the Dart platform, Flutter framework, and\nrelated tools.\n\nTelemetry is not sent on the very first run.\nTo disable reporting of telemetry, run this terminal command:\n\nflutter --disable-telemetry.\nIf you opt out of telemetry, an opt-out event will be sent,\nand then no further information will be sent.\nThis data is collected in accordance with the\nGoogle Privacy Policy (https://policies.google.com/privacy).\n\nYou have received two consent messages because the flutter tool is migrating to\na new analytics system. Disabling analytics collection will disable both the\nlegacy and new analytics collection systems. You can disable analytics reporting\nby running `flutter --disable-telemetry`\n```\n\n四、配置镜像\n\nflutter 项目有很多依赖，在国内下载这些依赖比较慢，可以将他们的安装源换成国内的。\n\n编辑 `~/.bash_profile` 文件：\n\n```js\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL= https://storage.flutter-io.cn\n```\n\n执行 `source ~/.bash_profile` 命令，使其生效。\n\n## 配置 iOS 环境\n\n1. 前往 Appstore 下载 Xcode。\n\n2. 打开 Xcode，点击左上角 Xcode - Open Developer Tool - Simulator 打开模拟器\n\n3. 模拟器被打开后，点击 Hardware - Device 选择需要的模拟器\n\n![02](Flutter之环境搭建/02.png)\n\n![03](Flutter之环境搭建/03.png)\n\n## 配置 Android 环境\n\n一、下载安装 Android Studio\n\n1. 下载 [Android Studio](https://developer.android.com/studio?utm_source=android-studio&hl=zh-cn)\n2. 下载完成后，双击安装包开始安装。\n3. 「下一步」。\n4. 安装完成后，在终端输入 `java -version` 验证是否安装成功。\n\n```js\n% java -version\njava version \"14.0.2\" 2020-07-14\nJava(TM) SE Runtime Environment (build 14.0.2+12-46)\nJava HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)\n```\n\n二、设置显示选项\n\n![04](Flutter之环境搭建/04.png)\n\n三、打开模拟器\n\n![05](Flutter之环境搭建/05.png)\n\n添加设备：【Create device】-【Phone】-【Pixel 3】-【Next】\n\n![06](Flutter之环境搭建/06.png)\n\n运行模拟器：\n\n![07](Flutter之环境搭建/07.png)\n\n![08](Flutter之环境搭建/08.png)\n\n四、配置flutter环境\n\n1、创建一个新项目，点击【New Project】\n\n![09](Flutter之环境搭建/09.png)\n\n2、设置项目信息，点击 【finish】\n\n![10](Flutter之环境搭建/10.png)\n\n3、创建完成\n\n![11](Flutter之环境搭建/11.png)\n\n4、打开设置页面，点击【Android Studio】-【Settings】\n\n![12](Flutter之环境搭建/12.png)\n\n5、下载安装 flutter，点击【Pluglns】- 搜索“flutter” - 点击【Install】开始下载，下载完成后点击【Restart IDE】重启 Android Studio。\n\n![13](Flutter之环境搭建/13.png)\n\n重启后打开【Pluglns】可以看到 Flutter、Dart 都已经下载安装好了。\n\n![14](Flutter之环境搭建/14.png)\n\n五、安装 Android SDK\n\nAndroid SDK 是针对安卓开发的套件，如果最新的 Android SDK 存在兼容性问题，可以单独安装指定版本的 Android SDK。如添加 Android SDK Platform 29：\n\n1、打开【Tools】-【SDK Manager】（或点击【Android Studio】-【Settings】）\n\n![15](Flutter之环境搭建/15.png)\n\n2、点击【Appearance & Behavior】-【System Settings】-【Android SDK】，添加 Android SDK Platform 29\n\n【SDK Platforms】-【SDK Tools】-【Show Package Details】-【29.0.2】\n\n![17](Flutter之环境搭建/17.png)\n\n【SDK Platforms】-【Show Package Details】-【Android SDK Platform 29】，最后点击【OK】\n\n![16](Flutter之环境搭建/16.png)\n\n![18](Flutter之环境搭建/18.png)\n\n下载完成点击【Finish】\n\n![19](Flutter之环境搭建/19.png)\n\n六、管理设备\n\n1、点击【Tools】-【Device Manager】\n\n![20](Flutter之环境搭建/20.png)\n\n2、点击【Create Device】\n\n![21](Flutter之环境搭建/21.png)\n\n3、创建新的设备\n\n![22](Flutter之环境搭建/22.png)\n\n![23](Flutter之环境搭建/23.png)\n\n![24](Flutter之环境搭建/24.png)\n\n![25](Flutter之环境搭建/25.png)\n\n4、创建成功\n\n![26](Flutter之环境搭建/26.png)\n\n七、执行 `flutter doctor` 命令检查当前 Flutter 环境\n\n如果是第一次运行 flutter，需要先执行 `source ~/.bash_profile`，在执行 `flutter doctor`。\n\n![27](Flutter之环境搭建/27.png)\n\n按照提示，执行 `flutter doctor --android-licenses`\n\n![28](Flutter之环境搭建/28.png)\n\n然后，一路输入 `y` + 回车\n\n![29](Flutter之环境搭建/29.png)\n\n![30](Flutter之环境搭建/30.png)\n\n![31](Flutter之环境搭建/31.png)\n\n![32](Flutter之环境搭建/32.png)\n\n![33](Flutter之环境搭建/33.png)\n\n最后再次执行 `flutter doctor`，成功 ✌🏻\n\n![34](Flutter之环境搭建/34.png)\n\n## 遇到的问题\n\n第一次下载 Android SDK 时选择的是最新版本\n\n![35](Flutter之环境搭建/35.png)\n\n执行 `flutter doctor` 报错\n\n![36](Flutter之环境搭建/36.png)\n\n这个时候，执行 `flutter doctor --android-licenses` 就会报错：\n\n![37](Flutter之环境搭建/37.png)\n\n参考文档：[记坑：flutter doctor --android-licenses 【报错】Exception in thread “main“ Android sdkmanager tool was foun](https://blog.csdn.net/weixin_45862329/article/details/129861888)\n\n解决方法：将Android Studio ->Android SDK ->SDK Tools处，勾选版本为8.0 的Android SDK Command-line Tools，并取消勾选版本为9.0 的Android SDK Command-line Tools.\n\n![38](Flutter之环境搭建/38.png)\n\n安装成功后，在执行 `flutter doctor --android-licenses` 就不会报错了。\n\n## 创建 Flutter 项目\n\n### 使用 Android Studio 创建\n\n点击【File】-【New】-【New Flutter Project】\n\n![39](Flutter之环境搭建/39.png)\n\n![40](Flutter之环境搭建/40.png)\n\n![41](Flutter之环境搭建/41.png)\n\n打开一个新的窗口【New Window】\n\n![42](Flutter之环境搭建/42.png)\n\n运行项目\n\n1. 选择设备\n2. 运行项目\n3. 停止运行\n\n![43](Flutter之环境搭建/43.png)\n\n### 使用终端创建\n\n1. 进入到需要创建项目的目录\n2. 使用 `flutter create helloflutter` 命令创建（注意：后面的名称不能由特殊符号，也不能由大写）\n\n```js\n % cd /Users/xx/Desktop/Flutter/HelloFlutter \n % flutter create helloflutter\nSigning iOS app for device deployment using developer identity: \"iPhone\nDeveloper: Xiaoshuo Li (SH8N382R65)\"\nCreating project helloflutter...\nResolving dependencies in helloflutter... \nGot dependencies in helloflutter.\nWrote 129 files.\n\nAll done!\nYou can find general documentation for Flutter at: https://docs.flutter.dev/\nDetailed API documentation is available at: https://api.flutter.dev/\nIf you prefer video documentation, consider:\nhttps://www.youtube.com/c/flutterdev\n\nIn order to run your application, type:\n\n  $ cd helloflutter\n  $ flutter run\n\nYour application code is in helloflutter/lib/main.dart.\n\n```\n","slug":"Flutter/Flutter之环境搭建","published":1,"updated":"2023-10-25T08:07:36.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrf0005aq7k1h9pp46b"},{"title":"Flutter之初见","date":"2023-10-20T09:43:11.000Z","_content":"\n* [创建一个Flutter项目](#创建一个flutter项目)\n* [Android studio 简介](#android-studio-简介)\n* [第一个项目 Hello world](#第一个项目-hello-world)\n* [同意协议](#同意协议)\n* [列表](#列表)\n* [计数器](#计数器)\n* [StatefulWidget](#statefulwidget)\n* [StatefulWidget 声明周期](#statefulwidget-声明周期)\n\n<!-- more -->\n\n相关文档：\n\n[Flutter(六)之Flutter开发初体验](https://juejin.cn/post/6844903949271564302)\n[Flutter(七)之有状态的StatefulWidget](https://juejin.cn/post/6844903951058354190)\n[《Flutter实战·第二版》](https://book.flutterchina.club/)\n\n## 创建一个Flutter项目\n\n第一步：点击`New Flutter Project`\n\n![01](Flutter之初见/01.png)\n\n第二步：配置 Flutter SDK 的路径\n\n![02](Flutter之初见/02.png)\n\n第三部：设置项目名称、项目路径\n\n![03](Flutter之初见/03.png)\n\n第四步：创建项目\n\n![04](Flutter之初见/04.png)\n\n## Android studio 简介\n\n![05](Flutter之初见/05.png)\n\n## 第一个项目 Hello world\n\n### runApp\n\n`/lib` 文件里是所有的 Flutter 代码，`main.dart` 是 App 的入口，添加 `main` 函数，并在函数内部调用 `material.dart` 库中的 `runApp` 方法：\n\n![06](Flutter之初见/06.png)\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(app)\n}\n```\n\n`runApp` 是 Flutter 提供的 App 运行函数入口，在 `material.dart` 库中。`material.dart` 是 Google 公司推行的一套设计风格。\n\n查看 `runApp` 的源码，可以看到需要传递一个 `Widget` 类型的参数：\n\n```dart\nvoid runApp(Widget app) {\n  final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized();\n  assert(binding.debugCheckZone('runApp'));\n  binding\n    ..scheduleAttachRootWidget(binding.wrapWithDefaultView(app))\n    ..scheduleWarmUpFrame();\n}\n```\n\n### Widget\n\nFlutter 中所有的内容都是 Widget，而iOS中`UIViewController`、`UIView`、`UIButton`等等都是不同的控件。\n\n创建一个页面，页面只显示“Hello world!”，传入一个 `Text` 对象：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(Text('Hello world!', textDirection: TextDirection.ltr));\n}\n```\n\n因为是第一次运行项目，所以点击的是Hot Restart（热重启）。\n\n![07](Flutter之初见/07.png)\n\n📢注意：页面在单独加载一个 `Text` 时，需要设置 `textDirection`，否则会报错：\n\n![08](Flutter之初见/08.png)\n\n### Center\n\n居中显示，设置字体大小、颜色\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    // 页面中心\n    Center(\n      child: Text(\n        'Hello world!', // 内容\n        textDirection: TextDirection.ltr, // 从左至右\n        style: TextStyle(fontSize: 36, color: Colors.blue),), // 字体大小：36，字体颜色：蓝色\n    )\n  );\n}\n```\n\n![09](Flutter之初见/09.png)\n\n### Material\n\n`Material` 库是由 Flutter 提供的特定风格的组件仓库，让创建页面更加便捷：\n\n```dart\nMaterialApp(\n  title: ,\n  theme: ,\n  home: ,\n)\n```\n\n在使用 `Material` 库创建页面时，需要传入一个`home` 参数，也就是要创建的页面，它是 `Scaffold` 类型的。\n\n### Scaffold\n\n`Scaffold` 称为**脚手架**，用来搭建页面的基本结构，如 `appBar`（导航栏）、`body`（内容）等。\n\n设置背景色白色，默认导航栏：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    // 页面\n    MaterialApp(\n      // 页面风格\n      home: Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text(\"Flutter\")\n        ),\n        // 页面中心\n        body: Center(\n          child: Text(\n            'Hello world!', // 内容\n            textDirection: TextDirection.ltr, // 从左至右\n            style: TextStyle(\n                fontSize: 36, // 字体大小\n                color: Colors.blue), // 字体颜色\n          ),\n        )\n      ),\n    )\n  );\n}\n```\n\n![10](Flutter之初见/10.png)\n\n### 代码重构\n\n上面的代码嵌套太深，可读性太差。根据功能，对代码进行封装重构。\n\n第一步：抽取 `runApp()`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(...);\n  }\n}\n```\n\n第二步：抽取 `MaterialApp()`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYPage(),\n    );\n  }\n}\n\n// 页面\nclass KYPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(...);\n  }\n}\n```\n\n第三步：抽取 Scaffold。\n\n```dart\n\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text(\"Flutter\")\n        ),\n        // 内容\n        body: KYBody()\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面中心\n    return Center(\n      child: Text(\n        'Hello world!', // 内容\n        textDirection: TextDirection.ltr, // 从左至右\n        style: TextStyle( // 字体样式\n            fontSize: 36,\n            color: Colors.blue),\n      ),\n    );\n  }\n}\n```\n\n在 Flutter 中所有的控件都继承自 `Widget`，而 `Widget` 又分为 `StatelessWidget` 和 `StatefulWidget`：\n\n* `StatelessWidget`：无状态的 `Widget`，内容在 APP 运行过程中**不会发生改变**。\n* `StatefulWidget`：有状态的 `Widget`，内容在 APP 运行过程中**会发生改变**。\n\n因为在 Hello World 代码中，没有可变的内容，所有用的是 `StatelessWidget`。\n\n## StatelessWidget\n\nStatelessWidget 继承自 Widget，它没有状态。\n\n继承自 StatelessWidget 的自定义控件，不需要维护状态，只需要在构造函数中初始化状态即可。\n\n继承自 StatelessWidget 的自定义控件，必须要实现 build 方法，build 方法返回一个 Widget 对象。\n\nbuild 方法的调用时机：\n\n1. 第一次创建控件时调用；\n2. 控件状态改变时调用；\n3. 调用 setState 方法时调用。\n\n## 同意协议\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text('Flutter')\n        ),\n        // 页面中心\n        body: Center(\n          child: Row(\n            // 水平居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            // 包含多个控件使用 children[]\n            children: [\n              // 选择器\n              Checkbox(\n                  value: true, // 默认选中\n                  onChanged: (value) { // 点击选择器\n                    print(value);\n                  }),\n              Text(\n                '同意协议', // 内容\n                style: TextStyle(fontSize: 28), // 字体样式\n              ),\n            ],\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n![11](Flutter之初见/11.png)\n\n点击勾选框，可以看到打印：\n\n```js\nflutter: false\n```\n\n### Row\n\n这里用到了一个控件 Row，即**行控件**，它在水平方向平铺的，支持创建多个控件，并对其自动布局：\n\n```dart\nRow(\n  // 对齐方式-居中\n  mainAxisAlignment: MainAxisAlignment.center,\n  // 子控件集合\n  children: [\n\n  ],\n)\n```\n\n### StatefulWidget & State\n\n继承 `StatefulWidget` 的类，可以介绍父 `Widget` 传递的数据 `State`（状态）。`StatefulWidget` 通过创建一个单独的类来记录状态。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    print('MyApp build');\n    return MaterialApp(\n      home: KYHome()\n    );\n  }\n}\n\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    print('KYHome build');\n    return Scaffold(\n      appBar: AppBar(\n          title: Text('Flutter')\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\nclass KYBody extends StatefulWidget {\n  // 创建状态\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n\nclass KYState extends State<KYBody> {\n  // 记录选择器状态，默认选中\n  var flag = true;\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYState build');\n    return Center(\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Checkbox(\n              value: flag,\n              onChanged: (bool? value) {\n                // 更新UI（1.调用闭包；2.刷新UI（即调用 KYState 的 build 方法）；）\n                setState(() {\n                  flag = value!; // 更新UI前，先更新选中状态\n                });\n              }),\n          Text(\n            '同意协议',\n            style: TextStyle(fontSize: 28),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![12](Flutter之初见/12.png)\n\n### setState\n\n更新UI时，通过调用 `setState` 方法实现：\n\n1. 调用闭包；\n2. 刷新UI（会重新调用 `KYState` 的 `build` 方法）；\n\n```dart\nsetState(() {\n  // 更新UI前，先执行闭包\n});\n```\n\n## 列表\n\n### Column\n\n```dart\nclass Column extends Flex {\n  const Column({\n    super.key,               // 唯一标识\n    super.mainAxisAlignment, // 主轴对齐方式\n    super.mainAxisSize,      // 轴线大小\n    super.crossAxisAlignment,// 交叉轴对齐方式\n    super.textDirection,     // 文本方向\n    super.verticalDirection, // 垂直方向\n    super.textBaseline,      // 文本基准线\n    super.children,          // 子控件集合\n  }) : super(\n    direction: Axis.vertical,// 方向\n  );\n}\n```\n\n使用 Column 实现自动垂直布局，类比 Row：\n\n```dart\nColumn(\n  // 对其方式-居中\n  mainAxisAlignment: MainAxisAlignment.center\n  // 子控件集合\n  children: [\n    \n  ],\n)\n```\n\n创建多个图片信息，垂直展示：\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n          title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 垂直排列 Widget，类比 Row\n    return Column(\n      children: [\n        KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n      ],\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之初见/13.png)\n\n在 Flutter 布局中，内容不能超出屏幕范围，如果超出，超出的部分会出现图中的错误。可以通过将 `Column` 替换成 `ListView` 解决。\n\n### ListView\n\n`ListView` 可以滚动展示子控件。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: [\n        KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n      ],\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![14](Flutter之初见/14.png)\n\n### Padding\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 内边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![15](Flutter之初见/15.png)\n\n### Container-Padding\n\n设置产品的内边距。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      // 内容\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 边距\n      padding: const EdgeInsets.all(20),\n      decoration: BoxDecoration(\n        border: Border.all()\n      ),\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![16](Flutter之初见/16.png)\n\n### SizedBox\n\n使用 `SizeBox`，在文字和图片之间增加间距。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      // 页面\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 内边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 边距\n      padding: const EdgeInsets.all(20),\n      // 所有边\n      decoration: BoxDecoration(\n        border: Border.all()\n      ),\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          SizedBox(height: 18,), // 间距\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![17](Flutter之初见/17.png)\n\n## 计数器\n\n通过这个项目，了解有**状态**的 StatefulWidget。\n\n### Column & Row\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      // 内容\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 中心\n    return Center(\n      // 垂直\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        // 子控件s\n        children: [\n          Row(),\n          Text('当前计数：'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![18](Flutter之初见/18.png)\n\n### MaterialButton\n\n添加按钮，使用 `MaterialButton` 样式。\n\n```dart\nMaterialButton(\n  // 背景色\n  color: Colors.blue,\n  // 文案\n  child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n  // 点击事件\n  onPressed: (){\n    \n  },\n)\n```\n\n添加 `+1` 和 `-1` 按钮后的代码：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      // 垂直布局\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平\n          Row(\n            // 水平-居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            // 子控件s\n            children: [\n              // +1 按钮\n              MaterialButton(\n                // 背景色\n                color: Colors.blue,\n                // 文案\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                // 点击事件\n                onPressed: (){\n\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n### setState()\n\n点击按钮修改计数：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n\n// 页面-内容-状态\nclass KYState extends State<KYBody> {\n  // 计数\n  var count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      // 垂直布局\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平布局\n          Row(\n            // 居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // +1 按钮\n              MaterialButton(\n                // 背景色\n                color: Colors.blue,\n                // 文案\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                // 点击事件\n                onPressed: (){\n                  // 更新UI（重新调用 State 的 build 方法）\n                  setState(() {\n                    // 修改数据（更新UI前，先调用闭包）\n                    count++;\n                  });\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count--;\n                  });\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：$count'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![20](Flutter之初见/20.png)\n\n## StatefulWidget\n\n在“列表”和“计数器”中，都用到了 `StatefulWidget` 和 `State` 的组合拳，在编译器中输入 `stful` 可以快速敲出：\n\n```dart\nclass _ extends StatefulWidget {\n  const ({Key? key}) : super(key: key);\n\n  @override\n  State<> createState() => _State();\n}\n\nclass _State extends State<> {\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n```\n\nFlutter 将 `StatefulWidget` 设计成了两个类的组合方式：\n\n1. `StatefulWidget` 作为 `Widget` 树的一部分；\n2. `State` 记录对应 `StatefulWidget` 的状态。\n\n查看 `StatefulWidget` 源码：\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ super.key });\n  \n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  @protected\n  @factory\n  State createState();\n}\n```\n\n创建 `StatefulWidget` 的一般步骤：\n\n1、自定义一个 `StatefulWidget` 类型的控件，并返回一个 `State` 类型的状态对象。\n\n```dart\nclass KYBody extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n```\n\n2、自定义一个 `State<KYBody>` 类型的状态对象，内部可以定义变量用于记录特定的状态。\n\n```dart\nclass KYState extends State<KYBody> {\n  // 计数\n  var count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(...);\n  }\n}\n```\n\n## StatefulWidget 声明周期\n\n以计数器代码为例：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYBody build');\n    return KYMutableContext();\n  }\n}\n\n// 可变内容\nclass KYMutableContext extends StatefulWidget {\n\n  KYMutableContext() {\n    print('KYMutableContext 构造方法');\n  }\n  @override\n  State<StatefulWidget> createState() {\n    print('KYMutableContext createState');\n    return KYState();\n  }\n}\n\n// 可变内容-状态\nclass KYState extends State<KYMutableContext> {\n  // 计数\n  var count = 0;\n\n  KYState() {\n    print('KYState 构造方法');\n  }\n\n  // 当此对象插入到树中时调用。\n  void initState() {\n    super.initState();\n    print('KYState init方法');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYState build');\n    return Center(\n      // 垂直布局\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平布局\n          Row(\n            // 水平-居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // +1 按钮\n              MaterialButton(\n                color: Colors.blue,\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count++;\n                  });\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count--;\n                  });\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：$count'),\n        ],\n      ),\n    );\n  }\n\n  // 每当小部件配置更改时调用。\n  @override\n  void didUpdateWidget(covariant KYMutableContext oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    print('KYState didUpdateWidget');\n  }\n\n  // 从树中删除此对象时调用。\n  @override\n  void deactivate() {\n    super.deactivate();\n    print('KYState deactivate');\n  }\n\n  // 当此对象从树中永久删除时调用。\n  @override\n  void dispose() {\n    super.dispose();\n    print('KYState dispose');\n  }\n\n  // 除了调用此方法外，还可以保证在发出重新组装信号时调用[build]方法。因此，大多数窗口小部件不需要在[重新组装]方法中执行任何操作。\n  @override\n  void reassemble() {\n    super.reassemble();\n    print('KYState reassemble');\n  }\n\n  // 当此[State]对象的依赖项更改时调用。\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    print('KYState didChangeDependencies');\n  }\n}\n```\n\n![21](Flutter之初见/21.png)\n\n> (ps：图片来自[Flutter(七)之有状态的StatefulWidget](https://juejin.cn/post/6844903951058354190))\n\n图片中灰色部分是 Flutter 的内部操作，白色部分是可监听的方法。\n\n### 启动程序\n\n点击 `Run 'main.dart'` 按钮运行程序，打印日志：\n\n```js\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYMutableContext createState\nflutter: KYState 构造方法\nflutter: KYState init方法\nflutter: KYState didChangeDependencies\nflutter: KYState build\n```\n\n1、首先，执行 `StatefulWidget` 的构造方法\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n2、然后，执行 `createState()` 方法\n\n```js\nflutter: KYMutableContext createState\n```\n\n3、执行 `State` 的构造方法\n\n```js\nflutter: KYState 构造方法\n```\n\n4、执行 `State` 的 `init` 方法\n\n```js\nflutter: KYState init方法\n```\n\n5、执行 `didChangeDependencies()` 方法\n\n```js\nflutter: KYState didChangeDependencies\n```\n\n6、最后，执行 `State` 的 `build` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 热重启\n\n然后点击 `Flutter Hot Restart` 热重启，打印日志：\n\n```js\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYMutableContext createState\nflutter: KYState 构造方法\nflutter: KYState init方法\nflutter: KYState didChangeDependencies\nflutter: KYState build\nflutter: KYState reassemble\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYState didUpdateWidget\nflutter: KYState build\n```\n\n1、首先执行 body 的 build 方法\n\n```js\nflutter: KYBody build\n```\n\n2、首先，执行 StatefulWidget 的构造方法\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n3、然后，执行 `createState()` 方法\n\n```js\nflutter: KYMutableContext createState\n```\n\n4、执行 State 的构造方法\n\n```js\nflutter: KYState 构造方法\n```\n\n5、执行 State 的 `init()` 方法\n\n```js\nflutter: KYState init方法\n```\n\n6、执行 `didChangeDependencies()` 方法\n\n```js\nflutter: KYState didChangeDependencies\n```\n\n7、执行 State 的 `build()` 方法\n\n```js\nflutter: KYState build\n```\n\n8、判断是**热重启**，继续执行 State 的 `reassemble()` 方法\n\n```js\nflutter: KYState reassemble\n```\n\n8、再次执行 body 的 `build()` 方法\n\n```js\nflutter: KYBody build\n```\n\n9、因为执行了 body 的 `build()` 方法，所以自然也要再执行 StatefulWidget 的构造方法。因为 `init()` 方法是在插入到树中时调用，所有不会调用。\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n10、执行 State 的 `didUpdateWidget()` 方法（每当小部件配置更改时调用）\n\n```js\nflutter: KYState didUpdateWidget\n```\n\n11、最后，执行 Steate 的 `build()` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 热重载\n\n然后点击 `Flutter Hot Reload` 热重载，打印日志：\n\n```js\nflutter: KYState reassemble\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYState didUpdateWidget\nflutter: KYState build\n```\n\n1、判断是**热重载**，执行 State 的 `reassemble()` 方法\n\n```js\nflutter: KYState reassemble\n```\n\n2、执行 body 的 `build()` 方法\n\n```js\nflutter: KYBody build\n```\n\n3、因为执行了 body 的 `build()` 方法，所以自然也要再执行 StatefulWidget 的构造方法。因为 `init()` 方法是在插入到树中时调用，所有不会调用。\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n4、执行 State 的 `didUpdateWidget()` 方法（每当小部件配置更改时调用）\n\n```js\nflutter: KYState didUpdateWidget\n```\n\n5、最后，执行 Steate 的 `build()` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 手动调用 setState() 方法\n\n然后点击“+1”按钮，打印日志：\n\n```js\nflutter: KYState build\n```\n\n可以看到，点击“+1”按钮调用了 `setState()` 方法，程序重新执行了 `KYState` 的 `build` 方法。\n\n### dirty state\n\n\n![21](Flutter之初见/21.png)\n\n图片中灰色部分是 Flutter 的内部操作，白色部分是可监听的方法。\n\n1. Flutter 会为需要更新的 Widget 添加标记，被添加了标记的状态称为 dirty state。\n\n2. Flutter 在执行**热重启**或**热重载**时，会刷新所有的 dirty state，调用其对应 Widget 的 build() 方法，同时将其标记为为 clean state。\n\n3. Flutter 会忽略 clean state 标记的 Widget。\n\n## @requested\n\n必传参数：如果不传，**编译时会报错**。\n\n`@requested`修饰的参数：如果不传，**编译时不会报错**，但是运行时会报错。\n\n## 快捷键\n\n开发工具：Android studio\n\n`option + command + b`：查看抽象类的子类，抽象类只声明方法不实现，子类负责实现。\n\n![22](Flutter之初见/22.png)\n\noption + Enter 扩展功能\n\nCMD + option + M 将选中代码提取到某个方法中\n\nCMD + option + W 将选中代码提取生成一个新的Widget\n\ncommand + N生成构造函数\n\n菜单栏: Code —> Generate —> Constructorƒ\n\nCommand + Shift + F全局搜索\n\n## 代码块\n","source":"_posts/Flutter/Flutter之初见.md","raw":"---\ntitle: Flutter之初见\ndate: 2023-10-20 17:43:11\ntags: Flutter\n---\n\n* [创建一个Flutter项目](#创建一个flutter项目)\n* [Android studio 简介](#android-studio-简介)\n* [第一个项目 Hello world](#第一个项目-hello-world)\n* [同意协议](#同意协议)\n* [列表](#列表)\n* [计数器](#计数器)\n* [StatefulWidget](#statefulwidget)\n* [StatefulWidget 声明周期](#statefulwidget-声明周期)\n\n<!-- more -->\n\n相关文档：\n\n[Flutter(六)之Flutter开发初体验](https://juejin.cn/post/6844903949271564302)\n[Flutter(七)之有状态的StatefulWidget](https://juejin.cn/post/6844903951058354190)\n[《Flutter实战·第二版》](https://book.flutterchina.club/)\n\n## 创建一个Flutter项目\n\n第一步：点击`New Flutter Project`\n\n![01](Flutter之初见/01.png)\n\n第二步：配置 Flutter SDK 的路径\n\n![02](Flutter之初见/02.png)\n\n第三部：设置项目名称、项目路径\n\n![03](Flutter之初见/03.png)\n\n第四步：创建项目\n\n![04](Flutter之初见/04.png)\n\n## Android studio 简介\n\n![05](Flutter之初见/05.png)\n\n## 第一个项目 Hello world\n\n### runApp\n\n`/lib` 文件里是所有的 Flutter 代码，`main.dart` 是 App 的入口，添加 `main` 函数，并在函数内部调用 `material.dart` 库中的 `runApp` 方法：\n\n![06](Flutter之初见/06.png)\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(app)\n}\n```\n\n`runApp` 是 Flutter 提供的 App 运行函数入口，在 `material.dart` 库中。`material.dart` 是 Google 公司推行的一套设计风格。\n\n查看 `runApp` 的源码，可以看到需要传递一个 `Widget` 类型的参数：\n\n```dart\nvoid runApp(Widget app) {\n  final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized();\n  assert(binding.debugCheckZone('runApp'));\n  binding\n    ..scheduleAttachRootWidget(binding.wrapWithDefaultView(app))\n    ..scheduleWarmUpFrame();\n}\n```\n\n### Widget\n\nFlutter 中所有的内容都是 Widget，而iOS中`UIViewController`、`UIView`、`UIButton`等等都是不同的控件。\n\n创建一个页面，页面只显示“Hello world!”，传入一个 `Text` 对象：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(Text('Hello world!', textDirection: TextDirection.ltr));\n}\n```\n\n因为是第一次运行项目，所以点击的是Hot Restart（热重启）。\n\n![07](Flutter之初见/07.png)\n\n📢注意：页面在单独加载一个 `Text` 时，需要设置 `textDirection`，否则会报错：\n\n![08](Flutter之初见/08.png)\n\n### Center\n\n居中显示，设置字体大小、颜色\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    // 页面中心\n    Center(\n      child: Text(\n        'Hello world!', // 内容\n        textDirection: TextDirection.ltr, // 从左至右\n        style: TextStyle(fontSize: 36, color: Colors.blue),), // 字体大小：36，字体颜色：蓝色\n    )\n  );\n}\n```\n\n![09](Flutter之初见/09.png)\n\n### Material\n\n`Material` 库是由 Flutter 提供的特定风格的组件仓库，让创建页面更加便捷：\n\n```dart\nMaterialApp(\n  title: ,\n  theme: ,\n  home: ,\n)\n```\n\n在使用 `Material` 库创建页面时，需要传入一个`home` 参数，也就是要创建的页面，它是 `Scaffold` 类型的。\n\n### Scaffold\n\n`Scaffold` 称为**脚手架**，用来搭建页面的基本结构，如 `appBar`（导航栏）、`body`（内容）等。\n\n设置背景色白色，默认导航栏：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    // 页面\n    MaterialApp(\n      // 页面风格\n      home: Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text(\"Flutter\")\n        ),\n        // 页面中心\n        body: Center(\n          child: Text(\n            'Hello world!', // 内容\n            textDirection: TextDirection.ltr, // 从左至右\n            style: TextStyle(\n                fontSize: 36, // 字体大小\n                color: Colors.blue), // 字体颜色\n          ),\n        )\n      ),\n    )\n  );\n}\n```\n\n![10](Flutter之初见/10.png)\n\n### 代码重构\n\n上面的代码嵌套太深，可读性太差。根据功能，对代码进行封装重构。\n\n第一步：抽取 `runApp()`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(...);\n  }\n}\n```\n\n第二步：抽取 `MaterialApp()`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYPage(),\n    );\n  }\n}\n\n// 页面\nclass KYPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(...);\n  }\n}\n```\n\n第三步：抽取 Scaffold。\n\n```dart\n\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text(\"Flutter\")\n        ),\n        // 内容\n        body: KYBody()\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面中心\n    return Center(\n      child: Text(\n        'Hello world!', // 内容\n        textDirection: TextDirection.ltr, // 从左至右\n        style: TextStyle( // 字体样式\n            fontSize: 36,\n            color: Colors.blue),\n      ),\n    );\n  }\n}\n```\n\n在 Flutter 中所有的控件都继承自 `Widget`，而 `Widget` 又分为 `StatelessWidget` 和 `StatefulWidget`：\n\n* `StatelessWidget`：无状态的 `Widget`，内容在 APP 运行过程中**不会发生改变**。\n* `StatefulWidget`：有状态的 `Widget`，内容在 APP 运行过程中**会发生改变**。\n\n因为在 Hello World 代码中，没有可变的内容，所有用的是 `StatelessWidget`。\n\n## StatelessWidget\n\nStatelessWidget 继承自 Widget，它没有状态。\n\n继承自 StatelessWidget 的自定义控件，不需要维护状态，只需要在构造函数中初始化状态即可。\n\n继承自 StatelessWidget 的自定义控件，必须要实现 build 方法，build 方法返回一个 Widget 对象。\n\nbuild 方法的调用时机：\n\n1. 第一次创建控件时调用；\n2. 控件状态改变时调用；\n3. 调用 setState 方法时调用。\n\n## 同意协议\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        // 导航栏\n        appBar: AppBar(\n            title: Text('Flutter')\n        ),\n        // 页面中心\n        body: Center(\n          child: Row(\n            // 水平居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            // 包含多个控件使用 children[]\n            children: [\n              // 选择器\n              Checkbox(\n                  value: true, // 默认选中\n                  onChanged: (value) { // 点击选择器\n                    print(value);\n                  }),\n              Text(\n                '同意协议', // 内容\n                style: TextStyle(fontSize: 28), // 字体样式\n              ),\n            ],\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n![11](Flutter之初见/11.png)\n\n点击勾选框，可以看到打印：\n\n```js\nflutter: false\n```\n\n### Row\n\n这里用到了一个控件 Row，即**行控件**，它在水平方向平铺的，支持创建多个控件，并对其自动布局：\n\n```dart\nRow(\n  // 对齐方式-居中\n  mainAxisAlignment: MainAxisAlignment.center,\n  // 子控件集合\n  children: [\n\n  ],\n)\n```\n\n### StatefulWidget & State\n\n继承 `StatefulWidget` 的类，可以介绍父 `Widget` 传递的数据 `State`（状态）。`StatefulWidget` 通过创建一个单独的类来记录状态。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    print('MyApp build');\n    return MaterialApp(\n      home: KYHome()\n    );\n  }\n}\n\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    print('KYHome build');\n    return Scaffold(\n      appBar: AppBar(\n          title: Text('Flutter')\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\nclass KYBody extends StatefulWidget {\n  // 创建状态\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n\nclass KYState extends State<KYBody> {\n  // 记录选择器状态，默认选中\n  var flag = true;\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYState build');\n    return Center(\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Checkbox(\n              value: flag,\n              onChanged: (bool? value) {\n                // 更新UI（1.调用闭包；2.刷新UI（即调用 KYState 的 build 方法）；）\n                setState(() {\n                  flag = value!; // 更新UI前，先更新选中状态\n                });\n              }),\n          Text(\n            '同意协议',\n            style: TextStyle(fontSize: 28),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![12](Flutter之初见/12.png)\n\n### setState\n\n更新UI时，通过调用 `setState` 方法实现：\n\n1. 调用闭包；\n2. 刷新UI（会重新调用 `KYState` 的 `build` 方法）；\n\n```dart\nsetState(() {\n  // 更新UI前，先执行闭包\n});\n```\n\n## 列表\n\n### Column\n\n```dart\nclass Column extends Flex {\n  const Column({\n    super.key,               // 唯一标识\n    super.mainAxisAlignment, // 主轴对齐方式\n    super.mainAxisSize,      // 轴线大小\n    super.crossAxisAlignment,// 交叉轴对齐方式\n    super.textDirection,     // 文本方向\n    super.verticalDirection, // 垂直方向\n    super.textBaseline,      // 文本基准线\n    super.children,          // 子控件集合\n  }) : super(\n    direction: Axis.vertical,// 方向\n  );\n}\n```\n\n使用 Column 实现自动垂直布局，类比 Row：\n\n```dart\nColumn(\n  // 对其方式-居中\n  mainAxisAlignment: MainAxisAlignment.center\n  // 子控件集合\n  children: [\n    \n  ],\n)\n```\n\n创建多个图片信息，垂直展示：\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n          title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 垂直排列 Widget，类比 Row\n    return Column(\n      children: [\n        KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n      ],\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之初见/13.png)\n\n在 Flutter 布局中，内容不能超出屏幕范围，如果超出，超出的部分会出现图中的错误。可以通过将 `Column` 替换成 `ListView` 解决。\n\n### ListView\n\n`ListView` 可以滚动展示子控件。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: [\n        KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n        KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n      ],\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![14](Flutter之初见/14.png)\n\n### Padding\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 内边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![15](Flutter之初见/15.png)\n\n### Container-Padding\n\n设置产品的内边距。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      // 内容\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 边距\n      padding: const EdgeInsets.all(20),\n      decoration: BoxDecoration(\n        border: Border.all()\n      ),\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![16](Flutter之初见/16.png)\n\n### SizedBox\n\n使用 `SizeBox`，在文字和图片之间增加间距。\n\n```dart\nimport 'package:flutter/material.dart';\nmain() {\n  runApp(MyApp());\n}\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: Text('列表'),\n      ),\n      // 页面\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 内边距\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: ListView(\n        children: [\n          KYProductItem('title01', '图片', 'https://pic3.zhimg.com/v2-002ce6e2ee957e0f666a7bfa479f33b2_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic2.zhimg.com/v2-2aebdafa0ab8ee5b55d58410f7192745_r.jpg'),\n          KYProductItem('title02', '图片', 'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg'),\n        ],\n      ),\n    );\n  }\n}\n\n// 产品信息\nclass KYProductItem extends StatelessWidget {\n  final String title;\n  final String desc;\n  final String imageURL;\n\n  KYProductItem(this.title, this.desc, this.imageURL);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 边距\n      padding: const EdgeInsets.all(20),\n      // 所有边\n      decoration: BoxDecoration(\n        border: Border.all()\n      ),\n      // 垂直排列\n      child: Column(\n        children: [\n          Text(title, style: TextStyle(fontSize: 30, color: Colors.blue),), // 标题\n          Text(desc, style: TextStyle(fontSize: 20, color: Colors.black),), // 详情\n          SizedBox(height: 18,), // 间距\n          Image.network(imageURL), // 网络图片\n        ],\n      ),\n    );\n  }\n}\n```\n\n![17](Flutter之初见/17.png)\n\n## 计数器\n\n通过这个项目，了解有**状态**的 StatefulWidget。\n\n### Column & Row\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 页面\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // 导航栏\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      // 内容\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 中心\n    return Center(\n      // 垂直\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        // 子控件s\n        children: [\n          Row(),\n          Text('当前计数：'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![18](Flutter之初见/18.png)\n\n### MaterialButton\n\n添加按钮，使用 `MaterialButton` 样式。\n\n```dart\nMaterialButton(\n  // 背景色\n  color: Colors.blue,\n  // 文案\n  child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n  // 点击事件\n  onPressed: (){\n    \n  },\n)\n```\n\n添加 `+1` 和 `-1` 按钮后的代码：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      // 垂直布局\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平\n          Row(\n            // 水平-居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            // 子控件s\n            children: [\n              // +1 按钮\n              MaterialButton(\n                // 背景色\n                color: Colors.blue,\n                // 文案\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                // 点击事件\n                onPressed: (){\n\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n### setState()\n\n点击按钮修改计数：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n\n// 页面-内容-状态\nclass KYState extends State<KYBody> {\n  // 计数\n  var count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      // 垂直布局\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平布局\n          Row(\n            // 居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // +1 按钮\n              MaterialButton(\n                // 背景色\n                color: Colors.blue,\n                // 文案\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                // 点击事件\n                onPressed: (){\n                  // 更新UI（重新调用 State 的 build 方法）\n                  setState(() {\n                    // 修改数据（更新UI前，先调用闭包）\n                    count++;\n                  });\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count--;\n                  });\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：$count'),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![20](Flutter之初见/20.png)\n\n## StatefulWidget\n\n在“列表”和“计数器”中，都用到了 `StatefulWidget` 和 `State` 的组合拳，在编译器中输入 `stful` 可以快速敲出：\n\n```dart\nclass _ extends StatefulWidget {\n  const ({Key? key}) : super(key: key);\n\n  @override\n  State<> createState() => _State();\n}\n\nclass _State extends State<> {\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n```\n\nFlutter 将 `StatefulWidget` 设计成了两个类的组合方式：\n\n1. `StatefulWidget` 作为 `Widget` 树的一部分；\n2. `State` 记录对应 `StatefulWidget` 的状态。\n\n查看 `StatefulWidget` 源码：\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ super.key });\n  \n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  @protected\n  @factory\n  State createState();\n}\n```\n\n创建 `StatefulWidget` 的一般步骤：\n\n1、自定义一个 `StatefulWidget` 类型的控件，并返回一个 `State` 类型的状态对象。\n\n```dart\nclass KYBody extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return KYState();\n  }\n}\n```\n\n2、自定义一个 `State<KYBody>` 类型的状态对象，内部可以定义变量用于记录特定的状态。\n\n```dart\nclass KYState extends State<KYBody> {\n  // 计数\n  var count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(...);\n  }\n}\n```\n\n## StatefulWidget 声明周期\n\n以计数器代码为例：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\n// 程序\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: KYHome(),\n    );\n  }\n}\n\n// 页面\nclass KYHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('计数器'),\n      ),\n      body: KYBody(),\n    );\n  }\n}\n\n// 页面-内容\nclass KYBody extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYBody build');\n    return KYMutableContext();\n  }\n}\n\n// 可变内容\nclass KYMutableContext extends StatefulWidget {\n\n  KYMutableContext() {\n    print('KYMutableContext 构造方法');\n  }\n  @override\n  State<StatefulWidget> createState() {\n    print('KYMutableContext createState');\n    return KYState();\n  }\n}\n\n// 可变内容-状态\nclass KYState extends State<KYMutableContext> {\n  // 计数\n  var count = 0;\n\n  KYState() {\n    print('KYState 构造方法');\n  }\n\n  // 当此对象插入到树中时调用。\n  void initState() {\n    super.initState();\n    print('KYState init方法');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    print('KYState build');\n    return Center(\n      // 垂直布局\n      child: Column(\n        // 垂直-居中\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 水平布局\n          Row(\n            // 水平-居中\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // +1 按钮\n              MaterialButton(\n                color: Colors.blue,\n                child: const Text(\"+1\", style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count++;\n                  });\n                },\n              ),\n              // -1 按钮\n              MaterialButton(\n                color: Colors.red,\n                child: const Text('-1', style: TextStyle(fontSize: 18, color: Colors.white),),\n                onPressed: (){\n                  setState(() {\n                    count--;\n                  });\n                },\n              ),\n            ],\n          ),\n          Text('当前计数：$count'),\n        ],\n      ),\n    );\n  }\n\n  // 每当小部件配置更改时调用。\n  @override\n  void didUpdateWidget(covariant KYMutableContext oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    print('KYState didUpdateWidget');\n  }\n\n  // 从树中删除此对象时调用。\n  @override\n  void deactivate() {\n    super.deactivate();\n    print('KYState deactivate');\n  }\n\n  // 当此对象从树中永久删除时调用。\n  @override\n  void dispose() {\n    super.dispose();\n    print('KYState dispose');\n  }\n\n  // 除了调用此方法外，还可以保证在发出重新组装信号时调用[build]方法。因此，大多数窗口小部件不需要在[重新组装]方法中执行任何操作。\n  @override\n  void reassemble() {\n    super.reassemble();\n    print('KYState reassemble');\n  }\n\n  // 当此[State]对象的依赖项更改时调用。\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    print('KYState didChangeDependencies');\n  }\n}\n```\n\n![21](Flutter之初见/21.png)\n\n> (ps：图片来自[Flutter(七)之有状态的StatefulWidget](https://juejin.cn/post/6844903951058354190))\n\n图片中灰色部分是 Flutter 的内部操作，白色部分是可监听的方法。\n\n### 启动程序\n\n点击 `Run 'main.dart'` 按钮运行程序，打印日志：\n\n```js\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYMutableContext createState\nflutter: KYState 构造方法\nflutter: KYState init方法\nflutter: KYState didChangeDependencies\nflutter: KYState build\n```\n\n1、首先，执行 `StatefulWidget` 的构造方法\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n2、然后，执行 `createState()` 方法\n\n```js\nflutter: KYMutableContext createState\n```\n\n3、执行 `State` 的构造方法\n\n```js\nflutter: KYState 构造方法\n```\n\n4、执行 `State` 的 `init` 方法\n\n```js\nflutter: KYState init方法\n```\n\n5、执行 `didChangeDependencies()` 方法\n\n```js\nflutter: KYState didChangeDependencies\n```\n\n6、最后，执行 `State` 的 `build` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 热重启\n\n然后点击 `Flutter Hot Restart` 热重启，打印日志：\n\n```js\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYMutableContext createState\nflutter: KYState 构造方法\nflutter: KYState init方法\nflutter: KYState didChangeDependencies\nflutter: KYState build\nflutter: KYState reassemble\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYState didUpdateWidget\nflutter: KYState build\n```\n\n1、首先执行 body 的 build 方法\n\n```js\nflutter: KYBody build\n```\n\n2、首先，执行 StatefulWidget 的构造方法\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n3、然后，执行 `createState()` 方法\n\n```js\nflutter: KYMutableContext createState\n```\n\n4、执行 State 的构造方法\n\n```js\nflutter: KYState 构造方法\n```\n\n5、执行 State 的 `init()` 方法\n\n```js\nflutter: KYState init方法\n```\n\n6、执行 `didChangeDependencies()` 方法\n\n```js\nflutter: KYState didChangeDependencies\n```\n\n7、执行 State 的 `build()` 方法\n\n```js\nflutter: KYState build\n```\n\n8、判断是**热重启**，继续执行 State 的 `reassemble()` 方法\n\n```js\nflutter: KYState reassemble\n```\n\n8、再次执行 body 的 `build()` 方法\n\n```js\nflutter: KYBody build\n```\n\n9、因为执行了 body 的 `build()` 方法，所以自然也要再执行 StatefulWidget 的构造方法。因为 `init()` 方法是在插入到树中时调用，所有不会调用。\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n10、执行 State 的 `didUpdateWidget()` 方法（每当小部件配置更改时调用）\n\n```js\nflutter: KYState didUpdateWidget\n```\n\n11、最后，执行 Steate 的 `build()` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 热重载\n\n然后点击 `Flutter Hot Reload` 热重载，打印日志：\n\n```js\nflutter: KYState reassemble\nflutter: KYBody build\nflutter: KYMutableContext 构造方法\nflutter: KYState didUpdateWidget\nflutter: KYState build\n```\n\n1、判断是**热重载**，执行 State 的 `reassemble()` 方法\n\n```js\nflutter: KYState reassemble\n```\n\n2、执行 body 的 `build()` 方法\n\n```js\nflutter: KYBody build\n```\n\n3、因为执行了 body 的 `build()` 方法，所以自然也要再执行 StatefulWidget 的构造方法。因为 `init()` 方法是在插入到树中时调用，所有不会调用。\n\n```js\nflutter: KYMutableContext 构造方法\n```\n\n4、执行 State 的 `didUpdateWidget()` 方法（每当小部件配置更改时调用）\n\n```js\nflutter: KYState didUpdateWidget\n```\n\n5、最后，执行 Steate 的 `build()` 方法，运行成功\n\n```js\nflutter: KYState build\n```\n\n### 手动调用 setState() 方法\n\n然后点击“+1”按钮，打印日志：\n\n```js\nflutter: KYState build\n```\n\n可以看到，点击“+1”按钮调用了 `setState()` 方法，程序重新执行了 `KYState` 的 `build` 方法。\n\n### dirty state\n\n\n![21](Flutter之初见/21.png)\n\n图片中灰色部分是 Flutter 的内部操作，白色部分是可监听的方法。\n\n1. Flutter 会为需要更新的 Widget 添加标记，被添加了标记的状态称为 dirty state。\n\n2. Flutter 在执行**热重启**或**热重载**时，会刷新所有的 dirty state，调用其对应 Widget 的 build() 方法，同时将其标记为为 clean state。\n\n3. Flutter 会忽略 clean state 标记的 Widget。\n\n## @requested\n\n必传参数：如果不传，**编译时会报错**。\n\n`@requested`修饰的参数：如果不传，**编译时不会报错**，但是运行时会报错。\n\n## 快捷键\n\n开发工具：Android studio\n\n`option + command + b`：查看抽象类的子类，抽象类只声明方法不实现，子类负责实现。\n\n![22](Flutter之初见/22.png)\n\noption + Enter 扩展功能\n\nCMD + option + M 将选中代码提取到某个方法中\n\nCMD + option + W 将选中代码提取生成一个新的Widget\n\ncommand + N生成构造函数\n\n菜单栏: Code —> Generate —> Constructorƒ\n\nCommand + Shift + F全局搜索\n\n## 代码块\n","slug":"Flutter/Flutter之初见","published":1,"updated":"2023-11-21T10:41:05.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgri0006aq7kez71u7re"},{"title":"Flutter之布局","date":"2023-11-21T09:10:46.000Z","_content":"\n- [Align](#align)\n- [Center](#center)\n- [Padding](#padding)\n- [Container](#container)\n- [BoxDecoration](#boxdecoration)\n- [Flex](#flex)\n- [Row](#row)\n- [Expand](#expand)\n- [Column](#column)\n- [Stack](#stack)\n\n<!-- more -->\n\n## Align\n\nAlign 的使用：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Align\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\nAlign\n*/\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.green,\n      child: Align(\n        alignment: Alignment.topLeft,\n        widthFactor: 3,\n        heightFactor: 3,\n        child: Container(\n          decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n          child: Icon(\n            Icons.people_alt,\n            size: 40,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![01](Flutter之布局/01.png)\n\n`Align` 定义：\n\n```dart\nclass Align extends SingleChildRenderObjectWidget {\n  const Align({\n    super.key,\n    this.alignment = Alignment.center, // 对齐方式默认居中\n    this.widthFactor,                  // 将宽度设置为子部件的宽度乘以 widthFactor\n    this.heightFactor,                 // 将高度设置为子部件的高度乘以 heightFactor\n    super.child,                       // 子部件\n  }) : assert(widthFactor == null || widthFactor >= 0.0),\n       assert(heightFactor == null || heightFactor >= 0.0);\n}\n```\n\n继承关系 `Align` 继承自 `SingleChildRenderObjectWidget`，`SingleChildRenderObjectWidget` 继承自 `RenderObjectWidget`，`RenderObjectWidget` 继承自 `Widget`。\n\n> RenderObjectWidgets 提供了 [RenderObjectElement] 的配置，RenderObjectElement 包装了 [RenderObject]，RenderObject 提供了实际渲染应用程序的功能。\n\nalignment 提供多种对齐方式，包括：center、left、top、right、bottom 等等。\n\nwidthFactor 和 heightFactor：\n\n1. 用来设置父部件的宽高，如当 widthFactor = 3，则父部件的宽度为子部件的 3 倍。\n\n2. 因为在对部件进行布局时，需要先确定父部件的大小，然后根据父部件的大小对子部件布局，所以需要设置 widthFactor 和 heightFactor。如果不设置，则Align会尽可能的大（等于其父部件的大小）。\n\n## Center\n\nCenter 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.green,\n      child: Center(\n        widthFactor: 2,\n        heightFactor: 1,\n        child: Container(\n          decoration: BoxDecoration(color: Colors.red),\n          child: Icon(\n            Icons.email,\n            size: 60,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![02](Flutter之布局/02.png)\n\nCenter 的定义：\n\n```dart\nclass Center extends Align {\n  const Center({ super.key, super.widthFactor, super.heightFactor, super.child });\n}\n```\n\n`Center` 继承自 `Align`，使用 `Align` 默认的 `alignment`（.center），不支持修改。 \n\n## Padding\n\nPadding 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.lightGreen,\n      child: Padding(\n        padding: EdgeInsets.all(20),\n        child: Container(\n          decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n          child: Text(\n              \"风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\"),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![03](Flutter之布局/03.png)\n\nPadding 的定义：\n\n```dart\nclass Padding extends SingleChildRenderObjectWidget {\n  const Padding({\n    super.key,\n    required this.padding,\n    super.child,\n  });\n}\n```\n\nPadding 用来设置内边距（父部件），或外边距（子部件）。\n\n## Container\n\nContainer 的定义：\n\n```dart\nclass Container extends StatelessWidget {\n  Container({\n    super.key,\n    this.alignment,                // 对齐方式\n    this.padding,                  // 内边距\n    this.color,                    // 背景色\n    this.decoration,               // 背景装饰\n    this.foregroundDecoration,     // 前景装饰\n    double? width,                 // 宽度\n    double? height,                // 高度\n    BoxConstraints? constraints,   // 约束\n    this.margin,                   // 外边距\n    this.transform,                // 变换\n    this.transformAlignment,       // 变换对齐方式\n    this.child,                    // 子部件\n    this.clipBehavior = Clip.none, // 超出部分是否裁剪\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n}\n```\n\nContainer 相当于 iOS 的 UIView，用来设置布局，可以设置背景色、边框、圆角等。\n\n如果需要一个有背景色、边框、圆角、阴影、固定尺寸、图像时，可以考虑 Container。\n\n## BoxDecoration\n\nBoxDecoration 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 200,\n      height: 200,\n      child: Icon(Icons.phone),\n      decoration: BoxDecoration(\n        color: Colors.lightGreen,\n        border: Border.all(\n          color: Colors.red,\n          width: 5.0,\n          style: BorderStyle.solid,\n        ),\n        // border: Border(\n        //   top: BorderSide(color: Colors.red, width: 5),\n        //   right: BorderSide(color: Colors.blue, width: 10),\n        // ),\n        borderRadius: BorderRadius.circular(20),\n        boxShadow: [\n          BoxShadow(\n            color: Colors.yellow,\n            offset: Offset(5, 5),\n            blurRadius: 20,\n          ),\n        ],\n        gradient: LinearGradient(\n          colors: [\n            Colors.blue,\n            Colors.red,\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n![04](Flutter之布局/04.png)\n\n圆角图片：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(20),\n          image: DecorationImage(\n              image: NetworkImage(\n                  \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\")),\n        ),\n      ),\n    );\n  }\n}\n```\n\nBoxDecoration 的定义：\n\n```dart\nclass BoxDecoration extends Decoration {\n  const BoxDecoration({\n    this.color,                      // 背景色，跟 Container 的背景色冲突\n    this.image,                      // 图片\n    this.border,                     // 边框\n    this.borderRadius,               // 圆角\n    this.boxShadow,                  // 阴影\n    this.gradient,                   // 渐变效果\n    this.backgroundBlendMode,        // 背景混合\n    this.shape = BoxShape.rectangle, // 形变\n  }) : assert(\n         backgroundBlendMode == null || color != null || gradient != null,\n         \"backgroundBlendMode applies to BoxDecoration's background color or \"\n         'gradient, but no color or gradient was provided.',\n       );\n}\n```\n\n![05](Flutter之布局/05.png)\n\n## Flex\n\n```dart\n```\n\n## Row\n\nRow 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Container(color: Colors.red, width: 80, height: 88),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.lightGreenAccent, width: 55, height: 55),\n          Container(color: Colors.yellow, width: 44, height: 44),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![06](Flutter之布局/06.png)\n\n## Expand\n\nExpand 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Expanded(\n            child: Container(color: Colors.red, width: 88, height: 88),\n          ),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.green, width: 55, height: 55),\n          Expanded(\n            child: Container(color: Colors.yellow, width: 44, height: 44),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![07](Flutter之布局/07.png)\n\n## Column\n\nColumn 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Expanded(\n            child: Container(color: Colors.red, width: 88, height: 88),\n          ),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.green, width: 55, height: 55),\n          Expanded(\n            child: Container(color: Colors.yellow, width: 44, height: 44),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![08](Flutter之布局/08.png)\n\n## Stack\n\nStack 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        Container(\n          color: Colors.green,\n          width: 200,\n          height: 200,\n        ),\n        Positioned(\n          top: 20,\n          left: 20,\n          child: Icon(Icons.people_alt),\n        ),\n        Positioned(\n          bottom: 20,\n          right: 20,\n          child: Text(\"Kevin Young\"),\n        ),\n      ],\n    );\n  }\n}\n```\n\n![09](Flutter之布局/09.png)\n","source":"_posts/Flutter/Flutter之布局.md","raw":"---\ntitle: Flutter之布局\ndate: 2023-11-21 17:10:46\ntags: Flutter\n---\n\n- [Align](#align)\n- [Center](#center)\n- [Padding](#padding)\n- [Container](#container)\n- [BoxDecoration](#boxdecoration)\n- [Flex](#flex)\n- [Row](#row)\n- [Expand](#expand)\n- [Column](#column)\n- [Stack](#stack)\n\n<!-- more -->\n\n## Align\n\nAlign 的使用：\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Align\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\nAlign\n*/\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.green,\n      child: Align(\n        alignment: Alignment.topLeft,\n        widthFactor: 3,\n        heightFactor: 3,\n        child: Container(\n          decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n          child: Icon(\n            Icons.people_alt,\n            size: 40,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![01](Flutter之布局/01.png)\n\n`Align` 定义：\n\n```dart\nclass Align extends SingleChildRenderObjectWidget {\n  const Align({\n    super.key,\n    this.alignment = Alignment.center, // 对齐方式默认居中\n    this.widthFactor,                  // 将宽度设置为子部件的宽度乘以 widthFactor\n    this.heightFactor,                 // 将高度设置为子部件的高度乘以 heightFactor\n    super.child,                       // 子部件\n  }) : assert(widthFactor == null || widthFactor >= 0.0),\n       assert(heightFactor == null || heightFactor >= 0.0);\n}\n```\n\n继承关系 `Align` 继承自 `SingleChildRenderObjectWidget`，`SingleChildRenderObjectWidget` 继承自 `RenderObjectWidget`，`RenderObjectWidget` 继承自 `Widget`。\n\n> RenderObjectWidgets 提供了 [RenderObjectElement] 的配置，RenderObjectElement 包装了 [RenderObject]，RenderObject 提供了实际渲染应用程序的功能。\n\nalignment 提供多种对齐方式，包括：center、left、top、right、bottom 等等。\n\nwidthFactor 和 heightFactor：\n\n1. 用来设置父部件的宽高，如当 widthFactor = 3，则父部件的宽度为子部件的 3 倍。\n\n2. 因为在对部件进行布局时，需要先确定父部件的大小，然后根据父部件的大小对子部件布局，所以需要设置 widthFactor 和 heightFactor。如果不设置，则Align会尽可能的大（等于其父部件的大小）。\n\n## Center\n\nCenter 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.green,\n      child: Center(\n        widthFactor: 2,\n        heightFactor: 1,\n        child: Container(\n          decoration: BoxDecoration(color: Colors.red),\n          child: Icon(\n            Icons.email,\n            size: 60,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![02](Flutter之布局/02.png)\n\nCenter 的定义：\n\n```dart\nclass Center extends Align {\n  const Center({ super.key, super.widthFactor, super.heightFactor, super.child });\n}\n```\n\n`Center` 继承自 `Align`，使用 `Align` 默认的 `alignment`（.center），不支持修改。 \n\n## Padding\n\nPadding 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.lightGreen,\n      child: Padding(\n        padding: EdgeInsets.all(20),\n        child: Container(\n          decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n          child: Text(\n              \"风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\"),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![03](Flutter之布局/03.png)\n\nPadding 的定义：\n\n```dart\nclass Padding extends SingleChildRenderObjectWidget {\n  const Padding({\n    super.key,\n    required this.padding,\n    super.child,\n  });\n}\n```\n\nPadding 用来设置内边距（父部件），或外边距（子部件）。\n\n## Container\n\nContainer 的定义：\n\n```dart\nclass Container extends StatelessWidget {\n  Container({\n    super.key,\n    this.alignment,                // 对齐方式\n    this.padding,                  // 内边距\n    this.color,                    // 背景色\n    this.decoration,               // 背景装饰\n    this.foregroundDecoration,     // 前景装饰\n    double? width,                 // 宽度\n    double? height,                // 高度\n    BoxConstraints? constraints,   // 约束\n    this.margin,                   // 外边距\n    this.transform,                // 变换\n    this.transformAlignment,       // 变换对齐方式\n    this.child,                    // 子部件\n    this.clipBehavior = Clip.none, // 超出部分是否裁剪\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n}\n```\n\nContainer 相当于 iOS 的 UIView，用来设置布局，可以设置背景色、边框、圆角等。\n\n如果需要一个有背景色、边框、圆角、阴影、固定尺寸、图像时，可以考虑 Container。\n\n## BoxDecoration\n\nBoxDecoration 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 200,\n      height: 200,\n      child: Icon(Icons.phone),\n      decoration: BoxDecoration(\n        color: Colors.lightGreen,\n        border: Border.all(\n          color: Colors.red,\n          width: 5.0,\n          style: BorderStyle.solid,\n        ),\n        // border: Border(\n        //   top: BorderSide(color: Colors.red, width: 5),\n        //   right: BorderSide(color: Colors.blue, width: 10),\n        // ),\n        borderRadius: BorderRadius.circular(20),\n        boxShadow: [\n          BoxShadow(\n            color: Colors.yellow,\n            offset: Offset(5, 5),\n            blurRadius: 20,\n          ),\n        ],\n        gradient: LinearGradient(\n          colors: [\n            Colors.blue,\n            Colors.red,\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n![04](Flutter之布局/04.png)\n\n圆角图片：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(20),\n          image: DecorationImage(\n              image: NetworkImage(\n                  \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\")),\n        ),\n      ),\n    );\n  }\n}\n```\n\nBoxDecoration 的定义：\n\n```dart\nclass BoxDecoration extends Decoration {\n  const BoxDecoration({\n    this.color,                      // 背景色，跟 Container 的背景色冲突\n    this.image,                      // 图片\n    this.border,                     // 边框\n    this.borderRadius,               // 圆角\n    this.boxShadow,                  // 阴影\n    this.gradient,                   // 渐变效果\n    this.backgroundBlendMode,        // 背景混合\n    this.shape = BoxShape.rectangle, // 形变\n  }) : assert(\n         backgroundBlendMode == null || color != null || gradient != null,\n         \"backgroundBlendMode applies to BoxDecoration's background color or \"\n         'gradient, but no color or gradient was provided.',\n       );\n}\n```\n\n![05](Flutter之布局/05.png)\n\n## Flex\n\n```dart\n```\n\n## Row\n\nRow 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Container(color: Colors.red, width: 80, height: 88),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.lightGreenAccent, width: 55, height: 55),\n          Container(color: Colors.yellow, width: 44, height: 44),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![06](Flutter之布局/06.png)\n\n## Expand\n\nExpand 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Expanded(\n            child: Container(color: Colors.red, width: 88, height: 88),\n          ),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.green, width: 55, height: 55),\n          Expanded(\n            child: Container(color: Colors.yellow, width: 44, height: 44),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![07](Flutter之布局/07.png)\n\n## Column\n\nColumn 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.max,\n        children: [\n          Expanded(\n            child: Container(color: Colors.red, width: 88, height: 88),\n          ),\n          Container(color: Colors.blue, width: 66, height: 66),\n          Container(color: Colors.green, width: 55, height: 55),\n          Expanded(\n            child: Container(color: Colors.yellow, width: 44, height: 44),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![08](Flutter之布局/08.png)\n\n## Stack\n\nStack 的使用：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        Container(\n          color: Colors.green,\n          width: 200,\n          height: 200,\n        ),\n        Positioned(\n          top: 20,\n          left: 20,\n          child: Icon(Icons.people_alt),\n        ),\n        Positioned(\n          bottom: 20,\n          right: 20,\n          child: Text(\"Kevin Young\"),\n        ),\n      ],\n    );\n  }\n}\n```\n\n![09](Flutter之布局/09.png)\n","slug":"Flutter/Flutter之布局","published":1,"updated":"2023-12-23T13:26:30.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrm0007aq7kxwxkivsl"},{"title":"Alamofire","date":"2023-07-25T08:03:03.000Z","_content":"\n[Alamofire](https://github.com/Alamofire/Alamofire/tree/master)\n\n[用法](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md)\n\n[高级用法](https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md)\n\n相关文档：\n\n[apple - Property Wrappers](https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md)\n\n[apple - Key Path Member Lookup](https://github.com/apple/swift-evolution/blob/main/proposals/0252-keypath-dynamic-member-lookup.md)\n\n[Alamofire源码学习目录合集](https://juejin.cn/post/6914685327172960263/)\n\n[链式调用与@dynamicMemberLookup](https://juejin.cn/post/6844903863951032327)\n\n[SwiftUI 和 Swift 5.1 新特性(3) Key Path Member Lookup](https://juejin.cn/post/6844903863951032327)\n\n<!-- more -->\n\n## Protected\n\n定义一个协议 `Lock`，让实现该协议的类拥有`lock()`、`unlock()`、`around()`能力，其中`lock()`、`unlock()`需要遵循协议的类自定义实现。\n\n```swift\nprivate protocol Lock {\n    func lock()\n    func unlock()\n}\n\nextension Lock {\n    /// 在获取锁的同时执行返回值的闭包。\n    ///\n    /// - Parameter closure: 要运行的闭包。\n    ///\n    /// - Returns:           闭包生成的值。\n    func around<T>(_ closure: () throws -> T) rethrows -> T {\n        lock(); defer { unlock() }\n        return try closure()\n    }\n    \n    /// 获取锁时执行闭包。\n    func around(_ closure: () throws -> Void) rethrows {\n        lock(); defer { unlock() }\n        try closure()\n    }\n}\n```\n\n自定义锁 `UnfairLock` 遵循 `Lock` 协议，并自定义实现`lock()`、`unlock()`能力。\n\n```swift\nfinal class UnfairLock: Lock {\n    private let unfairLock: os_unfair_lock_t\n\n    init() {\n        unfairLock = .allocate(capacity: 1)\n        unfairLock.initialize(to: os_unfair_lock())\n    }\n\n    deinit {\n        unfairLock.deinitialize(count: 1)\n        unfairLock.deallocate()\n    }\n\n    fileprivate func lock() {\n        os_unfair_lock_lock(unfairLock)\n    }\n\n    fileprivate func unlock() {\n        os_unfair_lock_unlock(unfairLock)\n    }\n}\n```\n\n使用 `@propertyWrapper` 和 `@dynamicMemberLookup` 两个批注，自定义属性包裹器 `Protected`，实现属性的读写安全。\n\n```swift\n@propertyWrapper\n@dynamicMemberLookup\nfinal class Protected<T> {\n    private let lock = UnfairLock()\n    private var value: T\n\n    init(_ value: T) {\n        self.value = value\n    }\n\n    /// propertyWrapper修饰必须要有的属性, 用来保存包裹的值\n    /// 只保证读写安全\n    var wrappedValue: T {\n        get { lock.around { value } }\n        set { lock.around { value = newValue } }\n    }\n\n    /// projectedValue 是 Swift 的语法糖，支持 `$` 访问\n    var projectedValue: Protected<T> { self }\n\n    /// 允许为包装后的值提供初始值\n    init(wrappedValue: T) {\n        value = wrappedValue\n    }\n\n    /// 同步读取或转换包含的值。\n    ///\n    /// - Parameter closure: 要执行的闭包。\n    ///\n    /// - Returns:           传递的闭包的返回值。\n    func read<U>(_ closure: (T) throws -> U) rethrows -> U {\n        try lock.around { try closure(self.value) }\n    }\n\n    /// 同步修改受保护的值。\n    @discardableResult\n    func write<U>(_ closure: (inout T) throws -> U) rethrows -> U {\n        try lock.around { try closure(&self.value) }\n    }\n\n    subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> Property {\n        get { lock.around { value[keyPath: keyPath] } }\n        set { lock.around { value[keyPath: keyPath] = newValue } }\n    }\n\n    subscript<Property>(dynamicMember keyPath: KeyPath<T, Property>) -> Property {\n        lock.around { value[keyPath: keyPath] }\n    }\n}\n```\n\n应用：\n\n```swift\nclass Test {\n  @Protected\n  var p: Int = 3\n}\n\nlet test = Test()\nlet a = test.p   // 3\nlet b = test.$p  // 此时 b 为 Protected<Int> 类型，可以调用 Protected 类中定义的方法\nb.read {\n  $0             // 3\n}\n\nprint(\"a = \\(a)\")  // Prints \"a = 3\"\nprint(\"b = \\(b)\")  // Prints \"b = __lldb_expr_15.Protected<Swift.Int>\"\nprint(\"b = \\(b.read{ $0 })\")  // Prints \"b = 3\"\n```\n\n### @propertyWrapper\n\n属性包装器是一种通用结构，用于封装属性的读写访问，或添加其他行为。比如限制可用的属性值、向读写访问添加额外逻辑、添加方法等。\n\nSwift 5.1 为创建属性包装器提供了一种新的解决方案，使用`@propertyWrapper`**批注**标记属性包装器。\n\n`wrappedValue`：使用`@propertyWrapper`的包装器，要求包装器对象必须包含一个**被包装的值的非静态属性**。\n\n```swift\n/// propertyWrapper修饰必须要有的属性, 用来保存包裹的值\n/// 只保证读写安全\nvar wrappedValue: T {\n    get { lock.around { value } }\n    set { lock.around { value = newValue } }\n}\n\n/// 允许为包装后的值提供初始值\ninit(wrappedValue: T) {\n    value = wrappedValue\n}\n```\n\n`projectedValue`：`@propertyWrapper` 提供了另一种语法糖——投影值，通过在属性前加`$`前缀来访问属性值。\n\n![01](Alamofire/01.png)\n\n### @dynamicMemberLookup\n\n`@dynamicMemberLookup` 称为**动态成员查找**，是Swift的一项功能特性，允许动态成员查找调用看起来像范文类型属性的常规调用。\n\n```swift\nlet dic = [\"name\": \"zhangsan\"]\nlet name = dic.name\n```\n\n`name`是从字典中查找的，而不是作为 `dic` 的属性访问的。\n\n实现支持动态查找的`People`类：\n\n1. 使用`@dynamicMemberLookup`标注`People`的类型；\n2. 实现 `subscript(dynamicMember key:)` 方法。\n\n```swift\n@dynamicMemberLookup\nstruct People {\n  private var map = [\"name\": \"zhangsna\", \"age\": \"18\"]\n  subscript(dynamicMember key: String) -> String {\n    map[key] ?? \"undefine\"\n  }\n}\n\nlet zhangsan = People()\nprint(\"name = \\(zhangsan.name)\")  // Prints \"name = zhangsna\"\nprint(\"age = \\(zhangsan.age)\")    // Prints \"age = 18\"\n```\n\n没有使用 `@dynamicMemberLookup` 标注的情况会报错：\n\n![02](Alamofire/02.png)\n\n#### 1. KeyPath\n\n`KeyPath<Root, Value>` 泛型类型，用来表示从 `Root` 类型到 `Value` 属性的访问路径。\n\n```swift\nstruct Person {\n  let name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nlet p = Person(name: \"zhangsna\", age: 18)\nprint(p[keyPath: keyPath])\n// Prints \"zhangsna\"\n```\n\n这里用到了一个语法 `\\Person.name`，它的类型是 `KeyPath<Person, String>`\n\n![03](Alamofire/03.png)\n\n* 同一类型 `KeyPath<Root, Value>` 可以代表多种获取路径：`KeyPath<Person, Int>` 既可以表示`\\Person.age`，也可以表示`\\Person.name.count`。\n\n* 两个 KeyPath 可以拼接成一个新的 KeyPath：`KeyPath1` 的类型是 `KeyPath<Person, String>`，`\\String.count` 的类型是 `KeyPath<String, Int>`，调用 `appending` 函数后变成了 `KeyPath<Person, Int>` 类型。\n\n```swift\nlet keyPath1 = \\Person.name\nlet keyPath2 = \\String.count\nlet keyPath3 = keyPath1.appending(path: \\String.count)\n\nprint(type(of: keyPath))   // Prints \"KeyPath<Person, String>\"\nprint(type(of: keyPath2))  // Prints \"KeyPath<String, Int>\"\nprint(type(of: keyPath3))  // Prints \"KeyPath<Person, Int>\"\n```\n\n* `KeyPath` 是 `WriteableKeyPath` 的父类，`WriteableKeyPath` 是 `ReferenceWritableKeyPath` 的父类。\n\n* `KeyPath` 的能力是最弱的，只能以只读的方式访问属性。\n\n```swift\nstruct Person {\n  let name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nlet p = Person(name: \"zhangsna\", age: 18)\nprint(p[keyPath: keyPath])\n// Prints \"zhangsna\"\n```\n\n* `WriteableKeyPath` 可以对可变属性进行读写操作。将 `let` 改成 `var`，则 `person.name` 的类型就变成了 `WriteableKeyPath`，可以直接修改 `p[keyPath: keyPath] = \"lisi\"`\n\n```swift\nstruct Person {\n  var name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nvar p = Person(name: \"zhangsna\", age: 18)\np[keyPath: keyPath] = \"lisi\"\nprint(p[keyPath: keyPath])\n// Prints \"lisi\"\n```\n\n* `ReferenceWritableKeyPath` 可以对**引用类型**的可变属性进行写入。将`struct`改成`class`，则 `Person.name` 的类型变成 `ReferenceWritableKeyPath`\n\n```swift\nclass Person {\n  var name: String = \"\"\n  let age: Int = 0\n}\n\nlet keyPath = \\Person.name\nvar p = Person()\np[keyPath: keyPath] = \"lisi\"\nprint(p[keyPath: keyPath])\n// Prints \"lisi\"\n```\n\n#### 2. 动态成员查找 Dynamic Member Lookup\n\nSwift4.2 引入了**动态成员查找**特性，实现使用静态的语法做动态的查找。\n\n```swift\n@dynamicMemberLookup\nstruct People {\n  private var map = [\"name\": \"zhangsna\", \"age\": \"18\"]\n  subscript(dynamicMember key: String) -> String {\n    map[key] ?? \"undefine\"\n  }\n}\n\nlet zhangsan = People()\nprint(\"name = \\(zhangsan.name)\")  // Prints \"name = zhangsna\"\nprint(\"age = \\(zhangsan.age)\")    // Prints \"age = 18\"\n```\n\n支持动态成员查找的类型首先需要用 `@dynamicMemberLookup` 来修饰，然后实现动态查找方法`subscript(dynamicMember member: String)`。\n\n直接使用 `.property` 的语法访问属性**貌似静态实则动态**，该语法实际上调用的是`subscript(dynamicMember member: String)`方法。\n\n#### 3. 成员查找 Key Path Member Lookup\n\nSwift5.1 引入的成员查找。\n\n编译器可以从 `KeyPath` 查询所有的目标，以及它们的类型：\n\n```swift\n@dynamicMemberLookup\nstruct Person {\n  struct Info {\n    var name: String\n  }\n  var info: Info\n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<Info, Property>) -> Property {\n    get { info[keyPath: keyPath] }\n    set { info[keyPath: keyPath] = newValue }\n  }\n}\n\nvar person = Person(info: Person.Info(name: \"zhangsan\"))\nperson.name = \"lisi\"\nprint(person.name)\n// Prints \"lisi\"\n```\n\n`person.info.name` 可以直接写成 `person.name`。\n\n`@dynamicMemberLookup` 非常适用于包装类型：\n\n```swift\nstruct Person {\n  var name: String\n  var age: Int\n}\n\n@dynamicMemberLookup\nstruct Wrapper<T> {\n  var value: T\n\n  init(value: T) {\n    self.value = value\n  }\n\n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> Property {\n    get { value[keyPath: keyPath] }\n    set { value[keyPath: keyPath] = newValue }\n  }\n}\n\nvar teacher = Wrapper(value: Person(name: \"zhangsan\", age: 18))\nteacher.age = 35\nprint(teacher.age)\n// Prints \"35\"\n```\n\n#### 链式调用\n\n通过回传 `self`，实现链式调用：\n\n```swift\nimport UIKit\n\nclass Label {\n  var text: String?\n  var textColor: UIColor?\n}\n\n/// setter\nextension Label {\n  func text(_ text: String) -> Label {\n    self.text = text\n    return self\n  }\n  \n  func textColor(_ textColor: UIColor) -> Label {\n    self.textColor = textColor\n    return self\n  }\n}\n\nLabel()\n  .text(\"name\")\n  .textColor(.black)\n```\n\n这种方法被动性比较大，如果 `Label` 的属性变化，则对应的 `setter` 方法也得改变。\n\n使用**动态成员查找**实现：\n\n```swift\nclass Label {\n  var text: String?\n  var textColor: UIColor?\n}\n\n@dynamicMemberLookup\nstruct Setter<T> {\n  var object: T\n  \n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> ((Property) -> Setter<T>) {\n    // 获取到真正的对象\n    var object = self.object\n    \n    return { newValue in\n      object[keyPath: keyPath] = newValue\n      // 因为使用 Setter 链式调用，而不是 object 本身，所以回传的类型是 Setter，而不是 object\n      return self\n    }\n  }\n}\n\nlet s = Setter(object: Label()).text(\"zhangsan\").textColor(.blue).object\nprint(s.text)\n// Prints \"Optional(\"zhangsan\")\"\n```\n\n创建一个 `UILabel`：\n\n![04](Alamofire/04.png)\n\n## 线程安全的属性 MutableState\n\n在 Request.swift 文件中，Alamofire 使用 `@Protected` 标注，实现了一个线程安全的对象 `mutableState`：\n\n```swift\n/// 受保护的`MutableState`值，该值提供对状态值的线程安全访问。\n@Protected\nfileprivate var mutableState = MutableState()\n```\n\n`MutableState` 中定义了很多变量，这些变量可能在异步线程调用：\n\n```swift\n/// 封装可变状态的类型，他们可能在从“underlyingQueue”以外的任何位置访问。\nstruct MutableState {\n\n    /// `Request`的状态\n    var state: State = .initialized\n    \n    /// 为上传进度回调提供的`ProgressHandler`和`DispatchQueue`。\n    var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?\n    \n    /// 为下载进度回调提供的`ProgressHandler`和`DispatchQueue`。\n    var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?\n    \n    /// 为处理请求重定向提供的`RedirectHandler`\n    var redirectHandler: RedirectHandler?\n    \n    /// 为处理响应缓存提供的`CachedResponseHandler`\n    var cachedResponseHandler: CachedResponseHandler?\n    \n    /// 当`Request`能够创建其自身的cURL描述时，调用队列和闭包。\n    var cURLHandler: (queue: DispatchQueue, handler: (String) -> Void)?\n    \n    /// 当`Request`创建`URLRequest`时调用队列和闭包。\n    var urlRequestHandler: (queue: DispatchQueue, handler: (URLRequest) -> Void)?\n    \n    /// `Request`创建`URLSessionTask`时调用的队列和闭包。\n    var urlSessionTaskHandler: (queue: DispatchQueue, handler: (URLSessionTask) -> Void)?\n    \n    /// 处理响应解析的响应序列化闭包。\n    var responseSerializers: [() -> Void] = []\n    \n    /// 所有响应序列化程序完成后执行的响应序列化完成闭包。\n    var responseSerializerCompletions: [() -> Void] = []\n    \n    /// 响应序列化程序处理是否完成。\n    var responseSerializerProcessingFinished = false\n    \n    /// `URLCredential `用于身份验证质询。\n    var credential: URLCredential?\n    \n    /// Alamofire代表请求创建的所有URLRequest。\n    var requests: [URLRequest] = []\n    \n    /// Alamofire代表请求创建的所有URLSessionTask。\n    var tasks: [URLSessionTask] = []\n    \n    /// Alamofire代表`Request`收集的所有`URLSessionTaskMetrics`值。应与创建的“任务”完全对应。\n    /// 「PS：对发送请求/DNS查询/TLS握手/请求响应等各种环节时间上的统计」\n    var metrics: [URLSessionTaskMetrics] = []\n    \n    /// 提供的任何重试器重试“请求”的次数。\n    var retryCount = 0\n    \n    /// `Request`的最终`AFError`，无论是来自各种内部Alamofire调用还是作为“任务”的结果。\n    var error: AFError?\n    \n    /// 实例是否已调用`finish()`并正在运行序列化程序。将来应该用状态机中的表示替换。\n    var isFinishing = false\n    \n    /// 请求完成时要运行的操作。用于并发支持。\n    var finishHandlers: [() -> Void] = []\n}\n```\n\n比如：\n\n```swift\n/// 当代表实例创建了初始“URLRequest”时调用。如果“RequestAdapter”处于活跃状态，则“URLRequest”将在发出之前进行调整。\n///\n/// - Parameter request: 已创建“URLRequest”。\nfunc didCreateInitialURLRequest(_ request: URLRequest) {\n    dispatchPrecondition(condition: .onQueue(underlyingQueue))\n\n    /*\n    1. 通过 $mutableState.write 调用一个线程安全的闭包，`$` 保证闭包线程安全\n    2. 将 request 添加到 .requets 数组中，`$` 保证 setter 方法线程安全\n    */\n    $mutableState.write { $0.requests.append(request) }\n\n    eventMonitor?.request(self, didCreateInitialURLRequest: request)\n}\n```\n\n或者\n\n```swift\n/// 完成此“请求”并启动响应序列化程序。\n///\n/// - Parameter error: 实例结束时可能出现的“错误”。\nfunc finish(error: AFError? = nil) {\n   dispatchPrecondition(condition: .onQueue(underlyingQueue))\n\n   guard !$mutableState.isFinishing else { return }\n\n   // `$` 保证了 setter 方法是线程安全的\n   $mutableState.isFinishing = true\n\n   if let error = error { self.error = error }\n\n   // Start response handlers\n   processNextResponseSerializer()\n\n   eventMonitor?.requestDidFinish(self)\n}\n```\n\n## AlamofireExtended\n\nAlamofire 扩展包裹器，用来对系统类进行扩展时包裹使用，避免方法入侵。\n\n### 第一种方式\n\n通过添加全局方法的方式扩展两个新的方法：\n\n```swift\nextension UIButton {\n  func method1() {}\n  func method2() {}\n}\n\nlet button = UIButton(type: .custom)\nbutton.method1()\n```\n\n通过这种方式添加的方法，在所有能访问到该扩展的地方都可以调用。调用时，扩展的方法直接出现在 `UIButton` 提示的方法列表中。这有一个问题，一方面会给调用者造成困惑，另一方发面会存在同名的风险，造成方法污染👇：\n\n![05](Alamofire/05.png)\n\n### 第二种方式\n\n写一个包裹器，将 UIButton 包裹起来，在包裹器中添加需要扩展的方法。\n\n```swift\nstruct UIButtonWrapper {\n  let button: UIButton\n  \n  func method1() {}\n  func method2() {}\n}\n\nextension UIButton {\n  var wrapper: UIButtonWrapper {\n    get { UIButtonWrapper.init(button: self) }\n  }\n}\n\nlet button = UIButton(type: .custom)\nbutton.wrapper.method1()\n```\n\n通过实现一个包裹器`wrapper`，扩展的方法只会出现在`wrapper`的调用提示方法列表里，`UIButton`的调用提示方法列表里只新增了一个 wrapper，从而避免了对`UIButton`的方法污染。\n\n`UIButtonWrapper` 是针对`UIButton`设计的一个包裹器，只适用于UIButton。可以借用Swift**泛型**与**扩展约束**的力量，实现一个泛型包裹器，从而实现为需要的任何类型扩展方法。\n\n### 第三种方式\n\n使用泛型和扩展约束，实现一个泛型包裹器：\n\n```swift\npublic struct AlamofireExtension<ExtendedType> {\n  public private(set) var type: ExtendedType\n  \n  public init(_ type: ExtendedType) {\n    self.type = type\n  }\n}\n\n// MARK: —— UIButton Extension\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n}\n\nextension UIButton {\n  var af: AlamofireExtension<UIButton> {\n    // AlamofireExtension.init(self)\n    get { AlamofireExtension(self) }\n  }\n}\n\n// MARK: —— UILabel Extension\nextension AlamofireExtension where ExtendedType == UILabel {\n  func methodForLabel1() {}\n  func methodForLabel2() {}\n}\n\nextension UILabel {\n  var af: AlamofireExtension<UILabel> {\n    get { AlamofireExtension(self) }\n  }\n}\n\nlet button = UIButton(type: .custom)\nbutton.af.methodForButton1()\n\nlet label = UILabel()\nlabel.af.methodForLabel1()\n```\n\n通过泛型 `AlamofireExtension<ExtendedType>` 实现了对`UIButton`和`UILabel`的同时支持，扩展约束 `where ExtendedType == UIButton` 实现了对`UIButton`和`UILabel`扩展方法的区分，这种区分可以从调用提示方法列表中看出来：\n\n`UILabel`提示方法列表：\n![06](Alamofire/06.png)\n\n`UIButton`提示方法列表：\n![07](Alamofire/07.png)\n\n通过`UIButton`和`UILabel`的扩展方式可以看出，在为类型扩展方法时，首先需要添加 `af` 计算属性来返回泛型包裹器`AlamofireExtension<ExtendedType>`。\n\n```swift\nvar af: AlamofireExtension<UIButton> {\n  // AlamofireExtension.init(self)\n  get { AlamofireExtension(self) }\n}\n```\n\n可以使用**泛型协议**和**扩展**的方式，添加默认实现，从而省略掉这一步。\n\n### 第四种方式\n\n使用**泛型协议**和**扩展**的，实现`af`计算属性：\n\n```swift\n// MARK: —— 通用扩展类型\npublic struct AlamofireExtension<ExtendedType> {\n  public private(set) var type: ExtendedType\n\n  public init(_ type: ExtendedType) {\n    self.type = type\n  }\n}\n\n// MARK: —— 描述“通用拓展类型”的协议\npublic protocol AlamofireExtended {\n  \n  // 正在扩展的类型\n  associatedtype ExtendedType\n  \n  // 静态包裹器\n  static var af: AlamofireExtension<ExtendedType>.Type { get set }\n  \n  // 实例包裹器\n  var af: AlamofireExtension<ExtendedType> { get set }\n}\n\nextension AlamofireExtended {\n  \n  // 静态包裹器默认实现\n  public static var af: AlamofireExtension<Self>.Type {\n    get { AlamofireExtension<Self>.self }\n    set {}\n  }\n  \n  // 实例包裹器默认实现\n  public var af: AlamofireExtension<Self> {\n    get { AlamofireExtension(self) }\n    set {}\n  }\n}\n```\n\n应用：\n\n```swift\n// 扩展方法\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n}\n\nextension AlamofireExtension where ExtendedType == UILabel {\n  func methodForLabel1() {}\n  func methodForLabel2() {}\n}\n\n// 采纳协议\nextension UIButton: AlamofireExtended {}\nextension UILabel: AlamofireExtended {}\n\nlet button = UIButton()\nbutton.af.methodForButton1()\n\nlet label = UILabel()\nlabel.af.methodForLabel1()\n```\n\n静态包裹器扩展了类型方法：\n\n```swift\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n  static func methodForButton3() {}\n  static func methodForButton4() {}\n}\n\nUIButton.af.methodForButton3()\n```\n\n扩展的类型方法，也有对应的提示方法列表：\n\n![08](Alamofire/08.png)\n\n## EventMonitor\n\n`protocol EventMonitor` 协议概述了 Alamofire 生命周期里的内部事件。EventMonitor 既包括从各种 `URLSession` 委托协议接收的事件，也包括`Request` 及其子类生命周期内的各种事件。\n\n```swift\npublic protocol EventMonitor {\n\n    /// 调度事件的调度队列，默认是主队列\n    var queue: DispatchQueue { get }\n\n    // MARK: - URLSession Events\n\n    // MARK: URLSessionDelegate Events\n\n    func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)\n\n    // MARK: URLSessionTaskDelegate Events\n\n    // MARK: URLSessionDataDelegate Events\n\n    // MARK: URLSessionDownloadDelegate Events\n\n    // MARK: - Request Events\n\n    // MARK: DataRequest Events\n\n    // MARK: DataStreamRequest Events\n\n    // MARK: UploadRequest Events\n\n    // MARK: DownloadRequest Events\n}\n```\n\n实例代码中只展示了`URLSessionDelegate`协议相关方法的声明，其它协议的声明省略。\n\n在 `EventMonitor` 协议声明完方法后，还要对这些方法提供默认实现：\n\n```swift\nextension EventMonitor {\n  \n    /// 调度事件的调度队列，默认是主队列\n    public var queue: DispatchQueue { .main }\n\n    // MARK: Default Implementations\n\n    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didReceive challenge: URLAuthenticationChallenge) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didSendBodyData bytesSent: Int64,\n                           totalBytesSent: Int64,\n                           totalBytesExpectedToSend: Int64) {}\n    public func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           willPerformHTTPRedirection response: HTTPURLResponse,\n                           newRequest request: URLRequest) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didFinishCollecting metrics: URLSessionTaskMetrics) {}\n    public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {}\n    public func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {}\n    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {}\n    public func urlSession(_ session: URLSession,\n                           dataTask: URLSessionDataTask,\n                           willCacheResponse proposedResponse: CachedURLResponse) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didResumeAtOffset fileOffset: Int64,\n                           expectedTotalBytes: Int64) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didWriteData bytesWritten: Int64,\n                           totalBytesWritten: Int64,\n                           totalBytesExpectedToWrite: Int64) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didFinishDownloadingTo location: URL) {}\n    public func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest) {}\n    public func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError) {}\n    public func request(_ request: Request,\n                        didAdaptInitialRequest initialRequest: URLRequest,\n                        to adaptedRequest: URLRequest) {}\n    public func request(_ request: Request,\n                        didFailToAdaptURLRequest initialRequest: URLRequest,\n                        withError error: AFError) {}\n    public func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest) {}\n    public func request(_ request: Request, didCreateTask task: URLSessionTask) {}\n    public func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics) {}\n    public func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError) {}\n    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {}\n    public func requestIsRetrying(_ request: Request) {}\n    public func requestDidFinish(_ request: Request) {}\n    public func requestDidResume(_ request: Request) {}\n    public func request(_ request: Request, didResumeTask task: URLSessionTask) {}\n    public func requestDidSuspend(_ request: Request) {}\n    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {}\n    public func requestDidCancel(_ request: Request) {}\n    public func request(_ request: Request, didCancelTask task: URLSessionTask) {}\n    public func request(_ request: DataRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        data: Data?,\n                        withResult result: Request.ValidationResult) {}\n    public func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>) {}\n    public func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>) {}\n    public func request(_ request: DataStreamRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        withResult result: Request.ValidationResult) {}\n    public func request<Value>(_ request: DataStreamRequest, didParseStream result: Result<Value, AFError>) {}\n    public func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable) {}\n    public func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError) {}\n    public func request(_ request: UploadRequest, didProvideInputStream stream: InputStream) {}\n    public func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>) {}\n    public func request(_ request: DownloadRequest, didCreateDestinationURL url: URL) {}\n    public func request(_ request: DownloadRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        fileURL: URL?,\n                        withResult result: Request.ValidationResult) {}\n    public func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>) {}\n    public func request<Value>(_ request: DownloadRequest, didParseResponse response: DownloadResponse<Value, AFError>) {}\n}\n```\n\n因为 `EventMonitor` 协议包含了 URLSession 和 Request 的各种事件，所以方法比较多。实现中什么也没做，只是提供了默认实现。\n\n`EventMonitor` 协议就像一个显示器，完整且全面的展示了 Alamofire 内部发生的各种事件，透过它可以大概了解 Alamofire 都做了些什么。然而，`EventMonitor` 只是一个抽象类，在Alamofire的逻辑代码部分用到的并不是它，而是遵循了 `EventMonitor` 协议的类 `CompositeEventMonitor`，负责处理 Alamofire 中的各种事件。\n\n```swift\n/// `EventMonitor`包含在所有实例中。`[AlamofireNotifications（）]`默认情况下。\npublic let defaultEventMonitors: [EventMonitor] = [AlamofireNotifications()]\n\n/// Session 的初始化方法\n///   - eventMonitors:            实例使用的其他“EventMonitor”们（自定义）。\npublic init(session: URLSession,\n          delegate: SessionDelegate,\n          rootQueue: DispatchQueue,\n          startRequestsImmediately: Bool = true,\n          requestQueue: DispatchQueue? = nil,\n          serializationQueue: DispatchQueue? = nil,\n          interceptor: RequestInterceptor? = nil,\n          serverTrustManager: ServerTrustManager? = nil,\n          redirectHandler: RedirectHandler? = nil,\n          cachedResponseHandler: CachedResponseHandler? = nil,\n          eventMonitors: [EventMonitor] = []) {\n  precondition(session.configuration.identifier == nil,\n               \"Alamofire does not support background URLSessionConfigurations.\")\n  precondition(session.delegateQueue.underlyingQueue === rootQueue,\n               \"Session(session:) initializer must be passed the DispatchQueue used as the delegateQueue's underlyingQueue as rootQueue.\")\n\n  self.session = session\n  self.delegate = delegate\n  \n  // ...\n\n  // 设置内部事件监听器们\n  eventMonitor = CompositeEventMonitor(monitors: defaultEventMonitors + eventMonitors)\n  delegate.eventMonitor = eventMonitor\n\n  // ...\n}\n```\n\n### CompositeEventMonitor\n\n`CompositeEventMonitor`，负责处理 Alamofire 中的各种事件。从命名就可以看出，这是一个**批量处理事件**的“管理类”，可以称为事件监视器集合。\n\n```swift\npublic final class CompositeEventMonitor: EventMonitor {\n    public let queue = DispatchQueue(label: \"org.alamofire.compositeEventMonitor\", qos: .utility)\n\n    let monitors: [EventMonitor]\n\n    init(monitors: [EventMonitor]) {\n        self.monitors = monitors\n    }\n\n    func performEvent(_ event: @escaping (EventMonitor) -> Void) {\n        queue.async {\n            for monitor in self.monitors {\n                monitor.queue.async { event(monitor) }\n            }\n        }\n    }\n    \n    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n        performEvent { $0.urlSession(session, didBecomeInvalidWithError: error) }\n    }\n\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didReceive challenge: URLAuthenticationChallenge) {\n        performEvent { $0.urlSession(session, task: task, didReceive: challenge) }\n    }\n\n    // 省略\n}\n```\n\n`CompositeEventMonitor` 遵循了 `EventMonitor` 协议，并且实现了全部方法。这里也只提供两个方法，其它方法省略。\n\n`CompositeEventMonitor` 实现这些方法为了是使用队列来调度方法的调用，所以方法实现部分都是一样的，都调用了 `performEvent` 方法:\n\n1. 在 Session 和 Request 事件回调时，最终都会来到 `performEvent` 方法；\n2. 依次取出数组里的事件监视器，放到同步队列里执行。\n\n```swift\nfunc performEvent(_ event: @escaping (EventMonitor) -> Void) {\n  queue.async {\n      for monitor in self.monitors {\n          monitor.queue.async { event(monitor) }\n      }\n  }\n}\n```\n\n`event(monitor)` 调用了闭包，闭包内部实现👇，`$0` 是参数 `monitor`：\n\n```swift\n$0.urlSession(session, didBecomeInvalidWithError: error)\n```\n\n### defaultEventMonitors\n\n在 Session 的初始化方法里👆🏻，eventMonitors 数组里包含两个部分，一个是默认的 `defaultEventMonitors`，另一个是调用者添加的自定义事件监听器：\n\n```swift\neventMonitor = CompositeEventMonitor(monitors: defaultEventMonitors + eventMonitors)\n```\n\n`defaultEventMonitors` 的定义：\n\n```swift\npublic let defaultEventMonitors: [EventMonitor] = [AlamofireNotifications()]\n```\n\n`AlamofireNotifications` 提供Alamofire通知的事件监视器。\n\n1. 遵循 EventMonitor 协议；\n2. 实现需要监听的方法；\n\n```swift\npublic final class AlamofireNotifications: EventMonitor {\n    public func requestDidResume(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didResumeNotification, with: request)\n    }\n\n    public func requestDidSuspend(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didSuspendNotification, with: request)\n    }\n\n    public func requestDidCancel(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didCancelNotification, with: request)\n    }\n\n    public func requestDidFinish(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didFinishNotification, with: request)\n    }\n\n    public func request(_ request: Request, didResumeTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didResumeTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didSuspendTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didCancelTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didCancelTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {\n        NotificationCenter.default.postNotification(named: Request.didCompleteTaskNotification, with: request)\n    }\n}\n```\n\n在 `CompositeEventMonitor` 的 `performEvent` 方法里，`event(monitor)` 会调用 `AlamofireNotifications`，触发对应的方法。\n\n### ClosureEventMonitor\n\n事件监视器——允许将可选闭包设置为接收事件。\n\n```swift\nopen class ClosureEventMonitor: EventMonitor {\n    /// 用于 `urlSession(_:didBecomeInvalidWithError:)` 事件调用的闭包\n    open var sessionDidBecomeInvalidWithError: ((URLSession, Error?) -> Void)?\n\n    /// 用于 `urlSession(_:task:didReceive:completionHandler:)` 事件调用的闭包.\n    open var taskDidReceiveChallenge: ((URLSession, URLSessionTask, URLAuthenticationChallenge) -> Void)?\n\n    // ...\n\n    public let queue: DispatchQueue\n\n    /// 用于执行事件闭包的队列\n    public init(queue: DispatchQueue = .main) {\n        self.queue = queue\n    }\n\n    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n        sessionDidBecomeInvalidWithError?(session, error)\n    }\n\n    open func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge) {\n        taskDidReceiveChallenge?(session, task, challenge)\n    }\n\n    // ...\n}\n```\n\n1、CompositeEventMonitor 的 performEvent，获取到 ClosureEventMonitor，将事件放入队列中；\n\n```swift\nfunc performEvent(_ event: @escaping (EventMonitor) -> Void) {\n  queue.async {\n      for monitor in self.monitors {\n          monitor.queue.async { event(monitor) }\n      }\n  }\n}\n```\n\n2、ClosureEventMonitor 调用实现的代理方法；\n\n```swift\n$0.urlSession(session, didBecomeInvalidWithError: error)\n```\n\n3、从而调用对应的闭包\n\n```swift\nopen func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n  sessionDidBecomeInvalidWithError?(session, error)\n}\n```\n\n## Concurrency\n\nasync-await\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 4.280519008636475-\nfunc work(_ action: String) {\n  print(\"\\(action)_①\")\n  sleep(2)\n  Task {\n    print(\"\\(action)_②\")\n    sleep(1)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  sleep(2)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n1_②\n1_④\n2_④\n2_②\n3_④\n9_④\n4_④\n5_④\n7_④\n6_④\n8_④\n10_④\n1_③\n3_②\n2_③\n4_②\n1_⑤\n5_②\n2_⑤\n3_③\n8_②\n3_⑤\n9_②\n7_②\n9_⑤\n7_⑤\n5_⑤\n4_⑤\n4_③\n10_⑤\n6_⑤\n6_②\n8_⑤\n10_②\n4.024436950683594-\n5_③\n8_③\n9_③\n7_③\n6_③\n10_③\n```\n\n增加测试数据：\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 8.030163764953613-\nfunc work(_ action: String) {\n  print(\"\\(action)_①\")\n  sleep(2)\n  Task {\n    print(\"\\(action)_②\")\n    sleep(1)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  sleep(2)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n11_①\n12_①\n3_④\n8_④\n1_④\n10_④\n11_④\n6_④\n5_④\n12_④\n7_④\n9_④\n4_④\n2_④\n7_⑤\n1_⑤\n11_⑤\n10_⑤\n9_⑤\n5_⑤\n3_⑤\n6_⑤\n12_⑤\n8_⑤\n4_⑤\n2_⑤\n13_①\n15_①\n18_①\n14_①\n16_①\n19_①\n4_②\n17_①\n20_①\n10_②\n1_②\n6_②\n10_③\n4_③\n1_③\n3_②\n8_②\n6_③\n11_②\n5_②\n11_③\n5_③\n16_④\n14_④\n3_③\n18_④\n15_④\n20_④\n19_④\n17_④\n9_②\n12_②\n13_④\n8_③\n7_②\n2_②\n9_③\n12_③\n2_③\n14_②\n7_③\n15_②\n19_②\n18_②\n16_⑤\n20_⑤\n17_⑤\n14_⑤\n19_⑤\n15_⑤\n18_⑤\n13_②\n17_②\n20_②\n13_⑤\n16_②\n8.013674974441528-\n14_③\n19_③\n15_③\n18_③\n13_③\n17_③\n16_③\n20_③\n```\n\n使用 `Task.sleep(nanoseconds:)`：\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 4.280519008636475-\nfunc work(_ action: String) async throws {\n  print(\"\\(action)_①\")\n  try await Task.sleep(nanoseconds: 2 * 1_000_000_000)\n  Task {\n    print(\"\\(action)_②\")\n    try await Task.sleep(nanoseconds: 1 * 1_000_000_000)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  try await Task.sleep(nanoseconds: 2 * 1_000_000_000)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    try await work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n11_①\n12_①\n13_①\n14_①\n15_①\n16_①\n17_①\n18_①\n19_①\n20_①\n2_④\n1_④\n3_④\n7_④\n6_④\n2_②\n4_④\n9_④\n12_④\n5_④\n8_④\n3_②\n6_②\n1_②\n12_②\n10_④\n11_④\n8_②\n9_②\n13_④\n10_②\n14_④\n7_②\n4_②\n20_④\n5_②\n17_④\n11_②\n18_②\n15_④\n19_④\n16_④\n13_②\n16_②\n15_②\n14_②\n18_④\n17_②\n20_②\n19_②\n2_③\n3_③\n12_③\n8_③\n10_③\n1_③\n18_③\n7_③\n6_③\n5_③\n16_③\n15_③\n9_③\n13_③\n14_③\n20_③\n17_③\n11_③\n4_③\n19_③\n2_⑤\n1_⑤\n9_⑤\n8_⑤\n12_⑤\n5_⑤\n11_⑤\n3_⑤\n10_⑤\n4_⑤\n7_⑤\n6_⑤\n13_⑤\n17_⑤\n18_⑤\n14_⑤\n19_⑤\n16_⑤\n20_⑤\n15_⑤\n4.280519008636475-\n```\n\n`await Task.sleep(nanoseconds:)` 方法有可能会调用失败，所以需要加 `try`：\n\n","source":"_posts/Github开源框架/Alamofire.md","raw":"---\ntitle: Alamofire\ndate: 2023-07-25 16:03:03\ntags: Swift\n---\n\n[Alamofire](https://github.com/Alamofire/Alamofire/tree/master)\n\n[用法](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md)\n\n[高级用法](https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md)\n\n相关文档：\n\n[apple - Property Wrappers](https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md)\n\n[apple - Key Path Member Lookup](https://github.com/apple/swift-evolution/blob/main/proposals/0252-keypath-dynamic-member-lookup.md)\n\n[Alamofire源码学习目录合集](https://juejin.cn/post/6914685327172960263/)\n\n[链式调用与@dynamicMemberLookup](https://juejin.cn/post/6844903863951032327)\n\n[SwiftUI 和 Swift 5.1 新特性(3) Key Path Member Lookup](https://juejin.cn/post/6844903863951032327)\n\n<!-- more -->\n\n## Protected\n\n定义一个协议 `Lock`，让实现该协议的类拥有`lock()`、`unlock()`、`around()`能力，其中`lock()`、`unlock()`需要遵循协议的类自定义实现。\n\n```swift\nprivate protocol Lock {\n    func lock()\n    func unlock()\n}\n\nextension Lock {\n    /// 在获取锁的同时执行返回值的闭包。\n    ///\n    /// - Parameter closure: 要运行的闭包。\n    ///\n    /// - Returns:           闭包生成的值。\n    func around<T>(_ closure: () throws -> T) rethrows -> T {\n        lock(); defer { unlock() }\n        return try closure()\n    }\n    \n    /// 获取锁时执行闭包。\n    func around(_ closure: () throws -> Void) rethrows {\n        lock(); defer { unlock() }\n        try closure()\n    }\n}\n```\n\n自定义锁 `UnfairLock` 遵循 `Lock` 协议，并自定义实现`lock()`、`unlock()`能力。\n\n```swift\nfinal class UnfairLock: Lock {\n    private let unfairLock: os_unfair_lock_t\n\n    init() {\n        unfairLock = .allocate(capacity: 1)\n        unfairLock.initialize(to: os_unfair_lock())\n    }\n\n    deinit {\n        unfairLock.deinitialize(count: 1)\n        unfairLock.deallocate()\n    }\n\n    fileprivate func lock() {\n        os_unfair_lock_lock(unfairLock)\n    }\n\n    fileprivate func unlock() {\n        os_unfair_lock_unlock(unfairLock)\n    }\n}\n```\n\n使用 `@propertyWrapper` 和 `@dynamicMemberLookup` 两个批注，自定义属性包裹器 `Protected`，实现属性的读写安全。\n\n```swift\n@propertyWrapper\n@dynamicMemberLookup\nfinal class Protected<T> {\n    private let lock = UnfairLock()\n    private var value: T\n\n    init(_ value: T) {\n        self.value = value\n    }\n\n    /// propertyWrapper修饰必须要有的属性, 用来保存包裹的值\n    /// 只保证读写安全\n    var wrappedValue: T {\n        get { lock.around { value } }\n        set { lock.around { value = newValue } }\n    }\n\n    /// projectedValue 是 Swift 的语法糖，支持 `$` 访问\n    var projectedValue: Protected<T> { self }\n\n    /// 允许为包装后的值提供初始值\n    init(wrappedValue: T) {\n        value = wrappedValue\n    }\n\n    /// 同步读取或转换包含的值。\n    ///\n    /// - Parameter closure: 要执行的闭包。\n    ///\n    /// - Returns:           传递的闭包的返回值。\n    func read<U>(_ closure: (T) throws -> U) rethrows -> U {\n        try lock.around { try closure(self.value) }\n    }\n\n    /// 同步修改受保护的值。\n    @discardableResult\n    func write<U>(_ closure: (inout T) throws -> U) rethrows -> U {\n        try lock.around { try closure(&self.value) }\n    }\n\n    subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> Property {\n        get { lock.around { value[keyPath: keyPath] } }\n        set { lock.around { value[keyPath: keyPath] = newValue } }\n    }\n\n    subscript<Property>(dynamicMember keyPath: KeyPath<T, Property>) -> Property {\n        lock.around { value[keyPath: keyPath] }\n    }\n}\n```\n\n应用：\n\n```swift\nclass Test {\n  @Protected\n  var p: Int = 3\n}\n\nlet test = Test()\nlet a = test.p   // 3\nlet b = test.$p  // 此时 b 为 Protected<Int> 类型，可以调用 Protected 类中定义的方法\nb.read {\n  $0             // 3\n}\n\nprint(\"a = \\(a)\")  // Prints \"a = 3\"\nprint(\"b = \\(b)\")  // Prints \"b = __lldb_expr_15.Protected<Swift.Int>\"\nprint(\"b = \\(b.read{ $0 })\")  // Prints \"b = 3\"\n```\n\n### @propertyWrapper\n\n属性包装器是一种通用结构，用于封装属性的读写访问，或添加其他行为。比如限制可用的属性值、向读写访问添加额外逻辑、添加方法等。\n\nSwift 5.1 为创建属性包装器提供了一种新的解决方案，使用`@propertyWrapper`**批注**标记属性包装器。\n\n`wrappedValue`：使用`@propertyWrapper`的包装器，要求包装器对象必须包含一个**被包装的值的非静态属性**。\n\n```swift\n/// propertyWrapper修饰必须要有的属性, 用来保存包裹的值\n/// 只保证读写安全\nvar wrappedValue: T {\n    get { lock.around { value } }\n    set { lock.around { value = newValue } }\n}\n\n/// 允许为包装后的值提供初始值\ninit(wrappedValue: T) {\n    value = wrappedValue\n}\n```\n\n`projectedValue`：`@propertyWrapper` 提供了另一种语法糖——投影值，通过在属性前加`$`前缀来访问属性值。\n\n![01](Alamofire/01.png)\n\n### @dynamicMemberLookup\n\n`@dynamicMemberLookup` 称为**动态成员查找**，是Swift的一项功能特性，允许动态成员查找调用看起来像范文类型属性的常规调用。\n\n```swift\nlet dic = [\"name\": \"zhangsan\"]\nlet name = dic.name\n```\n\n`name`是从字典中查找的，而不是作为 `dic` 的属性访问的。\n\n实现支持动态查找的`People`类：\n\n1. 使用`@dynamicMemberLookup`标注`People`的类型；\n2. 实现 `subscript(dynamicMember key:)` 方法。\n\n```swift\n@dynamicMemberLookup\nstruct People {\n  private var map = [\"name\": \"zhangsna\", \"age\": \"18\"]\n  subscript(dynamicMember key: String) -> String {\n    map[key] ?? \"undefine\"\n  }\n}\n\nlet zhangsan = People()\nprint(\"name = \\(zhangsan.name)\")  // Prints \"name = zhangsna\"\nprint(\"age = \\(zhangsan.age)\")    // Prints \"age = 18\"\n```\n\n没有使用 `@dynamicMemberLookup` 标注的情况会报错：\n\n![02](Alamofire/02.png)\n\n#### 1. KeyPath\n\n`KeyPath<Root, Value>` 泛型类型，用来表示从 `Root` 类型到 `Value` 属性的访问路径。\n\n```swift\nstruct Person {\n  let name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nlet p = Person(name: \"zhangsna\", age: 18)\nprint(p[keyPath: keyPath])\n// Prints \"zhangsna\"\n```\n\n这里用到了一个语法 `\\Person.name`，它的类型是 `KeyPath<Person, String>`\n\n![03](Alamofire/03.png)\n\n* 同一类型 `KeyPath<Root, Value>` 可以代表多种获取路径：`KeyPath<Person, Int>` 既可以表示`\\Person.age`，也可以表示`\\Person.name.count`。\n\n* 两个 KeyPath 可以拼接成一个新的 KeyPath：`KeyPath1` 的类型是 `KeyPath<Person, String>`，`\\String.count` 的类型是 `KeyPath<String, Int>`，调用 `appending` 函数后变成了 `KeyPath<Person, Int>` 类型。\n\n```swift\nlet keyPath1 = \\Person.name\nlet keyPath2 = \\String.count\nlet keyPath3 = keyPath1.appending(path: \\String.count)\n\nprint(type(of: keyPath))   // Prints \"KeyPath<Person, String>\"\nprint(type(of: keyPath2))  // Prints \"KeyPath<String, Int>\"\nprint(type(of: keyPath3))  // Prints \"KeyPath<Person, Int>\"\n```\n\n* `KeyPath` 是 `WriteableKeyPath` 的父类，`WriteableKeyPath` 是 `ReferenceWritableKeyPath` 的父类。\n\n* `KeyPath` 的能力是最弱的，只能以只读的方式访问属性。\n\n```swift\nstruct Person {\n  let name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nlet p = Person(name: \"zhangsna\", age: 18)\nprint(p[keyPath: keyPath])\n// Prints \"zhangsna\"\n```\n\n* `WriteableKeyPath` 可以对可变属性进行读写操作。将 `let` 改成 `var`，则 `person.name` 的类型就变成了 `WriteableKeyPath`，可以直接修改 `p[keyPath: keyPath] = \"lisi\"`\n\n```swift\nstruct Person {\n  var name: String\n  let age: Int\n}\n\nlet keyPath = \\Person.name\nvar p = Person(name: \"zhangsna\", age: 18)\np[keyPath: keyPath] = \"lisi\"\nprint(p[keyPath: keyPath])\n// Prints \"lisi\"\n```\n\n* `ReferenceWritableKeyPath` 可以对**引用类型**的可变属性进行写入。将`struct`改成`class`，则 `Person.name` 的类型变成 `ReferenceWritableKeyPath`\n\n```swift\nclass Person {\n  var name: String = \"\"\n  let age: Int = 0\n}\n\nlet keyPath = \\Person.name\nvar p = Person()\np[keyPath: keyPath] = \"lisi\"\nprint(p[keyPath: keyPath])\n// Prints \"lisi\"\n```\n\n#### 2. 动态成员查找 Dynamic Member Lookup\n\nSwift4.2 引入了**动态成员查找**特性，实现使用静态的语法做动态的查找。\n\n```swift\n@dynamicMemberLookup\nstruct People {\n  private var map = [\"name\": \"zhangsna\", \"age\": \"18\"]\n  subscript(dynamicMember key: String) -> String {\n    map[key] ?? \"undefine\"\n  }\n}\n\nlet zhangsan = People()\nprint(\"name = \\(zhangsan.name)\")  // Prints \"name = zhangsna\"\nprint(\"age = \\(zhangsan.age)\")    // Prints \"age = 18\"\n```\n\n支持动态成员查找的类型首先需要用 `@dynamicMemberLookup` 来修饰，然后实现动态查找方法`subscript(dynamicMember member: String)`。\n\n直接使用 `.property` 的语法访问属性**貌似静态实则动态**，该语法实际上调用的是`subscript(dynamicMember member: String)`方法。\n\n#### 3. 成员查找 Key Path Member Lookup\n\nSwift5.1 引入的成员查找。\n\n编译器可以从 `KeyPath` 查询所有的目标，以及它们的类型：\n\n```swift\n@dynamicMemberLookup\nstruct Person {\n  struct Info {\n    var name: String\n  }\n  var info: Info\n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<Info, Property>) -> Property {\n    get { info[keyPath: keyPath] }\n    set { info[keyPath: keyPath] = newValue }\n  }\n}\n\nvar person = Person(info: Person.Info(name: \"zhangsan\"))\nperson.name = \"lisi\"\nprint(person.name)\n// Prints \"lisi\"\n```\n\n`person.info.name` 可以直接写成 `person.name`。\n\n`@dynamicMemberLookup` 非常适用于包装类型：\n\n```swift\nstruct Person {\n  var name: String\n  var age: Int\n}\n\n@dynamicMemberLookup\nstruct Wrapper<T> {\n  var value: T\n\n  init(value: T) {\n    self.value = value\n  }\n\n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> Property {\n    get { value[keyPath: keyPath] }\n    set { value[keyPath: keyPath] = newValue }\n  }\n}\n\nvar teacher = Wrapper(value: Person(name: \"zhangsan\", age: 18))\nteacher.age = 35\nprint(teacher.age)\n// Prints \"35\"\n```\n\n#### 链式调用\n\n通过回传 `self`，实现链式调用：\n\n```swift\nimport UIKit\n\nclass Label {\n  var text: String?\n  var textColor: UIColor?\n}\n\n/// setter\nextension Label {\n  func text(_ text: String) -> Label {\n    self.text = text\n    return self\n  }\n  \n  func textColor(_ textColor: UIColor) -> Label {\n    self.textColor = textColor\n    return self\n  }\n}\n\nLabel()\n  .text(\"name\")\n  .textColor(.black)\n```\n\n这种方法被动性比较大，如果 `Label` 的属性变化，则对应的 `setter` 方法也得改变。\n\n使用**动态成员查找**实现：\n\n```swift\nclass Label {\n  var text: String?\n  var textColor: UIColor?\n}\n\n@dynamicMemberLookup\nstruct Setter<T> {\n  var object: T\n  \n  subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> ((Property) -> Setter<T>) {\n    // 获取到真正的对象\n    var object = self.object\n    \n    return { newValue in\n      object[keyPath: keyPath] = newValue\n      // 因为使用 Setter 链式调用，而不是 object 本身，所以回传的类型是 Setter，而不是 object\n      return self\n    }\n  }\n}\n\nlet s = Setter(object: Label()).text(\"zhangsan\").textColor(.blue).object\nprint(s.text)\n// Prints \"Optional(\"zhangsan\")\"\n```\n\n创建一个 `UILabel`：\n\n![04](Alamofire/04.png)\n\n## 线程安全的属性 MutableState\n\n在 Request.swift 文件中，Alamofire 使用 `@Protected` 标注，实现了一个线程安全的对象 `mutableState`：\n\n```swift\n/// 受保护的`MutableState`值，该值提供对状态值的线程安全访问。\n@Protected\nfileprivate var mutableState = MutableState()\n```\n\n`MutableState` 中定义了很多变量，这些变量可能在异步线程调用：\n\n```swift\n/// 封装可变状态的类型，他们可能在从“underlyingQueue”以外的任何位置访问。\nstruct MutableState {\n\n    /// `Request`的状态\n    var state: State = .initialized\n    \n    /// 为上传进度回调提供的`ProgressHandler`和`DispatchQueue`。\n    var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?\n    \n    /// 为下载进度回调提供的`ProgressHandler`和`DispatchQueue`。\n    var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?\n    \n    /// 为处理请求重定向提供的`RedirectHandler`\n    var redirectHandler: RedirectHandler?\n    \n    /// 为处理响应缓存提供的`CachedResponseHandler`\n    var cachedResponseHandler: CachedResponseHandler?\n    \n    /// 当`Request`能够创建其自身的cURL描述时，调用队列和闭包。\n    var cURLHandler: (queue: DispatchQueue, handler: (String) -> Void)?\n    \n    /// 当`Request`创建`URLRequest`时调用队列和闭包。\n    var urlRequestHandler: (queue: DispatchQueue, handler: (URLRequest) -> Void)?\n    \n    /// `Request`创建`URLSessionTask`时调用的队列和闭包。\n    var urlSessionTaskHandler: (queue: DispatchQueue, handler: (URLSessionTask) -> Void)?\n    \n    /// 处理响应解析的响应序列化闭包。\n    var responseSerializers: [() -> Void] = []\n    \n    /// 所有响应序列化程序完成后执行的响应序列化完成闭包。\n    var responseSerializerCompletions: [() -> Void] = []\n    \n    /// 响应序列化程序处理是否完成。\n    var responseSerializerProcessingFinished = false\n    \n    /// `URLCredential `用于身份验证质询。\n    var credential: URLCredential?\n    \n    /// Alamofire代表请求创建的所有URLRequest。\n    var requests: [URLRequest] = []\n    \n    /// Alamofire代表请求创建的所有URLSessionTask。\n    var tasks: [URLSessionTask] = []\n    \n    /// Alamofire代表`Request`收集的所有`URLSessionTaskMetrics`值。应与创建的“任务”完全对应。\n    /// 「PS：对发送请求/DNS查询/TLS握手/请求响应等各种环节时间上的统计」\n    var metrics: [URLSessionTaskMetrics] = []\n    \n    /// 提供的任何重试器重试“请求”的次数。\n    var retryCount = 0\n    \n    /// `Request`的最终`AFError`，无论是来自各种内部Alamofire调用还是作为“任务”的结果。\n    var error: AFError?\n    \n    /// 实例是否已调用`finish()`并正在运行序列化程序。将来应该用状态机中的表示替换。\n    var isFinishing = false\n    \n    /// 请求完成时要运行的操作。用于并发支持。\n    var finishHandlers: [() -> Void] = []\n}\n```\n\n比如：\n\n```swift\n/// 当代表实例创建了初始“URLRequest”时调用。如果“RequestAdapter”处于活跃状态，则“URLRequest”将在发出之前进行调整。\n///\n/// - Parameter request: 已创建“URLRequest”。\nfunc didCreateInitialURLRequest(_ request: URLRequest) {\n    dispatchPrecondition(condition: .onQueue(underlyingQueue))\n\n    /*\n    1. 通过 $mutableState.write 调用一个线程安全的闭包，`$` 保证闭包线程安全\n    2. 将 request 添加到 .requets 数组中，`$` 保证 setter 方法线程安全\n    */\n    $mutableState.write { $0.requests.append(request) }\n\n    eventMonitor?.request(self, didCreateInitialURLRequest: request)\n}\n```\n\n或者\n\n```swift\n/// 完成此“请求”并启动响应序列化程序。\n///\n/// - Parameter error: 实例结束时可能出现的“错误”。\nfunc finish(error: AFError? = nil) {\n   dispatchPrecondition(condition: .onQueue(underlyingQueue))\n\n   guard !$mutableState.isFinishing else { return }\n\n   // `$` 保证了 setter 方法是线程安全的\n   $mutableState.isFinishing = true\n\n   if let error = error { self.error = error }\n\n   // Start response handlers\n   processNextResponseSerializer()\n\n   eventMonitor?.requestDidFinish(self)\n}\n```\n\n## AlamofireExtended\n\nAlamofire 扩展包裹器，用来对系统类进行扩展时包裹使用，避免方法入侵。\n\n### 第一种方式\n\n通过添加全局方法的方式扩展两个新的方法：\n\n```swift\nextension UIButton {\n  func method1() {}\n  func method2() {}\n}\n\nlet button = UIButton(type: .custom)\nbutton.method1()\n```\n\n通过这种方式添加的方法，在所有能访问到该扩展的地方都可以调用。调用时，扩展的方法直接出现在 `UIButton` 提示的方法列表中。这有一个问题，一方面会给调用者造成困惑，另一方发面会存在同名的风险，造成方法污染👇：\n\n![05](Alamofire/05.png)\n\n### 第二种方式\n\n写一个包裹器，将 UIButton 包裹起来，在包裹器中添加需要扩展的方法。\n\n```swift\nstruct UIButtonWrapper {\n  let button: UIButton\n  \n  func method1() {}\n  func method2() {}\n}\n\nextension UIButton {\n  var wrapper: UIButtonWrapper {\n    get { UIButtonWrapper.init(button: self) }\n  }\n}\n\nlet button = UIButton(type: .custom)\nbutton.wrapper.method1()\n```\n\n通过实现一个包裹器`wrapper`，扩展的方法只会出现在`wrapper`的调用提示方法列表里，`UIButton`的调用提示方法列表里只新增了一个 wrapper，从而避免了对`UIButton`的方法污染。\n\n`UIButtonWrapper` 是针对`UIButton`设计的一个包裹器，只适用于UIButton。可以借用Swift**泛型**与**扩展约束**的力量，实现一个泛型包裹器，从而实现为需要的任何类型扩展方法。\n\n### 第三种方式\n\n使用泛型和扩展约束，实现一个泛型包裹器：\n\n```swift\npublic struct AlamofireExtension<ExtendedType> {\n  public private(set) var type: ExtendedType\n  \n  public init(_ type: ExtendedType) {\n    self.type = type\n  }\n}\n\n// MARK: —— UIButton Extension\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n}\n\nextension UIButton {\n  var af: AlamofireExtension<UIButton> {\n    // AlamofireExtension.init(self)\n    get { AlamofireExtension(self) }\n  }\n}\n\n// MARK: —— UILabel Extension\nextension AlamofireExtension where ExtendedType == UILabel {\n  func methodForLabel1() {}\n  func methodForLabel2() {}\n}\n\nextension UILabel {\n  var af: AlamofireExtension<UILabel> {\n    get { AlamofireExtension(self) }\n  }\n}\n\nlet button = UIButton(type: .custom)\nbutton.af.methodForButton1()\n\nlet label = UILabel()\nlabel.af.methodForLabel1()\n```\n\n通过泛型 `AlamofireExtension<ExtendedType>` 实现了对`UIButton`和`UILabel`的同时支持，扩展约束 `where ExtendedType == UIButton` 实现了对`UIButton`和`UILabel`扩展方法的区分，这种区分可以从调用提示方法列表中看出来：\n\n`UILabel`提示方法列表：\n![06](Alamofire/06.png)\n\n`UIButton`提示方法列表：\n![07](Alamofire/07.png)\n\n通过`UIButton`和`UILabel`的扩展方式可以看出，在为类型扩展方法时，首先需要添加 `af` 计算属性来返回泛型包裹器`AlamofireExtension<ExtendedType>`。\n\n```swift\nvar af: AlamofireExtension<UIButton> {\n  // AlamofireExtension.init(self)\n  get { AlamofireExtension(self) }\n}\n```\n\n可以使用**泛型协议**和**扩展**的方式，添加默认实现，从而省略掉这一步。\n\n### 第四种方式\n\n使用**泛型协议**和**扩展**的，实现`af`计算属性：\n\n```swift\n// MARK: —— 通用扩展类型\npublic struct AlamofireExtension<ExtendedType> {\n  public private(set) var type: ExtendedType\n\n  public init(_ type: ExtendedType) {\n    self.type = type\n  }\n}\n\n// MARK: —— 描述“通用拓展类型”的协议\npublic protocol AlamofireExtended {\n  \n  // 正在扩展的类型\n  associatedtype ExtendedType\n  \n  // 静态包裹器\n  static var af: AlamofireExtension<ExtendedType>.Type { get set }\n  \n  // 实例包裹器\n  var af: AlamofireExtension<ExtendedType> { get set }\n}\n\nextension AlamofireExtended {\n  \n  // 静态包裹器默认实现\n  public static var af: AlamofireExtension<Self>.Type {\n    get { AlamofireExtension<Self>.self }\n    set {}\n  }\n  \n  // 实例包裹器默认实现\n  public var af: AlamofireExtension<Self> {\n    get { AlamofireExtension(self) }\n    set {}\n  }\n}\n```\n\n应用：\n\n```swift\n// 扩展方法\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n}\n\nextension AlamofireExtension where ExtendedType == UILabel {\n  func methodForLabel1() {}\n  func methodForLabel2() {}\n}\n\n// 采纳协议\nextension UIButton: AlamofireExtended {}\nextension UILabel: AlamofireExtended {}\n\nlet button = UIButton()\nbutton.af.methodForButton1()\n\nlet label = UILabel()\nlabel.af.methodForLabel1()\n```\n\n静态包裹器扩展了类型方法：\n\n```swift\nextension AlamofireExtension where ExtendedType == UIButton {\n  func methodForButton1() {}\n  func methodForButton2() {}\n  static func methodForButton3() {}\n  static func methodForButton4() {}\n}\n\nUIButton.af.methodForButton3()\n```\n\n扩展的类型方法，也有对应的提示方法列表：\n\n![08](Alamofire/08.png)\n\n## EventMonitor\n\n`protocol EventMonitor` 协议概述了 Alamofire 生命周期里的内部事件。EventMonitor 既包括从各种 `URLSession` 委托协议接收的事件，也包括`Request` 及其子类生命周期内的各种事件。\n\n```swift\npublic protocol EventMonitor {\n\n    /// 调度事件的调度队列，默认是主队列\n    var queue: DispatchQueue { get }\n\n    // MARK: - URLSession Events\n\n    // MARK: URLSessionDelegate Events\n\n    func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)\n\n    // MARK: URLSessionTaskDelegate Events\n\n    // MARK: URLSessionDataDelegate Events\n\n    // MARK: URLSessionDownloadDelegate Events\n\n    // MARK: - Request Events\n\n    // MARK: DataRequest Events\n\n    // MARK: DataStreamRequest Events\n\n    // MARK: UploadRequest Events\n\n    // MARK: DownloadRequest Events\n}\n```\n\n实例代码中只展示了`URLSessionDelegate`协议相关方法的声明，其它协议的声明省略。\n\n在 `EventMonitor` 协议声明完方法后，还要对这些方法提供默认实现：\n\n```swift\nextension EventMonitor {\n  \n    /// 调度事件的调度队列，默认是主队列\n    public var queue: DispatchQueue { .main }\n\n    // MARK: Default Implementations\n\n    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didReceive challenge: URLAuthenticationChallenge) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didSendBodyData bytesSent: Int64,\n                           totalBytesSent: Int64,\n                           totalBytesExpectedToSend: Int64) {}\n    public func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           willPerformHTTPRedirection response: HTTPURLResponse,\n                           newRequest request: URLRequest) {}\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didFinishCollecting metrics: URLSessionTaskMetrics) {}\n    public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {}\n    public func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {}\n    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {}\n    public func urlSession(_ session: URLSession,\n                           dataTask: URLSessionDataTask,\n                           willCacheResponse proposedResponse: CachedURLResponse) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didResumeAtOffset fileOffset: Int64,\n                           expectedTotalBytes: Int64) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didWriteData bytesWritten: Int64,\n                           totalBytesWritten: Int64,\n                           totalBytesExpectedToWrite: Int64) {}\n    public func urlSession(_ session: URLSession,\n                           downloadTask: URLSessionDownloadTask,\n                           didFinishDownloadingTo location: URL) {}\n    public func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest) {}\n    public func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError) {}\n    public func request(_ request: Request,\n                        didAdaptInitialRequest initialRequest: URLRequest,\n                        to adaptedRequest: URLRequest) {}\n    public func request(_ request: Request,\n                        didFailToAdaptURLRequest initialRequest: URLRequest,\n                        withError error: AFError) {}\n    public func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest) {}\n    public func request(_ request: Request, didCreateTask task: URLSessionTask) {}\n    public func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics) {}\n    public func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError) {}\n    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {}\n    public func requestIsRetrying(_ request: Request) {}\n    public func requestDidFinish(_ request: Request) {}\n    public func requestDidResume(_ request: Request) {}\n    public func request(_ request: Request, didResumeTask task: URLSessionTask) {}\n    public func requestDidSuspend(_ request: Request) {}\n    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {}\n    public func requestDidCancel(_ request: Request) {}\n    public func request(_ request: Request, didCancelTask task: URLSessionTask) {}\n    public func request(_ request: DataRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        data: Data?,\n                        withResult result: Request.ValidationResult) {}\n    public func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>) {}\n    public func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>) {}\n    public func request(_ request: DataStreamRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        withResult result: Request.ValidationResult) {}\n    public func request<Value>(_ request: DataStreamRequest, didParseStream result: Result<Value, AFError>) {}\n    public func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable) {}\n    public func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError) {}\n    public func request(_ request: UploadRequest, didProvideInputStream stream: InputStream) {}\n    public func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>) {}\n    public func request(_ request: DownloadRequest, didCreateDestinationURL url: URL) {}\n    public func request(_ request: DownloadRequest,\n                        didValidateRequest urlRequest: URLRequest?,\n                        response: HTTPURLResponse,\n                        fileURL: URL?,\n                        withResult result: Request.ValidationResult) {}\n    public func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>) {}\n    public func request<Value>(_ request: DownloadRequest, didParseResponse response: DownloadResponse<Value, AFError>) {}\n}\n```\n\n因为 `EventMonitor` 协议包含了 URLSession 和 Request 的各种事件，所以方法比较多。实现中什么也没做，只是提供了默认实现。\n\n`EventMonitor` 协议就像一个显示器，完整且全面的展示了 Alamofire 内部发生的各种事件，透过它可以大概了解 Alamofire 都做了些什么。然而，`EventMonitor` 只是一个抽象类，在Alamofire的逻辑代码部分用到的并不是它，而是遵循了 `EventMonitor` 协议的类 `CompositeEventMonitor`，负责处理 Alamofire 中的各种事件。\n\n```swift\n/// `EventMonitor`包含在所有实例中。`[AlamofireNotifications（）]`默认情况下。\npublic let defaultEventMonitors: [EventMonitor] = [AlamofireNotifications()]\n\n/// Session 的初始化方法\n///   - eventMonitors:            实例使用的其他“EventMonitor”们（自定义）。\npublic init(session: URLSession,\n          delegate: SessionDelegate,\n          rootQueue: DispatchQueue,\n          startRequestsImmediately: Bool = true,\n          requestQueue: DispatchQueue? = nil,\n          serializationQueue: DispatchQueue? = nil,\n          interceptor: RequestInterceptor? = nil,\n          serverTrustManager: ServerTrustManager? = nil,\n          redirectHandler: RedirectHandler? = nil,\n          cachedResponseHandler: CachedResponseHandler? = nil,\n          eventMonitors: [EventMonitor] = []) {\n  precondition(session.configuration.identifier == nil,\n               \"Alamofire does not support background URLSessionConfigurations.\")\n  precondition(session.delegateQueue.underlyingQueue === rootQueue,\n               \"Session(session:) initializer must be passed the DispatchQueue used as the delegateQueue's underlyingQueue as rootQueue.\")\n\n  self.session = session\n  self.delegate = delegate\n  \n  // ...\n\n  // 设置内部事件监听器们\n  eventMonitor = CompositeEventMonitor(monitors: defaultEventMonitors + eventMonitors)\n  delegate.eventMonitor = eventMonitor\n\n  // ...\n}\n```\n\n### CompositeEventMonitor\n\n`CompositeEventMonitor`，负责处理 Alamofire 中的各种事件。从命名就可以看出，这是一个**批量处理事件**的“管理类”，可以称为事件监视器集合。\n\n```swift\npublic final class CompositeEventMonitor: EventMonitor {\n    public let queue = DispatchQueue(label: \"org.alamofire.compositeEventMonitor\", qos: .utility)\n\n    let monitors: [EventMonitor]\n\n    init(monitors: [EventMonitor]) {\n        self.monitors = monitors\n    }\n\n    func performEvent(_ event: @escaping (EventMonitor) -> Void) {\n        queue.async {\n            for monitor in self.monitors {\n                monitor.queue.async { event(monitor) }\n            }\n        }\n    }\n    \n    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n        performEvent { $0.urlSession(session, didBecomeInvalidWithError: error) }\n    }\n\n    public func urlSession(_ session: URLSession,\n                           task: URLSessionTask,\n                           didReceive challenge: URLAuthenticationChallenge) {\n        performEvent { $0.urlSession(session, task: task, didReceive: challenge) }\n    }\n\n    // 省略\n}\n```\n\n`CompositeEventMonitor` 遵循了 `EventMonitor` 协议，并且实现了全部方法。这里也只提供两个方法，其它方法省略。\n\n`CompositeEventMonitor` 实现这些方法为了是使用队列来调度方法的调用，所以方法实现部分都是一样的，都调用了 `performEvent` 方法:\n\n1. 在 Session 和 Request 事件回调时，最终都会来到 `performEvent` 方法；\n2. 依次取出数组里的事件监视器，放到同步队列里执行。\n\n```swift\nfunc performEvent(_ event: @escaping (EventMonitor) -> Void) {\n  queue.async {\n      for monitor in self.monitors {\n          monitor.queue.async { event(monitor) }\n      }\n  }\n}\n```\n\n`event(monitor)` 调用了闭包，闭包内部实现👇，`$0` 是参数 `monitor`：\n\n```swift\n$0.urlSession(session, didBecomeInvalidWithError: error)\n```\n\n### defaultEventMonitors\n\n在 Session 的初始化方法里👆🏻，eventMonitors 数组里包含两个部分，一个是默认的 `defaultEventMonitors`，另一个是调用者添加的自定义事件监听器：\n\n```swift\neventMonitor = CompositeEventMonitor(monitors: defaultEventMonitors + eventMonitors)\n```\n\n`defaultEventMonitors` 的定义：\n\n```swift\npublic let defaultEventMonitors: [EventMonitor] = [AlamofireNotifications()]\n```\n\n`AlamofireNotifications` 提供Alamofire通知的事件监视器。\n\n1. 遵循 EventMonitor 协议；\n2. 实现需要监听的方法；\n\n```swift\npublic final class AlamofireNotifications: EventMonitor {\n    public func requestDidResume(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didResumeNotification, with: request)\n    }\n\n    public func requestDidSuspend(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didSuspendNotification, with: request)\n    }\n\n    public func requestDidCancel(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didCancelNotification, with: request)\n    }\n\n    public func requestDidFinish(_ request: Request) {\n        NotificationCenter.default.postNotification(named: Request.didFinishNotification, with: request)\n    }\n\n    public func request(_ request: Request, didResumeTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didResumeTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didSuspendTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didCancelTask task: URLSessionTask) {\n        NotificationCenter.default.postNotification(named: Request.didCancelTaskNotification, with: request)\n    }\n\n    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {\n        NotificationCenter.default.postNotification(named: Request.didCompleteTaskNotification, with: request)\n    }\n}\n```\n\n在 `CompositeEventMonitor` 的 `performEvent` 方法里，`event(monitor)` 会调用 `AlamofireNotifications`，触发对应的方法。\n\n### ClosureEventMonitor\n\n事件监视器——允许将可选闭包设置为接收事件。\n\n```swift\nopen class ClosureEventMonitor: EventMonitor {\n    /// 用于 `urlSession(_:didBecomeInvalidWithError:)` 事件调用的闭包\n    open var sessionDidBecomeInvalidWithError: ((URLSession, Error?) -> Void)?\n\n    /// 用于 `urlSession(_:task:didReceive:completionHandler:)` 事件调用的闭包.\n    open var taskDidReceiveChallenge: ((URLSession, URLSessionTask, URLAuthenticationChallenge) -> Void)?\n\n    // ...\n\n    public let queue: DispatchQueue\n\n    /// 用于执行事件闭包的队列\n    public init(queue: DispatchQueue = .main) {\n        self.queue = queue\n    }\n\n    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n        sessionDidBecomeInvalidWithError?(session, error)\n    }\n\n    open func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge) {\n        taskDidReceiveChallenge?(session, task, challenge)\n    }\n\n    // ...\n}\n```\n\n1、CompositeEventMonitor 的 performEvent，获取到 ClosureEventMonitor，将事件放入队列中；\n\n```swift\nfunc performEvent(_ event: @escaping (EventMonitor) -> Void) {\n  queue.async {\n      for monitor in self.monitors {\n          monitor.queue.async { event(monitor) }\n      }\n  }\n}\n```\n\n2、ClosureEventMonitor 调用实现的代理方法；\n\n```swift\n$0.urlSession(session, didBecomeInvalidWithError: error)\n```\n\n3、从而调用对应的闭包\n\n```swift\nopen func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {\n  sessionDidBecomeInvalidWithError?(session, error)\n}\n```\n\n## Concurrency\n\nasync-await\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 4.280519008636475-\nfunc work(_ action: String) {\n  print(\"\\(action)_①\")\n  sleep(2)\n  Task {\n    print(\"\\(action)_②\")\n    sleep(1)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  sleep(2)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n1_②\n1_④\n2_④\n2_②\n3_④\n9_④\n4_④\n5_④\n7_④\n6_④\n8_④\n10_④\n1_③\n3_②\n2_③\n4_②\n1_⑤\n5_②\n2_⑤\n3_③\n8_②\n3_⑤\n9_②\n7_②\n9_⑤\n7_⑤\n5_⑤\n4_⑤\n4_③\n10_⑤\n6_⑤\n6_②\n8_⑤\n10_②\n4.024436950683594-\n5_③\n8_③\n9_③\n7_③\n6_③\n10_③\n```\n\n增加测试数据：\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 8.030163764953613-\nfunc work(_ action: String) {\n  print(\"\\(action)_①\")\n  sleep(2)\n  Task {\n    print(\"\\(action)_②\")\n    sleep(1)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  sleep(2)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n11_①\n12_①\n3_④\n8_④\n1_④\n10_④\n11_④\n6_④\n5_④\n12_④\n7_④\n9_④\n4_④\n2_④\n7_⑤\n1_⑤\n11_⑤\n10_⑤\n9_⑤\n5_⑤\n3_⑤\n6_⑤\n12_⑤\n8_⑤\n4_⑤\n2_⑤\n13_①\n15_①\n18_①\n14_①\n16_①\n19_①\n4_②\n17_①\n20_①\n10_②\n1_②\n6_②\n10_③\n4_③\n1_③\n3_②\n8_②\n6_③\n11_②\n5_②\n11_③\n5_③\n16_④\n14_④\n3_③\n18_④\n15_④\n20_④\n19_④\n17_④\n9_②\n12_②\n13_④\n8_③\n7_②\n2_②\n9_③\n12_③\n2_③\n14_②\n7_③\n15_②\n19_②\n18_②\n16_⑤\n20_⑤\n17_⑤\n14_⑤\n19_⑤\n15_⑤\n18_⑤\n13_②\n17_②\n20_②\n13_⑤\n16_②\n8.013674974441528-\n14_③\n19_③\n15_③\n18_③\n13_③\n17_③\n16_③\n20_③\n```\n\n使用 `Task.sleep(nanoseconds:)`：\n\n```swift\nvar startTime = Date.now\nvar count = 20\nvar finish = 0\n\n// 4.280519008636475-\nfunc work(_ action: String) async throws {\n  print(\"\\(action)_①\")\n  try await Task.sleep(nanoseconds: 2 * 1_000_000_000)\n  Task {\n    print(\"\\(action)_②\")\n    try await Task.sleep(nanoseconds: 1 * 1_000_000_000)\n    print(\"\\(action)_③\")\n  }\n  print(\"\\(action)_④\")\n  try await Task.sleep(nanoseconds: 2 * 1_000_000_000)\n  print(\"\\(action)_⑤\")\n  finish += 1\n  if finish == count {\n    print(\"\\(Date.now.timeIntervalSince1970 - startTime.timeIntervalSince1970)\" + \"-\")\n  }\n}\n\nfor i in 1...count {\n  Task {\n    try await work(\"\\(i)\")\n  }\n}\n```\n\n打印结果：\n\n```js\n1_①\n2_①\n3_①\n4_①\n5_①\n6_①\n7_①\n8_①\n9_①\n10_①\n11_①\n12_①\n13_①\n14_①\n15_①\n16_①\n17_①\n18_①\n19_①\n20_①\n2_④\n1_④\n3_④\n7_④\n6_④\n2_②\n4_④\n9_④\n12_④\n5_④\n8_④\n3_②\n6_②\n1_②\n12_②\n10_④\n11_④\n8_②\n9_②\n13_④\n10_②\n14_④\n7_②\n4_②\n20_④\n5_②\n17_④\n11_②\n18_②\n15_④\n19_④\n16_④\n13_②\n16_②\n15_②\n14_②\n18_④\n17_②\n20_②\n19_②\n2_③\n3_③\n12_③\n8_③\n10_③\n1_③\n18_③\n7_③\n6_③\n5_③\n16_③\n15_③\n9_③\n13_③\n14_③\n20_③\n17_③\n11_③\n4_③\n19_③\n2_⑤\n1_⑤\n9_⑤\n8_⑤\n12_⑤\n5_⑤\n11_⑤\n3_⑤\n10_⑤\n4_⑤\n7_⑤\n6_⑤\n13_⑤\n17_⑤\n18_⑤\n14_⑤\n19_⑤\n16_⑤\n20_⑤\n15_⑤\n4.280519008636475-\n```\n\n`await Task.sleep(nanoseconds:)` 方法有可能会调用失败，所以需要加 `try`：\n\n","slug":"Github开源框架/Alamofire","published":1,"updated":"2023-12-23T13:28:08.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrp000aaq7kocxwjpsx"},{"title":"OC对象的分类","date":"2020-05-09T08:37:02.000Z","_content":"\nObjective-C 中的对象主要可以分为3种：  \n* instance对象（实例对象）\n* class对象（类对象）\n* meta-class对象（元类对象）  \n\n<!-- more -->\n\n# instance 对象\ninstance 对象就是通过类 alloc 出来的对象，每次调用 alloc 都会产生新的 instance 对象。\n```\nNSObject *object1 = [[NSObject alloc] init];\nNSObject *object2 = [[NSObject alloc] init];\n```\n\nobject1、object2 是 NSObject 的 instance 对象，它们是不同的两个对象，分别占据着两块不同的内存。\n\n## instance 对象在内存中存储的信息\n\n* isa指针\n* 其他成员变量\n\n定义 Person\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation Person\n@end\n```\n\n创建 Person 的实例对象\n```\nPerson *p1 = [[Person alloc] init];\nPerson *p2 = [[Person alloc] init];\n```\n\np1、p2 对象在内存中存储的信息\n![OC对象的分类](OC对象的分类/OC对象的分类01.png)\n\n\n# class 对象\n每个类在内存中有且只有一个 class 对象，同一个类 alloc 出来的实例对象共同拥有唯一的 class 对象。\n\n获取 class 对象：\n```\nClass objectClass1 = [object1 class];\nClass objectClass2 = [object2 class];\nClass objectClass3 = object_getClass(object1);\nClass objectClass4 = object_getClass(object2);\nClass objectClass5 = [NSObject class];\n```\n\nobjectClass1 ~ objectClass5 都是 NSObject 的 class 对象，它们是同一个对象。\n\n👉 注意：\n下面这行代码获取的 objectClass 是 class 对象，并不是 meta-class 对象，-(void)Class 和 +(void)Class 返回的是类对象。\n```\nClass objectClass = [[NSObject class] class];\n```\n\n## class 对象在内存中存储的信息主要包括\n* isa 指针\n* superclass 指针\n* 类的属性信息（@property）、类的对象方法信息（instance method）\n* 类的协议信息（protocol）、类的成员变量信息（ivar）  \n......  \n\n![OC对象的分类](OC对象的分类/OC对象的分类02.png)\n\n不同的 instance 对象却拥有相同的属性、对象方法、协议和成员变量等等，这些信息都存放在 class 对象的内存中，保证了同样的信息只存储一份。\n\n# meta-class 对象\n\n每个类在内存中有且只有一个 meta-class 对象。通过 object_getClass 方法，将类对象当做参数传入，获得元类对象：\n```\nClass objectMetaClass = object_getClass(objectClass5);\n```\n\n## meta-class 对象在内存中存储的信息主要包括\n* isa 指针\n* superclass 指针\n* 类的类方法信息（class method）  \n......\n\n![OC对象的分类](OC对象的分类/OC对象的分类03.png)\n\n通过 class_isMetaClass 方法查看 objecClass 是否为 meta-class：\n```\n#import <objc/runtime.h>\n\nBOOL result = class_isMetaClass(objecClass)\n```\n\n# 窥视 objc_getClass()、object_getClass()\n\n## object_getClass\n打开 Runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，找到 objc-class.mm，搜索 object_getClass：\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa(); //obj 的 isa 指针\n    else return Nil;\n}\n```\n\nobject_getClass 的参数是 instance 对象/ class 对象/ meta-class 对象。object_getClass 返回的是 obj 的 isa 指针。  \n如果 obj 是 instance 对象则返回 class 对象。  \n如果 obj 是 class 对象则返回 meta-class 对象。  \n如果 obj 是 meta-class 对象则返回 NSObject（基类） 的 meta-class 对象。\n\n## objc_getClass\n打开 Runtime 源码，找到 runtime.mm，搜索 objc_getClass：\n```\nClass objc_getClass(const char *aClassName)\n{\n    if (!aClassName) return Nil;\n\n    // NO unconnected, YES class handler\n    return look_up_class(aClassName, NO, YES);\n}\n```\n\n上面👆的代码里可以确认 objc_getClass 的参数是一个类名。\n\nJump To Definition -> look_up_class：\n```\nClass \nlook_up_class(const char *name, \n              bool includeUnconnected __attribute__((unused)), \n              bool includeClassHandler __attribute__((unused)))\n{\n    if (!name) return nil;\n\n    Class result;\n    bool unrealized;\n    {\n        runtimeLock.lock();\n        result = getClassExceptSomeSwift(name);\n        unrealized = result  &&  !result->isRealized();\n        if (unrealized) {\n            result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock);\n            // runtimeLock is now unlocked\n        } else {\n            runtimeLock.unlock();\n        }\n    }\n\n    if (!result) {\n        // Ask Swift about its un-instantiated classes.\n\n        // We use thread-local storage to prevent infinite recursion\n        // if the hook function provokes another lookup of the same name\n        // (for example, if the hook calls objc_allocateClassPair)\n\n        auto *tls = _objc_fetch_pthread_data(true);\n\n        // Stop if this thread is already looking up this name.\n        for (unsigned i = 0; i < tls->classNameLookupsUsed; i++) {\n            if (0 == strcmp(name, tls->classNameLookups[i])) {\n                return nil;\n            }\n        }\n\n        // Save this lookup in tls.\n        if (tls->classNameLookupsUsed == tls->classNameLookupsAllocated) {\n            tls->classNameLookupsAllocated =\n                (tls->classNameLookupsAllocated * 2 ?: 1);\n            size_t size = tls->classNameLookupsAllocated *\n                sizeof(tls->classNameLookups[0]);\n            tls->classNameLookups = (const char **)\n                realloc(tls->classNameLookups, size);\n        }\n        tls->classNameLookups[tls->classNameLookupsUsed++] = name;\n\n        // Call the hook.\n        Class swiftcls = nil;\n        if (GetClassHook.get()(name, &swiftcls)) {\n            ASSERT(swiftcls->isRealized());\n            result = swiftcls;\n        }\n\n        // Erase the name from tls.\n        unsigned slot = --tls->classNameLookupsUsed;\n        ASSERT(slot >= 0  &&  slot < tls->classNameLookupsAllocated);\n        ASSERT(name == tls->classNameLookups[slot]);\n        tls->classNameLookups[slot] = nil;\n    }\n\n    return result;\n}\n```\nJump To Definition -> getClassExceptSomeSwift：\n```\nstatic Class getClassExceptSomeSwift(const char *name)\n{\n    runtimeLock.assertLocked();\n\n    // Try name as-is\n    Class result = getClass_impl(name);\n    if (result) return result;\n\n    // Try Swift-mangled equivalent of the given name.\n    if (char *swName = copySwiftV1MangledName(name)) {\n        result = getClass_impl(swName);\n        free(swName);\n        return result;\n    }\n\n    return nil;\n}\n```\n\nJump To Definition -> getClass_impl：\n```\nstatic Class getClass_impl(const char *name)\n{\n    runtimeLock.assertLocked();\n\n    // allocated in _read_images\n    ASSERT(gdb_objc_realized_classes);\n\n    // Try runtime-allocated table\n    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);\n    if (result) return result;\n\n    // Try table from dyld shared cache.\n    // Note we do this last to handle the case where we dlopen'ed a shared cache\n    // dylib with duplicates of classes already present in the main executable.\n    // In that case, we put the class from the main executable in\n    // gdb_objc_realized_classes and want to check that before considering any\n    // newly loaded shared cache binaries.\n    return getPreoptimizedClass(name);\n}\n```\n\nJump To Definition -> NXMapGet：\n```\nvoid *NXMapGet(NXMapTable *table, const void *key) {\n    void\t*value;\n    return (_NXMapMember(table, key, &value) != NX_MAPNOTAKEY) ? value : NULL;\n}\n```\n\nNXMapGet 根据传进来的类名返回了一个类对象。  \nClass objc_getClass(const char *aClassName) ：字符串类名 -> 对应的类对象","source":"_posts/OC底层原理/OC对象的分类.md","raw":"---\ntitle: OC对象的分类\ndate: 2020-05-09 16:37:02\ntags: OC底层原理\n---\n\nObjective-C 中的对象主要可以分为3种：  \n* instance对象（实例对象）\n* class对象（类对象）\n* meta-class对象（元类对象）  \n\n<!-- more -->\n\n# instance 对象\ninstance 对象就是通过类 alloc 出来的对象，每次调用 alloc 都会产生新的 instance 对象。\n```\nNSObject *object1 = [[NSObject alloc] init];\nNSObject *object2 = [[NSObject alloc] init];\n```\n\nobject1、object2 是 NSObject 的 instance 对象，它们是不同的两个对象，分别占据着两块不同的内存。\n\n## instance 对象在内存中存储的信息\n\n* isa指针\n* 其他成员变量\n\n定义 Person\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation Person\n@end\n```\n\n创建 Person 的实例对象\n```\nPerson *p1 = [[Person alloc] init];\nPerson *p2 = [[Person alloc] init];\n```\n\np1、p2 对象在内存中存储的信息\n![OC对象的分类](OC对象的分类/OC对象的分类01.png)\n\n\n# class 对象\n每个类在内存中有且只有一个 class 对象，同一个类 alloc 出来的实例对象共同拥有唯一的 class 对象。\n\n获取 class 对象：\n```\nClass objectClass1 = [object1 class];\nClass objectClass2 = [object2 class];\nClass objectClass3 = object_getClass(object1);\nClass objectClass4 = object_getClass(object2);\nClass objectClass5 = [NSObject class];\n```\n\nobjectClass1 ~ objectClass5 都是 NSObject 的 class 对象，它们是同一个对象。\n\n👉 注意：\n下面这行代码获取的 objectClass 是 class 对象，并不是 meta-class 对象，-(void)Class 和 +(void)Class 返回的是类对象。\n```\nClass objectClass = [[NSObject class] class];\n```\n\n## class 对象在内存中存储的信息主要包括\n* isa 指针\n* superclass 指针\n* 类的属性信息（@property）、类的对象方法信息（instance method）\n* 类的协议信息（protocol）、类的成员变量信息（ivar）  \n......  \n\n![OC对象的分类](OC对象的分类/OC对象的分类02.png)\n\n不同的 instance 对象却拥有相同的属性、对象方法、协议和成员变量等等，这些信息都存放在 class 对象的内存中，保证了同样的信息只存储一份。\n\n# meta-class 对象\n\n每个类在内存中有且只有一个 meta-class 对象。通过 object_getClass 方法，将类对象当做参数传入，获得元类对象：\n```\nClass objectMetaClass = object_getClass(objectClass5);\n```\n\n## meta-class 对象在内存中存储的信息主要包括\n* isa 指针\n* superclass 指针\n* 类的类方法信息（class method）  \n......\n\n![OC对象的分类](OC对象的分类/OC对象的分类03.png)\n\n通过 class_isMetaClass 方法查看 objecClass 是否为 meta-class：\n```\n#import <objc/runtime.h>\n\nBOOL result = class_isMetaClass(objecClass)\n```\n\n# 窥视 objc_getClass()、object_getClass()\n\n## object_getClass\n打开 Runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，找到 objc-class.mm，搜索 object_getClass：\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa(); //obj 的 isa 指针\n    else return Nil;\n}\n```\n\nobject_getClass 的参数是 instance 对象/ class 对象/ meta-class 对象。object_getClass 返回的是 obj 的 isa 指针。  \n如果 obj 是 instance 对象则返回 class 对象。  \n如果 obj 是 class 对象则返回 meta-class 对象。  \n如果 obj 是 meta-class 对象则返回 NSObject（基类） 的 meta-class 对象。\n\n## objc_getClass\n打开 Runtime 源码，找到 runtime.mm，搜索 objc_getClass：\n```\nClass objc_getClass(const char *aClassName)\n{\n    if (!aClassName) return Nil;\n\n    // NO unconnected, YES class handler\n    return look_up_class(aClassName, NO, YES);\n}\n```\n\n上面👆的代码里可以确认 objc_getClass 的参数是一个类名。\n\nJump To Definition -> look_up_class：\n```\nClass \nlook_up_class(const char *name, \n              bool includeUnconnected __attribute__((unused)), \n              bool includeClassHandler __attribute__((unused)))\n{\n    if (!name) return nil;\n\n    Class result;\n    bool unrealized;\n    {\n        runtimeLock.lock();\n        result = getClassExceptSomeSwift(name);\n        unrealized = result  &&  !result->isRealized();\n        if (unrealized) {\n            result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock);\n            // runtimeLock is now unlocked\n        } else {\n            runtimeLock.unlock();\n        }\n    }\n\n    if (!result) {\n        // Ask Swift about its un-instantiated classes.\n\n        // We use thread-local storage to prevent infinite recursion\n        // if the hook function provokes another lookup of the same name\n        // (for example, if the hook calls objc_allocateClassPair)\n\n        auto *tls = _objc_fetch_pthread_data(true);\n\n        // Stop if this thread is already looking up this name.\n        for (unsigned i = 0; i < tls->classNameLookupsUsed; i++) {\n            if (0 == strcmp(name, tls->classNameLookups[i])) {\n                return nil;\n            }\n        }\n\n        // Save this lookup in tls.\n        if (tls->classNameLookupsUsed == tls->classNameLookupsAllocated) {\n            tls->classNameLookupsAllocated =\n                (tls->classNameLookupsAllocated * 2 ?: 1);\n            size_t size = tls->classNameLookupsAllocated *\n                sizeof(tls->classNameLookups[0]);\n            tls->classNameLookups = (const char **)\n                realloc(tls->classNameLookups, size);\n        }\n        tls->classNameLookups[tls->classNameLookupsUsed++] = name;\n\n        // Call the hook.\n        Class swiftcls = nil;\n        if (GetClassHook.get()(name, &swiftcls)) {\n            ASSERT(swiftcls->isRealized());\n            result = swiftcls;\n        }\n\n        // Erase the name from tls.\n        unsigned slot = --tls->classNameLookupsUsed;\n        ASSERT(slot >= 0  &&  slot < tls->classNameLookupsAllocated);\n        ASSERT(name == tls->classNameLookups[slot]);\n        tls->classNameLookups[slot] = nil;\n    }\n\n    return result;\n}\n```\nJump To Definition -> getClassExceptSomeSwift：\n```\nstatic Class getClassExceptSomeSwift(const char *name)\n{\n    runtimeLock.assertLocked();\n\n    // Try name as-is\n    Class result = getClass_impl(name);\n    if (result) return result;\n\n    // Try Swift-mangled equivalent of the given name.\n    if (char *swName = copySwiftV1MangledName(name)) {\n        result = getClass_impl(swName);\n        free(swName);\n        return result;\n    }\n\n    return nil;\n}\n```\n\nJump To Definition -> getClass_impl：\n```\nstatic Class getClass_impl(const char *name)\n{\n    runtimeLock.assertLocked();\n\n    // allocated in _read_images\n    ASSERT(gdb_objc_realized_classes);\n\n    // Try runtime-allocated table\n    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);\n    if (result) return result;\n\n    // Try table from dyld shared cache.\n    // Note we do this last to handle the case where we dlopen'ed a shared cache\n    // dylib with duplicates of classes already present in the main executable.\n    // In that case, we put the class from the main executable in\n    // gdb_objc_realized_classes and want to check that before considering any\n    // newly loaded shared cache binaries.\n    return getPreoptimizedClass(name);\n}\n```\n\nJump To Definition -> NXMapGet：\n```\nvoid *NXMapGet(NXMapTable *table, const void *key) {\n    void\t*value;\n    return (_NXMapMember(table, key, &value) != NX_MAPNOTAKEY) ? value : NULL;\n}\n```\n\nNXMapGet 根据传进来的类名返回了一个类对象。  \nClass objc_getClass(const char *aClassName) ：字符串类名 -> 对应的类对象","slug":"OC底层原理/OC对象的分类","published":1,"updated":"2023-08-22T09:52:13.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrs000caq7kox2zw1da"},{"title":"KVO","date":"2020-05-13T06:59:58.000Z","_content":"\n思考：\n* iOS 用什么方式实现对一个对象的 KVO？(KVO的本质是什么？)  \n* 如何手动触发 KVO ？  \n* 直接修改成员变量会触发 KVO 么？  \n* 通过 KVC 修改属性会触发 KVO 么？ \n* KVC 的赋值和取值过程是怎样的？原理是什么？  \n\n<!-- more -->\n\n# KVO 监听\n\nKVO 的全称是 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。\n![isa和superclass](KVO/KVO01.png)\n\n定义 Person、Observer\n```\n@interface Person : NSObject\n@property (assign, nonatomic) int age;\n@end\n\n@implementation Person\n- (void)setAge:(int)age\n{\n    _age = age;\n    NSLog(@\"setAge: - %d\", age);\n}\n@end\n\n@interface Observer : NSObject\n@end\n\n@implementation Observer\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\n{\n    NSLog(@\"observeValueForKeyPath - %@\", change);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Observer *observer = [[Observer alloc] init];\n        Person *person1 = [[Person alloc] init];\n        Person *person2 = [[Person alloc] init];\n        \n        [person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n        \n        [person1 setAge:10];\n        [person2 setAge:20];\n\n        [person1 removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nobserveValueForKeyPath - {\n    kind = 1;\n    new = 10;\n    old = 0;\n}\n```\n\nperson2 和 person1 拥有同一个类对象，修改属性 age 时调用的是同一个类对象里的对象方法 `-(void)setAge`。\n\n## 未使用 KVO 监听的对象\n\n* 思考：person2 修改 age 时为什么在 Observer 里没有打印？  \n\n因为 person2 没有使用 KVO 监听，修改属性 age 时调用的是 Person 类对象里的对象方法 `-(void)setAge`，所以在 Observer 里没有打印。\n\n![isa和superclass](KVO/KVO02.png)\n\n## 使用了 KVO 监听的对象\n\n打印 person1、person2 类对象：\n```\nNSLog(@\"person1添加KVO之前 - %@\", object_getClass(person1));\nNSLog(@\"person1添加KVO之前 - %@\", object_getClass(person2));\n\n[person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n        \nNSLog(@\"person1添加KVO之后 - %@\", object_getClass(person1));\nNSLog(@\"person1添加KVO之后 - %@\", object_getClass(person2));\n```\n\n打印结果：\n```\nperson1添加KVO之前 - Person\nperson1添加KVO之前 - Person\nperson1添加KVO之后 - NSKVONotifying_Person\nperson1添加KVO之后 - Person\n```\n\n从打印结果看出，因为 person1 使用了 KVO 监听，所以系统通过 runtime 生成了一个NSKVONotifying_Person 对象，所以 person1 修改属性 age 时调用的是 生成了一个NSKVONotifying_Person 类对象里的对象方法 `-(void)setAge`。  \n\n### NSKVONotifying_Person 类对象\n\n![isa和superclass](KVO/KVO03.png)\n\n打印对象方法 `-(void)setAge` 的地址：\n```\nNSLog(@\"person1添加KVO之前 - %p %p\", [person methodForSelector:@selector(setAge:)], [person1 methodForSelector:@selector(setAge:)]);\n\n[person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\nNSLog(@\"person1添加KVO之后 - %p %p\", [person methodForSelector:@selector(setAge:)], [person1 methodForSelector:@selector(setAge:)]);\n```\n\n打印结果：\n```\nperson1添加KVO之前 - 0x100001cf0 0x100001cf0\nperson1添加KVO之后 - 0x7fff304afa0b 0x100001cf0\n```\n从打印结果看出，person1 添加 KVO 监听前后，对象方法 `-(void)setAge` 的地址变了。\n\n打印地址对应的方法名：\n```\n(lldb) p (IMP)0x100001cf0\n(IMP) $0 = 0x0000000100001cf0 (Interview01-KVC`-[Person setAge:] at Person.h:16)\n(lldb) p (IMP)0x7fff304afa0b\n(IMP) $1 = 0x00007fff304afa0b (Foundation`_NSSetIntValueAndNotify)\n```\n\n从打印结果看出，person1 添加 KVO 监听后，修改 age 时调用的是 Foundation 框架里的  _NSSetIntValueAndNotify 方法。\n\n### _NSSetIntValueAndNotify 方法\n_NSSetIntValueAndNotify 方法实现猜想：\n```\n- (void)setAge:(int)age {\n    _NSSetIntValueAndNotify();\n}\n\nvoid _NSSetIntValueAndNotify \n{\n    [self willChangeValueForKey:@\"age\"];\n    [super setAge:age];\n    [self didChagneValueForKey:@\"age\"];\n}\n\n- (void)didChagneValueForKey:(NSString *)key\n{\n    // 通知监听器，某属性值发生了改变\n    [observer observeValueForKeyPath:key ofObject:nil change:nil context:nil];\n}\n```\n\n查看 _NSSet*AndNotify 的存在：  \n![isa和superclass](KVO/KVO04.png)\n\n\n_NSSet*ValueAndNotify 的内部实现：\n```\nvoid _NSSet*ValueAndNotify \n{\n    [self willChangeValueForKey:@\"key\"];\n    // 原来的 setter 实现\n    [self didChagneValueForKey:@\"key\"];\n}\n```\n\n* 调用 `willChangeValueForKey:`  \n* 调用原来的 setter 实现  \n* 调用 `didChangeValueForKey:`，其内部会调用 observer 的 `observeValueForKeyPath:ofObject:change:context:` 方法\n\n\n### NSKVONotifying_Person 元类对象\n打印 person1 的元类对象：\n```\nNSLog(@\"person1添加KVO之后，类对象 - %@, %@\", object_getClass(person1), object_getClass(person2));\nNSLog(@\"person1添加KVO之后，元类对象 - %@, %@\", object_getClass(object_getClass(person1)), object_getClass(object_getClass(person2)));\n```\n\n打印结果：\n```\nperson1添加KVO之后，类对象 - NSKVONotifying_Person, Person\nperson1添加KVO之后，元类对象 - NSKVONotifying_Person, Person\n```\n\nNSKVONotifying_Person 类对象的 isa 指针指向的是 NSKVONotifying_Person 元类对象。\n\n\n### 修改成员变量的值是否会触发 KVO\n```\n@interface MJPerson : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation MJPerson\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MJObserver *observer = [[MJObserver alloc] init];\n        MJPerson *person = [[MJPerson alloc] init];\n        \n        [person addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\n        person->_age = 10;\n\n        [person removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n运行后并没有出现打印。虽然 person 添加了 KVO 监听，但是修改 age 时并没有调用 `-(void)setAge` 方法。\n\n# KVC\nKVC 的全称是 Key-Value Coding，俗称“键值编码”，可以通过一个 key 来访问某个属性。常见的API有：\n```\n- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- (void)setValue:(id)value forKey:(NSString *)key;\n- (id)valueForKeyPath:(NSString *)keyPath;\n- (id)valueForKey:(NSString *)key; \n```\n\n## setValue: forKey: 原理\n![isa和superclass](KVO/KVO05.png)\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n@end\n\n@implementation Person\n- (void)setAge:(int)age\n{\n    NSLog(@\"setAge: - %d\", age);\n}\n\n- (void)_setAge:(int)age\n{\n    NSLog(@\"_setAge: - %d\", age);\n}\n\n+ (BOOL)accessInstanceVariablesDirectly\n{\n    return YES; //默认的返回值就是YES（YES表示可以访问成员变量）\n}\n@end\n```\n\n通过你 kvc 修改 age 的值：\n```\nPerson *person = [[Person alloc] init];\n[person setValue:@10 forKey:@\"age\"];\n```\n\n依次注释掉 `setAge:`、`_setAge:` 方法，可以发现 `setValue:forKey:` 会优先调用 `setAge:`，`setAge:` 不存在时会调用 `_setAge:` 方法。如果 `setAge:` 和 `_setAge:` 都不存在时，会调用 `+(BOOL)accessInstanceVariablesDirectly` 方法判断是否可以访问成员变量。\n\n打断点后，可以在控制台看到 _age、_isAge、age、isAge 被依次赋值：\n![isa和superclass](KVO/KVO07.png)\n\n## KVC 触发 KVO\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int age;\n}\n@end\n\n@implementation Person\n- (void)willChangeValueForKey:(NSString *)key\n{\n    [super willChangeValueForKey:key];\n    NSLog(@\"willChangeValueForKey - %@\", key);\n}\n\n- (void)didChangeValueForKey:(NSString *)key\n{\n    NSLog(@\"didChangeValueForKey - begin - %@\", key);\n    [super didChangeValueForKey:key];\n    NSLog(@\"didChangeValueForKey - end - %@\", key);\n}\n\n+ (BOOL)accessInstanceVariablesDirectly\n{\n    return YES; //默认的返回值就是YES（YES表示可以访问成员变量）\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MJObserver *observer = [[MJObserver alloc] init];\n        MJPerson *person = [[MJPerson alloc] init];\n        \n        [person addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\n        [person setValue:@10 forKey:@\"age\"];\n\n        [person removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nwillChangeValueForKey - age\ndidChangeValueForKey - begin - age\nobserveValueForKeyPath - {\n    kind = 1;\n    new = 10;\n    old = 0;\n}\ndidChangeValueForKey - end - age\n```\n\n### setKey 和 _setKey 存在\n添加 KVO 监听时会调用一次 `+(BOOL)accessInstanceVariablesDirectly`， 调用 `setValue:forKey:` 时会调用一次 `+(BOOL)accessInstanceVariablesDirectly`，再去调用 `willChangeValueForKey` 和 `didChangeValueForKey`。 \n\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_05.png)\nsetValue:forKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_06.png)\n\n### setKey 和 _setKey 不存在\n添加 KVO 监听时会调用两次 `+ (BOOL)accessInstanceVariablesDirectly`， 调用 `setValue:forKey:` 时会调用两次 `+ (BOOL)accessInstanceVariablesDirectly`，再去调用 `willChangeValueForKey` 和 `didChangeValueForKey`。 \n\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_01.png)\n添加 KVO 监听第二次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_02.png)\nsetValue:forKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_03.png)\nsetValue:forKey: 第二次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_04.png)\n\n## valueForKey: 原理\n![isa和superclass](KVO/KVO06.png)\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n@end\n\n@implementation Person\n- (int)getAge\n{\n    return 11;\n}\n\n- (int)age\n{\n    return 12;\n}\n\n- (int)isAge\n{\n    return 13;\n}\n\n- (int)_age\n{\n    return 14;\n}\n@end\n```\n\n依次注释掉 `- (int)getAge`、`- (int)age`、`- (int)isAge`、`- (int)_age` 方法，从打印结果可以发现，`setValue:forKey:` 方法会优先调用 `- (void)setAge:(int)age`，`- (void)setAge:(int)age` 不存在时会调用 `- (void)_setAge:(int)age` 方法，以此类推。\n\n### setKey 和 _setKey 存在\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_07.png)\n\n### setKey 和 _setKey 不存在\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_08.png)\nvalueForKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_09.png)\n\n\n# 总结\n* iOS 用什么方式实现对一个对象的 KVO？(KVO的本质是什么？)  \n利用 RuntimeAPI 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类。  \n当修改 instance 对象的属性时，会调用 Foundation 的 _NSSetXXXValueAndNotify 函数：  \n```\nwillChangeValueForKey:\n父类原来的setter\ndidChangeValueForKey:\n```\n\ndidChangeValueForKey: 内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）\n\n* 如何手动触发 KVO ？  \n手动调用 willChangeValueForKey: 和 didChangeValueForKey:  \n```\nwillChangeValueForKey:\nperson->age = 10;\ndidChangeValueForKey:\n```\n\n* 直接修改成员变量会触发 KVO 么？  \n不会触发，修改 age 时并没有调用 -(void)setAge 方法。\n\n* 通过 KVC 修改属性会触发 KVO 么？  \n会触发KVO。通过KVC修改属性会调用 willChangeValueForKey: 和 didChangeValueForKey: 方法，而 didChangeValueForKey: 方法内部会触发 KVO 监听。  \n\n* KVC 的赋值和取值过程是怎样的？原理是什么？  \n赋值：`setValue:forKey:` 会按照 `setKey:`/`_setKey:` 顺序查找方法，如果方法存在，直接调用方法赋值。如果方法不存在，会调用 `accessInstanceVariablesDirectly` 方法，判断是否可以访问成员变量。如果可以，会按照 `_key`/`_isKey`/`key`/`isKsy` 顺序查找成员变量，找到后赋值。如果不可以访问成员变量，或者成员变量不存在，就会调用 `setValue:forUndefinedKey:` 并抛出异常 NSUnknownKeyException。  \n  \n  取值：`valueForKey:` 会按照 `getKey`/`key`/`isKey`/`_key` 顺序查找方法，如果方法存在，直接调用方法取值。如果方法不存在，会调用 `accessInstanceVariablesDirectly` 方法，判断是否可以访问成员变量。会按照 `_key`/`_isKey`/`key`/`isKsy` 顺序查找成员变量，找到成员变量后取值。如果不可以访问成员变量，或者成员变量不存在，就会调用 `valueForUndefinedKey:` 并抛出异常 NSUnknownKeyException。  \n","source":"_posts/OC底层原理/KVO.md","raw":"---\ntitle: KVO\ndate: 2020-05-13 14:59:58\ntags: OC底层原理\n---\n\n思考：\n* iOS 用什么方式实现对一个对象的 KVO？(KVO的本质是什么？)  \n* 如何手动触发 KVO ？  \n* 直接修改成员变量会触发 KVO 么？  \n* 通过 KVC 修改属性会触发 KVO 么？ \n* KVC 的赋值和取值过程是怎样的？原理是什么？  \n\n<!-- more -->\n\n# KVO 监听\n\nKVO 的全称是 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。\n![isa和superclass](KVO/KVO01.png)\n\n定义 Person、Observer\n```\n@interface Person : NSObject\n@property (assign, nonatomic) int age;\n@end\n\n@implementation Person\n- (void)setAge:(int)age\n{\n    _age = age;\n    NSLog(@\"setAge: - %d\", age);\n}\n@end\n\n@interface Observer : NSObject\n@end\n\n@implementation Observer\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\n{\n    NSLog(@\"observeValueForKeyPath - %@\", change);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Observer *observer = [[Observer alloc] init];\n        Person *person1 = [[Person alloc] init];\n        Person *person2 = [[Person alloc] init];\n        \n        [person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n        \n        [person1 setAge:10];\n        [person2 setAge:20];\n\n        [person1 removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nobserveValueForKeyPath - {\n    kind = 1;\n    new = 10;\n    old = 0;\n}\n```\n\nperson2 和 person1 拥有同一个类对象，修改属性 age 时调用的是同一个类对象里的对象方法 `-(void)setAge`。\n\n## 未使用 KVO 监听的对象\n\n* 思考：person2 修改 age 时为什么在 Observer 里没有打印？  \n\n因为 person2 没有使用 KVO 监听，修改属性 age 时调用的是 Person 类对象里的对象方法 `-(void)setAge`，所以在 Observer 里没有打印。\n\n![isa和superclass](KVO/KVO02.png)\n\n## 使用了 KVO 监听的对象\n\n打印 person1、person2 类对象：\n```\nNSLog(@\"person1添加KVO之前 - %@\", object_getClass(person1));\nNSLog(@\"person1添加KVO之前 - %@\", object_getClass(person2));\n\n[person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n        \nNSLog(@\"person1添加KVO之后 - %@\", object_getClass(person1));\nNSLog(@\"person1添加KVO之后 - %@\", object_getClass(person2));\n```\n\n打印结果：\n```\nperson1添加KVO之前 - Person\nperson1添加KVO之前 - Person\nperson1添加KVO之后 - NSKVONotifying_Person\nperson1添加KVO之后 - Person\n```\n\n从打印结果看出，因为 person1 使用了 KVO 监听，所以系统通过 runtime 生成了一个NSKVONotifying_Person 对象，所以 person1 修改属性 age 时调用的是 生成了一个NSKVONotifying_Person 类对象里的对象方法 `-(void)setAge`。  \n\n### NSKVONotifying_Person 类对象\n\n![isa和superclass](KVO/KVO03.png)\n\n打印对象方法 `-(void)setAge` 的地址：\n```\nNSLog(@\"person1添加KVO之前 - %p %p\", [person methodForSelector:@selector(setAge:)], [person1 methodForSelector:@selector(setAge:)]);\n\n[person1 addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\nNSLog(@\"person1添加KVO之后 - %p %p\", [person methodForSelector:@selector(setAge:)], [person1 methodForSelector:@selector(setAge:)]);\n```\n\n打印结果：\n```\nperson1添加KVO之前 - 0x100001cf0 0x100001cf0\nperson1添加KVO之后 - 0x7fff304afa0b 0x100001cf0\n```\n从打印结果看出，person1 添加 KVO 监听前后，对象方法 `-(void)setAge` 的地址变了。\n\n打印地址对应的方法名：\n```\n(lldb) p (IMP)0x100001cf0\n(IMP) $0 = 0x0000000100001cf0 (Interview01-KVC`-[Person setAge:] at Person.h:16)\n(lldb) p (IMP)0x7fff304afa0b\n(IMP) $1 = 0x00007fff304afa0b (Foundation`_NSSetIntValueAndNotify)\n```\n\n从打印结果看出，person1 添加 KVO 监听后，修改 age 时调用的是 Foundation 框架里的  _NSSetIntValueAndNotify 方法。\n\n### _NSSetIntValueAndNotify 方法\n_NSSetIntValueAndNotify 方法实现猜想：\n```\n- (void)setAge:(int)age {\n    _NSSetIntValueAndNotify();\n}\n\nvoid _NSSetIntValueAndNotify \n{\n    [self willChangeValueForKey:@\"age\"];\n    [super setAge:age];\n    [self didChagneValueForKey:@\"age\"];\n}\n\n- (void)didChagneValueForKey:(NSString *)key\n{\n    // 通知监听器，某属性值发生了改变\n    [observer observeValueForKeyPath:key ofObject:nil change:nil context:nil];\n}\n```\n\n查看 _NSSet*AndNotify 的存在：  \n![isa和superclass](KVO/KVO04.png)\n\n\n_NSSet*ValueAndNotify 的内部实现：\n```\nvoid _NSSet*ValueAndNotify \n{\n    [self willChangeValueForKey:@\"key\"];\n    // 原来的 setter 实现\n    [self didChagneValueForKey:@\"key\"];\n}\n```\n\n* 调用 `willChangeValueForKey:`  \n* 调用原来的 setter 实现  \n* 调用 `didChangeValueForKey:`，其内部会调用 observer 的 `observeValueForKeyPath:ofObject:change:context:` 方法\n\n\n### NSKVONotifying_Person 元类对象\n打印 person1 的元类对象：\n```\nNSLog(@\"person1添加KVO之后，类对象 - %@, %@\", object_getClass(person1), object_getClass(person2));\nNSLog(@\"person1添加KVO之后，元类对象 - %@, %@\", object_getClass(object_getClass(person1)), object_getClass(object_getClass(person2)));\n```\n\n打印结果：\n```\nperson1添加KVO之后，类对象 - NSKVONotifying_Person, Person\nperson1添加KVO之后，元类对象 - NSKVONotifying_Person, Person\n```\n\nNSKVONotifying_Person 类对象的 isa 指针指向的是 NSKVONotifying_Person 元类对象。\n\n\n### 修改成员变量的值是否会触发 KVO\n```\n@interface MJPerson : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation MJPerson\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MJObserver *observer = [[MJObserver alloc] init];\n        MJPerson *person = [[MJPerson alloc] init];\n        \n        [person addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\n        person->_age = 10;\n\n        [person removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n运行后并没有出现打印。虽然 person 添加了 KVO 监听，但是修改 age 时并没有调用 `-(void)setAge` 方法。\n\n# KVC\nKVC 的全称是 Key-Value Coding，俗称“键值编码”，可以通过一个 key 来访问某个属性。常见的API有：\n```\n- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- (void)setValue:(id)value forKey:(NSString *)key;\n- (id)valueForKeyPath:(NSString *)keyPath;\n- (id)valueForKey:(NSString *)key; \n```\n\n## setValue: forKey: 原理\n![isa和superclass](KVO/KVO05.png)\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n@end\n\n@implementation Person\n- (void)setAge:(int)age\n{\n    NSLog(@\"setAge: - %d\", age);\n}\n\n- (void)_setAge:(int)age\n{\n    NSLog(@\"_setAge: - %d\", age);\n}\n\n+ (BOOL)accessInstanceVariablesDirectly\n{\n    return YES; //默认的返回值就是YES（YES表示可以访问成员变量）\n}\n@end\n```\n\n通过你 kvc 修改 age 的值：\n```\nPerson *person = [[Person alloc] init];\n[person setValue:@10 forKey:@\"age\"];\n```\n\n依次注释掉 `setAge:`、`_setAge:` 方法，可以发现 `setValue:forKey:` 会优先调用 `setAge:`，`setAge:` 不存在时会调用 `_setAge:` 方法。如果 `setAge:` 和 `_setAge:` 都不存在时，会调用 `+(BOOL)accessInstanceVariablesDirectly` 方法判断是否可以访问成员变量。\n\n打断点后，可以在控制台看到 _age、_isAge、age、isAge 被依次赋值：\n![isa和superclass](KVO/KVO07.png)\n\n## KVC 触发 KVO\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int age;\n}\n@end\n\n@implementation Person\n- (void)willChangeValueForKey:(NSString *)key\n{\n    [super willChangeValueForKey:key];\n    NSLog(@\"willChangeValueForKey - %@\", key);\n}\n\n- (void)didChangeValueForKey:(NSString *)key\n{\n    NSLog(@\"didChangeValueForKey - begin - %@\", key);\n    [super didChangeValueForKey:key];\n    NSLog(@\"didChangeValueForKey - end - %@\", key);\n}\n\n+ (BOOL)accessInstanceVariablesDirectly\n{\n    return YES; //默认的返回值就是YES（YES表示可以访问成员变量）\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MJObserver *observer = [[MJObserver alloc] init];\n        MJPerson *person = [[MJPerson alloc] init];\n        \n        [person addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\n        [person setValue:@10 forKey:@\"age\"];\n\n        [person removeObserver:observer forKeyPath:@\"age\"];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nwillChangeValueForKey - age\ndidChangeValueForKey - begin - age\nobserveValueForKeyPath - {\n    kind = 1;\n    new = 10;\n    old = 0;\n}\ndidChangeValueForKey - end - age\n```\n\n### setKey 和 _setKey 存在\n添加 KVO 监听时会调用一次 `+(BOOL)accessInstanceVariablesDirectly`， 调用 `setValue:forKey:` 时会调用一次 `+(BOOL)accessInstanceVariablesDirectly`，再去调用 `willChangeValueForKey` 和 `didChangeValueForKey`。 \n\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_05.png)\nsetValue:forKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_06.png)\n\n### setKey 和 _setKey 不存在\n添加 KVO 监听时会调用两次 `+ (BOOL)accessInstanceVariablesDirectly`， 调用 `setValue:forKey:` 时会调用两次 `+ (BOOL)accessInstanceVariablesDirectly`，再去调用 `willChangeValueForKey` 和 `didChangeValueForKey`。 \n\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_01.png)\n添加 KVO 监听第二次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_02.png)\nsetValue:forKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_03.png)\nsetValue:forKey: 第二次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_04.png)\n\n## valueForKey: 原理\n![isa和superclass](KVO/KVO06.png)\n\n定义 Person：\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n@end\n\n@implementation Person\n- (int)getAge\n{\n    return 11;\n}\n\n- (int)age\n{\n    return 12;\n}\n\n- (int)isAge\n{\n    return 13;\n}\n\n- (int)_age\n{\n    return 14;\n}\n@end\n```\n\n依次注释掉 `- (int)getAge`、`- (int)age`、`- (int)isAge`、`- (int)_age` 方法，从打印结果可以发现，`setValue:forKey:` 方法会优先调用 `- (void)setAge:(int)age`，`- (void)setAge:(int)age` 不存在时会调用 `- (void)_setAge:(int)age` 方法，以此类推。\n\n### setKey 和 _setKey 存在\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_07.png)\n\n### setKey 和 _setKey 不存在\n添加 KVO 监听第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_08.png)\nvalueForKey: 第一次调用 accessInstanceVariablesDirectly 方法：\n![isa和superclass](KVO/accessInstanceVariablesDirectly_09.png)\n\n\n# 总结\n* iOS 用什么方式实现对一个对象的 KVO？(KVO的本质是什么？)  \n利用 RuntimeAPI 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类。  \n当修改 instance 对象的属性时，会调用 Foundation 的 _NSSetXXXValueAndNotify 函数：  \n```\nwillChangeValueForKey:\n父类原来的setter\ndidChangeValueForKey:\n```\n\ndidChangeValueForKey: 内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）\n\n* 如何手动触发 KVO ？  \n手动调用 willChangeValueForKey: 和 didChangeValueForKey:  \n```\nwillChangeValueForKey:\nperson->age = 10;\ndidChangeValueForKey:\n```\n\n* 直接修改成员变量会触发 KVO 么？  \n不会触发，修改 age 时并没有调用 -(void)setAge 方法。\n\n* 通过 KVC 修改属性会触发 KVO 么？  \n会触发KVO。通过KVC修改属性会调用 willChangeValueForKey: 和 didChangeValueForKey: 方法，而 didChangeValueForKey: 方法内部会触发 KVO 监听。  \n\n* KVC 的赋值和取值过程是怎样的？原理是什么？  \n赋值：`setValue:forKey:` 会按照 `setKey:`/`_setKey:` 顺序查找方法，如果方法存在，直接调用方法赋值。如果方法不存在，会调用 `accessInstanceVariablesDirectly` 方法，判断是否可以访问成员变量。如果可以，会按照 `_key`/`_isKey`/`key`/`isKsy` 顺序查找成员变量，找到后赋值。如果不可以访问成员变量，或者成员变量不存在，就会调用 `setValue:forUndefinedKey:` 并抛出异常 NSUnknownKeyException。  \n  \n  取值：`valueForKey:` 会按照 `getKey`/`key`/`isKey`/`_key` 顺序查找方法，如果方法存在，直接调用方法取值。如果方法不存在，会调用 `accessInstanceVariablesDirectly` 方法，判断是否可以访问成员变量。会按照 `_key`/`_isKey`/`key`/`isKsy` 顺序查找成员变量，找到成员变量后取值。如果不可以访问成员变量，或者成员变量不存在，就会调用 `valueForUndefinedKey:` 并抛出异常 NSUnknownKeyException。  \n","slug":"OC底层原理/KVO","published":1,"updated":"2023-08-22T09:52:13.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgrx000faq7k87bbdtin"},{"title":"Masonry","date":"2023-06-22T07:14:16.000Z","_content":"\n![01](Masonry/01.png)\n\n[Masonry](https://github.com/SnapKit/Masonry)\n\n<!-- more -->\n\n## 链式编程\n\n### 特点一\n\n* 链式编程可以通过点语法 `.` 调用函数。\n\n例如 Objective-C 中的 getter 方法：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  NSLog(@\"%@\", self.name);  // Prints \"zhangsan\"\n}\n\n- (NSString *)name {\n  return @\"zhangsan\";\n}\n```\n\n在 Objective-C 一般使用中括号 `[]` 的方式调用调用函数，但是也可以通过点语法 `.` 调用函数，但是编译器会提示警告：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  NSLog(@\"%@\", self.zhangsan);  // Prints \"zhangsan\"\n  self.lisi;  // Prints \"lisi\"\n  ViewController.wangwu;  // Prints \"wangwu\"\n}\n\n- (NSString *)zhangsan {\n  return @\"zhangsan\";\n}\n\n- (void)lisi {\n  NSLog(@\"lisi\");\n}\n\n+ (void)wangwu {\n  NSLog(@\"wangwu\");\n}\n```\n\n警告如下：\n\n![02](Masonry/02.png)\n\n### 特点二\n\n* 链式编程可以通过点语法 `.` **连续**调用函数。\n\n```swift\nself.lisi.wangwu\n```\n\n要想实现上面这段代码，可以参考链式编程**每个方法都有返回值**的特点。可以让函数执行完成后返回当前对象 `return self`，实现代码如下：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  self.lisi.wangwu;  // [[self lisi] wangwu]\n}\n\n- (ViewController *)lisi {\n  NSLog(@\"lisi\");\n  return self;\n}\n\n- (ViewController *)wangwu {\n  NSLog(@\"wangwu\");\n  return self;\n}\n\n@end\n```\n\n打印结果：\n\n```js\nlisi\nwangwu\n```\n\n上面这段代码，是参考 Objective-C 调用 getter 方法实现的，但是这种方式还比较局限。例如带有参数的函数调用：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [self lisi:@\"name1\"];\n}\n\n- (void)lisi:(NSString *)name {\n  NSLog(@\"%@: lisi\", name);\n}\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\n```\n\n函数往往是带有参数的，如果需要传入参数，该怎么用点语法`.`实现呢？\n\n这个时候 block 就该登场了：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  self.lisi(@\"name1\");\n}\n\n- (void(^)(NSString *name))lisi {\n  void(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: lisi\", name);\n  };\n  return block;\n}\n\n@end\n```\n\n通过 block 轻松实现了带有参数的 getter 方法，从而满足的点语法调用带参函数的要求。但是这样还不能满足**点语法连续调用**的特点，如连续调用两个或多个带参函数，该怎么实现呢？\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [[self lisi:@\"name1\"] wangwu:@\"name2\"];\n}\n\n- (ViewController *)lisi:(NSString *)name {\n  NSLog(@\"%@: lisi\", name);\n  return self;\n}\n\n- (ViewController *)wangwu:(NSString *)name {\n  NSLog(@\"%@: wangwu\", name);\n  return self;\n}\n\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\n```\n\n根据上面调用一个带参函数的实现，可以想到使用点语法连续调用带参函数的代码应该长这个样子：\n\n```swift\nself.lisi(@\"name1\").wangwu(@\"name2\")\n```\n\n这个时候带有**返回值**的 block 就该登场了：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  self.lisi(@\"name1\").wangwu(@\"name2\");\n}\n\n- (ViewController *(^)(NSString *name))lisi {\n  ViewController *(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: lisi\", name);\n    return self;\n  };\n  return block;\n}\n\n- (ViewController *(^)(NSString *name))wangwu {\n  ViewController *(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: wangwu\", name);\n    return self;\n  };\n  return block;\n}\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\n```\n\n实现细节：\n\n1. `self.lisi` 返回了一个类型为 `ViewController *(^)(NSString *name)` 的 block（参数类型：`NSString*`，返回值类型：`ViewController*`）；\n2. 通过括号 `()` 来实现 block 的调用，括号内是需要传递的参数，`self.lisi(@\"name1\")`；\n3. block 调用后返回了当前对象 `self`，从而实现了点语法`.`连续调用，`self.lisi(@\"name1\").wangwu(@\"name2\")`。\n\n### 特点三\n\n* 链式编程可以通过点语法 `.` **无限**连续调用函数。\n\n```swift\nself.lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\");\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\n```\n\n## Masonry简介\n\n来自 Masonry 说明文档里的示例：创建一个 view，它的上下左右四个边和父视图的四个边相距 10 的距离。\n\n![03](Masonry/03.png)\n\n方案一：使用 `NSLayoutConstraints` 布局的实现代码\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\nview1.translatesAutoresizingMaskIntoConstraints = NO;\nview1.backgroundColor = [UIColor greenColor];\n[superview addSubview:view1];\n\nUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n/**\n1. 添加约束组合\n2. 约束生效\n*/\n[superview addConstraints:@[\n   // 约束对象1：view1-top，view2-top，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeTop\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeTop\n                               multiplier:1.0\n                                 constant:padding.top],\n   // 约束对象2：view1-left，view2-left，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeLeft\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeLeft\n                               multiplier:1.0\n                                 constant:padding.left],\n   // 约束对象3：view1-bottom，view2-bottom，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeBottom\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeBottom\n                               multiplier:1.0\n                                 constant:-padding.bottom],\n   // 约束对象4：view1-right，view2-right，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeRight\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeRight\n                               multiplier:1\n                                 constant:-padding.right],\n\n]];\n```\n\n方案二：这是使用 Masonry 布局的实现代码\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\nview1.translatesAutoresizingMaskIntoConstraints = NO;\nview1.backgroundColor = [UIColor greenColor];\n[superview addSubview:view1];\n\nUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n/**\n1. 添加约束组合\n2. 约束生效\n*/\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top).with.offset(padding.top);\n   make.left.equalTo(superview.mas_left).with.offset(padding.left);\n   make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n   make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n```\n\n可以看得出 Masonry 作者通过举出这个例子想要表达的意思，用 Masonry 布局真的太方便了。\n\n## Autolayout\n\n### NSLayoutConstraint\n\n上面的例子添加了一个 view 到视图上，该 view 的四个边和 superview 的四个边设置边距为 10，而这每一个边的边距都对应着一个**约束对象**（`NSLayoutConstraint`）。\n\n如上边的约束对象的初始化方法：\n\n```swift\n// view1-top, view2-top, EQUAL\nNSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:view1\n                                                              attribute:NSLayoutAttributeTop\n                                                              relatedBy:NSLayoutRelationEqual\n                                                                 toItem:superview\n                                                              attribute:NSLayoutAttributeTop\n                                                             multiplier:1.0\n                                                               constant:padding.top],\n```\n\n从这段代码不难看出，约束是相对的，至少需要两个 view 才能创建出一个约束对象。可以总结出创建一个约束对象的条件：\n\n1. 第一个视图；\n2. 第一个视图的约束属性（约束方向：上/下/左/右等）；\n3. 第二个视图；\n4. 第二个视图的约束属性（约束方向：上/下/左/右等）；\n5. 约束关系（等于/大于/小于）；\n\n这五个条件是生成一个约束对象所必须的，也是一个约束对象所拥有的最基础的元素。这一点在 `NSLayoutConstraint.h` 文件中定义的属性也能看出来：\n\n```swift\n@interface NSLayoutConstraint : NSObject\n\n/// 第一个视图\n@property (nullable, readonly, assign) id firstItem;\n/// 第二个视图\n@property (nullable, readonly, assign) id secondItem;\n/// 第一个视图的约束属性\n@property (readonly) NSLayoutAttribute firstAttribute;\n/// 第二个视图的约束属性\n@property (readonly) NSLayoutAttribute secondAttribute;\n/// 约束关系\n@property (readonly) NSLayoutRelation relation;\n\n@end\n```\n\n### NSLayoutAttribute\n\n在 `NSLayoutConstraint.h` 文件中定义的属性中，可以看到两个约束属性 `firstAttribute` 和 `secondAttribute`，它们用来描述视图的那一个方向需要添加约束。`NSLayoutAttribute` 是一个枚举，定义了视图支持自动布局的各个位置。\n\n```swift\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    /*\n     * 视图位置\n     */\n    NSLayoutAttributeLeft = 1,\n    NSLayoutAttributeRight,\n    NSLayoutAttributeTop,\n    NSLayoutAttributeBottom,\n    /*\n     * 视图前后\n     */\n    NSLayoutAttributeLeading,\n    NSLayoutAttributeTrailing,\n    /*\n     * 视图宽高\n     */\n    NSLayoutAttributeWidth,\n    NSLayoutAttributeHeight,\n    /*\n     * 视图中心\n     */\n    NSLayoutAttributeCenterX,\n    NSLayoutAttributeCenterY,\n    /*\n     * 视图基线\n     */\n    NSLayoutAttributeLastBaseline,\n#if TARGET_OS_IPHONE\n    NSLayoutAttributeBaseline NS_SWIFT_UNAVAILABLE(\"Use 'lastBaseline' instead\") = NSLayoutAttributeLastBaseline,\n#else\n    NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline,\n#endif\n    NSLayoutAttributeFirstBaseline API_AVAILABLE(macos(10.11), ios(8.0)),\n\n#if TARGET_OS_IPHONE\n    /*\n     * 视图位置（带边距）\n     */\n    NSLayoutAttributeLeftMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeRightMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeTopMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeBottomMargin API_AVAILABLE(ios(8.0)),\n    /*\n     * 视图前后（带边距）\n     */\n    NSLayoutAttributeLeadingMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeTrailingMargin API_AVAILABLE(ios(8.0)),\n    /*\n     * 视图中心（带边距）\n     */\n    NSLayoutAttributeCenterXWithinMargins API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeCenterYWithinMargins API_AVAILABLE(ios(8.0)),\n#endif\n    // 占位符\n    NSLayoutAttributeNotAnAttribute = 0\n};\n```\n\n关于带 Margin 的枚举值：\n\n1. `NSLayoutAttributeLeft` 表示视图的最左边；\n2. `NSLayoutAttributeLeftMargin` 表示视图的左边，且与父视图的左边具有一个边距（margin），这个值通过 `layoutMargins` 进行修改。\n\n### NSLayoutRelation\n\n约束关系，在创建约束对象时，需要明确指出两个视图的约束关系。\n\n```swift\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    /// <=\n    NSLayoutRelationLessThanOrEqual = -1,\n    /// ==\n    NSLayoutRelationEqual = 0,\n    /// >=\n    NSLayoutRelationGreaterThanOrEqual = 1,\n};\n```\n\n## Masonry的UML\n\n![01](Masonry/01.png)\n\n图中从左至右把 Masonry 分为三块：\n\n1. `View+MASAdditions`，`UIView` 的延展，让 `UIView` 更方便的调用 Masonry 提供的属性和方法，这也是三方框架惯用的手段，为无访问权限的源代码扩展能力（逆向建模）；\n2. `MASConstraintMaker`，简称 Maker，是**创建约束**的工厂方法，即所有类都会以各种方式调用到这个类里，由它来完成创建约束的操作；\n3. `MASConstraint`，简称 Constant（约束），它是一个抽象父类，关联的子类有：`MASViewConstraint`（单个约束）、`MASCompositeConstraint`（约束结合），都被 Maker 创建。\n\n因为 Masonry 是采用链式编程的范式构建的，也是就是万物皆可点，一直点一直有（返回值），所以这三个模块包含使用点语法调用的属性或函数。\n\n### View+MASAdditions\n\n🤔思考：`UIView` 通过点语法会返回什么呢？\n\n对 `UIView` 的延展，主要是为了通过拓展的方式**放大接口**，给 `UIView` 增加新的属性和方法：\n\n1. 属性创造 `MASViewAttribute`，简称 Attribute，约束属性，它创建约束对象的条件之一；\n2. 方法创造 `MASConstraintMaker`，简称 Maker。\n\n```swift\n@interface MAS_VIEW (MASAdditions)\n\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;\n\n- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;\n\n@end\n```\n\n定义属性的目的，是想利用属性的 getter 方法，从而实现通过点语法调用函数的方式，创建约束属性。\n\n下面是属性的 getter 方法的具体实现，内部直接返回了一个初始化好的约束属性：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n- (MASViewAttribute *)mas_left {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASViewAttribute *)mas_top {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASViewAttribute *)mas_right {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASViewAttribute *)mas_bottom {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeBottom];\n}\n\n@end\n```\n\n对 `UIView` 的延展好处是，为 `UIView` 增加了 Masonry 自定义的属性和方法，从而使调用变的更加直接，就像是 `UIView` 原本就具有这些属性和方法一样：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  UIView *superview = self.view;\n  [superview addSubview:view1];\n\n  [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n      make.top.equalTo(superview.mas_top);\n  }];\n}\n```\n\n综上所述，`UIView` 通过点语法会创建出一个约束方向对象 `MASViewAttribute`。\n\n### MASViewAttribute\n\n* 这一部分关心的是 **Attribute**（约束属性），也就是约束方向。\n\n通过上面👆约束属性的初始化方法，不难看出一个 `MASViewAttribute` 类型的约束属性，至少包含两个东西：\n\n1. View：视图；\n2. Attribute：约束方向。\n\n```swift\nMASViewAttribute * attribute = [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n```\n\n从 `MASViewAttribute.h` 文件里也能看出这一点：\n\n```swift\n@interface MASViewAttribute : NSObject\n/// 约束视图\n@property (nonatomic, weak, readonly) id item;\n/// 约束属性\n@property (nonatomic, assign, readonly) NSLayoutAttribute layoutAttribute;\n@end\n```\n\n从定义可以看出 `MASViewAttribute` 将约束视图 View 和约束属性 Attribute 封装到了同一个类里，相对于 `NSLayoutAttribute` 枚举来说，`MASViewAttribute` 创建出来后是一个对象，拥有更多的信息，且更加的面向对象。这也正好弥补了 Objective-C 中枚举地位低的缺点。\n\n### MASConstraintMaker\n\n* 这一部分关心的是 **Constraint**（约束）的创建创建者 `MASConstraintMaker`，简称 Maker。\n\n🤔思考：约束创建者 Maker 通过点语法会返回什么呢？\n\n创建约束的工厂方法，负责约束对象的创建工作，即所有类都以代理的方式，调用到这个类里，由它来完成创建约束的操作。\n\n在 UIView 的延展部分提到了 Maker 的创建，通过调用 `mas_makeConstraints` 方法创建：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n@end\n```\n\n通过初始化代码，可以看出 Maker 首先持有了 view，成为了 view 专属的约束创造者，再通过 block 回调出去收集约束：\n\n```swift\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top);\n}];\n```\n\n关于 Maker 和 view 是一对一的关系，也可以从 Maker 的定义里看出来：\n\n```swift\n@interface MASConstraintMaker : NSObject\n\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n\n- (id)initWithView:(MAS_VIEW *)view;\n\n@end\n```\n\nMaker 将约束定义为属性，是想利用属性的 getter 方法，通过点语法的方式创建约束，如 `left` 属性的 getter 方法：\n\n```swift\n@implementation MASConstraintMaker\n\n- (id)initWithView:(MAS_VIEW *)view {\n    self = [super init];\n    if (!self) return nil;\n    \n    self.view = view;\n    self.constraints = NSMutableArray.new;\n    \n    return self;\n}\n\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASConstraint *)right {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASConstraint *)bottom {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeBottom];\n}\n\n@end\n```\n\n综上所述，约束创建者 Maker 通过点语法会创建出一个约束对象 `MASConstraint`。\n\n关于 Maker 的核心方法 `constraint:addConstraintWithLayoutAttribute:`，主要用来创建约束对象，下面以序号的方式演示代码的执行过程：\n\n1. 创建单个约束对象 `MASViewConstraint`；\n2. 创建约束集合 `MASCompositeConstraint`。\n\n```swift\n@implementation MASConstraintMaker\n\n- (void)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint {\n    NSUInteger index = [self.constraints indexOfObject:constraint];\n    NSAssert(index != NSNotFound, @\"Could not find constraint %@\", constraint);\n    [self.constraints replaceObjectAtIndex:index withObject:replacementConstraint];\n}\n\n/*\n 创建约束对象的入口，子类会通过代理调用该方法，创建新的约束对象\n*/\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    /*\n    创建约束属性 和 新的约束对象\n    */\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n     constraint 是 MASViewConstraint 类型会说明两件事：\n     1、constraint 不为空：newConstraint 不是视图的第一个约束对象；\n     2、constraint 不是 MASCompositeConstraint 类型：还没有创建过约束集合（一个视图只会创建一次）。\n\n     即需要创建一个约束集合\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        // 1、将第一个约束对象和第二个约束对象打包集合\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        // 2、设置代理，创建第三个约束对象及更多的约束对象时，重新来到这个方法\n        compositeConstraint.delegate = self;\n        // 3、让约束集合替换第一个约束对象（约束集合里已经保存了第一个约束对象）\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        /*\n        📢注意：这里返回的是 MASCompositeConstraint，和链式调用息息相关\n        */\n        return compositeConstraint;\n    }\n    /*\n    constraint 为空说明：\n    1、newConstraint 是视图的第一个约束对象\n    */\n    if (!constraint) {\n        // 设置代理，创建第二约束对象的时候，重新来到这个方法，创建约束集合👆\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    /*\n    📢注意：这里返回的是 MASViewConstraint，和链式调用息息相关\n    */\n    return newConstraint;\n}\n\n@end\n```\n\n### MASConstraint\n\n* 这一部分主要关心的是约束自身，简称 Constraint。\n\n🤔思考：约束是否也是可以点的，通过点语法可以创造出什么呢？\n\n这里的定义和约束创建者 Maker 类似，只不过这里没有写成属性（readonly）的方式，而是直接实现了 getter 方法。\n\n>猜想：这样写是因为用了面向对象的封装，属性是对象的特征。Maker 是可以拥有约束特征的，而约束自身不应该再拥有约束特征。如“人”可以有“左手”和“右手”，而“手”自身不再拥有这些特征。\n\n```swift\n@interface MASConstraint : NSObject\n\n- (MASConstraint *)left;\n- (MASConstraint *)top;\n- (MASConstraint *)right;\n- (MASConstraint *)bottom;\n\n@end\n```\n\ngetter 方法的实现部分 和 Maker 是完全一致的，毕竟想实现的功能是一样的。\n\n```swift\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n```\n\n`MASConstraint` 约束抽象类，与 Maker 一样可以通过点语法创建一个新的约束对象。`MASConstraint` 真正满足了链式编程要求，即**每个方都有返回值，返回值为对象自身**。又因为 `MASConstraint` 是 Maker 的属性，所以 Maker 也满足了链式编程。至此，Masonry 中可以实现链式编程的类有两个 `MASConstraint`（及其子类） 和 `MASConstraintMaker`。\n\n### MASViewConstraint\n\n`MASViewConstraint` 约束类，是 `MASConstraint` 的子类，Maker 生成的约束对象就是 `MASViewConstraint` 类型的。\n\n`MASViewConstraint` 对标的是 Autolayout 中的 `NSLayoutConstraint`，前边通过 `NSLayoutConstraint` 的定义看出它有 5 个基本条件：\n\n1. 第一个视图；\n2. 第一个视图的约束属性（约束方向：上/下/左/右等）；\n3. 第二个视图；\n4. 第二个视图的约束属性（约束方向：上/下/左/右等）；\n5. 约束关系（等于/大于/小于）；\n\n下面是 `MASViewConstraint` 的定义，可以看出，它只需要两个条件：\n\n```swift\n@interface MASViewConstraint : MASConstraint <NSCopying>\n\n@property (nonatomic, strong, readonly) MASViewAttribute *firstViewAttribute;\n\n@property (nonatomic, strong, readonly) MASViewAttribute *secondViewAttribute;\n\n@end\n```\n\n其实还有一个条件，约束关系，被定义子在了 `MASViewConstraint.m` 文件。综上所述，可以总结出创建一个 `MASViewConstraint` 对象的基本条件有三个：\n\n1. 第一个视图和第一个视图的约束属性；\n2. 第二个视图和第二个视图的约束属性；\n3. 约束关系。\n\n可以看的出，两者的条件内容本质是一样的，只不是实现方式不同而已。`MASViewConstraint` 使用面向对象的方式，把“视图”和“视图的约束属性”打包成元组的形式进行管理。\n\n🤔思考：把“视图”和“视图的约束属性”打包成元组的操作妙在哪？\n\n### MASCompositeConstraint\n\n`MASCompositeConstraint` 约束集合类，当一个 Maker 创建了一个以上的约束对象时，就会创建出约束集合来管理这些约束。\n\n```swift\n@interface MASCompositeConstraint : MASConstraint\n\n- (id)initWithChildren:(NSArray *)children;\n\n@end\n```\n\n## Masonry约束实现原理\n\n`UIView` 通过 `mas_makeConstraints` 方法为自己添加约束。\n\n### 案例一\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top);\n}];\n```\n\n`mas_makeConstraints` 的实现：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n@end\n```\n\n调用该方法做了四件事情：\n\n1. 设置不支持 AutoresizingMask；\n2. 初始化**专属**约束创造者 Maker；\n3. 收集约束；\n4. 添加约束（应用约束）。\n\n约束的收集过程：\n\n```swift\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top).with.offset(padding.top);\n}];\n```\n\n时序图\n\n![04](Masonry/04.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Constraint as MASViewConstraint\n        \n        View       ->>  + Addition   : \"mas_makeConstraints:\"\n        activate View\n\n        Addition   ->>  + Maker      : \"创建 Maker\"\n        Maker      -->> - Addition   : \"完成\"\n\n        Addition   ->>  + Maker      : \"添加“top”约束到约束数组 constraints 中（make.top）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition      ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition      : \"完成\"\n\n        Addition   ->>  + Maker      : \"引用约束（install）\"\n        Maker      -->> - Addition   : \"返回约束集合（constraints）\"\n        Addition   -->> - View       : \"返回约束集合（constraints）\"\n        deactivate View\n```\n\n第一步 `make.top`：Maker 创建 view 的 top 约束对象，核心方法 `constraint:addConstraintWithLayoutAttribute:`\n\n```swift\n@implementation MASConstraintMaker\n\n// 1.3\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    为约束设置代理：当约束通过点语法创建新的约束对象时，会通过代理再次来到这个方法进行创建约束\n    */\n    newConstraint.delegate = self;\n    /*\n    将新的约束放收集到数组里，等待应用到view上\n    */\n    [self.constraints addObject:newConstraint];\n    /*\n    📢注意：这里返回的是 MASViewConstraint 类型，和接下来 equal 的调用有关\n    */\n    return newConstraint;\n}\n\n// 1.2\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n// 1.1\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n@end\n```\n\n第一步执行完成后，生成了一个约束对象 `MASViewConstraint`，简称 Constraint，同时它已经有了第一个视图和它的约束属性（`NSLayoutAttributeTop`）。\n\n🤔思考：`make.top` 创建出来的 `top` 约束对象的类型一定是 `MASViewConstraint` 的吗?\n\n第二步 `make.top.equal`：设置依赖关系，首先来到约束抽象类 `MASConstraint` 里\n\n```swift\n@implementation MASConstraint\n\n- (MASConstraint * (^)(id))equalTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n\n@end\n```\n\n这一步有两个参数：\n\n1. attribute 约束属性（视图和视图的约束属性）;\n2. relation 约束关系（`NSLayoutRelationEqual`）。\n\n因为上面👆 `make.top` 返回的是 `MASViewConstraint` 类型，所以接下来会调用到子类 `MASViewConstraint` 实现的 `equalToWithRelation` 方法里：\n\n```swift\n@implementation MASViewConstraint\n\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attribute, NSLayoutRelation relation) {\n          /*\n          1. 设置约束关系\n          2. 设置第二个视图的约束属性\n          */\n          self.layoutRelation = relation;\n          self.secondViewAttribute = attribute;\n          return self;\n    };\n}\n\n@end\n```\n\n第二步执行完成后，Constraint 具备了全部基本条件：\n\n1. `firstViewAttribute`（view1 的约束属性）；\n2. `secondViewAttribute`（view2 的约束属性）；\n3. relation（约束关系）。\n\n### 案例二\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.left.right.bottom.equalTo(superview);\n}];\n```\n\n时序图\n\n![05](Masonry/05.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Composite as MASCompositeConstraint\n        participant Constraint as MASViewConstraint\n        \n        View       ->>  + Addition  : \"mas_makeConstraints:\"\n        activate View\n        \n        # 1. 创建 Maker\n        Addition   ->>  + Maker     : \"1. 创建 Maker\"\n        Maker      -->> - Addition  : \"完成\"\n\n        # 2. 添加约束\n        Addition   ->>  + Maker     : \"2.1 添加“top”约束到约束数组 constraints 中（make.top）\"\n        Maker -->> - Addition       : \"返回约束对象（MASViewConstraint）\"\n        \n        Addition ->>  + Constraint  : \"2.2 添加“Left”约束（make.top.left）\"\n        Constraint  ->> + Composite : \"创建约束集合，[Top, Left]\"\n        Composite  -->> - Constraint : \"更新 constraints = [[Top, Left]]\"\n        Constraint  -->> - Addition : \"返回约束集合（MASCompositeConstraint）\"\n        \n        Addition   ->>  + Composite : \"2.3 添加“Right”约束（make.top.left.right）\"\n        Composite  ->> + Constraint : \"创建约束对象\"\n        Constraint -->> - Composite : \"将约束对象放入约束集合\"\n        Composite  -->> - Addition  : \"返回“MASCompositeConstraint”对象（约束集合）\"\n\n        Addition   ->>  + Composite : \"2.4 添加“Right”约束（make.top.left.right）\"\n        Composite  ->> + Constraint : \"创建约束对象\"\n        Constraint -->> - Composite : \"将约束对象放入约束集合\"\n        Composite  -->> - Addition  : \"返回“MASCompositeConstraint”对象（约束集合）\"\n        \n        Addition   ->>  + Composite : \"2.5 .equalTo(superview)\"\n        Composite  ->> + Constraint : \"遍历集合中的约束对象.equalTo(superview)\"\n        Constraint -->> - Composite : \"完成\"\n        Composite  -->> - Addition  : \"完成\"\n\n        # 3. 应用约束\n        Addition   ->>  + Maker      : \"3.1 install\"\n        Maker      ->>  + Composite  : \"3.2 install\"\n        Composite  ->>  + Constraint : \"3.3 遍历集合中的约束对象，执行 install\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->>  - Maker     : \"完成\"\n        Maker      -->> - Addition   : \"完成，返回 constraints（约束集合）\"\n        Addition   -->> - View       : \"完成，返回 constraints（约束集合）\"\n        deactivate View\n```\n\n第一步 `make.top`：同案例一，`make.top` 返回的永远是 `MASViewConstraint`。\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：1\n */\n// 1.3\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    if (!constraint) {\n        // 1.4\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    /*\n    📢注意：返回的是 MASViewConstraint\n    */\n    return newConstraint;\n}\n\n// 1.2\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n// 1.1\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n@end\n```\n\n第二步 `make.top.left`：\n\n```swift\n@implementation MASConstraint\n\n// 2.1 来到父类调用基础方法\n- (MASConstraint *)left {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给谁呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n@end\n```\n\n因为第一步 `make.top` 返回的是 `MASViewConstraint` 类型，`MASViewConstraint` 作为子类重写了父类方法 `addConstraintWithLayoutAttribute:`：\n\n```swift\n@implementation MASViewConstraint\n\n// 2.2 子类重写父类方法\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    // self.delegate 是 Maker\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n@end\n```\n\n通过代理，再次掉到 Maker 创建约束的方法：\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：2\n */\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    true：此时的 constraint 是第一步创建的约束对象 MASViewConstraint\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        // 2.3 大于一个约束对象时，创建约束集合进行管理\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        /*\n        📢注意：返回的是 MASCompositeConstraint\n        */\n        return compositeConstraint;\n    }\n}\n\n@end\n```\n\n第三步 `make.top.left.right`：\n\n```swift\n@implementation MASConstraint\n\n// 3.1 来到父类调用基础方法\n- (MASConstraint *)right {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给睡呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n\n@end\n```\n\n因为在第二步中 `make.top.left` 返回的是 MASCompositeConstraint 类型，所以将由 MASCompositeConstraint 来执行接下来的任务：\n\n```swift\n@implementation MASCompositeConstraint\n\n// 3.3 子类重写父类方法，创建新的约束对象\n- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    id<MASConstraintDelegate> strongDelegate = self.delegate;\n    /*\n    因为创建约束对象的方法已经有了，没必要再实现一遍，所以可以直接调用那个负责创建约束对象的方法。\n    */\n    MASConstraint *newConstraint = [strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    newConstraint.delegate = self;\n    /*\n    收集到约束集合里，统一管理\n    */\n    [self.childConstraints addObject:newConstraint];\n    return newConstraint;\n}\n\n// 3.2 来到子类\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    [self constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    /*\n    📢注意：这里就返回了，返回的是 MASCompositeConstraint 自身\n    */\n    return self;\n}\n\n@end\n```\n\n负责创建约束对象的方法：\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：3\n */\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    否：constraint 是 MASCompositeConstraint 类型\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        //replace with composite constraint\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    }\n    /*\n    否：constraint 已经存在\n    */\n    if (!constraint) {\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    return newConstraint;\n}\n\n@end\n```\n\n第四步 `make.top.left.right.bottom` 和第三步相同\n\n```swift\n@implementation MASConstraint\n// 4.1 来到父类调用基础方法\n- (MASConstraint *)right {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给睡呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n// 4.3 子类重写父类方法，创建新的约束对象\n- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    id<MASConstraintDelegate> strongDelegate = self.delegate;\n    /*\n    因为创建约束对象的方法已经有了，没必要再实现一遍，所以可以直接调用那个负责创建约束对象的方法。\n    */\n    MASConstraint *newConstraint = [strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    newConstraint.delegate = self;\n    /*\n    收集到约束集合里，统一管理\n    */\n    [self.childConstraints addObject:newConstraint];\n    return newConstraint;\n}\n\n// 4.2 来到子类\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    [self constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    /*\n    📢注意：这里就返回了，返回的是 MASCompositeConstraint 自身\n    */\n    return self;\n}\n@end\n```\n\n第五步 `.equalTo(superview)`：\n\n```swift\n@implementation MASConstraint\n- (MASConstraint * (^)(id))equalTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attr, NSLayoutRelation relation) {\n        for (MASConstraint *constraint in self.childConstraints.copy) {\n            constraint.equalToWithRelation(attr, relation);\n        }\n        return self;\n    };\n}\n@end\n\n\n\n@implementation MASViewConstraint\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attribute, NSLayoutRelation relation) {\n        self.layoutRelation = relation;\n        self.secondViewAttribute = attribute;\n        return self;\n    };\n}\n@end\n```\n\n第六步 `install`：\n\n```swift\n@implementation MASConstraintMaker\n- (NSArray *)install {\n    if (self.removeExisting) {\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall];\n        }\n    }\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install];\n    }\n    [self.constraints removeAllObjects];\n    return constraints;\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n- (void)install {\n    /*\n    遍历加载所有约束对象\n    */\n    for (MASConstraint *constraint in self.childConstraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install];\n    }\n}\n@end\n```\n\n### 案例三\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview);\n    make.left.equalTo(superview);\n    make..right.bottom.equalTo(superview);\n}];\n```\n\n时序图\n\n![06](Masonry/06.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Constraint as MASViewConstraint\n        participant Composite as MASCompositeConstraint\n        \n        View       ->>  + Addition  : \"mas_makeConstraints:\"\n        activate View\n        \n        # 1. 创建 Maker\n        Addition   ->>  + Maker     : \"1. 创建 Maker\"\n        Maker      -->> - Addition  : \"完成\"\n\n        # 2. 添加约束\n        Addition ->>  + Maker        : \"2.1 添加“Top”约束到约束数组 constraints 中（make.top）\"\n        Maker    -->> - Addition     : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition   : \"完成\"\n\n        Addition   ->>  + Maker      : \"2.2 添加“Left”约束到约束数组 constraints 中（make.left）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition   : \"完成\"\n        \n        Addition   ->>  + Maker      : \"2.3 添加“Right”约束到约束数组 constraints 中（make.Right）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \"2.4 添加“Bottom”约束（make.right.bottom）\"\n        Constraint ->>  + Composite  : \"创建约束集合，将约束对象放入约束集合\"\n        Composite  -->> - Constraint : \"完成\"\n        Constraint -->> - Addition   : \"返回约束集合（MASCompositeConstraint）\"\n        \n        Addition   ->>  + Composite  : \"2.5 .equalTo(superview)\"\n        Composite  ->>  + Constraint : \"遍历集合中的约束对象.equalTo(superview)\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->> - Addition   : \"完成\"\n\n        # 3. 应用约束\n        Addition   ->>  + Maker      : \"3.1 遍历集合中 Constraint 对象执行 install\"\n        Maker      ->>  + Constraint : \"3.2 Constraint 对象执行 install\"\n        Constraint  -->>  - Maker    : \"完成\"\n        Maker      ->>  + Composite  : \"3.3 “约束集合 Composite”对象执行 install\"\n        Composite  ->>  + Constraint : \"3.3.1 遍历约束集合中的 Constraint 对象，执行 install\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->>  - Maker     : \"完成\"\n        Maker      -->> - Addition   : \"完成，返回 constraints（约束集合）\"\n        Addition   -->> - View       : \"完成，返回 constraints（约束集合）\"\n        deactivate View\n```","source":"_posts/Github开源框架/Masonry.md","raw":"---\ntitle: Masonry\ndate: 2023-06-22 15:14:16\ntags: Github开源框架\n---\n\n![01](Masonry/01.png)\n\n[Masonry](https://github.com/SnapKit/Masonry)\n\n<!-- more -->\n\n## 链式编程\n\n### 特点一\n\n* 链式编程可以通过点语法 `.` 调用函数。\n\n例如 Objective-C 中的 getter 方法：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  NSLog(@\"%@\", self.name);  // Prints \"zhangsan\"\n}\n\n- (NSString *)name {\n  return @\"zhangsan\";\n}\n```\n\n在 Objective-C 一般使用中括号 `[]` 的方式调用调用函数，但是也可以通过点语法 `.` 调用函数，但是编译器会提示警告：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  NSLog(@\"%@\", self.zhangsan);  // Prints \"zhangsan\"\n  self.lisi;  // Prints \"lisi\"\n  ViewController.wangwu;  // Prints \"wangwu\"\n}\n\n- (NSString *)zhangsan {\n  return @\"zhangsan\";\n}\n\n- (void)lisi {\n  NSLog(@\"lisi\");\n}\n\n+ (void)wangwu {\n  NSLog(@\"wangwu\");\n}\n```\n\n警告如下：\n\n![02](Masonry/02.png)\n\n### 特点二\n\n* 链式编程可以通过点语法 `.` **连续**调用函数。\n\n```swift\nself.lisi.wangwu\n```\n\n要想实现上面这段代码，可以参考链式编程**每个方法都有返回值**的特点。可以让函数执行完成后返回当前对象 `return self`，实现代码如下：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  self.lisi.wangwu;  // [[self lisi] wangwu]\n}\n\n- (ViewController *)lisi {\n  NSLog(@\"lisi\");\n  return self;\n}\n\n- (ViewController *)wangwu {\n  NSLog(@\"wangwu\");\n  return self;\n}\n\n@end\n```\n\n打印结果：\n\n```js\nlisi\nwangwu\n```\n\n上面这段代码，是参考 Objective-C 调用 getter 方法实现的，但是这种方式还比较局限。例如带有参数的函数调用：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [self lisi:@\"name1\"];\n}\n\n- (void)lisi:(NSString *)name {\n  NSLog(@\"%@: lisi\", name);\n}\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\n```\n\n函数往往是带有参数的，如果需要传入参数，该怎么用点语法`.`实现呢？\n\n这个时候 block 就该登场了：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  self.lisi(@\"name1\");\n}\n\n- (void(^)(NSString *name))lisi {\n  void(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: lisi\", name);\n  };\n  return block;\n}\n\n@end\n```\n\n通过 block 轻松实现了带有参数的 getter 方法，从而满足的点语法调用带参函数的要求。但是这样还不能满足**点语法连续调用**的特点，如连续调用两个或多个带参函数，该怎么实现呢？\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [[self lisi:@\"name1\"] wangwu:@\"name2\"];\n}\n\n- (ViewController *)lisi:(NSString *)name {\n  NSLog(@\"%@: lisi\", name);\n  return self;\n}\n\n- (ViewController *)wangwu:(NSString *)name {\n  NSLog(@\"%@: wangwu\", name);\n  return self;\n}\n\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\n```\n\n根据上面调用一个带参函数的实现，可以想到使用点语法连续调用带参函数的代码应该长这个样子：\n\n```swift\nself.lisi(@\"name1\").wangwu(@\"name2\")\n```\n\n这个时候带有**返回值**的 block 就该登场了：\n\n```swift\n@implementation ViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  self.lisi(@\"name1\").wangwu(@\"name2\");\n}\n\n- (ViewController *(^)(NSString *name))lisi {\n  ViewController *(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: lisi\", name);\n    return self;\n  };\n  return block;\n}\n\n- (ViewController *(^)(NSString *name))wangwu {\n  ViewController *(^block)(NSString *name) = ^(NSString *name) {\n    NSLog(@\"%@: wangwu\", name);\n    return self;\n  };\n  return block;\n}\n@end\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\n```\n\n实现细节：\n\n1. `self.lisi` 返回了一个类型为 `ViewController *(^)(NSString *name)` 的 block（参数类型：`NSString*`，返回值类型：`ViewController*`）；\n2. 通过括号 `()` 来实现 block 的调用，括号内是需要传递的参数，`self.lisi(@\"name1\")`；\n3. block 调用后返回了当前对象 `self`，从而实现了点语法`.`连续调用，`self.lisi(@\"name1\").wangwu(@\"name2\")`。\n\n### 特点三\n\n* 链式编程可以通过点语法 `.` **无限**连续调用函数。\n\n```swift\nself.lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\").lisi(@\"name1\").wangwu(@\"name2\");\n```\n\n打印结果：\n\n```js\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\nname1: lisi\nname2: wangwu\n```\n\n## Masonry简介\n\n来自 Masonry 说明文档里的示例：创建一个 view，它的上下左右四个边和父视图的四个边相距 10 的距离。\n\n![03](Masonry/03.png)\n\n方案一：使用 `NSLayoutConstraints` 布局的实现代码\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\nview1.translatesAutoresizingMaskIntoConstraints = NO;\nview1.backgroundColor = [UIColor greenColor];\n[superview addSubview:view1];\n\nUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n/**\n1. 添加约束组合\n2. 约束生效\n*/\n[superview addConstraints:@[\n   // 约束对象1：view1-top，view2-top，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeTop\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeTop\n                               multiplier:1.0\n                                 constant:padding.top],\n   // 约束对象2：view1-left，view2-left，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeLeft\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeLeft\n                               multiplier:1.0\n                                 constant:padding.left],\n   // 约束对象3：view1-bottom，view2-bottom，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeBottom\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeBottom\n                               multiplier:1.0\n                                 constant:-padding.bottom],\n   // 约束对象4：view1-right，view2-right，EQUAL\n   [NSLayoutConstraint constraintWithItem:view1\n                                attribute:NSLayoutAttributeRight\n                                relatedBy:NSLayoutRelationEqual\n                                   toItem:superview\n                                attribute:NSLayoutAttributeRight\n                               multiplier:1\n                                 constant:-padding.right],\n\n]];\n```\n\n方案二：这是使用 Masonry 布局的实现代码\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\nview1.translatesAutoresizingMaskIntoConstraints = NO;\nview1.backgroundColor = [UIColor greenColor];\n[superview addSubview:view1];\n\nUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n/**\n1. 添加约束组合\n2. 约束生效\n*/\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top).with.offset(padding.top);\n   make.left.equalTo(superview.mas_left).with.offset(padding.left);\n   make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);\n   make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n}];\n```\n\n可以看得出 Masonry 作者通过举出这个例子想要表达的意思，用 Masonry 布局真的太方便了。\n\n## Autolayout\n\n### NSLayoutConstraint\n\n上面的例子添加了一个 view 到视图上，该 view 的四个边和 superview 的四个边设置边距为 10，而这每一个边的边距都对应着一个**约束对象**（`NSLayoutConstraint`）。\n\n如上边的约束对象的初始化方法：\n\n```swift\n// view1-top, view2-top, EQUAL\nNSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:view1\n                                                              attribute:NSLayoutAttributeTop\n                                                              relatedBy:NSLayoutRelationEqual\n                                                                 toItem:superview\n                                                              attribute:NSLayoutAttributeTop\n                                                             multiplier:1.0\n                                                               constant:padding.top],\n```\n\n从这段代码不难看出，约束是相对的，至少需要两个 view 才能创建出一个约束对象。可以总结出创建一个约束对象的条件：\n\n1. 第一个视图；\n2. 第一个视图的约束属性（约束方向：上/下/左/右等）；\n3. 第二个视图；\n4. 第二个视图的约束属性（约束方向：上/下/左/右等）；\n5. 约束关系（等于/大于/小于）；\n\n这五个条件是生成一个约束对象所必须的，也是一个约束对象所拥有的最基础的元素。这一点在 `NSLayoutConstraint.h` 文件中定义的属性也能看出来：\n\n```swift\n@interface NSLayoutConstraint : NSObject\n\n/// 第一个视图\n@property (nullable, readonly, assign) id firstItem;\n/// 第二个视图\n@property (nullable, readonly, assign) id secondItem;\n/// 第一个视图的约束属性\n@property (readonly) NSLayoutAttribute firstAttribute;\n/// 第二个视图的约束属性\n@property (readonly) NSLayoutAttribute secondAttribute;\n/// 约束关系\n@property (readonly) NSLayoutRelation relation;\n\n@end\n```\n\n### NSLayoutAttribute\n\n在 `NSLayoutConstraint.h` 文件中定义的属性中，可以看到两个约束属性 `firstAttribute` 和 `secondAttribute`，它们用来描述视图的那一个方向需要添加约束。`NSLayoutAttribute` 是一个枚举，定义了视图支持自动布局的各个位置。\n\n```swift\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    /*\n     * 视图位置\n     */\n    NSLayoutAttributeLeft = 1,\n    NSLayoutAttributeRight,\n    NSLayoutAttributeTop,\n    NSLayoutAttributeBottom,\n    /*\n     * 视图前后\n     */\n    NSLayoutAttributeLeading,\n    NSLayoutAttributeTrailing,\n    /*\n     * 视图宽高\n     */\n    NSLayoutAttributeWidth,\n    NSLayoutAttributeHeight,\n    /*\n     * 视图中心\n     */\n    NSLayoutAttributeCenterX,\n    NSLayoutAttributeCenterY,\n    /*\n     * 视图基线\n     */\n    NSLayoutAttributeLastBaseline,\n#if TARGET_OS_IPHONE\n    NSLayoutAttributeBaseline NS_SWIFT_UNAVAILABLE(\"Use 'lastBaseline' instead\") = NSLayoutAttributeLastBaseline,\n#else\n    NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline,\n#endif\n    NSLayoutAttributeFirstBaseline API_AVAILABLE(macos(10.11), ios(8.0)),\n\n#if TARGET_OS_IPHONE\n    /*\n     * 视图位置（带边距）\n     */\n    NSLayoutAttributeLeftMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeRightMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeTopMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeBottomMargin API_AVAILABLE(ios(8.0)),\n    /*\n     * 视图前后（带边距）\n     */\n    NSLayoutAttributeLeadingMargin API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeTrailingMargin API_AVAILABLE(ios(8.0)),\n    /*\n     * 视图中心（带边距）\n     */\n    NSLayoutAttributeCenterXWithinMargins API_AVAILABLE(ios(8.0)),\n    NSLayoutAttributeCenterYWithinMargins API_AVAILABLE(ios(8.0)),\n#endif\n    // 占位符\n    NSLayoutAttributeNotAnAttribute = 0\n};\n```\n\n关于带 Margin 的枚举值：\n\n1. `NSLayoutAttributeLeft` 表示视图的最左边；\n2. `NSLayoutAttributeLeftMargin` 表示视图的左边，且与父视图的左边具有一个边距（margin），这个值通过 `layoutMargins` 进行修改。\n\n### NSLayoutRelation\n\n约束关系，在创建约束对象时，需要明确指出两个视图的约束关系。\n\n```swift\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    /// <=\n    NSLayoutRelationLessThanOrEqual = -1,\n    /// ==\n    NSLayoutRelationEqual = 0,\n    /// >=\n    NSLayoutRelationGreaterThanOrEqual = 1,\n};\n```\n\n## Masonry的UML\n\n![01](Masonry/01.png)\n\n图中从左至右把 Masonry 分为三块：\n\n1. `View+MASAdditions`，`UIView` 的延展，让 `UIView` 更方便的调用 Masonry 提供的属性和方法，这也是三方框架惯用的手段，为无访问权限的源代码扩展能力（逆向建模）；\n2. `MASConstraintMaker`，简称 Maker，是**创建约束**的工厂方法，即所有类都会以各种方式调用到这个类里，由它来完成创建约束的操作；\n3. `MASConstraint`，简称 Constant（约束），它是一个抽象父类，关联的子类有：`MASViewConstraint`（单个约束）、`MASCompositeConstraint`（约束结合），都被 Maker 创建。\n\n因为 Masonry 是采用链式编程的范式构建的，也是就是万物皆可点，一直点一直有（返回值），所以这三个模块包含使用点语法调用的属性或函数。\n\n### View+MASAdditions\n\n🤔思考：`UIView` 通过点语法会返回什么呢？\n\n对 `UIView` 的延展，主要是为了通过拓展的方式**放大接口**，给 `UIView` 增加新的属性和方法：\n\n1. 属性创造 `MASViewAttribute`，简称 Attribute，约束属性，它创建约束对象的条件之一；\n2. 方法创造 `MASConstraintMaker`，简称 Maker。\n\n```swift\n@interface MAS_VIEW (MASAdditions)\n\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;\n@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;\n\n- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;\n\n@end\n```\n\n定义属性的目的，是想利用属性的 getter 方法，从而实现通过点语法调用函数的方式，创建约束属性。\n\n下面是属性的 getter 方法的具体实现，内部直接返回了一个初始化好的约束属性：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n- (MASViewAttribute *)mas_left {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASViewAttribute *)mas_top {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASViewAttribute *)mas_right {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASViewAttribute *)mas_bottom {\n    return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeBottom];\n}\n\n@end\n```\n\n对 `UIView` 的延展好处是，为 `UIView` 增加了 Masonry 自定义的属性和方法，从而使调用变的更加直接，就像是 `UIView` 原本就具有这些属性和方法一样：\n\n```swift\n- (void)viewDidLoad {\n  [super viewDidLoad];\n  \n  UIView *superview = self.view;\n  [superview addSubview:view1];\n\n  [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n      make.top.equalTo(superview.mas_top);\n  }];\n}\n```\n\n综上所述，`UIView` 通过点语法会创建出一个约束方向对象 `MASViewAttribute`。\n\n### MASViewAttribute\n\n* 这一部分关心的是 **Attribute**（约束属性），也就是约束方向。\n\n通过上面👆约束属性的初始化方法，不难看出一个 `MASViewAttribute` 类型的约束属性，至少包含两个东西：\n\n1. View：视图；\n2. Attribute：约束方向。\n\n```swift\nMASViewAttribute * attribute = [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];\n```\n\n从 `MASViewAttribute.h` 文件里也能看出这一点：\n\n```swift\n@interface MASViewAttribute : NSObject\n/// 约束视图\n@property (nonatomic, weak, readonly) id item;\n/// 约束属性\n@property (nonatomic, assign, readonly) NSLayoutAttribute layoutAttribute;\n@end\n```\n\n从定义可以看出 `MASViewAttribute` 将约束视图 View 和约束属性 Attribute 封装到了同一个类里，相对于 `NSLayoutAttribute` 枚举来说，`MASViewAttribute` 创建出来后是一个对象，拥有更多的信息，且更加的面向对象。这也正好弥补了 Objective-C 中枚举地位低的缺点。\n\n### MASConstraintMaker\n\n* 这一部分关心的是 **Constraint**（约束）的创建创建者 `MASConstraintMaker`，简称 Maker。\n\n🤔思考：约束创建者 Maker 通过点语法会返回什么呢？\n\n创建约束的工厂方法，负责约束对象的创建工作，即所有类都以代理的方式，调用到这个类里，由它来完成创建约束的操作。\n\n在 UIView 的延展部分提到了 Maker 的创建，通过调用 `mas_makeConstraints` 方法创建：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n@end\n```\n\n通过初始化代码，可以看出 Maker 首先持有了 view，成为了 view 专属的约束创造者，再通过 block 回调出去收集约束：\n\n```swift\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top);\n}];\n```\n\n关于 Maker 和 view 是一对一的关系，也可以从 Maker 的定义里看出来：\n\n```swift\n@interface MASConstraintMaker : NSObject\n\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n\n- (id)initWithView:(MAS_VIEW *)view;\n\n@end\n```\n\nMaker 将约束定义为属性，是想利用属性的 getter 方法，通过点语法的方式创建约束，如 `left` 属性的 getter 方法：\n\n```swift\n@implementation MASConstraintMaker\n\n- (id)initWithView:(MAS_VIEW *)view {\n    self = [super init];\n    if (!self) return nil;\n    \n    self.view = view;\n    self.constraints = NSMutableArray.new;\n    \n    return self;\n}\n\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n- (MASConstraint *)right {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n\n- (MASConstraint *)bottom {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeBottom];\n}\n\n@end\n```\n\n综上所述，约束创建者 Maker 通过点语法会创建出一个约束对象 `MASConstraint`。\n\n关于 Maker 的核心方法 `constraint:addConstraintWithLayoutAttribute:`，主要用来创建约束对象，下面以序号的方式演示代码的执行过程：\n\n1. 创建单个约束对象 `MASViewConstraint`；\n2. 创建约束集合 `MASCompositeConstraint`。\n\n```swift\n@implementation MASConstraintMaker\n\n- (void)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint {\n    NSUInteger index = [self.constraints indexOfObject:constraint];\n    NSAssert(index != NSNotFound, @\"Could not find constraint %@\", constraint);\n    [self.constraints replaceObjectAtIndex:index withObject:replacementConstraint];\n}\n\n/*\n 创建约束对象的入口，子类会通过代理调用该方法，创建新的约束对象\n*/\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    /*\n    创建约束属性 和 新的约束对象\n    */\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n     constraint 是 MASViewConstraint 类型会说明两件事：\n     1、constraint 不为空：newConstraint 不是视图的第一个约束对象；\n     2、constraint 不是 MASCompositeConstraint 类型：还没有创建过约束集合（一个视图只会创建一次）。\n\n     即需要创建一个约束集合\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        // 1、将第一个约束对象和第二个约束对象打包集合\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        // 2、设置代理，创建第三个约束对象及更多的约束对象时，重新来到这个方法\n        compositeConstraint.delegate = self;\n        // 3、让约束集合替换第一个约束对象（约束集合里已经保存了第一个约束对象）\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        /*\n        📢注意：这里返回的是 MASCompositeConstraint，和链式调用息息相关\n        */\n        return compositeConstraint;\n    }\n    /*\n    constraint 为空说明：\n    1、newConstraint 是视图的第一个约束对象\n    */\n    if (!constraint) {\n        // 设置代理，创建第二约束对象的时候，重新来到这个方法，创建约束集合👆\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    /*\n    📢注意：这里返回的是 MASViewConstraint，和链式调用息息相关\n    */\n    return newConstraint;\n}\n\n@end\n```\n\n### MASConstraint\n\n* 这一部分主要关心的是约束自身，简称 Constraint。\n\n🤔思考：约束是否也是可以点的，通过点语法可以创造出什么呢？\n\n这里的定义和约束创建者 Maker 类似，只不过这里没有写成属性（readonly）的方式，而是直接实现了 getter 方法。\n\n>猜想：这样写是因为用了面向对象的封装，属性是对象的特征。Maker 是可以拥有约束特征的，而约束自身不应该再拥有约束特征。如“人”可以有“左手”和“右手”，而“手”自身不再拥有这些特征。\n\n```swift\n@interface MASConstraint : NSObject\n\n- (MASConstraint *)left;\n- (MASConstraint *)top;\n- (MASConstraint *)right;\n- (MASConstraint *)bottom;\n\n@end\n```\n\ngetter 方法的实现部分 和 Maker 是完全一致的，毕竟想实现的功能是一样的。\n\n```swift\n- (MASConstraint *)left {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n```\n\n`MASConstraint` 约束抽象类，与 Maker 一样可以通过点语法创建一个新的约束对象。`MASConstraint` 真正满足了链式编程要求，即**每个方都有返回值，返回值为对象自身**。又因为 `MASConstraint` 是 Maker 的属性，所以 Maker 也满足了链式编程。至此，Masonry 中可以实现链式编程的类有两个 `MASConstraint`（及其子类） 和 `MASConstraintMaker`。\n\n### MASViewConstraint\n\n`MASViewConstraint` 约束类，是 `MASConstraint` 的子类，Maker 生成的约束对象就是 `MASViewConstraint` 类型的。\n\n`MASViewConstraint` 对标的是 Autolayout 中的 `NSLayoutConstraint`，前边通过 `NSLayoutConstraint` 的定义看出它有 5 个基本条件：\n\n1. 第一个视图；\n2. 第一个视图的约束属性（约束方向：上/下/左/右等）；\n3. 第二个视图；\n4. 第二个视图的约束属性（约束方向：上/下/左/右等）；\n5. 约束关系（等于/大于/小于）；\n\n下面是 `MASViewConstraint` 的定义，可以看出，它只需要两个条件：\n\n```swift\n@interface MASViewConstraint : MASConstraint <NSCopying>\n\n@property (nonatomic, strong, readonly) MASViewAttribute *firstViewAttribute;\n\n@property (nonatomic, strong, readonly) MASViewAttribute *secondViewAttribute;\n\n@end\n```\n\n其实还有一个条件，约束关系，被定义子在了 `MASViewConstraint.m` 文件。综上所述，可以总结出创建一个 `MASViewConstraint` 对象的基本条件有三个：\n\n1. 第一个视图和第一个视图的约束属性；\n2. 第二个视图和第二个视图的约束属性；\n3. 约束关系。\n\n可以看的出，两者的条件内容本质是一样的，只不是实现方式不同而已。`MASViewConstraint` 使用面向对象的方式，把“视图”和“视图的约束属性”打包成元组的形式进行管理。\n\n🤔思考：把“视图”和“视图的约束属性”打包成元组的操作妙在哪？\n\n### MASCompositeConstraint\n\n`MASCompositeConstraint` 约束集合类，当一个 Maker 创建了一个以上的约束对象时，就会创建出约束集合来管理这些约束。\n\n```swift\n@interface MASCompositeConstraint : MASConstraint\n\n- (id)initWithChildren:(NSArray *)children;\n\n@end\n```\n\n## Masonry约束实现原理\n\n`UIView` 通过 `mas_makeConstraints` 方法为自己添加约束。\n\n### 案例一\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top);\n}];\n```\n\n`mas_makeConstraints` 的实现：\n\n```swift\n@implementation MAS_VIEW (MASAdditions)\n\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    // 1.设置不支持 AutoresizingMask\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    // 2.初始化专属约束创造者 Maker\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    // 3.收集约束\n    block(constraintMaker);\n    // 4.添加约束（应用约束）\n    return [constraintMaker install];\n}\n\n@end\n```\n\n调用该方法做了四件事情：\n\n1. 设置不支持 AutoresizingMask；\n2. 初始化**专属**约束创造者 Maker；\n3. 收集约束；\n4. 添加约束（应用约束）。\n\n约束的收集过程：\n\n```swift\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.equalTo(superview.mas_top).with.offset(padding.top);\n}];\n```\n\n时序图\n\n![04](Masonry/04.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Constraint as MASViewConstraint\n        \n        View       ->>  + Addition   : \"mas_makeConstraints:\"\n        activate View\n\n        Addition   ->>  + Maker      : \"创建 Maker\"\n        Maker      -->> - Addition   : \"完成\"\n\n        Addition   ->>  + Maker      : \"添加“top”约束到约束数组 constraints 中（make.top）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition      ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition      : \"完成\"\n\n        Addition   ->>  + Maker      : \"引用约束（install）\"\n        Maker      -->> - Addition   : \"返回约束集合（constraints）\"\n        Addition   -->> - View       : \"返回约束集合（constraints）\"\n        deactivate View\n```\n\n第一步 `make.top`：Maker 创建 view 的 top 约束对象，核心方法 `constraint:addConstraintWithLayoutAttribute:`\n\n```swift\n@implementation MASConstraintMaker\n\n// 1.3\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    为约束设置代理：当约束通过点语法创建新的约束对象时，会通过代理再次来到这个方法进行创建约束\n    */\n    newConstraint.delegate = self;\n    /*\n    将新的约束放收集到数组里，等待应用到view上\n    */\n    [self.constraints addObject:newConstraint];\n    /*\n    📢注意：这里返回的是 MASViewConstraint 类型，和接下来 equal 的调用有关\n    */\n    return newConstraint;\n}\n\n// 1.2\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n// 1.1\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n@end\n```\n\n第一步执行完成后，生成了一个约束对象 `MASViewConstraint`，简称 Constraint，同时它已经有了第一个视图和它的约束属性（`NSLayoutAttributeTop`）。\n\n🤔思考：`make.top` 创建出来的 `top` 约束对象的类型一定是 `MASViewConstraint` 的吗?\n\n第二步 `make.top.equal`：设置依赖关系，首先来到约束抽象类 `MASConstraint` 里\n\n```swift\n@implementation MASConstraint\n\n- (MASConstraint * (^)(id))equalTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n\n@end\n```\n\n这一步有两个参数：\n\n1. attribute 约束属性（视图和视图的约束属性）;\n2. relation 约束关系（`NSLayoutRelationEqual`）。\n\n因为上面👆 `make.top` 返回的是 `MASViewConstraint` 类型，所以接下来会调用到子类 `MASViewConstraint` 实现的 `equalToWithRelation` 方法里：\n\n```swift\n@implementation MASViewConstraint\n\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attribute, NSLayoutRelation relation) {\n          /*\n          1. 设置约束关系\n          2. 设置第二个视图的约束属性\n          */\n          self.layoutRelation = relation;\n          self.secondViewAttribute = attribute;\n          return self;\n    };\n}\n\n@end\n```\n\n第二步执行完成后，Constraint 具备了全部基本条件：\n\n1. `firstViewAttribute`（view1 的约束属性）；\n2. `secondViewAttribute`（view2 的约束属性）；\n3. relation（约束关系）。\n\n### 案例二\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n   make.top.left.right.bottom.equalTo(superview);\n}];\n```\n\n时序图\n\n![05](Masonry/05.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Composite as MASCompositeConstraint\n        participant Constraint as MASViewConstraint\n        \n        View       ->>  + Addition  : \"mas_makeConstraints:\"\n        activate View\n        \n        # 1. 创建 Maker\n        Addition   ->>  + Maker     : \"1. 创建 Maker\"\n        Maker      -->> - Addition  : \"完成\"\n\n        # 2. 添加约束\n        Addition   ->>  + Maker     : \"2.1 添加“top”约束到约束数组 constraints 中（make.top）\"\n        Maker -->> - Addition       : \"返回约束对象（MASViewConstraint）\"\n        \n        Addition ->>  + Constraint  : \"2.2 添加“Left”约束（make.top.left）\"\n        Constraint  ->> + Composite : \"创建约束集合，[Top, Left]\"\n        Composite  -->> - Constraint : \"更新 constraints = [[Top, Left]]\"\n        Constraint  -->> - Addition : \"返回约束集合（MASCompositeConstraint）\"\n        \n        Addition   ->>  + Composite : \"2.3 添加“Right”约束（make.top.left.right）\"\n        Composite  ->> + Constraint : \"创建约束对象\"\n        Constraint -->> - Composite : \"将约束对象放入约束集合\"\n        Composite  -->> - Addition  : \"返回“MASCompositeConstraint”对象（约束集合）\"\n\n        Addition   ->>  + Composite : \"2.4 添加“Right”约束（make.top.left.right）\"\n        Composite  ->> + Constraint : \"创建约束对象\"\n        Constraint -->> - Composite : \"将约束对象放入约束集合\"\n        Composite  -->> - Addition  : \"返回“MASCompositeConstraint”对象（约束集合）\"\n        \n        Addition   ->>  + Composite : \"2.5 .equalTo(superview)\"\n        Composite  ->> + Constraint : \"遍历集合中的约束对象.equalTo(superview)\"\n        Constraint -->> - Composite : \"完成\"\n        Composite  -->> - Addition  : \"完成\"\n\n        # 3. 应用约束\n        Addition   ->>  + Maker      : \"3.1 install\"\n        Maker      ->>  + Composite  : \"3.2 install\"\n        Composite  ->>  + Constraint : \"3.3 遍历集合中的约束对象，执行 install\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->>  - Maker     : \"完成\"\n        Maker      -->> - Addition   : \"完成，返回 constraints（约束集合）\"\n        Addition   -->> - View       : \"完成，返回 constraints（约束集合）\"\n        deactivate View\n```\n\n第一步 `make.top`：同案例一，`make.top` 返回的永远是 `MASViewConstraint`。\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：1\n */\n// 1.3\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    if (!constraint) {\n        // 1.4\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    /*\n    📢注意：返回的是 MASViewConstraint\n    */\n    return newConstraint;\n}\n\n// 1.2\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n// 1.1\n- (MASConstraint *)top {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];\n}\n\n@end\n```\n\n第二步 `make.top.left`：\n\n```swift\n@implementation MASConstraint\n\n// 2.1 来到父类调用基础方法\n- (MASConstraint *)left {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给谁呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];\n}\n\n@end\n```\n\n因为第一步 `make.top` 返回的是 `MASViewConstraint` 类型，`MASViewConstraint` 作为子类重写了父类方法 `addConstraintWithLayoutAttribute:`：\n\n```swift\n@implementation MASViewConstraint\n\n// 2.2 子类重写父类方法\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    NSAssert(!self.hasLayoutRelation, @\"Attributes should be chained before defining the constraint relation\");\n\n    // self.delegate 是 Maker\n    return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n@end\n```\n\n通过代理，再次掉到 Maker 创建约束的方法：\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：2\n */\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    true：此时的 constraint 是第一步创建的约束对象 MASViewConstraint\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        // 2.3 大于一个约束对象时，创建约束集合进行管理\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        /*\n        📢注意：返回的是 MASCompositeConstraint\n        */\n        return compositeConstraint;\n    }\n}\n\n@end\n```\n\n第三步 `make.top.left.right`：\n\n```swift\n@implementation MASConstraint\n\n// 3.1 来到父类调用基础方法\n- (MASConstraint *)right {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给睡呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n\n@end\n```\n\n因为在第二步中 `make.top.left` 返回的是 MASCompositeConstraint 类型，所以将由 MASCompositeConstraint 来执行接下来的任务：\n\n```swift\n@implementation MASCompositeConstraint\n\n// 3.3 子类重写父类方法，创建新的约束对象\n- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    id<MASConstraintDelegate> strongDelegate = self.delegate;\n    /*\n    因为创建约束对象的方法已经有了，没必要再实现一遍，所以可以直接调用那个负责创建约束对象的方法。\n    */\n    MASConstraint *newConstraint = [strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    newConstraint.delegate = self;\n    /*\n    收集到约束集合里，统一管理\n    */\n    [self.childConstraints addObject:newConstraint];\n    return newConstraint;\n}\n\n// 3.2 来到子类\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    [self constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    /*\n    📢注意：这里就返回了，返回的是 MASCompositeConstraint 自身\n    */\n    return self;\n}\n\n@end\n```\n\n负责创建约束对象的方法：\n\n```swift\n@implementation MASConstraintMaker\n/*\n 记录该方法调用次数：3\n */\n- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];\n    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];\n    /*\n    否：constraint 是 MASCompositeConstraint 类型\n    */\n    if ([constraint isKindOfClass:MASViewConstraint.class]) {\n        //replace with composite constraint\n        NSArray *children = @[constraint, newConstraint];\n        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];\n        compositeConstraint.delegate = self;\n        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];\n        return compositeConstraint;\n    }\n    /*\n    否：constraint 已经存在\n    */\n    if (!constraint) {\n        newConstraint.delegate = self;\n        [self.constraints addObject:newConstraint];\n    }\n    return newConstraint;\n}\n\n@end\n```\n\n第四步 `make.top.left.right.bottom` 和第三步相同\n\n```swift\n@implementation MASConstraint\n// 4.1 来到父类调用基础方法\n- (MASConstraint *)right {\n    /*\n    父类并没有实现该方法，会分发给子类完成，两个子类，该分给睡呢？\n    */\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n// 4.3 子类重写父类方法，创建新的约束对象\n- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    id<MASConstraintDelegate> strongDelegate = self.delegate;\n    /*\n    因为创建约束对象的方法已经有了，没必要再实现一遍，所以可以直接调用那个负责创建约束对象的方法。\n    */\n    MASConstraint *newConstraint = [strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    newConstraint.delegate = self;\n    /*\n    收集到约束集合里，统一管理\n    */\n    [self.childConstraints addObject:newConstraint];\n    return newConstraint;\n}\n\n// 4.2 来到子类\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    [self constraint:self addConstraintWithLayoutAttribute:layoutAttribute];\n    /*\n    📢注意：这里就返回了，返回的是 MASCompositeConstraint 自身\n    */\n    return self;\n}\n@end\n```\n\n第五步 `.equalTo(superview)`：\n\n```swift\n@implementation MASConstraint\n- (MASConstraint * (^)(id))equalTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attr, NSLayoutRelation relation) {\n        for (MASConstraint *constraint in self.childConstraints.copy) {\n            constraint.equalToWithRelation(attr, relation);\n        }\n        return self;\n    };\n}\n@end\n\n\n\n@implementation MASViewConstraint\n- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {\n    return ^id(id attribute, NSLayoutRelation relation) {\n        self.layoutRelation = relation;\n        self.secondViewAttribute = attribute;\n        return self;\n    };\n}\n@end\n```\n\n第六步 `install`：\n\n```swift\n@implementation MASConstraintMaker\n- (NSArray *)install {\n    if (self.removeExisting) {\n        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];\n        for (MASConstraint *constraint in installedConstraints) {\n            [constraint uninstall];\n        }\n    }\n    NSArray *constraints = self.constraints.copy;\n    for (MASConstraint *constraint in constraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install];\n    }\n    [self.constraints removeAllObjects];\n    return constraints;\n}\n@end\n\n\n\n@implementation MASCompositeConstraint\n- (void)install {\n    /*\n    遍历加载所有约束对象\n    */\n    for (MASConstraint *constraint in self.childConstraints) {\n        constraint.updateExisting = self.updateExisting;\n        [constraint install];\n    }\n}\n@end\n```\n\n### 案例三\n\n```swift\nUIView *superview = self.view;\n\nUIView *view1 = [[UIView alloc] init];\n[superview addSubview:view1];\n\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview);\n    make.left.equalTo(superview);\n    make..right.bottom.equalTo(superview);\n}];\n```\n\n时序图\n\n![06](Masonry/06.png)\n\n```mermaid\n    sequenceDiagram\n        participant View       as UIView\n        participant Addition   as View+MASAdditions\n        participant Maker      as MASConstraintMaker\n        participant Constraint as MASViewConstraint\n        participant Composite as MASCompositeConstraint\n        \n        View       ->>  + Addition  : \"mas_makeConstraints:\"\n        activate View\n        \n        # 1. 创建 Maker\n        Addition   ->>  + Maker     : \"1. 创建 Maker\"\n        Maker      -->> - Addition  : \"完成\"\n\n        # 2. 添加约束\n        Addition ->>  + Maker        : \"2.1 添加“Top”约束到约束数组 constraints 中（make.top）\"\n        Maker    -->> - Addition     : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition   : \"完成\"\n\n        Addition   ->>  + Maker      : \"2.2 添加“Left”约束到约束数组 constraints 中（make.left）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \".equalTo(superview)\"\n        Constraint -->> - Addition   : \"完成\"\n        \n        Addition   ->>  + Maker      : \"2.3 添加“Right”约束到约束数组 constraints 中（make.Right）\"\n        Maker      -->> - Addition   : \"返回约束对象（MASViewConstraint）\"\n\n        Addition   ->>  + Constraint : \"2.4 添加“Bottom”约束（make.right.bottom）\"\n        Constraint ->>  + Composite  : \"创建约束集合，将约束对象放入约束集合\"\n        Composite  -->> - Constraint : \"完成\"\n        Constraint -->> - Addition   : \"返回约束集合（MASCompositeConstraint）\"\n        \n        Addition   ->>  + Composite  : \"2.5 .equalTo(superview)\"\n        Composite  ->>  + Constraint : \"遍历集合中的约束对象.equalTo(superview)\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->> - Addition   : \"完成\"\n\n        # 3. 应用约束\n        Addition   ->>  + Maker      : \"3.1 遍历集合中 Constraint 对象执行 install\"\n        Maker      ->>  + Constraint : \"3.2 Constraint 对象执行 install\"\n        Constraint  -->>  - Maker    : \"完成\"\n        Maker      ->>  + Composite  : \"3.3 “约束集合 Composite”对象执行 install\"\n        Composite  ->>  + Constraint : \"3.3.1 遍历约束集合中的 Constraint 对象，执行 install\"\n        Constraint -->> - Composite  : \"完成\"\n        Composite  -->>  - Maker     : \"完成\"\n        Maker      -->> - Addition   : \"完成，返回 constraints（约束集合）\"\n        Addition   -->> - View       : \"完成，返回 constraints（约束集合）\"\n        deactivate View\n```","slug":"Github开源框架/Masonry","published":1,"updated":"2023-08-25T09:48:32.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgs0000haq7k2aakujar"},{"title":"OC对象的本质","date":"2020-05-06T06:36:30.000Z","_content":"\n思考：\n* 一个 NSObject 对象占用多少内存？ \n* 创建一个实例对象，至少需要多少内存？实际上分配了多少内存？\n\n<!-- more -->\n\n# Objective-C的本质\n\nObjective-C 代码的底层实现其实是 C\\C++ 代码，Objective-C 的面向对象是基于 C\\C++ 的数据结构(结构体)实现的。\n\n![ObjectiveC_C_C++_汇编语言_机器语言](OC对象的本质/ObjectiveC_C_C++_汇编语言_机器语言.png)\n\n## 将 Objective-C 代码转换为 C\\C++ 代码\n\n### 创建一个命令行项目\n![OC对象的本质](OC对象的本质/OC对象的本质.png)\n\n在终端打开 main.m 的位置，输入下面👇的命令生成 main.cpp 文件。因为要生成的代码包括 c/c++，所以使用 main.cpp 文件，main.cpp 文件是 c++ 文件，支持 c/c++。\n\n### 生成 main.cpp\n```\n$ clang -rewrite-objc main.m -o main.cpp\n```\n没有指定平台，默认生成的是多个平台的代码，代码量太大。\n\n### 指定生成 iphoneos 平台、arm64 架构的 main.cpp  \n指定平台：不同平台支持的代码不一样，如 Windows、mac、iOS。xcrun -sdk iphoneos：指定 iphoneos。    \n指定框架：不同框架支持的代码也不一样，模拟器(i386)、32bit(armv7)、64bit（arm64）。-arch arm64：指定 arm64 架构。\n```\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp\n```\n\n报错：xcrun: error: SDK \"iphoneos\" cannot be located  \n解决1：给Xcode命令行工具指定路径👇\n```\n$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/\n```\n\n（如果需要链接其他框架，使用-framework参数。比如-framework UIKit。(未验证)）\n```\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp -framework UIKit\n```\n\n### 取消 Xcode 对 main-arm64.cpp 的文件编译  \n生成的 main-arm64.cpp 文件添加到项目后，运行会报错。main-arm64.cpp 是临时生成的，内部有一个 main 函数，没做适配。 \n\n解决：删除 Build Phases -> Compile Sources -> main-arm64.cpp\n![main-arm64](OC对象的本质/取消编译main_arm64_cpp.png)\n\n\n\n\n# NSObject 的底层实现\n\n* 思考：一个OC对象在内存中是如何布局的？\n\n## NSObject 在 OC 中的定义：\n```\n@interface NSObject <NSObject> {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"\n    Class isa  OBJC_ISA_AVAILABILITY;\n#pragma clang diagnostic pop\n}\n\n//简化后：\n@interface NSObject {\n    Class isa;\n}\n```\n\n## 在 c++ 中的定义：\n```\nstruct NSObject_IMPL {\n    Class isa; // 8个字节\n};\n```\nClass 是指向结构体的指针：typedef struct objc_class *Class。  \nIMPL 是 implementation 的简写。结构体中只有一个成员变量，所以这个结构体在内存中占用的大小就是指针 isa 的大小。\n\n![OC对象的本质02](OC对象的本质/OC对象的本质02.png)\n\n## 打印 NSObject 实例对象的成员变量所占用的大小 >> 8\n```\n//1.导入头文件\n#import <objc/runtime.h>\n\n//2.打印，结果 8\nNSLog(@\"%zd\", class_getInstanceSize([NSObject class]));\n```\n\n## 打印 obj 指针所指向内存的大小 >> 16\n```\n//1.导入头文件\n#import <malloc/malloc.h>\n\n//2.打印，结果 16\nNSLog(@\"%zd\", malloc_size((__bridge const void *)obj));\n```\n__bridge 可以实现 Objective-C 与 C 语言变量 和 Objective-C 与 Core Foundation 对象之间的互相转换。  \n\n\n## 窥视 class_getInstanceSize\n下载 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。  \n打开源码搜索 class_getInstanceSize，找到 objc-class.mm 文件中 class_getInstanceSize 的实现代码。\n```\nsize_t class_getInstanceSize(Class cls)\n{\n    if (!cls) return 0;\n    return cls->alignedInstanceSize();\n}\n```\nJump to Definition -> alignedInstanceSize：\n```\n// Class's ivar size rounded up to a pointer-size boundary.\nuint32_t alignedInstanceSize() const {\n    return word_align(unalignedInstanceSize());\n}\n```\n翻译过来就是，class_getInstanceSize 内部根据成员变量的大小和内存对齐原则得到 NSObject 实例对象里成员变量所占用的内存大小。\n\n👉 内存对齐原则：结构体的大小必须是最大成员大小的倍数。\n\n## 窥视 alloc\nalloc 的内部实现是 allocWithZone，在源码中搜索 allocWithZone：\n\n```\nid\n_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)\n{\n    id obj;\n\n    if (fastpath(!zone)) {\n        obj = class_createInstance(cls, 0); //参数：类，额外空间0\n    } else {\n        obj = class_createInstanceFromZone(cls, 0, zone);\n    }\n\n    if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);\n    return obj;\n}\n```\n\nJump to Definition -> class_createInstance：\n\n```\nid\nclass_createInstance(Class cls, size_t extraBytes)\n{\n    if (!cls) return nil;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n}\n```\n\nJump to Definition -> _class_createInstanceFromZone：\n\n```\n//创建 cls 的实例对象\nstatic ALWAYS_INLINE id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,\n                              int construct_flags = OBJECT_CONSTRUCT_NONE,\n                              bool cxxConstruct = true,\n                              size_t *outAllocatedSize = nil)\n{\n    ASSERT(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocNonpointer();\n    size_t size;\n\n    size = cls->instanceSize(extraBytes); //分配内存空间方法👇\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    id obj;\n    if (zone) {\n        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);\n    } else {\n        obj = (id)calloc(1, size); //c语言分配内存的函数，分配空间：size\n    }\n    if (slowpath(!obj)) {\n        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {\n            return _objc_callBadAllocHandler(cls);\n        }\n        return nil;\n    }\n\n    if (!zone && fast) {\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n        // Use raw pointer isa on the assumption that they might be\n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (fastpath(!hasCxxCtor)) {\n        return obj;\n    }\n\n    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;\n    return object_cxxConstructFromClass(obj, cls, construct_flags);\n}\n```\n\nJump to Definition -> instanceSize：\n\n```\nsize_t instanceSize(size_t extraBytes) const {\n    if (fastpath(cache.hasFastInstanceSize(extraBytes))) {\n        return cache.fastInstanceSize(extraBytes);\n    }\n\n    size_t size = alignedInstanceSize() + extraBytes;\n    // CF requires all objects be at least 16 bytes.\n    if (size < 16) size = 16; //至少16个字节\n    return size;\n}\n```\n可以看到，创建的实例对象的大小最终由 instanceSize 方法实现。内存大小至少16个字节，CoreFoundation 框架内部就是这么硬性规定的。\n\n## 小结：  \n\n```\nNSObject *obj = [[NSObject alloc] init];\n```\n\n* 上面👆这句代码实际上是在内存中生成了一个 c 语言定义的结构体，结构体内有一个类型为 Class 的 isa 指针，结构体的大小 8 个字节。Class 是一个指向结构体的指针。\n* 创建的实例对象的大小至少16个字节.\n\n\n# 查看实例变量的内存的方法\n\n## 通过 Xcode 工具查看对象内存  \n打开 Debug -> Debug Workflow -> View Memory，在 Address 输入对象的地址。  \n![OC对象的本质03](OC对象的本质/OC对象的本质03.png)\n\n\n## 常用 LLDB 指令\n### print、p：打印\n\n```\n(lldb) print obj\n(NSObject *) $0 = 0x000000010380ef00\n(lldb) p obj\n(NSObject *) $1 = 0x000000010380ef00\n```\n\n### po：打印对象\n\n```\n(lldb) po obj\n<NSObject: 0x10380ef00>\n```\n\n### 格式  \nx是16进制，f是浮点，d是10进制\n\n### 字节大小  \nb：byte 1字节，h：half word 2字节  \nw：word 4字节，g：giant word 8字节\n\n### 读取内存  \n* memory read/数量格式字节数 内存地址\n\nmemory read 内存地址\n\n```\n(lldb) memory read 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ ....... \n```\n\nx/数量格式字节数 内存地址\n\n```\n(lldb) x 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) x/3xg 0x10380ef00\n0x10380ef00: 0x001dffff9a8b8141 0x0000000000000000\n0x10380ef10: 0x000000010380efe0\n(lldb) x/4xg 0x10380ef00\n0x10380ef00: 0x001dffff9a8b8141 0x0000000000000000\n0x10380ef10: 0x000000010380efe0 0x000000010380f220\n(lldb) x/4xw 0x10380ef00\n0x10380ef00: 0x9a8b8141 0x001dffff 0x00000000 0x00000000\n(lldb) x/4dw 0x10380ef00\n0x10380ef00: -1702133439\n0x10380ef04: 1966079\n0x10380ef08: 0\n0x10380ef0c: 0\n```\n\n打印结果中， x/3xg 0x10380ef00 打印的 `0x001dffff9a8b8141 0x0000000000000000` 部分是属于 obj 的内存。x/4xw 0x10380ef00 打印的 `0x9a8b8141 0x001dffff 0x00000000 0x00000000` 部分属于 obj 的内存。\n\n### 修改内存中的值  \nmemory  write  内存地址  数值  \n将内存中的第6个字节改成06：\n\n```\n(lldb) po obj\n<NSObject: 0x10380ef00>\n\n(lldb) memory read 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) memory write 0x10380ef06 6\n(lldb) x 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 06 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) \n```\n\npo obj 获取到对象地址 0x10380ef00，所以第6个字节的地址就是 0x10380ef06。通过 memory write 0x10380ef06 6，将 0x10380ef06 处的字节改为 6。上面👆 x 0x10380ef00 打印出的结果中可以看到，第 6 个字节成功被修改为 06。\n\n\n# Student 的本质\n定义一个继承 NSObject 的类 Student：\n\n```\n@interface Student : NSObject {\n    @public\n    int _no;\n    int _age;\n}\n@end\n\n@implementation Student\n@end\n```\n\n创建一个 Student 的实例对象：\n\n```\nStudent *stu = [[Student alloc] init];\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Student 的实现：\n\n```\nstruct Student_IMPL {\n    struct NSObject_IMPL NSObject_IVARS;\n    int _no;\n    int _age;\n};\n```\n\n因为 NSObject_IMPL 内部只有一个成员变量指针 isa，所以上面👆的代码可以写成：\n\n```\nstruct Student_IMPL {\n    Class isa;\n    int _no;\n    int _age;\n};\n```\n\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶03.png)  \n\n结构体 Student_IMPL 的成员变量大小是16字节。  \nisa（8字节）+ _no（4字节）+ _age（4字节）= Student_IMPL（16字节）。  \n\n根据地址也可以看出成员变量的大小：  \n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶01.png)  \n\n如图，指针 stu 指向的地址就是 isa 指向的地址（参考理解：数组首元素的地址就是数组的地址）。指针 isa 占8个字节，所以 _no 的地址在 isa 的地址基础上加8个字节。_no 是 Int 类型4字节，所以 _age 的地址在 _no 地址的基础上加4个字节。实例变量内部的成员变量的地址，在堆中依次往后加。\n\n打开内存图：\nDebug -> Debug Workflow -> View Memory\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶02.png)  \n因为 iOS 平台是小端模式，所以从内存中读取数据的方式是从高地址开始读取（右→左）。_no 是 0x00000004，_age 是 0x00000005：\n\n```\n(lldb) x/4xw 0x103a085d0\n0x103a085d0: 0x000011c9 0x001d8001 0x00000004 0x00000005\n```\n\n通过修改内存中的值的方式来修改 _no，查看内存：\n\n```\n(lldb) x 0x103a085d0\n0x103a085d0: c9 11 00 00 01 80 1d 00 04 00 00 00 05 00 00 00  ................\n0x103a085e0: b0 86 a0 03 01 00 00 00 f0 88 a0 03 01 00 00 00  ................\n```\n\n_no 的地址（0x103a085d0）向右数8个找到04的地址（0x103a085d8），通过 memory write 将实例对象的第8个字节 04 给为 09，打印 _no = 9。\n\n```\n(lldb) memory write 0x103a085d8 9\n(lldb) x 0x103a085d0\n0x103a085d0: c9 11 00 00 01 80 1d 00 09 00 00 00 05 00 00 00  ................\n0x103a085e0: b0 86 a0 03 01 00 00 00 f0 88 a0 03 01 00 00 00  ................\n(lldb) p stu->_no\n(int) $3 = 9\n```\n\n## 小结\n* iOS 平台是小端模式，所以从内存中读取数据的方式是从高地址开始读取。\n* 使用 memory write，可以通过修改内存中的值的方式来修改成员变量的值。\n\n# 更复杂的继承关系\n\n## 定义 Person、Student\n\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n{\n    int _no;\n}\n@end\n\n@implementation Student\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person、Student 的实现：\n\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n}; // 16 内存对齐：结构体的大小必须是最大成员大小的倍数\n\nstruct Student_IMPL {\n    struct Person_IMPL Person_IVARS; // 16\n    int _no; // 4\n}; // 16\n```\n\n继承关系图解：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶04.png)  \n\n## Person、Student 的内存大小\n\n打印 Person、Student 实例变量的大小：  \n\n```\nStudent *stu = [[Student alloc] init];\nNSLog(@\"stu - %zd\", class_getInstanceSize([Student class])); //打印结果 16\nNSLog(@\"stu - %zd\", malloc_size((__bridge const void *)stu)); //打印结果 16\n\nPerson *person = [[Person alloc] init];\nNSLog(@\"person - %zd\", class_getInstanceSize([Person class])); //打印结果 16\nNSLog(@\"person - %zd\", malloc_size((__bridge const void *)person)); //打印结果 16\n```\n\n虽然 Student 比 Person 多了一个成员变量 _no（4字节），但是 Student 和 Person 打印出来的内存大小都是16字节。\n\nPerson、Student 的内存分配图解：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶05.png)  \n\nPerson 的成员变量的内存之和是12个字节，根据内存对齐的规则，Person 的内存大小必须是内存最大的成员变量 isa（8字节）的倍数，所以分配了16字节的内存给 Person。Student 的成员变量之和是20字节，但是 Person 中有多余的4字节，所以成员变量 _no 的内存被放到了 Person 多余的内存空间里，最终分配给 Student 的内存大小为16字节。  \n\n## @property 定义属性的内存分配\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Person\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person 的实现：\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n    int _height; //4\n}; // 16 \n```\n\n## 小结\n* 子类在分配内存时，如果父类的内存空间有剩余，优先使用父类的内存空间。\n* 创建出来的实列对象的内存中只存有成员变量，不包含方法。以 Person 为例，因为不同的 Person 实例对象的方法是相同的公用的，所以方法放到类对象的方法列表里，供不同的 Person 实例对象调用。\n\n\n# 窥视 alignedInstanceSize\nclass_getInstanceSize 获取内存大小调用的是 alignedInstanceSize：\n```\n// Class's ivar size rounded up to a pointer-size boundary.\nuint32_t alignedInstanceSize() const {\n    return word_align(unalignedInstanceSize());\n}\n```\n\nalign：对齐。`word_align(unalignedInstanceSize())`：传入一个未对齐（unaligned）的内存，`word_align` 方法将其对齐后返回。\n\n\n# Person 对象的内存分配\n\n定义 Person\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _height;\n    int _no;\n}\n@end\n\n@implementation Person\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person 的实现：\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n    int _height; //4\n    int _no; //4\n}; // 24\n```\n\n创建 Person 实例变量，打印内存大小：\n```\nPerson *person = [[Person alloc] init];\nNSLog(@\"person - %zd\", sizeof(struct Person_IMPL)); //24\nNSLog(@\"person - %zd\", class_getInstanceSize([Person class])); //24\nNSLog(@\"person - %zd\", malloc_size((__bridge const void *)person)); //32\n```\n\nsizeof() 是运算符，计算类型的大小，是在编译的时候就确定的。\n\nPerson 内的成员变量的从内存图中可以确认，Person 分配的内存是32：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶06.png) \n\n## 窥视 _class_createInstanceFromZone\nalloc -> allocWithZoone -> _objc_rootAllocWithZone -> class_createInstance -> _class_createInstanceFromZone\n\n_class_createInstanceFromZone 实现：\n```\n//创建 cls 的实例对象\nstatic ALWAYS_INLINE id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,\n                              int construct_flags = OBJECT_CONSTRUCT_NONE,\n                              bool cxxConstruct = true,\n                              size_t *outAllocatedSize = nil)\n{\n    ASSERT(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocNonpointer();\n    size_t size;\n\n    size = cls->instanceSize(extraBytes); //分配空间\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    id obj;\n    if (zone) {\n        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);\n    } else {\n        obj = (id)calloc(1, size); //c语言分配内存的函数，需要分配的内存大小：size\n    }\n    if (slowpath(!obj)) {\n        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {\n            return _objc_callBadAllocHandler(cls);\n        }\n        return nil;\n    }\n\n    if (!zone && fast) {\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n        // Use raw pointer isa on the assumption that they might be\n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (fastpath(!hasCxxCtor)) {\n        return obj;\n    }\n\n    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;\n    return object_cxxConstructFromClass(obj, cls, construct_flags);\n}\n```\n\n可以看出，代码最终是调用 `obj = (id)calloc(1, size);` 创建的实列对象。而 `size = cls->instanceSize(extraBytes);` 是根据成员变量大小计算出来的需要开辟的内存大小。`instanceSize(extraBytes)` 的参数 extraBytes 是额外空间，来自 `_objc_rootAllocWithZone`，`_objc_rootAllocWithZone` 传入的 extraBytes = 0：\n```\nid\n_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)\n{\n    id obj;\n\n    if (fastpath(!zone)) {\n        obj = class_createInstance(cls, 0);\n    } else {\n        obj = class_createInstanceFromZone(cls, 0, zone);\n    }\n\n    if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);\n    return obj;\n}\n```\n\n排查完 `instanceSize(extraBytes)` 后，可以确定 `class_getInstanceSize()` 与 `malloc_size()` 获取到的内存大小不同的原因来自 calloc。\n\n# 窥视 calloc\ncalloc 是 c 语言的标准库，需要下载 [libmalloc](https://opensource.apple.com/tarballs/libmalloc/)（libmalloc-283 文件里没有 malloc.c 文件了，这里下的是 libmalloc-166.200.60.tar.gz）。\n\n打开 libmalloc 项目找到 malloc.c 文件，再找到 calloc 方法：\n```\nvoid *\ncalloc(size_t num_items, size_t size)\n{\n\tvoid *retval;\n\tretval = malloc_zone_calloc(default_zone, num_items, size);\n\tif (retval == NULL) {\n\t\terrno = ENOMEM;\n\t}\n\treturn retval;\n}\n```\n\nJump to Definition -> malloc_zone_calloc\n```\nvoid *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n{\n\tvoid *ptr;\n\tsize_t alloc_size;\n\tif (malloc_check_start && (malloc_check_counter++ >= malloc_check_start)) {\n\t\tinternal_check();\n\t}\n\tif (os_mul_overflow(num_items, size, &alloc_size) || alloc_size > MALLOC_ABSOLUTE_MAX_SIZE){\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tptr = zone->calloc(zone, num_items, size);\n\t\n\tif (malloc_logger) {\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n\t\t\t\t(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n\t}\n\treturn ptr;\n}\n```\n\n`malloc_zone_calloc` 中就是系统分配内存的具体实现。另外，在系统分配内存时有一个 `NANO_MAX_SIZE`：\n```\n#define NANO_MAX_SIZE\t\t\t256 /* Buckets sized {16, 32, 48, 64, 80, 96, 112, ...} */\n```\n\nBuckets sized：iOS 堆空间里内存分为一块一块的内存空间，大小都是16的倍数，最大的内存空间块是256。\n\n`malloc_zone_calloc` 这里也存在内存对齐原则。前面在生成结构体的时候提到过，根据内存对齐原则，结构体的大小必须是最大成员大小的倍数。而在这里，系统在分配内存时，分配的内存必须是16的倍数。因为 ios 系统为了提升内存分配的速度，固定了需要分配的内存空间块（Buckets sized）。在需要分配内存的时候，会找到最合适的内存空间块们来分配给实例对象。\n\n# 总结\n\n* 一个 NSObject 对象占用多少内存？  \nalloc 方法让系统分配了16个字节给 NSObject 对象（可以通过 malloc_size 函数获取）。  \nNSObject 对象内部只有一个成员变量，即指针 isa，所以只使用了8个字节的空间（64bit环境下，可以通过 class_getInstanceSize 函数获得）。\n\n* 创建一个实例对象，至少需要多少内存？实际上分配了多少内存？\n```\n//至少需要内存大小：\n#import <objc/runtime.h>\nclass_getInstanceSize([NSObject class]);\n\n//实际分配内存大小：\n#import <malloc/malloc.h>\nmalloc_size((__bridge const void *)obj);\n```\n\n* 内存对齐原则：结构体的大小必须是最大成员大小的倍数，系统分配内存的大小必须是固定的大小（16的倍数）。","source":"_posts/OC底层原理/OC对象的本质.md","raw":"---\ntitle: OC对象的本质\ndate: 2020-05-06 14:36:30\ntags: OC底层原理\n---\n\n思考：\n* 一个 NSObject 对象占用多少内存？ \n* 创建一个实例对象，至少需要多少内存？实际上分配了多少内存？\n\n<!-- more -->\n\n# Objective-C的本质\n\nObjective-C 代码的底层实现其实是 C\\C++ 代码，Objective-C 的面向对象是基于 C\\C++ 的数据结构(结构体)实现的。\n\n![ObjectiveC_C_C++_汇编语言_机器语言](OC对象的本质/ObjectiveC_C_C++_汇编语言_机器语言.png)\n\n## 将 Objective-C 代码转换为 C\\C++ 代码\n\n### 创建一个命令行项目\n![OC对象的本质](OC对象的本质/OC对象的本质.png)\n\n在终端打开 main.m 的位置，输入下面👇的命令生成 main.cpp 文件。因为要生成的代码包括 c/c++，所以使用 main.cpp 文件，main.cpp 文件是 c++ 文件，支持 c/c++。\n\n### 生成 main.cpp\n```\n$ clang -rewrite-objc main.m -o main.cpp\n```\n没有指定平台，默认生成的是多个平台的代码，代码量太大。\n\n### 指定生成 iphoneos 平台、arm64 架构的 main.cpp  \n指定平台：不同平台支持的代码不一样，如 Windows、mac、iOS。xcrun -sdk iphoneos：指定 iphoneos。    \n指定框架：不同框架支持的代码也不一样，模拟器(i386)、32bit(armv7)、64bit（arm64）。-arch arm64：指定 arm64 架构。\n```\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp\n```\n\n报错：xcrun: error: SDK \"iphoneos\" cannot be located  \n解决1：给Xcode命令行工具指定路径👇\n```\n$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/\n```\n\n（如果需要链接其他框架，使用-framework参数。比如-framework UIKit。(未验证)）\n```\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp -framework UIKit\n```\n\n### 取消 Xcode 对 main-arm64.cpp 的文件编译  \n生成的 main-arm64.cpp 文件添加到项目后，运行会报错。main-arm64.cpp 是临时生成的，内部有一个 main 函数，没做适配。 \n\n解决：删除 Build Phases -> Compile Sources -> main-arm64.cpp\n![main-arm64](OC对象的本质/取消编译main_arm64_cpp.png)\n\n\n\n\n# NSObject 的底层实现\n\n* 思考：一个OC对象在内存中是如何布局的？\n\n## NSObject 在 OC 中的定义：\n```\n@interface NSObject <NSObject> {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"\n    Class isa  OBJC_ISA_AVAILABILITY;\n#pragma clang diagnostic pop\n}\n\n//简化后：\n@interface NSObject {\n    Class isa;\n}\n```\n\n## 在 c++ 中的定义：\n```\nstruct NSObject_IMPL {\n    Class isa; // 8个字节\n};\n```\nClass 是指向结构体的指针：typedef struct objc_class *Class。  \nIMPL 是 implementation 的简写。结构体中只有一个成员变量，所以这个结构体在内存中占用的大小就是指针 isa 的大小。\n\n![OC对象的本质02](OC对象的本质/OC对象的本质02.png)\n\n## 打印 NSObject 实例对象的成员变量所占用的大小 >> 8\n```\n//1.导入头文件\n#import <objc/runtime.h>\n\n//2.打印，结果 8\nNSLog(@\"%zd\", class_getInstanceSize([NSObject class]));\n```\n\n## 打印 obj 指针所指向内存的大小 >> 16\n```\n//1.导入头文件\n#import <malloc/malloc.h>\n\n//2.打印，结果 16\nNSLog(@\"%zd\", malloc_size((__bridge const void *)obj));\n```\n__bridge 可以实现 Objective-C 与 C 语言变量 和 Objective-C 与 Core Foundation 对象之间的互相转换。  \n\n\n## 窥视 class_getInstanceSize\n下载 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。  \n打开源码搜索 class_getInstanceSize，找到 objc-class.mm 文件中 class_getInstanceSize 的实现代码。\n```\nsize_t class_getInstanceSize(Class cls)\n{\n    if (!cls) return 0;\n    return cls->alignedInstanceSize();\n}\n```\nJump to Definition -> alignedInstanceSize：\n```\n// Class's ivar size rounded up to a pointer-size boundary.\nuint32_t alignedInstanceSize() const {\n    return word_align(unalignedInstanceSize());\n}\n```\n翻译过来就是，class_getInstanceSize 内部根据成员变量的大小和内存对齐原则得到 NSObject 实例对象里成员变量所占用的内存大小。\n\n👉 内存对齐原则：结构体的大小必须是最大成员大小的倍数。\n\n## 窥视 alloc\nalloc 的内部实现是 allocWithZone，在源码中搜索 allocWithZone：\n\n```\nid\n_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)\n{\n    id obj;\n\n    if (fastpath(!zone)) {\n        obj = class_createInstance(cls, 0); //参数：类，额外空间0\n    } else {\n        obj = class_createInstanceFromZone(cls, 0, zone);\n    }\n\n    if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);\n    return obj;\n}\n```\n\nJump to Definition -> class_createInstance：\n\n```\nid\nclass_createInstance(Class cls, size_t extraBytes)\n{\n    if (!cls) return nil;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n}\n```\n\nJump to Definition -> _class_createInstanceFromZone：\n\n```\n//创建 cls 的实例对象\nstatic ALWAYS_INLINE id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,\n                              int construct_flags = OBJECT_CONSTRUCT_NONE,\n                              bool cxxConstruct = true,\n                              size_t *outAllocatedSize = nil)\n{\n    ASSERT(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocNonpointer();\n    size_t size;\n\n    size = cls->instanceSize(extraBytes); //分配内存空间方法👇\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    id obj;\n    if (zone) {\n        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);\n    } else {\n        obj = (id)calloc(1, size); //c语言分配内存的函数，分配空间：size\n    }\n    if (slowpath(!obj)) {\n        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {\n            return _objc_callBadAllocHandler(cls);\n        }\n        return nil;\n    }\n\n    if (!zone && fast) {\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n        // Use raw pointer isa on the assumption that they might be\n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (fastpath(!hasCxxCtor)) {\n        return obj;\n    }\n\n    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;\n    return object_cxxConstructFromClass(obj, cls, construct_flags);\n}\n```\n\nJump to Definition -> instanceSize：\n\n```\nsize_t instanceSize(size_t extraBytes) const {\n    if (fastpath(cache.hasFastInstanceSize(extraBytes))) {\n        return cache.fastInstanceSize(extraBytes);\n    }\n\n    size_t size = alignedInstanceSize() + extraBytes;\n    // CF requires all objects be at least 16 bytes.\n    if (size < 16) size = 16; //至少16个字节\n    return size;\n}\n```\n可以看到，创建的实例对象的大小最终由 instanceSize 方法实现。内存大小至少16个字节，CoreFoundation 框架内部就是这么硬性规定的。\n\n## 小结：  \n\n```\nNSObject *obj = [[NSObject alloc] init];\n```\n\n* 上面👆这句代码实际上是在内存中生成了一个 c 语言定义的结构体，结构体内有一个类型为 Class 的 isa 指针，结构体的大小 8 个字节。Class 是一个指向结构体的指针。\n* 创建的实例对象的大小至少16个字节.\n\n\n# 查看实例变量的内存的方法\n\n## 通过 Xcode 工具查看对象内存  \n打开 Debug -> Debug Workflow -> View Memory，在 Address 输入对象的地址。  \n![OC对象的本质03](OC对象的本质/OC对象的本质03.png)\n\n\n## 常用 LLDB 指令\n### print、p：打印\n\n```\n(lldb) print obj\n(NSObject *) $0 = 0x000000010380ef00\n(lldb) p obj\n(NSObject *) $1 = 0x000000010380ef00\n```\n\n### po：打印对象\n\n```\n(lldb) po obj\n<NSObject: 0x10380ef00>\n```\n\n### 格式  \nx是16进制，f是浮点，d是10进制\n\n### 字节大小  \nb：byte 1字节，h：half word 2字节  \nw：word 4字节，g：giant word 8字节\n\n### 读取内存  \n* memory read/数量格式字节数 内存地址\n\nmemory read 内存地址\n\n```\n(lldb) memory read 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ ....... \n```\n\nx/数量格式字节数 内存地址\n\n```\n(lldb) x 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) x/3xg 0x10380ef00\n0x10380ef00: 0x001dffff9a8b8141 0x0000000000000000\n0x10380ef10: 0x000000010380efe0\n(lldb) x/4xg 0x10380ef00\n0x10380ef00: 0x001dffff9a8b8141 0x0000000000000000\n0x10380ef10: 0x000000010380efe0 0x000000010380f220\n(lldb) x/4xw 0x10380ef00\n0x10380ef00: 0x9a8b8141 0x001dffff 0x00000000 0x00000000\n(lldb) x/4dw 0x10380ef00\n0x10380ef00: -1702133439\n0x10380ef04: 1966079\n0x10380ef08: 0\n0x10380ef0c: 0\n```\n\n打印结果中， x/3xg 0x10380ef00 打印的 `0x001dffff9a8b8141 0x0000000000000000` 部分是属于 obj 的内存。x/4xw 0x10380ef00 打印的 `0x9a8b8141 0x001dffff 0x00000000 0x00000000` 部分属于 obj 的内存。\n\n### 修改内存中的值  \nmemory  write  内存地址  数值  \n将内存中的第6个字节改成06：\n\n```\n(lldb) po obj\n<NSObject: 0x10380ef00>\n\n(lldb) memory read 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 1d 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) memory write 0x10380ef06 6\n(lldb) x 0x10380ef00\n0x10380ef00: 41 81 8b 9a ff ff 06 00 00 00 00 00 00 00 00 00  A...............\n0x10380ef10: e0 ef 80 03 01 00 00 00 20 f2 80 03 01 00 00 00  ........ .......\n(lldb) \n```\n\npo obj 获取到对象地址 0x10380ef00，所以第6个字节的地址就是 0x10380ef06。通过 memory write 0x10380ef06 6，将 0x10380ef06 处的字节改为 6。上面👆 x 0x10380ef00 打印出的结果中可以看到，第 6 个字节成功被修改为 06。\n\n\n# Student 的本质\n定义一个继承 NSObject 的类 Student：\n\n```\n@interface Student : NSObject {\n    @public\n    int _no;\n    int _age;\n}\n@end\n\n@implementation Student\n@end\n```\n\n创建一个 Student 的实例对象：\n\n```\nStudent *stu = [[Student alloc] init];\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Student 的实现：\n\n```\nstruct Student_IMPL {\n    struct NSObject_IMPL NSObject_IVARS;\n    int _no;\n    int _age;\n};\n```\n\n因为 NSObject_IMPL 内部只有一个成员变量指针 isa，所以上面👆的代码可以写成：\n\n```\nstruct Student_IMPL {\n    Class isa;\n    int _no;\n    int _age;\n};\n```\n\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶03.png)  \n\n结构体 Student_IMPL 的成员变量大小是16字节。  \nisa（8字节）+ _no（4字节）+ _age（4字节）= Student_IMPL（16字节）。  \n\n根据地址也可以看出成员变量的大小：  \n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶01.png)  \n\n如图，指针 stu 指向的地址就是 isa 指向的地址（参考理解：数组首元素的地址就是数组的地址）。指针 isa 占8个字节，所以 _no 的地址在 isa 的地址基础上加8个字节。_no 是 Int 类型4字节，所以 _age 的地址在 _no 地址的基础上加4个字节。实例变量内部的成员变量的地址，在堆中依次往后加。\n\n打开内存图：\nDebug -> Debug Workflow -> View Memory\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶02.png)  \n因为 iOS 平台是小端模式，所以从内存中读取数据的方式是从高地址开始读取（右→左）。_no 是 0x00000004，_age 是 0x00000005：\n\n```\n(lldb) x/4xw 0x103a085d0\n0x103a085d0: 0x000011c9 0x001d8001 0x00000004 0x00000005\n```\n\n通过修改内存中的值的方式来修改 _no，查看内存：\n\n```\n(lldb) x 0x103a085d0\n0x103a085d0: c9 11 00 00 01 80 1d 00 04 00 00 00 05 00 00 00  ................\n0x103a085e0: b0 86 a0 03 01 00 00 00 f0 88 a0 03 01 00 00 00  ................\n```\n\n_no 的地址（0x103a085d0）向右数8个找到04的地址（0x103a085d8），通过 memory write 将实例对象的第8个字节 04 给为 09，打印 _no = 9。\n\n```\n(lldb) memory write 0x103a085d8 9\n(lldb) x 0x103a085d0\n0x103a085d0: c9 11 00 00 01 80 1d 00 09 00 00 00 05 00 00 00  ................\n0x103a085e0: b0 86 a0 03 01 00 00 00 f0 88 a0 03 01 00 00 00  ................\n(lldb) p stu->_no\n(int) $3 = 9\n```\n\n## 小结\n* iOS 平台是小端模式，所以从内存中读取数据的方式是从高地址开始读取。\n* 使用 memory write，可以通过修改内存中的值的方式来修改成员变量的值。\n\n# 更复杂的继承关系\n\n## 定义 Person、Student\n\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n{\n    int _no;\n}\n@end\n\n@implementation Student\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person、Student 的实现：\n\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n}; // 16 内存对齐：结构体的大小必须是最大成员大小的倍数\n\nstruct Student_IMPL {\n    struct Person_IMPL Person_IVARS; // 16\n    int _no; // 4\n}; // 16\n```\n\n继承关系图解：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶04.png)  \n\n## Person、Student 的内存大小\n\n打印 Person、Student 实例变量的大小：  \n\n```\nStudent *stu = [[Student alloc] init];\nNSLog(@\"stu - %zd\", class_getInstanceSize([Student class])); //打印结果 16\nNSLog(@\"stu - %zd\", malloc_size((__bridge const void *)stu)); //打印结果 16\n\nPerson *person = [[Person alloc] init];\nNSLog(@\"person - %zd\", class_getInstanceSize([Person class])); //打印结果 16\nNSLog(@\"person - %zd\", malloc_size((__bridge const void *)person)); //打印结果 16\n```\n\n虽然 Student 比 Person 多了一个成员变量 _no（4字节），但是 Student 和 Person 打印出来的内存大小都是16字节。\n\nPerson、Student 的内存分配图解：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶05.png)  \n\nPerson 的成员变量的内存之和是12个字节，根据内存对齐的规则，Person 的内存大小必须是内存最大的成员变量 isa（8字节）的倍数，所以分配了16字节的内存给 Person。Student 的成员变量之和是20字节，但是 Person 中有多余的4字节，所以成员变量 _no 的内存被放到了 Person 多余的内存空间里，最终分配给 Student 的内存大小为16字节。  \n\n## @property 定义属性的内存分配\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n}\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Person\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person 的实现：\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n    int _height; //4\n}; // 16 \n```\n\n## 小结\n* 子类在分配内存时，如果父类的内存空间有剩余，优先使用父类的内存空间。\n* 创建出来的实列对象的内存中只存有成员变量，不包含方法。以 Person 为例，因为不同的 Person 实例对象的方法是相同的公用的，所以方法放到类对象的方法列表里，供不同的 Person 实例对象调用。\n\n\n# 窥视 alignedInstanceSize\nclass_getInstanceSize 获取内存大小调用的是 alignedInstanceSize：\n```\n// Class's ivar size rounded up to a pointer-size boundary.\nuint32_t alignedInstanceSize() const {\n    return word_align(unalignedInstanceSize());\n}\n```\n\nalign：对齐。`word_align(unalignedInstanceSize())`：传入一个未对齐（unaligned）的内存，`word_align` 方法将其对齐后返回。\n\n\n# Person 对象的内存分配\n\n定义 Person\n```\n@interface Person : NSObject\n{\n    @public\n    int _age;\n    int _height;\n    int _no;\n}\n@end\n\n@implementation Person\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Person 的实现：\n```\nstruct Person_IMPL {\n    struct NSObject_IMPL NSObject_IVARS; // 8\n    int _age; // 4\n    int _height; //4\n    int _no; //4\n}; // 24\n```\n\n创建 Person 实例变量，打印内存大小：\n```\nPerson *person = [[Person alloc] init];\nNSLog(@\"person - %zd\", sizeof(struct Person_IMPL)); //24\nNSLog(@\"person - %zd\", class_getInstanceSize([Person class])); //24\nNSLog(@\"person - %zd\", malloc_size((__bridge const void *)person)); //32\n```\n\nsizeof() 是运算符，计算类型的大小，是在编译的时候就确定的。\n\nPerson 内的成员变量的从内存图中可以确认，Person 分配的内存是32：\n![OC对象的本质进阶01](OC对象的本质/OC对象的本质进阶06.png) \n\n## 窥视 _class_createInstanceFromZone\nalloc -> allocWithZoone -> _objc_rootAllocWithZone -> class_createInstance -> _class_createInstanceFromZone\n\n_class_createInstanceFromZone 实现：\n```\n//创建 cls 的实例对象\nstatic ALWAYS_INLINE id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,\n                              int construct_flags = OBJECT_CONSTRUCT_NONE,\n                              bool cxxConstruct = true,\n                              size_t *outAllocatedSize = nil)\n{\n    ASSERT(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocNonpointer();\n    size_t size;\n\n    size = cls->instanceSize(extraBytes); //分配空间\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    id obj;\n    if (zone) {\n        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);\n    } else {\n        obj = (id)calloc(1, size); //c语言分配内存的函数，需要分配的内存大小：size\n    }\n    if (slowpath(!obj)) {\n        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {\n            return _objc_callBadAllocHandler(cls);\n        }\n        return nil;\n    }\n\n    if (!zone && fast) {\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n        // Use raw pointer isa on the assumption that they might be\n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (fastpath(!hasCxxCtor)) {\n        return obj;\n    }\n\n    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;\n    return object_cxxConstructFromClass(obj, cls, construct_flags);\n}\n```\n\n可以看出，代码最终是调用 `obj = (id)calloc(1, size);` 创建的实列对象。而 `size = cls->instanceSize(extraBytes);` 是根据成员变量大小计算出来的需要开辟的内存大小。`instanceSize(extraBytes)` 的参数 extraBytes 是额外空间，来自 `_objc_rootAllocWithZone`，`_objc_rootAllocWithZone` 传入的 extraBytes = 0：\n```\nid\n_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)\n{\n    id obj;\n\n    if (fastpath(!zone)) {\n        obj = class_createInstance(cls, 0);\n    } else {\n        obj = class_createInstanceFromZone(cls, 0, zone);\n    }\n\n    if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);\n    return obj;\n}\n```\n\n排查完 `instanceSize(extraBytes)` 后，可以确定 `class_getInstanceSize()` 与 `malloc_size()` 获取到的内存大小不同的原因来自 calloc。\n\n# 窥视 calloc\ncalloc 是 c 语言的标准库，需要下载 [libmalloc](https://opensource.apple.com/tarballs/libmalloc/)（libmalloc-283 文件里没有 malloc.c 文件了，这里下的是 libmalloc-166.200.60.tar.gz）。\n\n打开 libmalloc 项目找到 malloc.c 文件，再找到 calloc 方法：\n```\nvoid *\ncalloc(size_t num_items, size_t size)\n{\n\tvoid *retval;\n\tretval = malloc_zone_calloc(default_zone, num_items, size);\n\tif (retval == NULL) {\n\t\terrno = ENOMEM;\n\t}\n\treturn retval;\n}\n```\n\nJump to Definition -> malloc_zone_calloc\n```\nvoid *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n{\n\tvoid *ptr;\n\tsize_t alloc_size;\n\tif (malloc_check_start && (malloc_check_counter++ >= malloc_check_start)) {\n\t\tinternal_check();\n\t}\n\tif (os_mul_overflow(num_items, size, &alloc_size) || alloc_size > MALLOC_ABSOLUTE_MAX_SIZE){\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tptr = zone->calloc(zone, num_items, size);\n\t\n\tif (malloc_logger) {\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n\t\t\t\t(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n\t}\n\treturn ptr;\n}\n```\n\n`malloc_zone_calloc` 中就是系统分配内存的具体实现。另外，在系统分配内存时有一个 `NANO_MAX_SIZE`：\n```\n#define NANO_MAX_SIZE\t\t\t256 /* Buckets sized {16, 32, 48, 64, 80, 96, 112, ...} */\n```\n\nBuckets sized：iOS 堆空间里内存分为一块一块的内存空间，大小都是16的倍数，最大的内存空间块是256。\n\n`malloc_zone_calloc` 这里也存在内存对齐原则。前面在生成结构体的时候提到过，根据内存对齐原则，结构体的大小必须是最大成员大小的倍数。而在这里，系统在分配内存时，分配的内存必须是16的倍数。因为 ios 系统为了提升内存分配的速度，固定了需要分配的内存空间块（Buckets sized）。在需要分配内存的时候，会找到最合适的内存空间块们来分配给实例对象。\n\n# 总结\n\n* 一个 NSObject 对象占用多少内存？  \nalloc 方法让系统分配了16个字节给 NSObject 对象（可以通过 malloc_size 函数获取）。  \nNSObject 对象内部只有一个成员变量，即指针 isa，所以只使用了8个字节的空间（64bit环境下，可以通过 class_getInstanceSize 函数获得）。\n\n* 创建一个实例对象，至少需要多少内存？实际上分配了多少内存？\n```\n//至少需要内存大小：\n#import <objc/runtime.h>\nclass_getInstanceSize([NSObject class]);\n\n//实际分配内存大小：\n#import <malloc/malloc.h>\nmalloc_size((__bridge const void *)obj);\n```\n\n* 内存对齐原则：结构体的大小必须是最大成员大小的倍数，系统分配内存的大小必须是固定的大小（16的倍数）。","slug":"OC底层原理/OC对象的本质","published":1,"updated":"2023-08-22T09:52:13.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgs4000jaq7k6dc0xf0v"},{"title":"Category 的实现原理","date":"2020-05-18T07:09:22.000Z","_content":"\n思考：\n* Category 和 Class Extension 的区别是什么？\n* Category 的实现原理  \n\n<!-- more -->\n\n# Category 的底层结构\n\n* Category 在编译完成后就变成了一个 _category_t 结构体，里面存储这分类的所有信息。\n* 在程序运行时通过 Runtime 加载所有 _category_t 的数据，把所有 _category_t 的数据（方法、属性、协议）合并到一个大数组中。\n* 合并时先扩充内存，然后将类对象里面的原有数据向后移动，再将分类数据（方法、属性、协议）插入到前排。\n* 靠后被编译到的 _category_t 数据（方法、属性、协议），因为在这个大数组的前排，所以会被优先调用到。  \n\n## 定义 Persion+Test\n```\n@interface Persion (Test)\n- (void)run;\n- (void)test;\n+ (void)test2;\n@end\n\n@implementation Persion (Test)\n- (void)run\n{\n    NSLog(@\"Person (Test) - run\");\n}\n- (void)test\n{\n    NSLog(@\"test\");\n}\n+ (void)test2\n{\n    \n}\n@end\n```\n\n## Persion+Test.cpp\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Persion+Test 的实现：\n```\n//_category_t 结构体\nstruct _category_t {\n\tconst char *name; //类名\n\tstruct _class_t *cls; //父类\n\tconst struct _method_list_t *instance_methods; //对象方法列表\n\tconst struct _method_list_t *class_methods; //类方法列表\n\tconst struct _protocol_list_t *protocols; //协议列表\n\tconst struct _prop_list_t *properties; //属性列表\n};\nextern \"C\" __declspec(dllimport) struct objc_cache _objc_empty_cache;\n#pragma warning(disable:4273)\n\n//Category 类对象的对象方法列表\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[2];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t2,\n\t{{(struct objc_selector *)\"run\", \"v16@0:8\", (void *)_I_Persion_Test_run},\n\t{(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_Persion_Test_test}}\n};\n\n//Category 类对象的类方法列表\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_CLASS_METHODS_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t1,\n\t{{(struct objc_selector *)\"test2\", \"v16@0:8\", (void *)_C_Persion_Test_test2}}\n};\n\nextern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_Persion;\n\n//Persion+Test 分类的结构体\nstatic struct _category_t _OBJC_$_CATEGORY_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"Persion\", //类名\n\t0, // &OBJC_CLASS_$_Persion,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Persion_$_Test, //对象方法列表\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_CLASS_METHODS_Persion_$_Test, //类方法列表\n\t0, //协议列表\n\t0, //属性列表\n};\nstatic void OBJC_CATEGORY_SETUP_$_Persion_$_Test(void ) {\n\t_OBJC_$_CATEGORY_Persion_$_Test.cls = &OBJC_CLASS_$_Persion;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n\t(void *)&OBJC_CATEGORY_SETUP_$_Persion_$_Test,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Persion_$_Test,\n};\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n# Category 的加载处理过程\n\n## objc4 源码解读过程\n* objc-os.mm  \n_objc_init  \nmap_images  \nmap_images_nolock\n\n* objc-runtime-new.mm  \n_read_images  \nremethodizeClass  \nattachCategories  \nattachLists  \nrealloc、memmove、 memcpy\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。找到运行时入口 objc-os.mm 文件，打开文件找到运行时的初始化方法 `void _objc_init(void)` 方法：\n\n### _objc_init\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init(); //设置系统的环境变量\n    tls_init(); //线程相关的处理\n    static_init(); //运行C++静态构造函数\n    runtime_init();\n    exception_init(); //注册异常的回调\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image); //调用dyld的函数注册一个回调，并执行回调函数。\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n#### map_images\nJump To Definition -> map_images:\n```\nvoid\nmap_images(unsigned count, const char * const paths[],\n           const struct mach_header * const mhdrs[])\n{\n    mutex_locker_t lock(runtimeLock);\n    return map_images_nolock(count, paths, mhdrs);\n}\n```\nmap_images 方法的主要作用是处理由dyld映射的镜像文件.  \n\n#### map_images_nolock\nJump To Definition -> map_images_nolock：\n```\nvoid \nmap_images_nolock(unsigned mhCount, const char * const mhPaths[],\n                  const struct mach_header * const mhdrs[])\n{\n    ...\n\t...\n\t...//一堆方法\n\n    if (hCount > 0) {\n        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);\n    }\n\n    firstTime = NO;\n    \n    // Call image load funcs after everything is set up.\n    for (auto func : loadImageFuncs) {\n        for (uint32_t i = 0; i < mhCount; i++) {\n            func(mhdrs[i]);\n        }\n    }\n}\n```\n\n_read_images：images 是模块/镜像的意思。该方法是读取模块用的，比如读取类信息、分类信息等。  \n\n### _read_images\nJump To Definition -> _read_images：\n```\nvoid _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)\n{\n    ...\n\t...\n\t...//一堆方法\n\n    // Category discovery MUST BE Late to avoid potential races\n    // when other threads call the new category code before\n    // this thread finishes its fixups.\n\n    // +load handled by prepare_load_methods()\n\n    // Realize non-lazy classes (for +load methods and static instances)\n    for (EACH_HEADER) {\n        classref_t const *classlist = \n            _getObjc2NonlazyClassList(hi, &count); // 获取分类数组\n        for (i = 0; i < count; i++) {\n            Class cls = remapClass(classlist[i]); //通过 remapClass 获取类对应的指针\n            if (!cls) continue;\n\n            addClassTableEntry(cls);\n\n            if (cls->isSwiftStable()) {\n                if (cls->swiftMetadataInitializer()) {\n                    _objc_fatal(\"Swift class %s with a metadata initializer \"\n                                \"is not allowed to be non-lazy\",\n                                cls->nameForLogging());\n                }\n                // fixme also disallow relocatable classes\n                // We can't disallow all Swift classes because of\n                // classes like Swift.__EmptyArrayStorage\n            }\n            realizeClassWithoutSwift(cls, nil);\n        }\n    }\n\t\n\t...\n\t...\n\t...//一堆方法\n}\n```\n\n上面👆代码是 _read_images 处理 Category 的核心代码，首先通过 _getObjc2NonlazyClassList 方法获取 Category 数组，遍历 Category 数组通过 remapClass 获取分类对应的指针，作为参数调用 realizeClassWithoutSwift 方法。\n\n#### realizeClassWithoutSwift\nJump To Definition -> realizeClassWithoutSwift：\n```\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n\t...\n\t...\n\t...//一堆方法\n\n    // Attach categories\n    methodizeClass(cls, previously);\n\n    return cls;\n}\n```\n\nrealizeClassWithoutSwift 方法内部进过一顿骚操作，最后调用 methodizeClass 方法开始加载分类信息。\n\nAttach categories：将分类信息附加到类对象里。  \n\n#### methodizeClass\nJump To Definition -> methodizeClass：\n```\nstatic void methodizeClass(Class cls, Class previously)\n{\n    runtimeLock.assertLocked();\n\n    bool isMeta = cls->isMetaClass(); //是否是元类对象\n    auto rw = cls->data();\n    auto ro = rw->ro();\n    auto rwe = rw->ext();\n\n    // Methodizing for the first time\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: methodizing class '%s' %s\", \n                     cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n    }\n\n    // Install methods and properties that the class implements itself.\n    // 方法数组\n    method_list_t *list = ro->baseMethods();\n    if (list) {\n        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));\n        if (rwe) rwe->methods.attachLists(&list, 1);\n    }\n    \n    // 属性数组\n    property_list_t *proplist = ro->baseProperties;\n    if (rwe && proplist) {\n        rwe->properties.attachLists(&proplist, 1);\n    }\n    \n    // 协议数组\n    protocol_list_t *protolist = ro->baseProtocols;\n    if (rwe && protolist) {\n        rwe->protocols.attachLists(&protolist, 1);\n    }\n\n    // Root classes get bonus method implementations if they don't have \n    // them already. These apply before category replacements.\n    if (cls->isRootMetaclass()) {\n        // root metaclass\n        addMethod(cls, @selector(initialize), (IMP)&objc_noop_imp, \"\", NO);\n    }\n    \n    // 添加分类方法、属性、协议数据\n    // Attach categories.\n    if (previously) {\n        if (isMeta) {\n            objc::unattachedCategories.attachToClass(cls, previously,\n                                                     ATTACH_METACLASS);\n        } else {\n            // When a class relocates, categories with class methods\n            // may be registered on the class itself rather than on\n            // the metaclass. Tell attachToClass to look for those.\n            objc::unattachedCategories.attachToClass(cls, previously,\n                                                     ATTACH_CLASS_AND_METACLASS);\n        }\n    }\n    objc::unattachedCategories.attachToClass(cls, cls,\n                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);\n\n#if DEBUG\n    // Debug: sanity-check all SELs; log method list contents\n    for (const auto& meth : rw->methods()) {\n        if (PrintConnecting) {\n            _objc_inform(\"METHOD %c[%s %s]\", isMeta ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(meth.name));\n        }\n        ASSERT(sel_registerName(sel_getName(meth.name)) == meth.name); \n    }\n#endif\n}\n```\nInstall methods and properties that the class implements itself. 可以看出该方法是在加载类对象自己内部的信息。分别针对方法数组、属性数组和协议数组调用 attachLists 方法，将信息添加到类对象里。\n\n#### attachToClass\nJump To Definition -> attachToClass:\n```\nvoid attachToClass(Class cls, Class previously, int flags)\n    {\n        runtimeLock.assertLocked();\n        ASSERT((flags & ATTACH_CLASS) ||\n               (flags & ATTACH_METACLASS) ||\n               (flags & ATTACH_CLASS_AND_METACLASS));\n\n        auto &map = get();\n        auto it = map.find(previously);\n\n        if (it != map.end()) {\n            category_list &list = it->second;\n            if (flags & ATTACH_CLASS_AND_METACLASS) {\n                int otherFlags = flags & ~ATTACH_CLASS_AND_METACLASS;\n                attachCategories(cls, list.array(), list.count(), otherFlags | ATTACH_CLASS);\n                attachCategories(cls->ISA(), list.array(), list.count(), otherFlags | ATTACH_METACLASS);\n            } else {\n                attachCategories(cls, list.array(), list.count(), flags);\n            }\n            map.erase(it);\n        }\n    }\n```\n\n#### attachCategories\nJump To Definition -> attachCategories:\n```\nstatic void\nattachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,\n                 int flags)\n{\n    if (slowpath(PrintReplacedMethods)) {\n        printReplacements(cls, cats_list, cats_count);\n    }\n    if (slowpath(PrintConnecting)) {\n        _objc_inform(\"CLASS: attaching %d categories to%s class '%s'%s\",\n                     cats_count, (flags & ATTACH_EXISTING) ? \" existing\" : \"\",\n                     cls->nameForLogging(), (flags & ATTACH_METACLASS) ? \" (meta)\" : \"\");\n    }\n\n    /*\n     * Only a few classes have more than 64 categories during launch.\n     * This uses a little stack, and avoids malloc.\n     *\n     * Categories must be added in the proper order, which is back\n     * to front. To do that with the chunking, we iterate cats_list\n     * from front to back, build up the local buffers backwards,\n     * and call attachLists on the chunks. attachLists prepends the\n     * lists, so the final result is in the expected order.\n     */\n    constexpr uint32_t ATTACH_BUFSIZ = 64;\n    method_list_t   *mlists[ATTACH_BUFSIZ];\n    property_list_t *proplists[ATTACH_BUFSIZ];\n    protocol_list_t *protolists[ATTACH_BUFSIZ];\n\n    uint32_t mcount = 0;\n    uint32_t propcount = 0;\n    uint32_t protocount = 0;\n    bool fromBundle = NO;\n    bool isMeta = (flags & ATTACH_METACLASS);\n    auto rwe = cls->data()->extAllocIfNeeded();\n\n    for (uint32_t i = 0; i < cats_count; i++) {\n        \n        // 取出某个分类 entry 是 category_t 类型\n        auto& entry = cats_list[i];\n        \n        // 方法数组\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            if (mcount == ATTACH_BUFSIZ) {\n                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n                rwe->methods.attachLists(mlists, mcount);\n                mcount = 0;\n            }\n            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;\n            fromBundle |= entry.hi->isBundle();\n        }\n        \n        // 属性数组\n        property_list_t *proplist =\n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            if (propcount == ATTACH_BUFSIZ) {\n                rwe->properties.attachLists(proplists, propcount);\n                propcount = 0;\n            }\n            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;\n        }\n        \n        // 协议数组\n        protocol_list_t *protolist = entry.cat->protocolsForMeta(isMeta);\n        if (protolist) {\n            if (protocount == ATTACH_BUFSIZ) {\n                rwe->protocols.attachLists(protolists, protocount);\n                protocount = 0;\n            }\n            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;\n        }\n    }\n\n    if (mcount > 0) {\n        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);\n        rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);\n        if (flags & ATTACH_EXISTING) flushCaches(cls);\n    }\n\n    rwe->properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);\n\n    rwe->protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);\n}\n```\n\n分别针对方法数组、属性数组和协议数组调用 attachLists 方法，将分类信息添加到原类对象里。\n\n#### attachLists\nJump To Definition -> attachLists:\n```\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count; // 原内存空间大小\n            uint32_t newCount = oldCount + addedCount; // 新内存空间大小\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); // 重新分配内存空间\n            array()->count = newCount;\n            memmove(array()->lists + addedCount, array()->lists, \n                    oldCount * sizeof(array()->lists[0])); // 调整内存格式\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0])); // 拷贝分类信息\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n#### realloc、memmove、memcpy\nattachLists 方法内部\n1.通过参数 addedCount 确定需要增加的内存空间 newCount，然后通过 realloc 方法重新分配空间。  \n2.空间增加后，通过 memmove 方法将类对象里的信息往后移动 addedCount 距离，把前排 addedCount 大小的空间空出来留给将要添加进来的分类信息。  \n![Category的实现原理01](Category的实现原理/Category的实现原理02.png)\n\n3.类对象的前排空间空出来后，再通过 memcpy 方法将分类信息拷贝到该空间里。\n![Category的实现原理01](Category的实现原理/Category的实现原理03.png)\n\n## Category 的编译顺序\n原文件 Persion.m 最先编译，之后添加的分类按照添加顺序，优先编译后来添加的分类。添加顺序：\n![Category的实现原理01](Category的实现原理/Category的实现原理01.png)\n\n如图编译顺序按照 Compile Sources 里的顺序，为 Persion.m -> Persion+Test.m -> Persion+Demo.m。如果 Persion.m、Persion+Test.m、Persion+Demo.m 中有相同的方法，后编译的类中的方法会优先于先编译的类中的方法（不是覆盖，只是优先被查询到）。\n\n调用日志：\n![Category的实现原理01](Category的实现原理/Category的实现原理04.png)\n\n可以看到 Persion.m 被优先编译，其次是后来添加的 Persion+Test.m，第三个编译的是 最后添加的 Persion+Demo.m。添加顺序决定编译顺序只对分类有效，Persion.m 一定是最先编译的，这一点通过 methodizeClass 方法也能看出来，先处理类对象，再处理分类。\n\n# Class Extension 的实现原理\n\n## 定义 Persion()\n```\n@interface Persion : NSObject\n@property (nonatomic, copy) NSString *categoryTest1;\n- (void)run;\n- (void)test;\n+ (void)test2;\n@end\n\n@interface Persion()\n@property (nonatomic, copy) NSString *categoryTest2;\n@end\n\n@implementation Persion\n- (void)run\n{\n    NSLog(@\"Person - run\");\n}\n- (void)test\n{\n    NSLog(@\"test\");\n}\n+ (void)test2\n{\n    \n}\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Persion 的实现：\n```\nextern \"C\" unsigned long OBJC_IVAR_$_Persion$_categoryTest1;\nextern \"C\" unsigned long OBJC_IVAR_$_Persion$_categoryTest2;\nstruct Persion_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tNSString * _Nonnull _categoryTest1;\n\tNSString *_categoryTest2;\n};\n```\n\n上面👆这块代码可以看到，在 Persion() 中定义的 categoryTest2 已经包含在类 Persion 类对象的结构体里面了。可以证明 Class Extension 在编译的时候，它的数据就已经包含在类信息中了。从实现上来看，Class Extension 不应该叫做匿名分类，叫类扩展更适合。\n\n## 小结\n* 运行时入口 objc-os.mm，初始化方法 void _objc_init(void) 方法。\n* objc4 的代码虽然改了，但是实现原理还是没变。\n\n# 总结\n* Category 的实现原理  \nCategory 编译之后的底层结构是 struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息，在程序运行的时候，runtime 会将 Category 的数据，合并到类信息中（类对象、元类对象中）。\n* Category 和 Class Extension 的区别是什么？  \nClass Extension 在编译的时候，它的数据就已经包含在类信息中。Category 是在运行时，才会将数据合并到类信息中。\n","source":"_posts/OC底层原理/Category的实现原理.md","raw":"---\ntitle: Category 的实现原理\ndate: 2020-05-18 15:09:22\ntags: OC底层原理\n---\n\n思考：\n* Category 和 Class Extension 的区别是什么？\n* Category 的实现原理  \n\n<!-- more -->\n\n# Category 的底层结构\n\n* Category 在编译完成后就变成了一个 _category_t 结构体，里面存储这分类的所有信息。\n* 在程序运行时通过 Runtime 加载所有 _category_t 的数据，把所有 _category_t 的数据（方法、属性、协议）合并到一个大数组中。\n* 合并时先扩充内存，然后将类对象里面的原有数据向后移动，再将分类数据（方法、属性、协议）插入到前排。\n* 靠后被编译到的 _category_t 数据（方法、属性、协议），因为在这个大数组的前排，所以会被优先调用到。  \n\n## 定义 Persion+Test\n```\n@interface Persion (Test)\n- (void)run;\n- (void)test;\n+ (void)test2;\n@end\n\n@implementation Persion (Test)\n- (void)run\n{\n    NSLog(@\"Person (Test) - run\");\n}\n- (void)test\n{\n    NSLog(@\"test\");\n}\n+ (void)test2\n{\n    \n}\n@end\n```\n\n## Persion+Test.cpp\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Persion+Test 的实现：\n```\n//_category_t 结构体\nstruct _category_t {\n\tconst char *name; //类名\n\tstruct _class_t *cls; //父类\n\tconst struct _method_list_t *instance_methods; //对象方法列表\n\tconst struct _method_list_t *class_methods; //类方法列表\n\tconst struct _protocol_list_t *protocols; //协议列表\n\tconst struct _prop_list_t *properties; //属性列表\n};\nextern \"C\" __declspec(dllimport) struct objc_cache _objc_empty_cache;\n#pragma warning(disable:4273)\n\n//Category 类对象的对象方法列表\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[2];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t2,\n\t{{(struct objc_selector *)\"run\", \"v16@0:8\", (void *)_I_Persion_Test_run},\n\t{(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_Persion_Test_test}}\n};\n\n//Category 类对象的类方法列表\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_CLASS_METHODS_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t1,\n\t{{(struct objc_selector *)\"test2\", \"v16@0:8\", (void *)_C_Persion_Test_test2}}\n};\n\nextern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_Persion;\n\n//Persion+Test 分类的结构体\nstatic struct _category_t _OBJC_$_CATEGORY_Persion_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"Persion\", //类名\n\t0, // &OBJC_CLASS_$_Persion,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Persion_$_Test, //对象方法列表\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_CLASS_METHODS_Persion_$_Test, //类方法列表\n\t0, //协议列表\n\t0, //属性列表\n};\nstatic void OBJC_CATEGORY_SETUP_$_Persion_$_Test(void ) {\n\t_OBJC_$_CATEGORY_Persion_$_Test.cls = &OBJC_CLASS_$_Persion;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n\t(void *)&OBJC_CATEGORY_SETUP_$_Persion_$_Test,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Persion_$_Test,\n};\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n# Category 的加载处理过程\n\n## objc4 源码解读过程\n* objc-os.mm  \n_objc_init  \nmap_images  \nmap_images_nolock\n\n* objc-runtime-new.mm  \n_read_images  \nremethodizeClass  \nattachCategories  \nattachLists  \nrealloc、memmove、 memcpy\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。找到运行时入口 objc-os.mm 文件，打开文件找到运行时的初始化方法 `void _objc_init(void)` 方法：\n\n### _objc_init\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init(); //设置系统的环境变量\n    tls_init(); //线程相关的处理\n    static_init(); //运行C++静态构造函数\n    runtime_init();\n    exception_init(); //注册异常的回调\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image); //调用dyld的函数注册一个回调，并执行回调函数。\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n#### map_images\nJump To Definition -> map_images:\n```\nvoid\nmap_images(unsigned count, const char * const paths[],\n           const struct mach_header * const mhdrs[])\n{\n    mutex_locker_t lock(runtimeLock);\n    return map_images_nolock(count, paths, mhdrs);\n}\n```\nmap_images 方法的主要作用是处理由dyld映射的镜像文件.  \n\n#### map_images_nolock\nJump To Definition -> map_images_nolock：\n```\nvoid \nmap_images_nolock(unsigned mhCount, const char * const mhPaths[],\n                  const struct mach_header * const mhdrs[])\n{\n    ...\n\t...\n\t...//一堆方法\n\n    if (hCount > 0) {\n        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);\n    }\n\n    firstTime = NO;\n    \n    // Call image load funcs after everything is set up.\n    for (auto func : loadImageFuncs) {\n        for (uint32_t i = 0; i < mhCount; i++) {\n            func(mhdrs[i]);\n        }\n    }\n}\n```\n\n_read_images：images 是模块/镜像的意思。该方法是读取模块用的，比如读取类信息、分类信息等。  \n\n### _read_images\nJump To Definition -> _read_images：\n```\nvoid _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)\n{\n    ...\n\t...\n\t...//一堆方法\n\n    // Category discovery MUST BE Late to avoid potential races\n    // when other threads call the new category code before\n    // this thread finishes its fixups.\n\n    // +load handled by prepare_load_methods()\n\n    // Realize non-lazy classes (for +load methods and static instances)\n    for (EACH_HEADER) {\n        classref_t const *classlist = \n            _getObjc2NonlazyClassList(hi, &count); // 获取分类数组\n        for (i = 0; i < count; i++) {\n            Class cls = remapClass(classlist[i]); //通过 remapClass 获取类对应的指针\n            if (!cls) continue;\n\n            addClassTableEntry(cls);\n\n            if (cls->isSwiftStable()) {\n                if (cls->swiftMetadataInitializer()) {\n                    _objc_fatal(\"Swift class %s with a metadata initializer \"\n                                \"is not allowed to be non-lazy\",\n                                cls->nameForLogging());\n                }\n                // fixme also disallow relocatable classes\n                // We can't disallow all Swift classes because of\n                // classes like Swift.__EmptyArrayStorage\n            }\n            realizeClassWithoutSwift(cls, nil);\n        }\n    }\n\t\n\t...\n\t...\n\t...//一堆方法\n}\n```\n\n上面👆代码是 _read_images 处理 Category 的核心代码，首先通过 _getObjc2NonlazyClassList 方法获取 Category 数组，遍历 Category 数组通过 remapClass 获取分类对应的指针，作为参数调用 realizeClassWithoutSwift 方法。\n\n#### realizeClassWithoutSwift\nJump To Definition -> realizeClassWithoutSwift：\n```\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n\t...\n\t...\n\t...//一堆方法\n\n    // Attach categories\n    methodizeClass(cls, previously);\n\n    return cls;\n}\n```\n\nrealizeClassWithoutSwift 方法内部进过一顿骚操作，最后调用 methodizeClass 方法开始加载分类信息。\n\nAttach categories：将分类信息附加到类对象里。  \n\n#### methodizeClass\nJump To Definition -> methodizeClass：\n```\nstatic void methodizeClass(Class cls, Class previously)\n{\n    runtimeLock.assertLocked();\n\n    bool isMeta = cls->isMetaClass(); //是否是元类对象\n    auto rw = cls->data();\n    auto ro = rw->ro();\n    auto rwe = rw->ext();\n\n    // Methodizing for the first time\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: methodizing class '%s' %s\", \n                     cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n    }\n\n    // Install methods and properties that the class implements itself.\n    // 方法数组\n    method_list_t *list = ro->baseMethods();\n    if (list) {\n        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));\n        if (rwe) rwe->methods.attachLists(&list, 1);\n    }\n    \n    // 属性数组\n    property_list_t *proplist = ro->baseProperties;\n    if (rwe && proplist) {\n        rwe->properties.attachLists(&proplist, 1);\n    }\n    \n    // 协议数组\n    protocol_list_t *protolist = ro->baseProtocols;\n    if (rwe && protolist) {\n        rwe->protocols.attachLists(&protolist, 1);\n    }\n\n    // Root classes get bonus method implementations if they don't have \n    // them already. These apply before category replacements.\n    if (cls->isRootMetaclass()) {\n        // root metaclass\n        addMethod(cls, @selector(initialize), (IMP)&objc_noop_imp, \"\", NO);\n    }\n    \n    // 添加分类方法、属性、协议数据\n    // Attach categories.\n    if (previously) {\n        if (isMeta) {\n            objc::unattachedCategories.attachToClass(cls, previously,\n                                                     ATTACH_METACLASS);\n        } else {\n            // When a class relocates, categories with class methods\n            // may be registered on the class itself rather than on\n            // the metaclass. Tell attachToClass to look for those.\n            objc::unattachedCategories.attachToClass(cls, previously,\n                                                     ATTACH_CLASS_AND_METACLASS);\n        }\n    }\n    objc::unattachedCategories.attachToClass(cls, cls,\n                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);\n\n#if DEBUG\n    // Debug: sanity-check all SELs; log method list contents\n    for (const auto& meth : rw->methods()) {\n        if (PrintConnecting) {\n            _objc_inform(\"METHOD %c[%s %s]\", isMeta ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(meth.name));\n        }\n        ASSERT(sel_registerName(sel_getName(meth.name)) == meth.name); \n    }\n#endif\n}\n```\nInstall methods and properties that the class implements itself. 可以看出该方法是在加载类对象自己内部的信息。分别针对方法数组、属性数组和协议数组调用 attachLists 方法，将信息添加到类对象里。\n\n#### attachToClass\nJump To Definition -> attachToClass:\n```\nvoid attachToClass(Class cls, Class previously, int flags)\n    {\n        runtimeLock.assertLocked();\n        ASSERT((flags & ATTACH_CLASS) ||\n               (flags & ATTACH_METACLASS) ||\n               (flags & ATTACH_CLASS_AND_METACLASS));\n\n        auto &map = get();\n        auto it = map.find(previously);\n\n        if (it != map.end()) {\n            category_list &list = it->second;\n            if (flags & ATTACH_CLASS_AND_METACLASS) {\n                int otherFlags = flags & ~ATTACH_CLASS_AND_METACLASS;\n                attachCategories(cls, list.array(), list.count(), otherFlags | ATTACH_CLASS);\n                attachCategories(cls->ISA(), list.array(), list.count(), otherFlags | ATTACH_METACLASS);\n            } else {\n                attachCategories(cls, list.array(), list.count(), flags);\n            }\n            map.erase(it);\n        }\n    }\n```\n\n#### attachCategories\nJump To Definition -> attachCategories:\n```\nstatic void\nattachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,\n                 int flags)\n{\n    if (slowpath(PrintReplacedMethods)) {\n        printReplacements(cls, cats_list, cats_count);\n    }\n    if (slowpath(PrintConnecting)) {\n        _objc_inform(\"CLASS: attaching %d categories to%s class '%s'%s\",\n                     cats_count, (flags & ATTACH_EXISTING) ? \" existing\" : \"\",\n                     cls->nameForLogging(), (flags & ATTACH_METACLASS) ? \" (meta)\" : \"\");\n    }\n\n    /*\n     * Only a few classes have more than 64 categories during launch.\n     * This uses a little stack, and avoids malloc.\n     *\n     * Categories must be added in the proper order, which is back\n     * to front. To do that with the chunking, we iterate cats_list\n     * from front to back, build up the local buffers backwards,\n     * and call attachLists on the chunks. attachLists prepends the\n     * lists, so the final result is in the expected order.\n     */\n    constexpr uint32_t ATTACH_BUFSIZ = 64;\n    method_list_t   *mlists[ATTACH_BUFSIZ];\n    property_list_t *proplists[ATTACH_BUFSIZ];\n    protocol_list_t *protolists[ATTACH_BUFSIZ];\n\n    uint32_t mcount = 0;\n    uint32_t propcount = 0;\n    uint32_t protocount = 0;\n    bool fromBundle = NO;\n    bool isMeta = (flags & ATTACH_METACLASS);\n    auto rwe = cls->data()->extAllocIfNeeded();\n\n    for (uint32_t i = 0; i < cats_count; i++) {\n        \n        // 取出某个分类 entry 是 category_t 类型\n        auto& entry = cats_list[i];\n        \n        // 方法数组\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            if (mcount == ATTACH_BUFSIZ) {\n                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n                rwe->methods.attachLists(mlists, mcount);\n                mcount = 0;\n            }\n            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;\n            fromBundle |= entry.hi->isBundle();\n        }\n        \n        // 属性数组\n        property_list_t *proplist =\n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            if (propcount == ATTACH_BUFSIZ) {\n                rwe->properties.attachLists(proplists, propcount);\n                propcount = 0;\n            }\n            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;\n        }\n        \n        // 协议数组\n        protocol_list_t *protolist = entry.cat->protocolsForMeta(isMeta);\n        if (protolist) {\n            if (protocount == ATTACH_BUFSIZ) {\n                rwe->protocols.attachLists(protolists, protocount);\n                protocount = 0;\n            }\n            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;\n        }\n    }\n\n    if (mcount > 0) {\n        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);\n        rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);\n        if (flags & ATTACH_EXISTING) flushCaches(cls);\n    }\n\n    rwe->properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);\n\n    rwe->protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);\n}\n```\n\n分别针对方法数组、属性数组和协议数组调用 attachLists 方法，将分类信息添加到原类对象里。\n\n#### attachLists\nJump To Definition -> attachLists:\n```\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count; // 原内存空间大小\n            uint32_t newCount = oldCount + addedCount; // 新内存空间大小\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); // 重新分配内存空间\n            array()->count = newCount;\n            memmove(array()->lists + addedCount, array()->lists, \n                    oldCount * sizeof(array()->lists[0])); // 调整内存格式\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0])); // 拷贝分类信息\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n#### realloc、memmove、memcpy\nattachLists 方法内部\n1.通过参数 addedCount 确定需要增加的内存空间 newCount，然后通过 realloc 方法重新分配空间。  \n2.空间增加后，通过 memmove 方法将类对象里的信息往后移动 addedCount 距离，把前排 addedCount 大小的空间空出来留给将要添加进来的分类信息。  \n![Category的实现原理01](Category的实现原理/Category的实现原理02.png)\n\n3.类对象的前排空间空出来后，再通过 memcpy 方法将分类信息拷贝到该空间里。\n![Category的实现原理01](Category的实现原理/Category的实现原理03.png)\n\n## Category 的编译顺序\n原文件 Persion.m 最先编译，之后添加的分类按照添加顺序，优先编译后来添加的分类。添加顺序：\n![Category的实现原理01](Category的实现原理/Category的实现原理01.png)\n\n如图编译顺序按照 Compile Sources 里的顺序，为 Persion.m -> Persion+Test.m -> Persion+Demo.m。如果 Persion.m、Persion+Test.m、Persion+Demo.m 中有相同的方法，后编译的类中的方法会优先于先编译的类中的方法（不是覆盖，只是优先被查询到）。\n\n调用日志：\n![Category的实现原理01](Category的实现原理/Category的实现原理04.png)\n\n可以看到 Persion.m 被优先编译，其次是后来添加的 Persion+Test.m，第三个编译的是 最后添加的 Persion+Demo.m。添加顺序决定编译顺序只对分类有效，Persion.m 一定是最先编译的，这一点通过 methodizeClass 方法也能看出来，先处理类对象，再处理分类。\n\n# Class Extension 的实现原理\n\n## 定义 Persion()\n```\n@interface Persion : NSObject\n@property (nonatomic, copy) NSString *categoryTest1;\n- (void)run;\n- (void)test;\n+ (void)test2;\n@end\n\n@interface Persion()\n@property (nonatomic, copy) NSString *categoryTest2;\n@end\n\n@implementation Persion\n- (void)run\n{\n    NSLog(@\"Person - run\");\n}\n- (void)test\n{\n    NSLog(@\"test\");\n}\n+ (void)test2\n{\n    \n}\n@end\n```\n\n将 OC 代码转换为 C\\C++ 代码，并在生成的 C/C++ 代码中找到 Persion 的实现：\n```\nextern \"C\" unsigned long OBJC_IVAR_$_Persion$_categoryTest1;\nextern \"C\" unsigned long OBJC_IVAR_$_Persion$_categoryTest2;\nstruct Persion_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tNSString * _Nonnull _categoryTest1;\n\tNSString *_categoryTest2;\n};\n```\n\n上面👆这块代码可以看到，在 Persion() 中定义的 categoryTest2 已经包含在类 Persion 类对象的结构体里面了。可以证明 Class Extension 在编译的时候，它的数据就已经包含在类信息中了。从实现上来看，Class Extension 不应该叫做匿名分类，叫类扩展更适合。\n\n## 小结\n* 运行时入口 objc-os.mm，初始化方法 void _objc_init(void) 方法。\n* objc4 的代码虽然改了，但是实现原理还是没变。\n\n# 总结\n* Category 的实现原理  \nCategory 编译之后的底层结构是 struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息，在程序运行的时候，runtime 会将 Category 的数据，合并到类信息中（类对象、元类对象中）。\n* Category 和 Class Extension 的区别是什么？  \nClass Extension 在编译的时候，它的数据就已经包含在类信息中。Category 是在运行时，才会将数据合并到类信息中。\n","slug":"OC底层原理/Category的实现原理","published":1,"updated":"2023-08-22T09:52:13.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgs7000laq7k5o86rcmw"},{"title":"+load 的实现原理","date":"2020-05-20T02:45:30.000Z","_content":"\n思考：\n* Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？\n\n<!-- more -->\n\n+load 方法会在 runtime 加载类、分类时调用。每个类、分类的 +load 方法，在程序运行过程中只调用一次。\n\n# 定义 Persion、Persion+Test1 和 Persion+Test2\n```\n@interface MJPerson : NSObject\n+ (void)test;\n@end\n\n@implementation MJPerson\n+ (void)load\n{\n    NSLog(@\"MJPerson +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson +test\");\n}\n@end\n\n@interface MJPerson (Test1)\n@end\n\n@implementation MJPerson (Test1)\n+ (void)load\n{\n    NSLog(@\"MJPerson (Test1) +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson (Test1) +test\");\n}\n@end\n\n@interface MJPerson (Test2)\n@end\n\n@implementation MJPerson (Test2)\n+ (void)load\n{\n    NSLog(@\"MJPerson (Test2) +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson (Test2) +test\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion test];\n    }\n    return 0;\n}\n```\n\n编译顺序：\n![load的实现原理01](load的实现原理/load的实现原理01.png)\n\n打印结果：\n```\nPersion +load\nPersion (Test2) +load\nPersion (Test1) +load\nmain\nPersion (Test1) +test\n```\n\n从打印结果👆可以看出：  \n* 类和分类里的 +load 方法都会被调用\n* +load 方法的调用顺序和编译顺序是一致的\n* Persion (Test1) 最后被编译，所以优先调用 Persion (Test1) 里的 +test 方法  \n\n# objc4 源码解读过程\n* objc-os.mm  \n_objc_init  \nload_images\n\n* prepare_load_methods  \nschedule_class_load  \nadd_class_to_loadable_list  \nadd_category_to_loadable_list\n\n* call_load_methods  \ncall_class_loads  \ncall_category_loads  \n(*load_method)(cls, SEL_load)\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。找到运行时入口 objc-os.mm 文件，打开文件找到运行时的初始化方法 void _objc_init(void) 方法：\n\n# + load 方法的调用流程\n## _objc_init\nruntime 的初始化方法：\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init(); //设置系统的环境变量\n    tls_init(); //线程相关的处理\n    static_init(); //运行C ++静态构造函数\n    runtime_init();\n    exception_init(); //注册异常的回调\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image); //调用dyld的函数注册一个回调，并执行回调函数。\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n## load_images\nJump To Definition -> load_images（加载类信息）：\n```\nvoid\nload_images(const char *path __unused, const struct mach_header *mh)\n{\n    if (!didInitialAttachCategories && didCallDyldNotifyRegister) {\n        didInitialAttachCategories = true;\n        loadAllCategories();\n    }\n\n    // Return without taking locks if there are no +load methods here.\n    if (!hasLoadMethods((const headerType *)mh)) return;\n\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // Discover load methods\n    {\n        mutex_locker_t lock2(runtimeLock);\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // Call +load methods (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n```\n\nCall +load methods. 可以看出 call_load_methods() 方法里调用了 +load 方法。\n\n## call_load_methods\n\nJump To Definition -> call_load_methods（调用 +load 方法）：\n```\nvoid call_load_methods(void)\n{\n    static bool loading = NO;\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // Re-entrant calls do nothing; the outermost call will finish the job.\n    if (loading) return;\n    loading = YES;\n\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 1. Repeatedly call class +loads until there aren't any more\n        while (loadable_classes_used > 0) {\n            call_class_loads(); // 调用类的 +load 方法\n        }\n\n        // 2. Call category +loads ONCE\n        more_categories = call_category_loads(); // 调用分类的 +load 方法\n\n        // 3. Run more +loads if there are classes OR more untried categories\n    } while (loadable_classes_used > 0  ||  more_categories);\n\n    objc_autoreleasePoolPop(pool);\n\n    loading = NO;\n}\n```\n\ncall_load_methods 方法中先调用了 call_class_loads 方法去调用“类”的 +load 方法，后调用了 call_category_loads 去调用“分类”的 +load 方法。\n\n## call_class_loads\nJump To Definition -> call_class_loads（调用“类”的 +load 方法）：\n```\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method; //取出 +load 方法\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        (*load_method)(cls, @selector(load)); //调用 +load 方法\n    }\n    \n    // Destroy the detached list.\n    if (classes) free(classes);\n}\n```\n\n## call_category_loads\nJump To Definition -> call_category_loads（调用“分类”的 +load 方法）：\n```\nstatic bool call_category_loads(void)\n{\n    int i, shift;\n    bool new_categories_added = NO;\n    \n    // Detach current loadable list.\n    struct loadable_category *cats = loadable_categories;\n    int used = loadable_categories_used;\n    int allocated = loadable_categories_allocated;\n    loadable_categories = nil;\n    loadable_categories_allocated = 0;\n    loadable_categories_used = 0;\n\n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Category cat = cats[i].cat;\n        load_method_t load_method = (load_method_t)cats[i].method; //取出 +load 方法\n        Class cls;\n        if (!cat) continue;\n\n        cls = _category_getClass(cat);\n        if (cls  &&  cls->isLoadable()) {\n            if (PrintLoading) {\n                _objc_inform(\"LOAD: +[%s(%s) load]\\n\", \n                             cls->nameForLogging(), \n                             _category_getName(cat));\n            }\n            (*load_method)(cls, @selector(load)); //调用 +load 方法\n            cats[i].cat = nil;\n        }\n    }\n\n    // Compact detached list (order-preserving)\n    shift = 0;\n    for (i = 0; i < used; i++) {\n        if (cats[i].cat) {\n            cats[i-shift] = cats[i];\n        } else {\n            shift++;\n        }\n    }\n    used -= shift;\n\n    // Copy any new +load candidates from the new list to the detached list.\n    new_categories_added = (loadable_categories_used > 0);\n    for (i = 0; i < loadable_categories_used; i++) {\n        if (used == allocated) {\n            allocated = allocated*2 + 16;\n            cats = (struct loadable_category *)\n                realloc(cats, allocated *\n                                  sizeof(struct loadable_category));\n        }\n        cats[used++] = loadable_categories[i];\n    }\n\n    // Destroy the new list.\n    if (loadable_categories) free(loadable_categories);\n\n    // Reattach the (now augmented) detached list. \n    // But if there's nothing left to load, destroy the list.\n    if (used) {\n        loadable_categories = cats;\n        loadable_categories_used = used;\n        loadable_categories_allocated = allocated;\n    } else {\n        if (cats) free(cats);\n        loadable_categories = nil;\n        loadable_categories_used = 0;\n        loadable_categories_allocated = 0;\n    }\n\n    if (PrintLoading) {\n        if (loadable_categories_used != 0) {\n            _objc_inform(\"LOAD: %d categories still waiting for +load\\n\",\n                         loadable_categories_used);\n        }\n    }\n\n    return new_categories_added;\n}\n```\n\n## 小结\n* 在上面👆出现的 call_class_loads 和 call_category_loads 方法中，cats / classes 是存放着类 / 分类的数组。cats[i].method / classes[i].method 即取出类 / 分类里的 +load 方法，然后通过 `*load_method)(cls, @selector(load))` 方法进行调用。  \n\n* 因为在 call_load_methods 方法中，是按照 call_class_loads()、call_category_loads() 顺序调用的，所以打印日志里先调用“类”里的 +load 方法，再调用“分类”里的 +load 方法。  \n\n* cats[i].method / classes[i].method 调用的 method 方法就是 +load 方法。\n\n至于分类 +load 方法的调用顺序，以及子类 +load 方法的调用顺序，还得看一下 prepare_load_methods 方法👇。\n\n# 子类的 +load 方法\n\n## 定义 Student : Persion\n```\n@interface Student : Persion\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)load\n{\n    NSLog(@\"Student +load\");\n}\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n+ (void)load\n{\n    NSLog(@\"Student (Test1) +load\");\n}\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n+ (void)load\n{\n    NSLog(@\"Student (Test2) +load\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion test];\n    }\n    return 0;\n}\n```\n\n编译顺序：\n![load的实现原理02](load的实现原理/load的实现原理02.png)\n\n打印结果：\n```\nPersion +load\nStudent +load\nPersion (Test2) +load\nStudent (Test1) +load\nPersion (Test1) +load\nStudent (Test2) +load\nmain\nPersion (Test1) +test\n```\n\n通过\"+load 方法的调用过程\"知道了 call_load_methods 是调用 +load 方法的入口。而在 load_images 方法中还有一个 prepare_load_methods 方法是在 call_load_methods 方法前调用的。从命名上可以猜到，prepare_load_methods 方法是在调用 call_load_methods 方法之前做一些准备工作的方法。\n\n## prepare_load_methods\n\n获取并保存所有的类和分类。\n\nJump To Definition -> prepare_load_methods：\n```\nvoid prepare_load_methods(const headerType *mhdr)\n{\n    size_t count, i;\n\n    runtimeLock.assertLocked();\n\n    classref_t const *classlist = \n        _getObjc2NonlazyClassList(mhdr, &count); //获取所有的类\n    for (i = 0; i < count; i++) {\n        schedule_class_load(remapClass(classlist[i])); //将类 cls 及其父类添加到 loadable_classes 数组中\n    }\n\n    category_t * const *categorylist = _getObjc2NonlazyCategoryList(mhdr, &count); //获取所有的分类\n    for (i = 0; i < count; i++) { //遍历分类数组，逐个取出所有分类 cat\n        category_t *cat = categorylist[i];\n        Class cls = remapClass(cat->cls);\n        if (!cls) continue;  // category for ignored weak-linked class\n        if (cls->isSwiftStable()) {\n            _objc_fatal(\"Swift class extensions and categories on Swift \"\n                        \"classes are not allowed to have +load methods\");\n        }\n        realizeClassWithoutSwift(cls, nil);\n        ASSERT(cls->ISA()->isRealized());\n        add_category_to_loadable_list(cat); //将分类 cat 添加到 loadable_categories 数组中\n    }\n}\n```\n\n_getObjc2NonlazyClassList 方法是获取到所有的类。  \n\n_getObjc2NonlazyCategoryList 方法是获取到所有的分类。  \n\nschedule_class_load 方法内部调用了一个 add_class_to_loadable_list 方法，是将类 cls 及其父类添加到 loadable_classes 数组中。  \n\nadd_category_to_loadable_list 方法是将分类 cat 添加到 loadable_categories 数组中。\n\n## schedule_class_load\n\n通过递归，通过 add_class_to_loadable_list 方法，将类 cls 的父类及其自身添加到 loadable_classes 数组中。  \n\nJump To Definition -> schedule_class_load：\n```\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    ASSERT(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return; //如果是已经处理过的类则直接返回\n\n    // Ensure superclass-first ordering\n    schedule_class_load(cls->superclass); //递归，先处理类 cls 的父类\n\n    add_class_to_loadable_list(cls); //将类 cls 添加到 loadable_classes 数组中\n    cls->setInfo(RW_LOADED); //标记类 cls 已经处理过了\n}\n```\n\nschedule_class_load 方法内部通过 schedule_class_load(cls->superclass) 方法形成递归，优先让父类调用 schedule_class_load() 方法，添加的 loadable_classes 数组中，直到父类不存在时再处理类 cls。  \n\n在 schedule_class_load 方法的最后，通过修改类 cls 的 info 信息来标记已经加入到 loadable_classes 数组中了，避免重复操作。\n\n## add_class_to_loadable_list\n\n将传入的 cls 类添加到 loadable_classes 数组中。\n\nJump To Definition -> add_class_to_loadable_list：\n```\nvoid add_class_to_loadable_list(Class cls)\n{\n    IMP method;\n\n    loadMethodLock.assertLocked();\n\n    method = cls->getLoadMethod();\n    if (!method) return;  // Don't bother if cls has no +load method\n    \n    if (PrintLoading) {\n        _objc_inform(\"LOAD: class '%s' scheduled for +load\", \n                     cls->nameForLogging());\n    }\n    \n    if (loadable_classes_used == loadable_classes_allocated) {\n        loadable_classes_allocated = loadable_classes_allocated*2 + 16;\n        loadable_classes = (struct loadable_class *)\n            realloc(loadable_classes,\n                              loadable_classes_allocated *\n                              sizeof(struct loadable_class));\n    }\n    \n    loadable_classes[loadable_classes_used].cls = cls;\n    loadable_classes[loadable_classes_used].method = method;\n    loadable_classes_used++; //下标累加（按照编译顺序，后添加的类依次往后放置）\n}\n```\n\nloadable_classes 可以理解为 runtime 中存储所有“类”的容器。\n\n## add_category_to_loadable_list\n\n将传入的分类 cat 添加到 loadable_categories 数组中。   \n\nJump To Definition -> add_category_to_loadable_list：  \n```\nvoid add_category_to_loadable_list(Category cat)\n{\n    IMP method;\n\n    loadMethodLock.assertLocked();\n\n    method = _category_getLoadMethod(cat);\n\n    // Don't bother if cat has no +load method\n    if (!method) return;\n\n    if (PrintLoading) {\n        _objc_inform(\"LOAD: category '%s(%s)' scheduled for +load\", \n                     _category_getClassName(cat), _category_getName(cat));\n    }\n    \n    if (loadable_categories_used == loadable_categories_allocated) {\n        loadable_categories_allocated = loadable_categories_allocated*2 + 16;\n        loadable_categories = (struct loadable_category *)\n            realloc(loadable_categories,\n                              loadable_categories_allocated *\n                              sizeof(struct loadable_category));\n    }\n\n    loadable_categories[loadable_categories_used].cat = cat;\n    loadable_categories[loadable_categories_used].method = method;\n    loadable_categories_used++;//下标累加（按照编译顺序，后添加的分类依次往后放置）\n}\n```\n\nloadable_categories 可以理解为 runtime 中存储所有“分类”的容器。\n\nJump To Definition -> method：  \n```\nstruct loadable_class {\n    Class cls;  // may be nil\n    IMP method; // +load 方法\n};\n\nstruct loadable_category {\n    Category cat;  // may be nil\n    IMP method; // +load 方法\n};\n```\n\n# +load 方法的调用顺序\n\n## 类 +load > 分类 +load\n因为 runtime 中 call_load_methods 方法里是按照 call_class_loads()、call_category_loads() 顺序调用的，所以是先调用类的 +load 方法，再调用分类的 +load 方法。\n\n## 父类 +load > 子类 +load\n在调用 call_class_loads 方法之前调用了 prepare_load_methods 方法用来加载所有的类。因为 prepare_load_methods 方法中的 schedule_class_load 方法在添加类时通过递归的方式优先找到该类的父类进行添加，所以在先调用类的 +load 方法的基础上，优先调用父类的 +load 方法，在调用子类的 +load 方法。\n\n## 分类 +load 的调用顺序 == 编译顺序\n在添加所有分类的时候，因为 prepare_load_methods 方法直接调用 add_category_to_loadable_list 方法进行了添加，所有在 call_category_loads 方法中获取分类并调用分类的 +load 方法的顺序就是分类的编译顺序。\n\n## 小结\n* runtime 会优先调用类的 +load 方法，调用时按照编译先后顺序调用（先编译，先调用）。对于有继承关系的类，在调用子类的 +load 方法之前会优先调用父类的 +load 方法。\n* 在类的 +load 方法调用完成后再调用分类的 +load 方法，调用时按照编译先后顺序调用（先编译，先调用）。\n* 类中的 +load 方法的调用流程：  \n```\n_objc_init -> load_images\n\nload_images -> prepare_load_methods -> schedule_class_load -> add_class_to_loadable_list  \n\nload_images -> call_load_methods -> call_class_loads\n```\n\n* 分类中的 +load 方法的调用流程：  \n```\n_objc_init -> load_images  \n\nload_images -> prepare_load_methods -> add_category_to_loadable_list\n\nload_images -> call_load_methods -> call_category_loads\n```\n\n# +load 方法与继承\n## 定义 Student : Persion\n```\n@interface Student : Persion\n+ (void)test;\n@end\n\n@implementation Student\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Student load];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPersion +load\nPersion (Test2) +load\nPersion (Test1) +load\nmain\nPersion (Test1) +load\n```\n\n## [Student load] 的本质\n`[Student load]` 这句代码本质就是 `objc_msgSend(objc_getClass(\"Student\")`, `sel_registerName(\"load\"))`，即向 Student 类对象发送一条 \"load\" 消息，Student 类对象再通过 isa 指针找到 Student 元类对象去查找 +load 方法。因为 Student 里没有实现 +load 方法，所以 Student 元类对象会通过 superclass 指针找到父类 Persion 的元类对象  。Persion 的元类对象在查找 +load 方法时，会优先查找到最后被编译的分类 Persion (Test1)，找到 +load 方法并调用。所以 +load 方法是可以被继承的。\n\n+load 方法是可以被继承的。在启动时由 runtime 调用的 +load 方法是优先调用父类的 +load 方法。而通过 `[Student load]` 这种方式主动调用 +load 方法，是优先调用子类的 +load 方法。\n\n# 总结\n* Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？  \nCategory 有 +load 方法。  \n+load 方法在 runtime 加载类、分类的时候调用。  \n+load 方法可以继承，但是一般情况下不会主动去调用 +load 方法，都是让系统启动时自动调用。","source":"_posts/OC底层原理/load的实现原理.md","raw":"---\ntitle: +load 的实现原理\ndate: 2020-05-20 10:45:30\ntags: OC底层原理\n---\n\n思考：\n* Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？\n\n<!-- more -->\n\n+load 方法会在 runtime 加载类、分类时调用。每个类、分类的 +load 方法，在程序运行过程中只调用一次。\n\n# 定义 Persion、Persion+Test1 和 Persion+Test2\n```\n@interface MJPerson : NSObject\n+ (void)test;\n@end\n\n@implementation MJPerson\n+ (void)load\n{\n    NSLog(@\"MJPerson +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson +test\");\n}\n@end\n\n@interface MJPerson (Test1)\n@end\n\n@implementation MJPerson (Test1)\n+ (void)load\n{\n    NSLog(@\"MJPerson (Test1) +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson (Test1) +test\");\n}\n@end\n\n@interface MJPerson (Test2)\n@end\n\n@implementation MJPerson (Test2)\n+ (void)load\n{\n    NSLog(@\"MJPerson (Test2) +load\");\n}\n+ (void)test\n{\n    NSLog(@\"MJPerson (Test2) +test\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion test];\n    }\n    return 0;\n}\n```\n\n编译顺序：\n![load的实现原理01](load的实现原理/load的实现原理01.png)\n\n打印结果：\n```\nPersion +load\nPersion (Test2) +load\nPersion (Test1) +load\nmain\nPersion (Test1) +test\n```\n\n从打印结果👆可以看出：  \n* 类和分类里的 +load 方法都会被调用\n* +load 方法的调用顺序和编译顺序是一致的\n* Persion (Test1) 最后被编译，所以优先调用 Persion (Test1) 里的 +test 方法  \n\n# objc4 源码解读过程\n* objc-os.mm  \n_objc_init  \nload_images\n\n* prepare_load_methods  \nschedule_class_load  \nadd_class_to_loadable_list  \nadd_category_to_loadable_list\n\n* call_load_methods  \ncall_class_loads  \ncall_category_loads  \n(*load_method)(cls, SEL_load)\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)。找到运行时入口 objc-os.mm 文件，打开文件找到运行时的初始化方法 void _objc_init(void) 方法：\n\n# + load 方法的调用流程\n## _objc_init\nruntime 的初始化方法：\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init(); //设置系统的环境变量\n    tls_init(); //线程相关的处理\n    static_init(); //运行C ++静态构造函数\n    runtime_init();\n    exception_init(); //注册异常的回调\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image); //调用dyld的函数注册一个回调，并执行回调函数。\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n## load_images\nJump To Definition -> load_images（加载类信息）：\n```\nvoid\nload_images(const char *path __unused, const struct mach_header *mh)\n{\n    if (!didInitialAttachCategories && didCallDyldNotifyRegister) {\n        didInitialAttachCategories = true;\n        loadAllCategories();\n    }\n\n    // Return without taking locks if there are no +load methods here.\n    if (!hasLoadMethods((const headerType *)mh)) return;\n\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // Discover load methods\n    {\n        mutex_locker_t lock2(runtimeLock);\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // Call +load methods (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n```\n\nCall +load methods. 可以看出 call_load_methods() 方法里调用了 +load 方法。\n\n## call_load_methods\n\nJump To Definition -> call_load_methods（调用 +load 方法）：\n```\nvoid call_load_methods(void)\n{\n    static bool loading = NO;\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // Re-entrant calls do nothing; the outermost call will finish the job.\n    if (loading) return;\n    loading = YES;\n\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 1. Repeatedly call class +loads until there aren't any more\n        while (loadable_classes_used > 0) {\n            call_class_loads(); // 调用类的 +load 方法\n        }\n\n        // 2. Call category +loads ONCE\n        more_categories = call_category_loads(); // 调用分类的 +load 方法\n\n        // 3. Run more +loads if there are classes OR more untried categories\n    } while (loadable_classes_used > 0  ||  more_categories);\n\n    objc_autoreleasePoolPop(pool);\n\n    loading = NO;\n}\n```\n\ncall_load_methods 方法中先调用了 call_class_loads 方法去调用“类”的 +load 方法，后调用了 call_category_loads 去调用“分类”的 +load 方法。\n\n## call_class_loads\nJump To Definition -> call_class_loads（调用“类”的 +load 方法）：\n```\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method; //取出 +load 方法\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        (*load_method)(cls, @selector(load)); //调用 +load 方法\n    }\n    \n    // Destroy the detached list.\n    if (classes) free(classes);\n}\n```\n\n## call_category_loads\nJump To Definition -> call_category_loads（调用“分类”的 +load 方法）：\n```\nstatic bool call_category_loads(void)\n{\n    int i, shift;\n    bool new_categories_added = NO;\n    \n    // Detach current loadable list.\n    struct loadable_category *cats = loadable_categories;\n    int used = loadable_categories_used;\n    int allocated = loadable_categories_allocated;\n    loadable_categories = nil;\n    loadable_categories_allocated = 0;\n    loadable_categories_used = 0;\n\n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Category cat = cats[i].cat;\n        load_method_t load_method = (load_method_t)cats[i].method; //取出 +load 方法\n        Class cls;\n        if (!cat) continue;\n\n        cls = _category_getClass(cat);\n        if (cls  &&  cls->isLoadable()) {\n            if (PrintLoading) {\n                _objc_inform(\"LOAD: +[%s(%s) load]\\n\", \n                             cls->nameForLogging(), \n                             _category_getName(cat));\n            }\n            (*load_method)(cls, @selector(load)); //调用 +load 方法\n            cats[i].cat = nil;\n        }\n    }\n\n    // Compact detached list (order-preserving)\n    shift = 0;\n    for (i = 0; i < used; i++) {\n        if (cats[i].cat) {\n            cats[i-shift] = cats[i];\n        } else {\n            shift++;\n        }\n    }\n    used -= shift;\n\n    // Copy any new +load candidates from the new list to the detached list.\n    new_categories_added = (loadable_categories_used > 0);\n    for (i = 0; i < loadable_categories_used; i++) {\n        if (used == allocated) {\n            allocated = allocated*2 + 16;\n            cats = (struct loadable_category *)\n                realloc(cats, allocated *\n                                  sizeof(struct loadable_category));\n        }\n        cats[used++] = loadable_categories[i];\n    }\n\n    // Destroy the new list.\n    if (loadable_categories) free(loadable_categories);\n\n    // Reattach the (now augmented) detached list. \n    // But if there's nothing left to load, destroy the list.\n    if (used) {\n        loadable_categories = cats;\n        loadable_categories_used = used;\n        loadable_categories_allocated = allocated;\n    } else {\n        if (cats) free(cats);\n        loadable_categories = nil;\n        loadable_categories_used = 0;\n        loadable_categories_allocated = 0;\n    }\n\n    if (PrintLoading) {\n        if (loadable_categories_used != 0) {\n            _objc_inform(\"LOAD: %d categories still waiting for +load\\n\",\n                         loadable_categories_used);\n        }\n    }\n\n    return new_categories_added;\n}\n```\n\n## 小结\n* 在上面👆出现的 call_class_loads 和 call_category_loads 方法中，cats / classes 是存放着类 / 分类的数组。cats[i].method / classes[i].method 即取出类 / 分类里的 +load 方法，然后通过 `*load_method)(cls, @selector(load))` 方法进行调用。  \n\n* 因为在 call_load_methods 方法中，是按照 call_class_loads()、call_category_loads() 顺序调用的，所以打印日志里先调用“类”里的 +load 方法，再调用“分类”里的 +load 方法。  \n\n* cats[i].method / classes[i].method 调用的 method 方法就是 +load 方法。\n\n至于分类 +load 方法的调用顺序，以及子类 +load 方法的调用顺序，还得看一下 prepare_load_methods 方法👇。\n\n# 子类的 +load 方法\n\n## 定义 Student : Persion\n```\n@interface Student : Persion\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)load\n{\n    NSLog(@\"Student +load\");\n}\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n+ (void)load\n{\n    NSLog(@\"Student (Test1) +load\");\n}\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n+ (void)load\n{\n    NSLog(@\"Student (Test2) +load\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion test];\n    }\n    return 0;\n}\n```\n\n编译顺序：\n![load的实现原理02](load的实现原理/load的实现原理02.png)\n\n打印结果：\n```\nPersion +load\nStudent +load\nPersion (Test2) +load\nStudent (Test1) +load\nPersion (Test1) +load\nStudent (Test2) +load\nmain\nPersion (Test1) +test\n```\n\n通过\"+load 方法的调用过程\"知道了 call_load_methods 是调用 +load 方法的入口。而在 load_images 方法中还有一个 prepare_load_methods 方法是在 call_load_methods 方法前调用的。从命名上可以猜到，prepare_load_methods 方法是在调用 call_load_methods 方法之前做一些准备工作的方法。\n\n## prepare_load_methods\n\n获取并保存所有的类和分类。\n\nJump To Definition -> prepare_load_methods：\n```\nvoid prepare_load_methods(const headerType *mhdr)\n{\n    size_t count, i;\n\n    runtimeLock.assertLocked();\n\n    classref_t const *classlist = \n        _getObjc2NonlazyClassList(mhdr, &count); //获取所有的类\n    for (i = 0; i < count; i++) {\n        schedule_class_load(remapClass(classlist[i])); //将类 cls 及其父类添加到 loadable_classes 数组中\n    }\n\n    category_t * const *categorylist = _getObjc2NonlazyCategoryList(mhdr, &count); //获取所有的分类\n    for (i = 0; i < count; i++) { //遍历分类数组，逐个取出所有分类 cat\n        category_t *cat = categorylist[i];\n        Class cls = remapClass(cat->cls);\n        if (!cls) continue;  // category for ignored weak-linked class\n        if (cls->isSwiftStable()) {\n            _objc_fatal(\"Swift class extensions and categories on Swift \"\n                        \"classes are not allowed to have +load methods\");\n        }\n        realizeClassWithoutSwift(cls, nil);\n        ASSERT(cls->ISA()->isRealized());\n        add_category_to_loadable_list(cat); //将分类 cat 添加到 loadable_categories 数组中\n    }\n}\n```\n\n_getObjc2NonlazyClassList 方法是获取到所有的类。  \n\n_getObjc2NonlazyCategoryList 方法是获取到所有的分类。  \n\nschedule_class_load 方法内部调用了一个 add_class_to_loadable_list 方法，是将类 cls 及其父类添加到 loadable_classes 数组中。  \n\nadd_category_to_loadable_list 方法是将分类 cat 添加到 loadable_categories 数组中。\n\n## schedule_class_load\n\n通过递归，通过 add_class_to_loadable_list 方法，将类 cls 的父类及其自身添加到 loadable_classes 数组中。  \n\nJump To Definition -> schedule_class_load：\n```\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    ASSERT(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return; //如果是已经处理过的类则直接返回\n\n    // Ensure superclass-first ordering\n    schedule_class_load(cls->superclass); //递归，先处理类 cls 的父类\n\n    add_class_to_loadable_list(cls); //将类 cls 添加到 loadable_classes 数组中\n    cls->setInfo(RW_LOADED); //标记类 cls 已经处理过了\n}\n```\n\nschedule_class_load 方法内部通过 schedule_class_load(cls->superclass) 方法形成递归，优先让父类调用 schedule_class_load() 方法，添加的 loadable_classes 数组中，直到父类不存在时再处理类 cls。  \n\n在 schedule_class_load 方法的最后，通过修改类 cls 的 info 信息来标记已经加入到 loadable_classes 数组中了，避免重复操作。\n\n## add_class_to_loadable_list\n\n将传入的 cls 类添加到 loadable_classes 数组中。\n\nJump To Definition -> add_class_to_loadable_list：\n```\nvoid add_class_to_loadable_list(Class cls)\n{\n    IMP method;\n\n    loadMethodLock.assertLocked();\n\n    method = cls->getLoadMethod();\n    if (!method) return;  // Don't bother if cls has no +load method\n    \n    if (PrintLoading) {\n        _objc_inform(\"LOAD: class '%s' scheduled for +load\", \n                     cls->nameForLogging());\n    }\n    \n    if (loadable_classes_used == loadable_classes_allocated) {\n        loadable_classes_allocated = loadable_classes_allocated*2 + 16;\n        loadable_classes = (struct loadable_class *)\n            realloc(loadable_classes,\n                              loadable_classes_allocated *\n                              sizeof(struct loadable_class));\n    }\n    \n    loadable_classes[loadable_classes_used].cls = cls;\n    loadable_classes[loadable_classes_used].method = method;\n    loadable_classes_used++; //下标累加（按照编译顺序，后添加的类依次往后放置）\n}\n```\n\nloadable_classes 可以理解为 runtime 中存储所有“类”的容器。\n\n## add_category_to_loadable_list\n\n将传入的分类 cat 添加到 loadable_categories 数组中。   \n\nJump To Definition -> add_category_to_loadable_list：  \n```\nvoid add_category_to_loadable_list(Category cat)\n{\n    IMP method;\n\n    loadMethodLock.assertLocked();\n\n    method = _category_getLoadMethod(cat);\n\n    // Don't bother if cat has no +load method\n    if (!method) return;\n\n    if (PrintLoading) {\n        _objc_inform(\"LOAD: category '%s(%s)' scheduled for +load\", \n                     _category_getClassName(cat), _category_getName(cat));\n    }\n    \n    if (loadable_categories_used == loadable_categories_allocated) {\n        loadable_categories_allocated = loadable_categories_allocated*2 + 16;\n        loadable_categories = (struct loadable_category *)\n            realloc(loadable_categories,\n                              loadable_categories_allocated *\n                              sizeof(struct loadable_category));\n    }\n\n    loadable_categories[loadable_categories_used].cat = cat;\n    loadable_categories[loadable_categories_used].method = method;\n    loadable_categories_used++;//下标累加（按照编译顺序，后添加的分类依次往后放置）\n}\n```\n\nloadable_categories 可以理解为 runtime 中存储所有“分类”的容器。\n\nJump To Definition -> method：  \n```\nstruct loadable_class {\n    Class cls;  // may be nil\n    IMP method; // +load 方法\n};\n\nstruct loadable_category {\n    Category cat;  // may be nil\n    IMP method; // +load 方法\n};\n```\n\n# +load 方法的调用顺序\n\n## 类 +load > 分类 +load\n因为 runtime 中 call_load_methods 方法里是按照 call_class_loads()、call_category_loads() 顺序调用的，所以是先调用类的 +load 方法，再调用分类的 +load 方法。\n\n## 父类 +load > 子类 +load\n在调用 call_class_loads 方法之前调用了 prepare_load_methods 方法用来加载所有的类。因为 prepare_load_methods 方法中的 schedule_class_load 方法在添加类时通过递归的方式优先找到该类的父类进行添加，所以在先调用类的 +load 方法的基础上，优先调用父类的 +load 方法，在调用子类的 +load 方法。\n\n## 分类 +load 的调用顺序 == 编译顺序\n在添加所有分类的时候，因为 prepare_load_methods 方法直接调用 add_category_to_loadable_list 方法进行了添加，所有在 call_category_loads 方法中获取分类并调用分类的 +load 方法的顺序就是分类的编译顺序。\n\n## 小结\n* runtime 会优先调用类的 +load 方法，调用时按照编译先后顺序调用（先编译，先调用）。对于有继承关系的类，在调用子类的 +load 方法之前会优先调用父类的 +load 方法。\n* 在类的 +load 方法调用完成后再调用分类的 +load 方法，调用时按照编译先后顺序调用（先编译，先调用）。\n* 类中的 +load 方法的调用流程：  \n```\n_objc_init -> load_images\n\nload_images -> prepare_load_methods -> schedule_class_load -> add_class_to_loadable_list  \n\nload_images -> call_load_methods -> call_class_loads\n```\n\n* 分类中的 +load 方法的调用流程：  \n```\n_objc_init -> load_images  \n\nload_images -> prepare_load_methods -> add_category_to_loadable_list\n\nload_images -> call_load_methods -> call_category_loads\n```\n\n# +load 方法与继承\n## 定义 Student : Persion\n```\n@interface Student : Persion\n+ (void)test;\n@end\n\n@implementation Student\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Student load];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPersion +load\nPersion (Test2) +load\nPersion (Test1) +load\nmain\nPersion (Test1) +load\n```\n\n## [Student load] 的本质\n`[Student load]` 这句代码本质就是 `objc_msgSend(objc_getClass(\"Student\")`, `sel_registerName(\"load\"))`，即向 Student 类对象发送一条 \"load\" 消息，Student 类对象再通过 isa 指针找到 Student 元类对象去查找 +load 方法。因为 Student 里没有实现 +load 方法，所以 Student 元类对象会通过 superclass 指针找到父类 Persion 的元类对象  。Persion 的元类对象在查找 +load 方法时，会优先查找到最后被编译的分类 Persion (Test1)，找到 +load 方法并调用。所以 +load 方法是可以被继承的。\n\n+load 方法是可以被继承的。在启动时由 runtime 调用的 +load 方法是优先调用父类的 +load 方法。而通过 `[Student load]` 这种方式主动调用 +load 方法，是优先调用子类的 +load 方法。\n\n# 总结\n* Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？  \nCategory 有 +load 方法。  \n+load 方法在 runtime 加载类、分类的时候调用。  \n+load 方法可以继承，但是一般情况下不会主动去调用 +load 方法，都是让系统启动时自动调用。","slug":"OC底层原理/load的实现原理","published":1,"updated":"2023-08-22T09:52:13.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgsa000naq7k7110g6m6"},{"title":"isa和superclass","date":"2020-05-11T06:35:58.000Z","_content":"\n思考：\n* 对象的 isa 指针指向哪里？\n* OC 的类信息存放在哪里？\n\n<!-- more -->\n\n# 图解\n![isa和superclass](isa和superclass/isa和superclass01.png)\n* instance 的 isa 指向 class\n* class 的 isa 指向 meta-class\n* meta-class 的 isa 指向基类的 meta-class\n* class 的 superclass 指向父类的 class，如果没有父类，superclass 指针为nil\n* meta-class 的 superclass 指向父类的 meta-class，基类的 meta-class 的 superclass 指向基类的 class\n* instance 调用对象方法的轨迹：isa 找到 class，方法不存在，就通过 superclass 找父类\n* class 调用类方法的轨迹：isa 找 meta-class，方法不存在，就通过 superclass 找父类\n\n# isa\n\n## instance 对象、class 对象 和 meta-class 对象之间的 isa 关系\n![isa和superclass](isa和superclass/isa和superclass02.png)\n\n### 定义 Person\n```\n@interface Person : NSObject <NSCopying>\n{\n    @public\n    int _age;\n}\n@property (nonatomic, assign) int no;\n- (void)personInstanceMethod;\n+ (void)personClassMethod;\n@end\n\n@implementation Person\n@end\n```\n\n创建 Person 的实例对象\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [[Person alloc] init];\n        \n        person->_age = 10;\n\n        [person personInstanceMethod];\n        \n        [Person personClassMethod];\n        \n    }\n    return 0;\n}\n```\n\n### 将 OC 代码转换为 C\\C++ 代码\n找到 main.m 所在文件，在终端输入：\n```\n$ xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc main.m\n```\n\n没有通过 ‘-o’ 生成指定文件时，默认生成 main.cpp 文件，打开 main.cpp 文件。找到 main 函数：\n```\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n        (*(int *)((char *)person + OBJC_IVAR_$_Person$_age)) = 10;\n\n        ((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"personInstanceMethod\"));\n\n        ((void (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n\n    }\n    return 0;\n}\n```\n\n找到 objc_msgSend：\n```\n((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"personInstanceMethod\"));\n\n((void (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n\n//简化后：\nobjc_msgSend(person, sel_registerName(\"personInstanceMethod\"));\n\nobjc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n```\n\n`[person personInstanceMethod]` 的具体实现是 `objc_msgSend(person, sel_registerName(\"personInstanceMethod\"))`。  \n即在实例对象 person 调用 `-(void)personInstanceMethod` 对象方法的时候，向实例对象 person 发送一条 \"personInstanceMethod\" 消息。  \n\n`[Person personClassMethod]` 的具体实现是 `objc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"))`。  \n即在类对象 Person 调用 `+(void)personClassMethod` 类方法的时候，向类对象 Person 发送一条 \"personClassMethod\" 消息。  \n\n### 方法调用与对象的关系\n```\n[person personInstanceMethod];\n[Person personClassMethod];\n```\n\n上面👆两个方法调用表现出来的是，实例对象 person 可以调用存在 Person 类对象里的对象方法， Person 类对象可以调用存储在 Person 元类对象里的类方法。\n\n### 小结\n* instance 对象的 isa 指针指向 class 对象。当调用对象方法时，通过 instance 对象的 isa 指针找到 class 对象，最后找到对象方法的实现进行调用。\n* class 对象的 isa 指针指向 meta-class 对象。当调用类方法时，通过 class 对象的 isa 指针找到 meta-class对象，最后找到类方法的实现进行调用。\n\n## ISA_MASK\n\n<!-- ![isa和superclass](isa和superclass/isa和superclass10.png) -->\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [[Person alloc] init];\n        \n        Class personClass = [Person class];\n\n        Class personMetaClass = object_getClass(personClass);\n\n        NSLog(@\"%p %p %p\", person, personClass, personMetaClass);\n    }\n    return 0;\n}\n```\n### 实例对象的 isa 指针\n打印 Person->isa、personClass：\n```\n(lldb) p/x (long)person->isa //指针地址格式设置16进制\n(long) $2 = 0x001d8001000014f1\n(lldb) p/x personClass\n(Class) $3 = 0x00000001000014f0 Person\n```\n\n上面👆的打印结果可以看到，Person 的类对象地址是 0x00000001000014f0，而 Person 的实例对象的 isa 指针的地址是 0x001d8001000014f1。\n\n不相等原因是在 64bit 之前 isa 指针的地址等于被指向对象的地址，从 64bit 开始 isa 需要进行一次位运算，才能计算出真实地址：\n![isa和superclass](isa和superclass/isa和superclass09.png)\n\nISA_MASK 在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的定义：\n```\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                        \\\n      uintptr_t nonpointer        : 1;                                         \\\n      uintptr_t has_assoc         : 1;                                         \\\n      uintptr_t has_cxx_dtor      : 1;                                         \\\n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                         \\\n      uintptr_t weakly_referenced : 1;                                         \\\n      uintptr_t deallocating      : 1;                                         \\\n      uintptr_t has_sidetable_rc  : 1;                                         \\\n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n```\n\niPhoneOS 是 __arm64__ 架构，ISA_MASK：0x0000000ffffffff8。  \nMacOS 是 __x86_64__ 架构，ISA_MASK：0x00007ffffffffff8ULL。  \n\n打印 person->isa & ISA_MASK\n```\n(lldb) p/x 0x001d8001000014f1 & 0x00007ffffffffff8\n(long) $4 = 0x00000001000014f0\n```\n\n上面👆的打印结果可以看出，Person 实例对象的 isa 指针 & ISA_MASK 就是 Person 类对象的地址。\n\n\n### 类对象的 isa 指针\n类对象的类型 Class 是一个指向结构体 objc_class 的指针：\n```\ntypedef struct objc_class *Class;\n```\n\nJump TO Definition -> objc_class：\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n👆 objc_class 的 isa 是不支持外部访问的，所以 personClass->isa 获取不到 isa 指针地址，所以要自定义一个 test_objc_class 结构体，再将 personClass 的类型强转为 test_objc_class 类型：\n```\nstruct test_objc_class {\n    Class isa;\n    Class superclass;\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Class personClass = [Person class];\n\n        struct test_objc_class *personClass2 = (__bridge struct test_objc_class *)(personClass); \n    }\n    return 0;\n}\n\n```\n\n因为 personClass 是 OC 对象，将 OC 代码专为 c++ 代码需要用到桥接 (__bridge struct test_objc_class *)。  \n\n打印 personClass2->isa、personMetaClass 和 personClass2->isa & ISA_MASK：\n```\n(lldb) p/x personClass2->isa\n(Class) $5 = 0x001d8001000014c9\n(lldb) p/x personMetaClass\n(Class) $6 = 0x00000001000014c8\n(lldb) p/x 0x001d8001000014c9 & 0x00007ffffffffff8\n(long) $7 = 0x00000001000014c8\n```\n\n上面👆的打印结果可以看出，Person 类对象的 isa 指针 & ISA_MASK 就是 Person 元类对象的地址。\n\n# superclass\n\n定义 Student 继承自 Person：\n```\n@interface Student : Person <NSCoding>\n{\n    @public\n    int _weight;\n}\n@property (nonatomic, assign) int height;\n- (void)studentInstanceMethod;\n+ (void)studentClassMethod;\n@end\n\n@implementation Student\n- (void)studentInstanceMethod\n{\n    \n}\n+ (void)studentClassMethod\n{\n    \n}\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    return nil;\n}\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    \n}\n@end\n```\n\n创建 Student 的实例对象\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n         Student *student = [[Student alloc] init];\n         \n         [student personInstanceMethod];\n         \n         [student init];\n         \n         [Student studentClassMethod];\n         \n         [Student personClassMethod];\n         \n         [Student load];\n    }\n    return 0;\n}\n```\n\n## class 对象的 superclass 指针\n\nStudent 类对象、Person 类对象 和 NSObject 类对象之间的 superclass 关系：\n![isa和superclass](isa和superclass/isa和superclass03.png)\n\n获取 test_objc_class 类型的 Person 类对象和 Student 类对象：\n```\nstruct test_objc_class *personClass = (__bridge struct test_objc_class *)([Person class]);\n\nstruct test_objc_class *studentClass = (__bridge struct test_objc_class *)([Student class]);\n```\n\n打印 personClass、studentClass 和 studentClass->superclass：\n```\n(lldb) p personClass\n(test_objc_class *) $0 = 0x00000001000014b8\n(lldb) p studentClass\n(test_objc_class *) $1 = 0x0000000100001508\n(lldb) p/x studentClass->superclass\n(Class) $2 = 0x00000001000014b8 Person\n```\n\n上面👆的打印结果可以看出，Student 类对象的 superclass 指针地址就是 Person 类对象的地址。\n\n### Student 的实例对象调用父类 Person 里的对象方法：\n```\n[student personInstanceMethod];\n```\n\n对象方法 `-(void)personInstanceMethod` 保存在 Person 的类对象里，`[student personInstanceMethod]` 首先通过 student 的 isa 指针找到 Student 的类对象，再通过 Student 类对象里的 superclass 找到 Person 的类对象，最后在 Person 类对象里找到了对象方法 `-(void)personInstanceMethod`。\n\n### Student 的实例对象调用父类 NSObject 里的对象方法：\n```\n[student init];\n```\n\n对象方法 `-(void)init` 方法保存在 NSObject 的类对象里，`[student init]` 首先通过 student 的 isa 指针找到 Student 的类对象，再通过 Student 类对象里的 superclass 找到 Person 的类对象，再通过 Person 类对象里的 superclass 找到 NSObject 的类对象，最后在 NSObject 类对象里找到了对象方法 `-(void)init`。\n\n### 小结\n* 具有继承关系的不同的类之间，是通过 superlass 指针连接的。有了 superlass 指针的连接，就实现了子类调用父类方法的逻辑。\n* 当 Student 的 instance 对象在调用 Person 的对象方法时，会先通过 isa 找到 Student 的 class，然后通过 superclass 找到 Person 的 class，最后找到对象方法的实现进行调用。\n\n\n## meta-class 对象的 superclass 指针\n\nStudent 元类对象、Person 元类对象 和 NSObject 元类对象之间的 superclass 关系：\n![isa和superclass](isa和superclass/isa和superclass04.png)\n\n### Student 类对象调用 Student 元类对象里的类方法：\n```\n[Student studentClassMethod];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，最终在 Student 元类对象里找到类方法 `+(void)studentClassMethod`。\n\n### Student 类对象调用父类 Person 元类对象里的类方法：\n```\n[Student personClassMethod];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，再通过 Student 元类对象里的 superclass 找到 Person 元类对象，最终在 Person 元类对象里找到类方法 `+(void)personClassMethod`。\n\n### Student 类对象调用父类 NSObject 元类对象里的类方法：\n```\n[Student load];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，再通过 Student 元类对象里的 superclass 找到 Person 元类对象，再通过 Person 元类对象里的 superclass 找到 NSObject 元类对象，最终在 NSObject 元类对象里找到类方法 `+(void)load`。\n\n\n# instance 对象调用对象方法流程\n\n```\n[student unrecoginzedSelector];\n```\n\n向实例对象 student 发送一条 \"unrecoginzedSelector\" 消息。student 通过 isa 指针找到 Student 类对象，在类对象里查找对象方法 `-(void)unrecoginzedSelector`。如果没有，Student 类对象会通过 superclass 指针找到 Student 父类的类对象，并在父类的类对象里查找对象方法 `-(void)unrecoginzedSelector`。如果还是没有找到，再通过 superclass 查找父类的类对象。以此往复，直找到基类 NSObject 的类对象。流程图：\n![isa和superclass](isa和superclass/isa和superclass05.png)\n\n## unrecoginzed selector sent to instance\n如果在 NSObject 的类对象里也没有查找到对象方法 `-(void)unrecoginzedSelector`，就会返回出现‘unrecoginzed selector sent to instance’错误。\n\n## 子类重写父类的对象方法\n\n```\n@interface Person : NSObject <NSCopying>\n- (void)test;\n@end\n\n@implementation Person\n- (void)test \n{\n\n}\n@end\n\n@interface Student : Person <NSCoding>\n@end\n\n@implementation Student\n- (void)test\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n         Student *student = [[Student alloc] init];\n         \n         [student test];\n    }\n    return 0;\n}\n```\n\n向实例对象 student 发送一条 \"test\" 消息。studnet 通过 isa 指针找到 Student 类对象，在类对象里查找对象方法 -(void)test，找到后返回，不在查找父类的类对象。\n\n# class 对象调用类方法流程\n\n```\n[Student unrecoginzedSelector];\n```\n\n向类对象 Student 发送一条 \"unrecoginzedSelector\" 消息。Student 通过 isa 指针找到 Student 元类对象，在元类对象里查找类方法 `-(void)unrecoginzedSelector` 。如果没有，Student 元类对象会通过 superclass 指针找到 Student 父类的元类对象，并在父类的元类对象里查找类方法 `-(void)unrecoginzedSelector`。如果还是没有找到，再通过 superclass 查找父类的元类对象。以此往复，直找到基类 NSObject 的元类对象。如果在 NSObject 的元类对象里也没有查找到类方法 `-(void)unrecoginzedSelector`，就会通过 superclass 指针找到 NSObject 的类对象查找类方法 `-(void)unrecoginzedSelector`。流程图：\n![isa和superclass](isa和superclass/isa和superclass06.png)\n\n## unrecoginzed selector sent to class\n如果在 NSObject 的类对象里也没找到类方法 `-(void)unrecoginzedSelector`，就会返回出现‘unrecoginzed selector sent to class’错误。\n\n## 子类重写父类的类方法\n\n```\n@interface Person : NSObject <NSCopying>\n+ (void)test;\n@end\n\n@implementation Person\n+ (void)test \n{\n\n}\n@end\n\n@interface Student : Person <NSCoding>\n@end\n\n@implementation Student\n+ (void)test\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n         \n         [Student test];\n    }\n    return 0;\n}\n```\n\n向类对象 Student 发送一条 \"test\" Student 通过 isa 指针找到 Student 元类对象，在元类对象里查找类方法 +(void)test，找到后返回，不在查找父类的元类对象。\n\n# class 对象调用对象方法流程\n\n## 定义 NSObject+test\n```\n@interface NSObject (Test)\n+ (void)test;\n@end\n\n@implementation NSObject (Test)\n- (void)test\n{\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n\n@interface Person : NSObject <NSCopying>\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"[Person class] - %p\", [Person class]);\n        NSLog(@\"[NSObject class] - %p\", [NSObject class]);\n        \n        [Person test];\n        [NSObject test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n[Person class] - 0x1000011e0\n[NSObject class] - 0x7fffaa791140\n[NSObject test] - 0x1000011e0 //[Person test] 打印结果\n[NSObject test] - 0x7fffaa791140 //[NSObject test] 打印结果\n```\n## [Person test]\n\n向类对象 Person 发送一条 \"test\" 消息。Person 通过 isa 指针找到 Person 元类对象，在元类对象里查找类方法 `+(void)test`。如果没有，Person 元类对象会通过 superclass 指针找到 NSObject 的元类对象，并在 NSObject 的元类对象里查找类方法 `+(void)test`。如果还是没有找到，再通过 superclass 指针找到 NSObject 的类对象，在类对象中找到对象方法 `-(void)test` 并返回。  \n\nNSObject+test 里打印的 self，是 objc_msgSend() 里的对象，即接收‘test’消息的对象。[Person test] 中，因为是向 Person 发送了一条”test“消息，所以打印的 self 是 Person 的类对象。流程图：\n![isa和superclass](isa和superclass/isa和superclass07.png)\n\n### + (void)test 与 - (void)test 同时存在\n\n```\n@interface NSObject (Test)\n+ (void)test;\n@end\n\n@implementation NSObject (Test)\n+ (void)test\n{\n    NSLog(@\"+[NSObject test] - %p\", self);\n}\n- (void)test\n{\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n```\n\n此时 [Person test] 调用的就是类方法 `+(void)test` 了。因为 `+(void)test` 存储在 NSObject 元类对象里，而 `-(void)test` 存储在 NSObject 类对象里。查找类方法 `+(void)test` 时，会优先找到 NSObject 元类对象，在元类对象里找到类方法 `+(void)test` 后返回，不再到类对象里找了。\n\n## [NSObject test]\n\n向类对象 NSObject 发送一条 \"test\" 消息。NSObject 通过 isa 指针找到 NSObject 元类对象，在元类对象里查找类方法 +(void)test 。如果没有，NSObject 元类对象再通过 superclass 指针找到 NSObject 的类对象，在类对象中找到对象方法 -(void)test 并返回。流程图:\n![isa和superclass](isa和superclass/isa和superclass08.png)  \n\n## class 对象调用对象方法的可能性\n\n```\n[Person test];\n```\n\n上面👆这句代码的本质是：\n```\nobjc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"test\"));\n```\n\n向类对象 Person 发送一条 \"test\" 消息，这条消息里并没有包含方法的类型，即不区分类方法和对象方法。\n\n\n# 窥探 struct objc_class 的结构\n\n## 废弃的 struct objc_class\n\n```\nClass personClass = [Person class];\n\nClass personMetaClass = object_getClass(personClass);\n```\n\n在上面👆类对象的 isa 处提到过，类对象和元类对象的类型 Class 是一个指向结构体 objc_class 的指针：\n```\ntypedef struct objc_class *Class;\n```\n\n![isa和superclass](isa和superclass/isa和superclass12.png)\n\nJump TO Definition -> objc_class：\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n代码中包含以下代码：\n```\n#if !__OBJC2__\n\n#endif\n\nOBJC2_UNAVAILABLE\n```\n\n说明，结构体 struct objc_class 在 __OBJC2__ 里被废弃掉了。\n\n## 新版 struct objc_class\n\n可以在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 找到最新的源码，打开 objc-runtime-new.h :\n\nobjc_class：\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // 方法缓存\n    class_data_bits_t bits;    // 用于获取具体的类信息\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n    ...\n    ...\n    ... 一堆方法\n};\n```\n\nobjc_object：\n```\nstruct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\nclass_rw_ext_t、class_rw_t：\n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods; //方法列表\n    property_array_t properties; //属性列表\n    protocol_array_t protocols; //协议列表\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\nprivate:\n    using ro_or_rw_ext_t = objc::PointerUnion<const class_ro_t *, class_rw_ext_t *>;\n\n    const ro_or_rw_ext_t get_ro_or_rwe() const {\n        return ro_or_rw_ext_t{ro_or_rw_ext};\n    }\n\n    void set_ro_or_rwe(const class_ro_t *ro) {\n        ro_or_rw_ext_t{ro}.storeAt(ro_or_rw_ext, memory_order_relaxed);\n    }\n\n    void set_ro_or_rwe(class_rw_ext_t *rwe, const class_ro_t *ro) {\n        // the release barrier is so that the class_rw_ext_t::ro initialization\n        // is visible to lockless readers\n        rwe->ro = ro;\n        ro_or_rw_ext_t{rwe}.storeAt(ro_or_rw_ext, memory_order_release);\n    }\n\n    class_rw_ext_t *extAlloc(const class_ro_t *ro, bool deep = false);\n\npublic:\n    void setFlags(uint32_t set)\n    {\n        __c11_atomic_fetch_or((_Atomic(uint32_t) *)&flags, set, __ATOMIC_RELAXED);\n    }\n    ...\n    ...\n    ... 一堆方法\n};\n```\n\nclass_rw_t 可以翻译为 class_readWrite_table，即读写表。在 objc4 的旧版本里，class_rw_ext_t 里的成员变量是直接定义在 class_rw_t 里的。\n\nclass_ro_t：\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize; //instance 对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name; //类名\n    method_list_t * baseMethodList; //方法列表\n    protocol_list_t * baseProtocols; //协议列表\n    const ivar_list_t * ivars; //成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties; //属性列表\n\n    // This field exists only when RO_HAS_SWIFT_INITIALIZER is set.\n    _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];\n\n    _objc_swiftMetadataInitializer swiftMetadataInitializer() const {\n        if (flags & RO_HAS_SWIFT_INITIALIZER) {\n            return _swiftMetadataInitializer_NEVER_USE[0];\n        } else {\n            return nil;\n        }\n    }\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n\n    class_ro_t *duplicate() const {\n        if (flags & RO_HAS_SWIFT_INITIALIZER) {\n            size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]);\n            class_ro_t *ro = (class_ro_t *)memdup(this, size);\n            ro->_swiftMetadataInitializer_NEVER_USE[0] = this->_swiftMetadataInitializer_NEVER_USE[0];\n            return ro;\n        } else {\n            size_t size = sizeof(*this);\n            class_ro_t *ro = (class_ro_t *)memdup(this, size);\n            return ro;\n        }\n    }\n};\n```\n\nclass_ro_t 可以翻译为 class_readOnly_table，即只读表。\n\nclass_data_bits_t：\n```\nstruct class_data_bits_t {\n    ...\n\n    class_rw_t* data() const {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n\n    ...\n```\n\nclass_data_bits_t 内部通过 bits & FAST_DATA_MASK 找到 class_rw_t。\n\nobjc_class、class_rw_t 和 class_ro_t 之间的关系可以简化为：\n![isa和superclass](isa和superclass/isa和superclass11.png)\n\n## 查看 objc_class 对象的真实结构\n\n导入 ClassInfo.h，定义 Person 和 Student 类：\n```\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n#import \"ClassInfo.h\"\n\n//Person\n@interface Person : NSObject <NSCopying>\n{\n@public\n    int _age;\n}\n@property (nonatomic, assign) int no;\n- (void)personInstanceMethod;\n+ (void)personClassMethod;\n@end\n\n@implementation Person\n\n- (void)test\n{\n    \n}\n\n- (void)personInstanceMethod\n{\n    \n}\n+ (void)personClassMethod\n{\n    \n}\n- (id)copyWithZone:(NSZone *)zone\n{\n    return nil;\n}\n@end\n\n//Student\n@interface Student : MJPerson <NSCoding>\n{\n@public\n    int _weight;\n}\n@property (nonatomic, assign) int height;\n- (void)studentInstanceMethod;\n+ (void)studentClassMethod;\n@end\n\n@implementation Student\n- (void)test\n{\n    \n}\n- (void)studentInstanceMethod\n{\n    \n}\n+ (void)studentClassMethod\n{\n    \n}\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    return nil;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n        stu->_weight = 10;\n        \n        test_objc_class *studentClass = (__bridge test_objc_class *)([Student class]);\n        test_objc_class *personClass = (__bridge test_objc_class *)([Person class]);\n        \n        class_rw_t *studentClassData = studentClass->data();\n        class_rw_t *personClassData = personClass->data();\n        \n        class_rw_t *studentMetaClassData = studentClass->metaClass()->data();\n        class_rw_t *personMetaClassData = personClass->metaClass()->data();\n\n        NSLog(@\"1111\");\n    }\n    return 0;\n}\n```\n\n加断点后，可以在控制栏里看到每个类内部的具体信息了。\n\nstudentClassData:\n![isa和superclass](isa和superclass/isa和superclass13.png)\n\n可以看到 Student 的类对象里存储了属性、对象方法、协议、成员变量信息。\n\nstudentMetaClassData:\n![isa和superclass](isa和superclass/isa和superclass14.png)\n\n可以看到 Student 的元类对象里存储了类方法、协议。属性、成员变量信息都为 NULL。  \n\n元类对象中存储的协议信息与类对象中存储的协议信息地址相同，所以是同一份。如何确定协议信息是存储在类对象中还是元类对象中呢？还是两个都存储了？ \n\n# 总结\n\n* 对象的 isa 指针指向哪里？  \ninstance 对象的 isa 指向 class 对象  \nclass 对象的 isa 指向 meta-class 对象  \nmeta-class 对象的 isa 指向基类的 meta-class 对象\n\n* OC 的类信息存放在哪里？  \n对象方法、属性、成员变量、协议信息，存放在 class 对象中  \n类方法，存放在 meta-class 对象中  \n成员变量的具体值，存放在 instance 对象\n\n\nps:\nClassInfo.h\n```\n#import <Foundation/Foundation.h>\n\n#ifndef ClassInfo_h\n#define ClassInfo_h\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n};\n\nstruct entsize_list_tt {\n    uint32_t entsizeAndFlags;\n    uint32_t count;\n};\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n    method_t first;\n};\n\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n    uint32_t alignment_raw;\n    uint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n    ivar_t first;\n};\n\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n    property_t first;\n};\n\nstruct chained_property_list {\n    chained_property_list *next;\n    uint32_t count;\n    property_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n    uintptr_t count;\n    protocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout;\n    const char * name;  // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;  // 成员变量列表\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const class_ro_t *ro;\n    method_list_t * methods;    // 方法列表\n    property_list_t *properties;    // 属性列表\n    const protocol_list_t * protocols;  // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n    uintptr_t bits;\npublic:\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n};\n\n/* OC对象 */\nstruct test_objc_object {\n    void *isa;\n};\n\n/* 类对象 */\nstruct test_objc_class : test_objc_object {\n    Class superclass;\n    cache_t cache;\n    class_data_bits_t bits;\npublic:\n    class_rw_t* data() {\n        return bits.data();\n    }\n    \n    test_objc_class* metaClass() {\n        return (test_objc_class *)((long long)isa & ISA_MASK);\n    }\n};\n\n#endif /* ClassInfo_h */\n```","source":"_posts/OC底层原理/isa和superclass.md","raw":"---\ntitle: isa和superclass\ndate: 2020-05-11 14:35:58\ntags: OC底层原理\n---\n\n思考：\n* 对象的 isa 指针指向哪里？\n* OC 的类信息存放在哪里？\n\n<!-- more -->\n\n# 图解\n![isa和superclass](isa和superclass/isa和superclass01.png)\n* instance 的 isa 指向 class\n* class 的 isa 指向 meta-class\n* meta-class 的 isa 指向基类的 meta-class\n* class 的 superclass 指向父类的 class，如果没有父类，superclass 指针为nil\n* meta-class 的 superclass 指向父类的 meta-class，基类的 meta-class 的 superclass 指向基类的 class\n* instance 调用对象方法的轨迹：isa 找到 class，方法不存在，就通过 superclass 找父类\n* class 调用类方法的轨迹：isa 找 meta-class，方法不存在，就通过 superclass 找父类\n\n# isa\n\n## instance 对象、class 对象 和 meta-class 对象之间的 isa 关系\n![isa和superclass](isa和superclass/isa和superclass02.png)\n\n### 定义 Person\n```\n@interface Person : NSObject <NSCopying>\n{\n    @public\n    int _age;\n}\n@property (nonatomic, assign) int no;\n- (void)personInstanceMethod;\n+ (void)personClassMethod;\n@end\n\n@implementation Person\n@end\n```\n\n创建 Person 的实例对象\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [[Person alloc] init];\n        \n        person->_age = 10;\n\n        [person personInstanceMethod];\n        \n        [Person personClassMethod];\n        \n    }\n    return 0;\n}\n```\n\n### 将 OC 代码转换为 C\\C++ 代码\n找到 main.m 所在文件，在终端输入：\n```\n$ xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc main.m\n```\n\n没有通过 ‘-o’ 生成指定文件时，默认生成 main.cpp 文件，打开 main.cpp 文件。找到 main 函数：\n```\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n        (*(int *)((char *)person + OBJC_IVAR_$_Person$_age)) = 10;\n\n        ((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"personInstanceMethod\"));\n\n        ((void (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n\n    }\n    return 0;\n}\n```\n\n找到 objc_msgSend：\n```\n((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(\"personInstanceMethod\"));\n\n((void (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n\n//简化后：\nobjc_msgSend(person, sel_registerName(\"personInstanceMethod\"));\n\nobjc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"));\n```\n\n`[person personInstanceMethod]` 的具体实现是 `objc_msgSend(person, sel_registerName(\"personInstanceMethod\"))`。  \n即在实例对象 person 调用 `-(void)personInstanceMethod` 对象方法的时候，向实例对象 person 发送一条 \"personInstanceMethod\" 消息。  \n\n`[Person personClassMethod]` 的具体实现是 `objc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"personClassMethod\"))`。  \n即在类对象 Person 调用 `+(void)personClassMethod` 类方法的时候，向类对象 Person 发送一条 \"personClassMethod\" 消息。  \n\n### 方法调用与对象的关系\n```\n[person personInstanceMethod];\n[Person personClassMethod];\n```\n\n上面👆两个方法调用表现出来的是，实例对象 person 可以调用存在 Person 类对象里的对象方法， Person 类对象可以调用存储在 Person 元类对象里的类方法。\n\n### 小结\n* instance 对象的 isa 指针指向 class 对象。当调用对象方法时，通过 instance 对象的 isa 指针找到 class 对象，最后找到对象方法的实现进行调用。\n* class 对象的 isa 指针指向 meta-class 对象。当调用类方法时，通过 class 对象的 isa 指针找到 meta-class对象，最后找到类方法的实现进行调用。\n\n## ISA_MASK\n\n<!-- ![isa和superclass](isa和superclass/isa和superclass10.png) -->\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [[Person alloc] init];\n        \n        Class personClass = [Person class];\n\n        Class personMetaClass = object_getClass(personClass);\n\n        NSLog(@\"%p %p %p\", person, personClass, personMetaClass);\n    }\n    return 0;\n}\n```\n### 实例对象的 isa 指针\n打印 Person->isa、personClass：\n```\n(lldb) p/x (long)person->isa //指针地址格式设置16进制\n(long) $2 = 0x001d8001000014f1\n(lldb) p/x personClass\n(Class) $3 = 0x00000001000014f0 Person\n```\n\n上面👆的打印结果可以看到，Person 的类对象地址是 0x00000001000014f0，而 Person 的实例对象的 isa 指针的地址是 0x001d8001000014f1。\n\n不相等原因是在 64bit 之前 isa 指针的地址等于被指向对象的地址，从 64bit 开始 isa 需要进行一次位运算，才能计算出真实地址：\n![isa和superclass](isa和superclass/isa和superclass09.png)\n\nISA_MASK 在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的定义：\n```\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                        \\\n      uintptr_t nonpointer        : 1;                                         \\\n      uintptr_t has_assoc         : 1;                                         \\\n      uintptr_t has_cxx_dtor      : 1;                                         \\\n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                         \\\n      uintptr_t weakly_referenced : 1;                                         \\\n      uintptr_t deallocating      : 1;                                         \\\n      uintptr_t has_sidetable_rc  : 1;                                         \\\n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n```\n\niPhoneOS 是 __arm64__ 架构，ISA_MASK：0x0000000ffffffff8。  \nMacOS 是 __x86_64__ 架构，ISA_MASK：0x00007ffffffffff8ULL。  \n\n打印 person->isa & ISA_MASK\n```\n(lldb) p/x 0x001d8001000014f1 & 0x00007ffffffffff8\n(long) $4 = 0x00000001000014f0\n```\n\n上面👆的打印结果可以看出，Person 实例对象的 isa 指针 & ISA_MASK 就是 Person 类对象的地址。\n\n\n### 类对象的 isa 指针\n类对象的类型 Class 是一个指向结构体 objc_class 的指针：\n```\ntypedef struct objc_class *Class;\n```\n\nJump TO Definition -> objc_class：\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n👆 objc_class 的 isa 是不支持外部访问的，所以 personClass->isa 获取不到 isa 指针地址，所以要自定义一个 test_objc_class 结构体，再将 personClass 的类型强转为 test_objc_class 类型：\n```\nstruct test_objc_class {\n    Class isa;\n    Class superclass;\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Class personClass = [Person class];\n\n        struct test_objc_class *personClass2 = (__bridge struct test_objc_class *)(personClass); \n    }\n    return 0;\n}\n\n```\n\n因为 personClass 是 OC 对象，将 OC 代码专为 c++ 代码需要用到桥接 (__bridge struct test_objc_class *)。  \n\n打印 personClass2->isa、personMetaClass 和 personClass2->isa & ISA_MASK：\n```\n(lldb) p/x personClass2->isa\n(Class) $5 = 0x001d8001000014c9\n(lldb) p/x personMetaClass\n(Class) $6 = 0x00000001000014c8\n(lldb) p/x 0x001d8001000014c9 & 0x00007ffffffffff8\n(long) $7 = 0x00000001000014c8\n```\n\n上面👆的打印结果可以看出，Person 类对象的 isa 指针 & ISA_MASK 就是 Person 元类对象的地址。\n\n# superclass\n\n定义 Student 继承自 Person：\n```\n@interface Student : Person <NSCoding>\n{\n    @public\n    int _weight;\n}\n@property (nonatomic, assign) int height;\n- (void)studentInstanceMethod;\n+ (void)studentClassMethod;\n@end\n\n@implementation Student\n- (void)studentInstanceMethod\n{\n    \n}\n+ (void)studentClassMethod\n{\n    \n}\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    return nil;\n}\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    \n}\n@end\n```\n\n创建 Student 的实例对象\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n         Student *student = [[Student alloc] init];\n         \n         [student personInstanceMethod];\n         \n         [student init];\n         \n         [Student studentClassMethod];\n         \n         [Student personClassMethod];\n         \n         [Student load];\n    }\n    return 0;\n}\n```\n\n## class 对象的 superclass 指针\n\nStudent 类对象、Person 类对象 和 NSObject 类对象之间的 superclass 关系：\n![isa和superclass](isa和superclass/isa和superclass03.png)\n\n获取 test_objc_class 类型的 Person 类对象和 Student 类对象：\n```\nstruct test_objc_class *personClass = (__bridge struct test_objc_class *)([Person class]);\n\nstruct test_objc_class *studentClass = (__bridge struct test_objc_class *)([Student class]);\n```\n\n打印 personClass、studentClass 和 studentClass->superclass：\n```\n(lldb) p personClass\n(test_objc_class *) $0 = 0x00000001000014b8\n(lldb) p studentClass\n(test_objc_class *) $1 = 0x0000000100001508\n(lldb) p/x studentClass->superclass\n(Class) $2 = 0x00000001000014b8 Person\n```\n\n上面👆的打印结果可以看出，Student 类对象的 superclass 指针地址就是 Person 类对象的地址。\n\n### Student 的实例对象调用父类 Person 里的对象方法：\n```\n[student personInstanceMethod];\n```\n\n对象方法 `-(void)personInstanceMethod` 保存在 Person 的类对象里，`[student personInstanceMethod]` 首先通过 student 的 isa 指针找到 Student 的类对象，再通过 Student 类对象里的 superclass 找到 Person 的类对象，最后在 Person 类对象里找到了对象方法 `-(void)personInstanceMethod`。\n\n### Student 的实例对象调用父类 NSObject 里的对象方法：\n```\n[student init];\n```\n\n对象方法 `-(void)init` 方法保存在 NSObject 的类对象里，`[student init]` 首先通过 student 的 isa 指针找到 Student 的类对象，再通过 Student 类对象里的 superclass 找到 Person 的类对象，再通过 Person 类对象里的 superclass 找到 NSObject 的类对象，最后在 NSObject 类对象里找到了对象方法 `-(void)init`。\n\n### 小结\n* 具有继承关系的不同的类之间，是通过 superlass 指针连接的。有了 superlass 指针的连接，就实现了子类调用父类方法的逻辑。\n* 当 Student 的 instance 对象在调用 Person 的对象方法时，会先通过 isa 找到 Student 的 class，然后通过 superclass 找到 Person 的 class，最后找到对象方法的实现进行调用。\n\n\n## meta-class 对象的 superclass 指针\n\nStudent 元类对象、Person 元类对象 和 NSObject 元类对象之间的 superclass 关系：\n![isa和superclass](isa和superclass/isa和superclass04.png)\n\n### Student 类对象调用 Student 元类对象里的类方法：\n```\n[Student studentClassMethod];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，最终在 Student 元类对象里找到类方法 `+(void)studentClassMethod`。\n\n### Student 类对象调用父类 Person 元类对象里的类方法：\n```\n[Student personClassMethod];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，再通过 Student 元类对象里的 superclass 找到 Person 元类对象，最终在 Person 元类对象里找到类方法 `+(void)personClassMethod`。\n\n### Student 类对象调用父类 NSObject 元类对象里的类方法：\n```\n[Student load];\n```\n\n首先通过 Student 类对象里的 isa 指针找到 Student 元类对象，再通过 Student 元类对象里的 superclass 找到 Person 元类对象，再通过 Person 元类对象里的 superclass 找到 NSObject 元类对象，最终在 NSObject 元类对象里找到类方法 `+(void)load`。\n\n\n# instance 对象调用对象方法流程\n\n```\n[student unrecoginzedSelector];\n```\n\n向实例对象 student 发送一条 \"unrecoginzedSelector\" 消息。student 通过 isa 指针找到 Student 类对象，在类对象里查找对象方法 `-(void)unrecoginzedSelector`。如果没有，Student 类对象会通过 superclass 指针找到 Student 父类的类对象，并在父类的类对象里查找对象方法 `-(void)unrecoginzedSelector`。如果还是没有找到，再通过 superclass 查找父类的类对象。以此往复，直找到基类 NSObject 的类对象。流程图：\n![isa和superclass](isa和superclass/isa和superclass05.png)\n\n## unrecoginzed selector sent to instance\n如果在 NSObject 的类对象里也没有查找到对象方法 `-(void)unrecoginzedSelector`，就会返回出现‘unrecoginzed selector sent to instance’错误。\n\n## 子类重写父类的对象方法\n\n```\n@interface Person : NSObject <NSCopying>\n- (void)test;\n@end\n\n@implementation Person\n- (void)test \n{\n\n}\n@end\n\n@interface Student : Person <NSCoding>\n@end\n\n@implementation Student\n- (void)test\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n         Student *student = [[Student alloc] init];\n         \n         [student test];\n    }\n    return 0;\n}\n```\n\n向实例对象 student 发送一条 \"test\" 消息。studnet 通过 isa 指针找到 Student 类对象，在类对象里查找对象方法 -(void)test，找到后返回，不在查找父类的类对象。\n\n# class 对象调用类方法流程\n\n```\n[Student unrecoginzedSelector];\n```\n\n向类对象 Student 发送一条 \"unrecoginzedSelector\" 消息。Student 通过 isa 指针找到 Student 元类对象，在元类对象里查找类方法 `-(void)unrecoginzedSelector` 。如果没有，Student 元类对象会通过 superclass 指针找到 Student 父类的元类对象，并在父类的元类对象里查找类方法 `-(void)unrecoginzedSelector`。如果还是没有找到，再通过 superclass 查找父类的元类对象。以此往复，直找到基类 NSObject 的元类对象。如果在 NSObject 的元类对象里也没有查找到类方法 `-(void)unrecoginzedSelector`，就会通过 superclass 指针找到 NSObject 的类对象查找类方法 `-(void)unrecoginzedSelector`。流程图：\n![isa和superclass](isa和superclass/isa和superclass06.png)\n\n## unrecoginzed selector sent to class\n如果在 NSObject 的类对象里也没找到类方法 `-(void)unrecoginzedSelector`，就会返回出现‘unrecoginzed selector sent to class’错误。\n\n## 子类重写父类的类方法\n\n```\n@interface Person : NSObject <NSCopying>\n+ (void)test;\n@end\n\n@implementation Person\n+ (void)test \n{\n\n}\n@end\n\n@interface Student : Person <NSCoding>\n@end\n\n@implementation Student\n+ (void)test\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n         \n         [Student test];\n    }\n    return 0;\n}\n```\n\n向类对象 Student 发送一条 \"test\" Student 通过 isa 指针找到 Student 元类对象，在元类对象里查找类方法 +(void)test，找到后返回，不在查找父类的元类对象。\n\n# class 对象调用对象方法流程\n\n## 定义 NSObject+test\n```\n@interface NSObject (Test)\n+ (void)test;\n@end\n\n@implementation NSObject (Test)\n- (void)test\n{\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n\n@interface Person : NSObject <NSCopying>\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"[Person class] - %p\", [Person class]);\n        NSLog(@\"[NSObject class] - %p\", [NSObject class]);\n        \n        [Person test];\n        [NSObject test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n[Person class] - 0x1000011e0\n[NSObject class] - 0x7fffaa791140\n[NSObject test] - 0x1000011e0 //[Person test] 打印结果\n[NSObject test] - 0x7fffaa791140 //[NSObject test] 打印结果\n```\n## [Person test]\n\n向类对象 Person 发送一条 \"test\" 消息。Person 通过 isa 指针找到 Person 元类对象，在元类对象里查找类方法 `+(void)test`。如果没有，Person 元类对象会通过 superclass 指针找到 NSObject 的元类对象，并在 NSObject 的元类对象里查找类方法 `+(void)test`。如果还是没有找到，再通过 superclass 指针找到 NSObject 的类对象，在类对象中找到对象方法 `-(void)test` 并返回。  \n\nNSObject+test 里打印的 self，是 objc_msgSend() 里的对象，即接收‘test’消息的对象。[Person test] 中，因为是向 Person 发送了一条”test“消息，所以打印的 self 是 Person 的类对象。流程图：\n![isa和superclass](isa和superclass/isa和superclass07.png)\n\n### + (void)test 与 - (void)test 同时存在\n\n```\n@interface NSObject (Test)\n+ (void)test;\n@end\n\n@implementation NSObject (Test)\n+ (void)test\n{\n    NSLog(@\"+[NSObject test] - %p\", self);\n}\n- (void)test\n{\n    NSLog(@\"-[NSObject test] - %p\", self);\n}\n@end\n```\n\n此时 [Person test] 调用的就是类方法 `+(void)test` 了。因为 `+(void)test` 存储在 NSObject 元类对象里，而 `-(void)test` 存储在 NSObject 类对象里。查找类方法 `+(void)test` 时，会优先找到 NSObject 元类对象，在元类对象里找到类方法 `+(void)test` 后返回，不再到类对象里找了。\n\n## [NSObject test]\n\n向类对象 NSObject 发送一条 \"test\" 消息。NSObject 通过 isa 指针找到 NSObject 元类对象，在元类对象里查找类方法 +(void)test 。如果没有，NSObject 元类对象再通过 superclass 指针找到 NSObject 的类对象，在类对象中找到对象方法 -(void)test 并返回。流程图:\n![isa和superclass](isa和superclass/isa和superclass08.png)  \n\n## class 对象调用对象方法的可能性\n\n```\n[Person test];\n```\n\n上面👆这句代码的本质是：\n```\nobjc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"test\"));\n```\n\n向类对象 Person 发送一条 \"test\" 消息，这条消息里并没有包含方法的类型，即不区分类方法和对象方法。\n\n\n# 窥探 struct objc_class 的结构\n\n## 废弃的 struct objc_class\n\n```\nClass personClass = [Person class];\n\nClass personMetaClass = object_getClass(personClass);\n```\n\n在上面👆类对象的 isa 处提到过，类对象和元类对象的类型 Class 是一个指向结构体 objc_class 的指针：\n```\ntypedef struct objc_class *Class;\n```\n\n![isa和superclass](isa和superclass/isa和superclass12.png)\n\nJump TO Definition -> objc_class：\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n代码中包含以下代码：\n```\n#if !__OBJC2__\n\n#endif\n\nOBJC2_UNAVAILABLE\n```\n\n说明，结构体 struct objc_class 在 __OBJC2__ 里被废弃掉了。\n\n## 新版 struct objc_class\n\n可以在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 找到最新的源码，打开 objc-runtime-new.h :\n\nobjc_class：\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // 方法缓存\n    class_data_bits_t bits;    // 用于获取具体的类信息\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n    ...\n    ...\n    ... 一堆方法\n};\n```\n\nobjc_object：\n```\nstruct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\nclass_rw_ext_t、class_rw_t：\n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods; //方法列表\n    property_array_t properties; //属性列表\n    protocol_array_t protocols; //协议列表\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\nprivate:\n    using ro_or_rw_ext_t = objc::PointerUnion<const class_ro_t *, class_rw_ext_t *>;\n\n    const ro_or_rw_ext_t get_ro_or_rwe() const {\n        return ro_or_rw_ext_t{ro_or_rw_ext};\n    }\n\n    void set_ro_or_rwe(const class_ro_t *ro) {\n        ro_or_rw_ext_t{ro}.storeAt(ro_or_rw_ext, memory_order_relaxed);\n    }\n\n    void set_ro_or_rwe(class_rw_ext_t *rwe, const class_ro_t *ro) {\n        // the release barrier is so that the class_rw_ext_t::ro initialization\n        // is visible to lockless readers\n        rwe->ro = ro;\n        ro_or_rw_ext_t{rwe}.storeAt(ro_or_rw_ext, memory_order_release);\n    }\n\n    class_rw_ext_t *extAlloc(const class_ro_t *ro, bool deep = false);\n\npublic:\n    void setFlags(uint32_t set)\n    {\n        __c11_atomic_fetch_or((_Atomic(uint32_t) *)&flags, set, __ATOMIC_RELAXED);\n    }\n    ...\n    ...\n    ... 一堆方法\n};\n```\n\nclass_rw_t 可以翻译为 class_readWrite_table，即读写表。在 objc4 的旧版本里，class_rw_ext_t 里的成员变量是直接定义在 class_rw_t 里的。\n\nclass_ro_t：\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize; //instance 对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name; //类名\n    method_list_t * baseMethodList; //方法列表\n    protocol_list_t * baseProtocols; //协议列表\n    const ivar_list_t * ivars; //成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties; //属性列表\n\n    // This field exists only when RO_HAS_SWIFT_INITIALIZER is set.\n    _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];\n\n    _objc_swiftMetadataInitializer swiftMetadataInitializer() const {\n        if (flags & RO_HAS_SWIFT_INITIALIZER) {\n            return _swiftMetadataInitializer_NEVER_USE[0];\n        } else {\n            return nil;\n        }\n    }\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n\n    class_ro_t *duplicate() const {\n        if (flags & RO_HAS_SWIFT_INITIALIZER) {\n            size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]);\n            class_ro_t *ro = (class_ro_t *)memdup(this, size);\n            ro->_swiftMetadataInitializer_NEVER_USE[0] = this->_swiftMetadataInitializer_NEVER_USE[0];\n            return ro;\n        } else {\n            size_t size = sizeof(*this);\n            class_ro_t *ro = (class_ro_t *)memdup(this, size);\n            return ro;\n        }\n    }\n};\n```\n\nclass_ro_t 可以翻译为 class_readOnly_table，即只读表。\n\nclass_data_bits_t：\n```\nstruct class_data_bits_t {\n    ...\n\n    class_rw_t* data() const {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n\n    ...\n```\n\nclass_data_bits_t 内部通过 bits & FAST_DATA_MASK 找到 class_rw_t。\n\nobjc_class、class_rw_t 和 class_ro_t 之间的关系可以简化为：\n![isa和superclass](isa和superclass/isa和superclass11.png)\n\n## 查看 objc_class 对象的真实结构\n\n导入 ClassInfo.h，定义 Person 和 Student 类：\n```\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n#import \"ClassInfo.h\"\n\n//Person\n@interface Person : NSObject <NSCopying>\n{\n@public\n    int _age;\n}\n@property (nonatomic, assign) int no;\n- (void)personInstanceMethod;\n+ (void)personClassMethod;\n@end\n\n@implementation Person\n\n- (void)test\n{\n    \n}\n\n- (void)personInstanceMethod\n{\n    \n}\n+ (void)personClassMethod\n{\n    \n}\n- (id)copyWithZone:(NSZone *)zone\n{\n    return nil;\n}\n@end\n\n//Student\n@interface Student : MJPerson <NSCoding>\n{\n@public\n    int _weight;\n}\n@property (nonatomic, assign) int height;\n- (void)studentInstanceMethod;\n+ (void)studentClassMethod;\n@end\n\n@implementation Student\n- (void)test\n{\n    \n}\n- (void)studentInstanceMethod\n{\n    \n}\n+ (void)studentClassMethod\n{\n    \n}\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    return nil;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    \n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n        stu->_weight = 10;\n        \n        test_objc_class *studentClass = (__bridge test_objc_class *)([Student class]);\n        test_objc_class *personClass = (__bridge test_objc_class *)([Person class]);\n        \n        class_rw_t *studentClassData = studentClass->data();\n        class_rw_t *personClassData = personClass->data();\n        \n        class_rw_t *studentMetaClassData = studentClass->metaClass()->data();\n        class_rw_t *personMetaClassData = personClass->metaClass()->data();\n\n        NSLog(@\"1111\");\n    }\n    return 0;\n}\n```\n\n加断点后，可以在控制栏里看到每个类内部的具体信息了。\n\nstudentClassData:\n![isa和superclass](isa和superclass/isa和superclass13.png)\n\n可以看到 Student 的类对象里存储了属性、对象方法、协议、成员变量信息。\n\nstudentMetaClassData:\n![isa和superclass](isa和superclass/isa和superclass14.png)\n\n可以看到 Student 的元类对象里存储了类方法、协议。属性、成员变量信息都为 NULL。  \n\n元类对象中存储的协议信息与类对象中存储的协议信息地址相同，所以是同一份。如何确定协议信息是存储在类对象中还是元类对象中呢？还是两个都存储了？ \n\n# 总结\n\n* 对象的 isa 指针指向哪里？  \ninstance 对象的 isa 指向 class 对象  \nclass 对象的 isa 指向 meta-class 对象  \nmeta-class 对象的 isa 指向基类的 meta-class 对象\n\n* OC 的类信息存放在哪里？  \n对象方法、属性、成员变量、协议信息，存放在 class 对象中  \n类方法，存放在 meta-class 对象中  \n成员变量的具体值，存放在 instance 对象\n\n\nps:\nClassInfo.h\n```\n#import <Foundation/Foundation.h>\n\n#ifndef ClassInfo_h\n#define ClassInfo_h\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n};\n\nstruct entsize_list_tt {\n    uint32_t entsizeAndFlags;\n    uint32_t count;\n};\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n    method_t first;\n};\n\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n    uint32_t alignment_raw;\n    uint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n    ivar_t first;\n};\n\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n    property_t first;\n};\n\nstruct chained_property_list {\n    chained_property_list *next;\n    uint32_t count;\n    property_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n    uintptr_t count;\n    protocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout;\n    const char * name;  // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;  // 成员变量列表\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const class_ro_t *ro;\n    method_list_t * methods;    // 方法列表\n    property_list_t *properties;    // 属性列表\n    const protocol_list_t * protocols;  // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n    uintptr_t bits;\npublic:\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n};\n\n/* OC对象 */\nstruct test_objc_object {\n    void *isa;\n};\n\n/* 类对象 */\nstruct test_objc_class : test_objc_object {\n    Class superclass;\n    cache_t cache;\n    class_data_bits_t bits;\npublic:\n    class_rw_t* data() {\n        return bits.data();\n    }\n    \n    test_objc_class* metaClass() {\n        return (test_objc_class *)((long long)isa & ISA_MASK);\n    }\n};\n\n#endif /* ClassInfo_h */\n```","slug":"OC底层原理/isa和superclass","published":1,"updated":"2023-08-22T09:52:13.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgse000paq7ke4h1hfiz"},{"title":"+initialize方法","date":"2020-05-22T07:20:48.000Z","_content":"\n思考：\n* load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？\n\n<!-- more -->\n\n+initialize 方法会在类第一次接收到消息时调用\n\n# 定义 Persion、Student 及其分类\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n+ (void)initialize\n{\n    NSLog(@\"Person +initialize\");\n}\n@end\n\n@interface Person (Test1)\n@end\n\n@implementation Person (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Person (Test1) +initialize\");\n}\n@end\n\n@interface Person (Test2)\n@end\n\n@implementation Person (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Person (Test2) +initialize\");\n}\n@end\n\n@interface Student : Persion\n@end\n\n@implementation Student\n+ (void)initialize\n{\n    NSLog(@\"Student +initialize\");\n}\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Student (Test1) +initialize\");\n}\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Student (Test2) +initialize\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion alloc];\n        [Student alloc];\n    }\n    return 0;\n}\n```\n\n编译顺序：  \n![initialize方法01](initialize方法/initialize方法01.png)\n\n打印结果：\n```\nPersion (Test1) +initialize\nStudent (Test2) +initialize\n```\n\n# objc4源码解读过程\n* objc-msg-arm64.s  \nobjc_msgSend  \n\n* objc-runtime-new.mm  \nclass_getInstanceMethod  \nlookUpImpOrNil  \nlookUpImpOrForward  \n_class_initialize  \ncallInitialize  \nobjc_msgSend(cls, SEL_initialize)\n\n[Persion alloc] 的本质是：\n```\nobjc_msgSend(objc_getClass(\"Persion\"), sel_registerName(\"alloc\"))\n```\n\n[Student alloc] 的本质是：  \n```\n objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\"))\n```\n\n# objc_msgSend()\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，搜索 objc_msgSend()，会发现 objc_msgSend() 方法的源码是汇编语言。\n \nobjc_msgSend() - 类方法调用流程：  \nisa -> 类对象/元类对象，寻找方法，调用  \nsuperclass -> 类对象/元类对象，寻找方法，调用  \nsuperclass -> 类对象/元类对象，寻找方法，调用\n\n从“寻找方法”入手👇\n\n# class_getClassMethod\n\nclass_getClassMethod 是获取类方法的函数，内部调用的是 class_getInstanceMethod 获取对象方法的函数。\n```\nMethod class_getClassMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    return class_getInstanceMethod(cls->getMeta(), sel);\n}\n```\n\n## class_getInstanceMethod\nJump To Definition -> class_getInstanceMethod\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n#warning fixme build and search caches\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);\n\n#warning fixme build and search caches\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n## lookUpImpOrForward\n\n在 class_getInstanceMethod 方法中，调用 lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER) 方法。所以 behavior == LOOKUP_RESOLVER\n\nJump To Definition -> lookUpImpOrForward\n```\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    ...\n    ...\n    ...//一堆方法\n\n    // Check for +initialize\n    if ((behavior & LOOKUP_INITIALIZE)  &&  !cls->isInitialized()) { //如果类还没有实现 +initialized 方法\n        initializeNonMetaClass (_class_getNonMetaClass(cls, inst));\n        // If sel == initialize, initializeNonMetaClass will send +initialize \n        // and then the messenger will send +initialize again after this \n        // procedure finishes. Of course, if this is not being called \n        // from the messenger then it won't happen. 2778172\n    }\n\n    ...\n    ...\n    ...//一堆方法\n}\n```\n\n## initializeNonMetaClass\n\ninitializeNonMetaClass 方法使用递归的方式优先将传入的类 cls 的父类调用 initializeNonMetaClass 方法进行处理。\n\nJump To Definition -> initializeNonMetaClass\n```\nvoid initializeNonMetaClass(Class cls)\n{\n    ASSERT(!cls->isMetaClass());\n\n    Class supercls;\n    bool reallyInitialize = NO;\n\n    // Make sure super is done initializing BEFORE beginning to initialize cls.\n    // See note about deadlock above.\n    supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) { // 存在父类 && 父类没有调用个 +initialize 方法\n        initializeNonMetaClass(supercls);\n    }\n    \n    // Try to atomically set CLS_INITIALIZING.\n    SmallVector<_objc_willInitializeClassCallback, 1> localWillInitializeFuncs;\n    {\n        monitor_locker_t lock(classInitLock);\n        if (!cls->isInitialized() && !cls->isInitializing()) {\n            cls->setInitializing(); //设置 RW_INITIALIZING 状态\n            reallyInitialize = YES;\n\n            // Grab a copy of the will-initialize funcs with the lock held.\n            localWillInitializeFuncs.initFrom(willInitializeFuncs);\n        }\n    }\n    \n    if (reallyInitialize) {\n        // We successfully set the CLS_INITIALIZING bit. Initialize the class.\n        \n        // Record that we're initializing this class so we can message it.\n        _setThisThreadIsInitializingClass(cls);\n\n        if (MultithreadedForkChild) {\n            // LOL JK we don't really call +initialize methods after fork().\n            performForkChildInitialize(cls, supercls); // 设置 RW_INITIALIZED 状态\n            return;\n        }\n        \n        for (auto callback : localWillInitializeFuncs)\n            callback.f(callback.context, cls);\n\n        // Send the +initialize message.\n        // Note that +initialize is sent to the superclass (again) if \n        // this class doesn't implement +initialize. 2157218\n        if (PrintInitializing) {\n            _objc_inform(\"INITIALIZE: thread %p: calling +[%s initialize]\",\n                         objc_thread_self(), cls->nameForLogging());\n        }\n\n        // Exceptions: A +initialize call that throws an exception \n        // is deemed to be a complete and successful +initialize.\n        //\n        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a\n        // bootstrapping problem of this versus CF's call to\n        // objc_exception_set_functions().\n#if __OBJC2__\n        @try\n#endif\n        {\n            callInitialize(cls);\n\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: finished +[%s initialize]\",\n                             objc_thread_self(), cls->nameForLogging());\n            }\n        }\n        ...\n        ...\n        ...\n}\n```\n\n设置正在调用 +initialize 方法的状态 RW_INITIALIZING：\n```\ncls->setInitializing()\n```\n\n设置已经调用 +initialize 方法的状态 RW_INITIALIZED：\n```\nperformForkChildInitialize(cls, supercls) -> lockAndFinishInitializing(cls, supercls) -> _finishInitializing(cls, supercls) -> cls->setInitialized()\n```\n\nisInitializing()、setInitializing()、isInitialized()、setInitialized() 方法：\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n\n    void setInfo(uint32_t set) {\n        ASSERT(isFuture()  ||  isRealized());\n        data()->setFlags(set);\n    }\n\n    ...\n    ...\n    ...//一堆方法\n\n    bool isInitializing() {\n        return getMeta()->data()->flags & RW_INITIALIZING;\n    }\n\n    void setInitializing() {\n        ASSERT(!isMetaClass());\n        ISA()->setInfo(RW_INITIALIZING);\n    }\n\n    bool isInitialized() {\n        return getMeta()->data()->flags & RW_INITIALIZED;\n    }\n\n    void setInitialized();\n\n    ...\n    ...\n    ...//一堆方法\n```\n\n## callInitialize\n\n向传入的类 cls 发送“initialize”消息。至此实现了 +initialize 方法的调用。\n\nJump To Definition -> callInitialize\n```\nvoid callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));\n    asm(\"\");\n}\n```\n\n# 调用顺序\n```\n@interface Persion : NSObject\n@end\n\n@implementation Persion\n+ (void)initialize\n{\n    NSLog(@\"Persion +initialize\");\n}\n@end\n\n@interface Persion (Test1)\n@end\n\n@implementation Persion (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Persion (Test1) +initialize\");\n}\n@end\n\n@interface Persion (Test2)\n@end\n\n@implementation Persion (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Persion (Test2) +initialize\");\n}\n@end\n\n@interface Student : Persion\n@end\n\n@implementation Student\n@end\n\n@interface Teacher : Persion\n@end\n\n@implementation Teacher\n@end\n```\n\n编译顺序：  \n![initialize方法01](initialize方法/initialize方法01.png)\n\n打印结果：\n```\nPersion (Test1) +initialize\nPersion (Test1) +initialize\nPersion (Test1) +initialize\n```\n\n## 优先调用父类的 +initialize 方法  \n从 initializeNonMetaClass 方法中有个一递归设计，跟 +load 方法调用中的 schedule_class_load 方法如出一辙。会先判断父类的 +initialize 方法是否已经调用，如果没有会优先先调用父类的 +initialize 方法。在将所有的父类都处理完后，再调用传入的类 cls 的 +initialize 方法。  \n\n## 每个类只会调用一次 +initialize 方法 \n因为有 !cls->isInitialized() 判断，所以每个类只会初始化1次，也就是每个类只会调用一次 +initialize 方法。  \n\n## 父类的 +initialize 可能会被调用多次\n如果子类没有实现 +initialize 会调用父类的 +initialize（所以父类的 +initialize 可能会被调用多次）。这一点通过 callInitialize 方法可以看出，向传入的类 cls 发送一条 @selector(initialize) 消息。类 cls 会通过 isa 找到 cls 元类对象查找 +initialize 方法，如果没有再通过 superclass 指针找到父类的元类方法查找 +initialize 方法，找到后并调用。\n\n## 总结\n* load、initialize 方法的区别什么？  \n  1、调用方式  \n  1> +load 是根据函数地址直接调用（ (*load_method)(cls, @selector(load))）；  \n  2> +initialize 是通过 objc_msgSend 调用；  \n\n  2、调用时刻  \n  1> +load 是 runtime 加载类、分类的时刻调用，每个类只会调用一次；  \n  2> +initialize 是类第一次收到消息的时候调用，每个类只会调用一次，父类的 +initialize 方法可能会被调用多次；  \n\n* +load 和 +initialize 的调用顺序？  \n  +load 方法：  \n  1、先调用类的 +load  \n  1> 先编译的类，优先调用 +load；  \n  2> 先调用父类的 +load，再调用子类的 +load；  \n\n  2、再调用分类的 +load  \n  1> 先编译的分类，优先调用 +load；  \n\n  +initialize 方法：  \n  1、先初始化父类，再初始化子类；  \n  2、子类没有 +initialize 方法时会调用父类的 +initialize 方法；  \n  3、有分类实现 +initialize 方法的，只调用最后被编译的分类里的 +initialize 方法；\n\n* 出现继承时他们之间的调用过程？  \n  +load 方法：  \n  1、+load 是先调用父类的 +load，再调用子类的 +load。调用 +load 方法时是通过找到每个类 +load 方法的函数地址调用的。  \n  2、+initialize 也是先调用父类，再调用子类的。调用 +initialize 方法是通过 objc_msgSend 调用的。类收到 objc_msgSend 消息后，通过 isa 指针找到元类对象，如果没有再通过 superclass 指针找到父类的元类对象查找。","source":"_posts/OC底层原理/initialize方法.md","raw":"---\ntitle: +initialize方法\ndate: 2020-05-22 15:20:48\ntags: OC底层原理\n---\n\n思考：\n* load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？\n\n<!-- more -->\n\n+initialize 方法会在类第一次接收到消息时调用\n\n# 定义 Persion、Student 及其分类\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n+ (void)initialize\n{\n    NSLog(@\"Person +initialize\");\n}\n@end\n\n@interface Person (Test1)\n@end\n\n@implementation Person (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Person (Test1) +initialize\");\n}\n@end\n\n@interface Person (Test2)\n@end\n\n@implementation Person (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Person (Test2) +initialize\");\n}\n@end\n\n@interface Student : Persion\n@end\n\n@implementation Student\n+ (void)initialize\n{\n    NSLog(@\"Student +initialize\");\n}\n@end\n\n@interface Student (Test1)\n@end\n\n@implementation Student (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Student (Test1) +initialize\");\n}\n@end\n\n@interface Student (Test2)\n@end\n\n@implementation Student (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Student (Test2) +initialize\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main\");\n        [Persion alloc];\n        [Student alloc];\n    }\n    return 0;\n}\n```\n\n编译顺序：  \n![initialize方法01](initialize方法/initialize方法01.png)\n\n打印结果：\n```\nPersion (Test1) +initialize\nStudent (Test2) +initialize\n```\n\n# objc4源码解读过程\n* objc-msg-arm64.s  \nobjc_msgSend  \n\n* objc-runtime-new.mm  \nclass_getInstanceMethod  \nlookUpImpOrNil  \nlookUpImpOrForward  \n_class_initialize  \ncallInitialize  \nobjc_msgSend(cls, SEL_initialize)\n\n[Persion alloc] 的本质是：\n```\nobjc_msgSend(objc_getClass(\"Persion\"), sel_registerName(\"alloc\"))\n```\n\n[Student alloc] 的本质是：  \n```\n objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\"))\n```\n\n# objc_msgSend()\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，搜索 objc_msgSend()，会发现 objc_msgSend() 方法的源码是汇编语言。\n \nobjc_msgSend() - 类方法调用流程：  \nisa -> 类对象/元类对象，寻找方法，调用  \nsuperclass -> 类对象/元类对象，寻找方法，调用  \nsuperclass -> 类对象/元类对象，寻找方法，调用\n\n从“寻找方法”入手👇\n\n# class_getClassMethod\n\nclass_getClassMethod 是获取类方法的函数，内部调用的是 class_getInstanceMethod 获取对象方法的函数。\n```\nMethod class_getClassMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    return class_getInstanceMethod(cls->getMeta(), sel);\n}\n```\n\n## class_getInstanceMethod\nJump To Definition -> class_getInstanceMethod\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n#warning fixme build and search caches\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);\n\n#warning fixme build and search caches\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n## lookUpImpOrForward\n\n在 class_getInstanceMethod 方法中，调用 lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER) 方法。所以 behavior == LOOKUP_RESOLVER\n\nJump To Definition -> lookUpImpOrForward\n```\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    ...\n    ...\n    ...//一堆方法\n\n    // Check for +initialize\n    if ((behavior & LOOKUP_INITIALIZE)  &&  !cls->isInitialized()) { //如果类还没有实现 +initialized 方法\n        initializeNonMetaClass (_class_getNonMetaClass(cls, inst));\n        // If sel == initialize, initializeNonMetaClass will send +initialize \n        // and then the messenger will send +initialize again after this \n        // procedure finishes. Of course, if this is not being called \n        // from the messenger then it won't happen. 2778172\n    }\n\n    ...\n    ...\n    ...//一堆方法\n}\n```\n\n## initializeNonMetaClass\n\ninitializeNonMetaClass 方法使用递归的方式优先将传入的类 cls 的父类调用 initializeNonMetaClass 方法进行处理。\n\nJump To Definition -> initializeNonMetaClass\n```\nvoid initializeNonMetaClass(Class cls)\n{\n    ASSERT(!cls->isMetaClass());\n\n    Class supercls;\n    bool reallyInitialize = NO;\n\n    // Make sure super is done initializing BEFORE beginning to initialize cls.\n    // See note about deadlock above.\n    supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) { // 存在父类 && 父类没有调用个 +initialize 方法\n        initializeNonMetaClass(supercls);\n    }\n    \n    // Try to atomically set CLS_INITIALIZING.\n    SmallVector<_objc_willInitializeClassCallback, 1> localWillInitializeFuncs;\n    {\n        monitor_locker_t lock(classInitLock);\n        if (!cls->isInitialized() && !cls->isInitializing()) {\n            cls->setInitializing(); //设置 RW_INITIALIZING 状态\n            reallyInitialize = YES;\n\n            // Grab a copy of the will-initialize funcs with the lock held.\n            localWillInitializeFuncs.initFrom(willInitializeFuncs);\n        }\n    }\n    \n    if (reallyInitialize) {\n        // We successfully set the CLS_INITIALIZING bit. Initialize the class.\n        \n        // Record that we're initializing this class so we can message it.\n        _setThisThreadIsInitializingClass(cls);\n\n        if (MultithreadedForkChild) {\n            // LOL JK we don't really call +initialize methods after fork().\n            performForkChildInitialize(cls, supercls); // 设置 RW_INITIALIZED 状态\n            return;\n        }\n        \n        for (auto callback : localWillInitializeFuncs)\n            callback.f(callback.context, cls);\n\n        // Send the +initialize message.\n        // Note that +initialize is sent to the superclass (again) if \n        // this class doesn't implement +initialize. 2157218\n        if (PrintInitializing) {\n            _objc_inform(\"INITIALIZE: thread %p: calling +[%s initialize]\",\n                         objc_thread_self(), cls->nameForLogging());\n        }\n\n        // Exceptions: A +initialize call that throws an exception \n        // is deemed to be a complete and successful +initialize.\n        //\n        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a\n        // bootstrapping problem of this versus CF's call to\n        // objc_exception_set_functions().\n#if __OBJC2__\n        @try\n#endif\n        {\n            callInitialize(cls);\n\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: finished +[%s initialize]\",\n                             objc_thread_self(), cls->nameForLogging());\n            }\n        }\n        ...\n        ...\n        ...\n}\n```\n\n设置正在调用 +initialize 方法的状态 RW_INITIALIZING：\n```\ncls->setInitializing()\n```\n\n设置已经调用 +initialize 方法的状态 RW_INITIALIZED：\n```\nperformForkChildInitialize(cls, supercls) -> lockAndFinishInitializing(cls, supercls) -> _finishInitializing(cls, supercls) -> cls->setInitialized()\n```\n\nisInitializing()、setInitializing()、isInitialized()、setInitialized() 方法：\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n\n    void setInfo(uint32_t set) {\n        ASSERT(isFuture()  ||  isRealized());\n        data()->setFlags(set);\n    }\n\n    ...\n    ...\n    ...//一堆方法\n\n    bool isInitializing() {\n        return getMeta()->data()->flags & RW_INITIALIZING;\n    }\n\n    void setInitializing() {\n        ASSERT(!isMetaClass());\n        ISA()->setInfo(RW_INITIALIZING);\n    }\n\n    bool isInitialized() {\n        return getMeta()->data()->flags & RW_INITIALIZED;\n    }\n\n    void setInitialized();\n\n    ...\n    ...\n    ...//一堆方法\n```\n\n## callInitialize\n\n向传入的类 cls 发送“initialize”消息。至此实现了 +initialize 方法的调用。\n\nJump To Definition -> callInitialize\n```\nvoid callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));\n    asm(\"\");\n}\n```\n\n# 调用顺序\n```\n@interface Persion : NSObject\n@end\n\n@implementation Persion\n+ (void)initialize\n{\n    NSLog(@\"Persion +initialize\");\n}\n@end\n\n@interface Persion (Test1)\n@end\n\n@implementation Persion (Test1)\n+ (void)initialize\n{\n    NSLog(@\"Persion (Test1) +initialize\");\n}\n@end\n\n@interface Persion (Test2)\n@end\n\n@implementation Persion (Test2)\n+ (void)initialize\n{\n    NSLog(@\"Persion (Test2) +initialize\");\n}\n@end\n\n@interface Student : Persion\n@end\n\n@implementation Student\n@end\n\n@interface Teacher : Persion\n@end\n\n@implementation Teacher\n@end\n```\n\n编译顺序：  \n![initialize方法01](initialize方法/initialize方法01.png)\n\n打印结果：\n```\nPersion (Test1) +initialize\nPersion (Test1) +initialize\nPersion (Test1) +initialize\n```\n\n## 优先调用父类的 +initialize 方法  \n从 initializeNonMetaClass 方法中有个一递归设计，跟 +load 方法调用中的 schedule_class_load 方法如出一辙。会先判断父类的 +initialize 方法是否已经调用，如果没有会优先先调用父类的 +initialize 方法。在将所有的父类都处理完后，再调用传入的类 cls 的 +initialize 方法。  \n\n## 每个类只会调用一次 +initialize 方法 \n因为有 !cls->isInitialized() 判断，所以每个类只会初始化1次，也就是每个类只会调用一次 +initialize 方法。  \n\n## 父类的 +initialize 可能会被调用多次\n如果子类没有实现 +initialize 会调用父类的 +initialize（所以父类的 +initialize 可能会被调用多次）。这一点通过 callInitialize 方法可以看出，向传入的类 cls 发送一条 @selector(initialize) 消息。类 cls 会通过 isa 找到 cls 元类对象查找 +initialize 方法，如果没有再通过 superclass 指针找到父类的元类方法查找 +initialize 方法，找到后并调用。\n\n## 总结\n* load、initialize 方法的区别什么？  \n  1、调用方式  \n  1> +load 是根据函数地址直接调用（ (*load_method)(cls, @selector(load))）；  \n  2> +initialize 是通过 objc_msgSend 调用；  \n\n  2、调用时刻  \n  1> +load 是 runtime 加载类、分类的时刻调用，每个类只会调用一次；  \n  2> +initialize 是类第一次收到消息的时候调用，每个类只会调用一次，父类的 +initialize 方法可能会被调用多次；  \n\n* +load 和 +initialize 的调用顺序？  \n  +load 方法：  \n  1、先调用类的 +load  \n  1> 先编译的类，优先调用 +load；  \n  2> 先调用父类的 +load，再调用子类的 +load；  \n\n  2、再调用分类的 +load  \n  1> 先编译的分类，优先调用 +load；  \n\n  +initialize 方法：  \n  1、先初始化父类，再初始化子类；  \n  2、子类没有 +initialize 方法时会调用父类的 +initialize 方法；  \n  3、有分类实现 +initialize 方法的，只调用最后被编译的分类里的 +initialize 方法；\n\n* 出现继承时他们之间的调用过程？  \n  +load 方法：  \n  1、+load 是先调用父类的 +load，再调用子类的 +load。调用 +load 方法时是通过找到每个类 +load 方法的函数地址调用的。  \n  2、+initialize 也是先调用父类，再调用子类的。调用 +initialize 方法是通过 objc_msgSend 调用的。类收到 objc_msgSend 消息后，通过 isa 指针找到元类对象，如果没有再通过 superclass 指针找到父类的元类对象查找。","slug":"OC底层原理/initialize方法","published":1,"updated":"2023-08-22T09:52:13.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgsi000saq7kdzopg4t7"},{"title":"RunLoop","date":"2020-07-02T08:16:35.000Z","_content":"\n思考：\n* 讲讲 RunLoop，项目中有用到吗？\n* RunLoop 内部实现逻辑？\n* RunLoop 和线程的关系？\n* timer 与 RunLoop 的关系？\n* 程序中添加每3秒响应一次的 NSTimer，当拖动 tableview 时 timer 可能无法响应要怎么解决？\n* RunLoop 是怎么响应用户操作的， 具体流程是什么样的？\n* 说说 RunLoop 的几种状态\n* RunLoop 的 mode 作用是什么？\n\n<!-- more -->\n\n# 什么是 RunLoop\n\n顾名思义：运行循环，在程序运行过程中循环做一些事情。\n\n应用范畴：\n1. 定时器（Timer）、PerformSelector  \n2. GCD Async Main Queue  \n3. 事件响应、手势识别、界面刷新  \n4. 网络请求  \n5. AutoreleasePool  \n![RunLoop01](RunLoop/RunLoop01.png)\n\n## 如果没有 RunLoop\n打印完“Hello, World!”后，执行完 return 方法会退出程序：\n```\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"Hello, World!\");\n    }\n    return 0; //退出程序\n}\n```\n\n## 如果有了 RunLoop\n程序并不会马上退出，而是保持运行状态。`UIApplicationMain()` 方法的内部创建了 RunLoop：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n## RunLoop 的基本作用\n* 保持程序的持续运行\n* 处理App中的各种事件（比如触摸事件、定时器事件等）\n* 节省CPU资源，提高程序性能：该做事时做事，该休息时休息  \n......\n\n## RunLoop 的实现原理（伪代码）\n```\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        int retVal = 0;\n        do {\n            // 没有任务时进入睡眠等待消息，不会执行下一行代码；有任务消息是被唤醒，执行下一行代码处理消息；\n            int message = sleep_and_wait(); \n            // 处理消息\n            retVal = process_message(message); \n        } while (0 == retVal);\n        return 0;\n    }\n}\n```\n\n# RunLoop 对象\n\n## 获取 RunLoop 对象\n\niOS 中有2套 API 来访问和使用 RunLoop：\n1. Foundation：NSRunLoop  \n2. Core Foundation：CFRunLoopRef\n\nFoundation\n```\n// 获取当前线程的 RunLoop 对象\nNSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop]; \n// 获取主线程的 RunLoop 对象\nNSRunLoop *mainRunLoop = [NSRunLoop mainRunLoop]; \nNSLog(@\"%p %p\", currentRunLoop, mainRunLoop);\n```\n\n打印结果：\n```\n0x600003a0e880 0x600003a0e880\n```\n\n因为是在主线程打印的，所以 `+currentRunLoop` 和 `+mainRunLoop` 获取的都是主线程的 RunLoop。\n\nCore Foundation\n```\n// 获取当前线程的 RunLoop 对象\nCFRunLoopRef currentCFRunLoop = CFRunLoopGetCurrent(); \n// 获取主线程的 RunLoop 对象\nCFRunLoopRef mainCFRunLoop = CFRunLoopGetMain(); \nNSLog(@\"%p %p\", currentCFRunLoop, mainCFRunLoop);\n```\n\n打印结果：\n```\n0x600002208500 0x600002208500\n```\n\n因为是在主线程打印的，所以 `CFRunLoopGetCurrent()` 和 `CFRunLoopGetMain()` 获取的都是主线程的 CFRunLoopRef。\n\n从打印结果可以看出，上面种方式在获取主线程的 RunLoop 时获取到的 `NSRunLoop` 和 `CFRunLoopRef` 内存地址不一样。NSRunLoop 和 CFRunLoopRef 都代表着 RunLoop 对象，但是 NSRunLoop 是基于 CFRunLoopRef 的一层 OC 包装，真正的 RunLoop 是里面的 `CFRunLoopRef`（如：NSArray 是基于 CFArrayRef 的封装，NSString 是基于 CFStringRef 的封装）。\n\n## RunLoop 与线程\n* 每条线程都有唯一的一个与之对应的 RunLoop 对象；\n* RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value；\n* 线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建；\n* RunLoop 会在线程结束时销毁；\n* 主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n\nCFRunLoopRef 是开源的，下载 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 。找到 CFRunLoop.c 文件里的 `_CFRunLoopGet0()` 方法：\n```\n/// 全局字典，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef __CFRunLoops = NULL;\n/// 获取一个 pthread 对应的 RunLoop\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n    if (pthread_equal(t, kNilPthreadT)) {\n        t = pthread_main_thread_np();\n    }\n    __CFLock(&loopsLock);\n    if (!__CFRunLoops) { //如果不存在就创建\n        __CFUnlock(&loopsLock);\n        ///初始化全局Dic\n        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n        ///为主线程创建一个 RunLoop\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n            CFRelease(dict);\n        }\n        CFRelease(mainLoop);\n        __CFLock(&loopsLock);\n    }\n    ///以 pthreadPointer(t) 为 key，在 __CFRunLoops 里查找 loop\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    __CFUnlock(&loopsLock);\n    if (!loop) {\n        ///如果 loop 不存在就创建新的 newLoop\n        CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFLock(&loopsLock);\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); \n        if (!loop) {\n            ///以 pthreadPointer(t) 为 key，newLoop 为 value 保存到 __CFRunLoops 里\n            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n            loop = newLoop;\n        }\n        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n        __CFUnlock(&loopsLock);\n        CFRelease(newLoop);\n    }\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}\n```\n\n从源码里可以看到线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。`_CFRunLoopGet0()` 先调用 `CFDictionaryGetValue()` 方法，以线程 pthreadPointer(t) 为 key 在 `__CFRunLoops` 里查找 loop。如果 loop 不存在，再通过 `__CFRunLoopCreate()` 方法创建新的 newLoop，并以线程 pthreadPointer(t) 为 key，newLoop 为 value 保存到 `__CFRunLoops` 里。\n\n## RunLoop 相关的类\n\nCore Foundation 中关于 RunLoop 的5个类：\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n查看 RunLoop 源码，找到 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 里的 RunLoop.c 文件：\n\n### CFRunLoopRef\nCFRunLoopRef：RunLoop 类对象的结构体。\n```\ntypedef struct __CFRunLoop * CFRunLoopRef;\n\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */\n    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};\n```\n\n 精简版\n ![RunLoop03](RunLoop/RunLoop02.png)\n\n_pthread：`__CFRunLoop` 对应的线程。  \n_currentMode：当前的 CFRunLoopModeRef。  \n_modes：装着 CFRunLoopModeRef 的集合。\n\nCFRunLoopModeRef 代表 RunLoop 的运行模式。RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。不同组（不同mode）的 Sources0/Sources1/Timer/Observer 能分隔开来，互不影响。  \n\n👉 注意：如果 Mode 里没有任何 Sources0/Sources1/Timer/Observer，RunLoop 会立马退出。\n![RunLoop04](RunLoop/RunLoop04.png) \n\n### CFRunLoopModeRef\nCFRunLoopModeRef：RunLoop 的运行模式。\n```\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\n\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n精简版\n![RunLoop03](RunLoop/RunLoop03.png)\n\n_sources0：装着 CFRunLoopSourceRef 的集合。  \n_sources1：装着 CFRunLoopSourceRef 的集合。  \n_observers：装着 CFRunLoopObserverRef 的集合。  \n_timers：装着 CFRunLoopTimerRef 的集合。\n\nRunLoop 在选择了某一种模式作为当前模式后，就开始处理当前模式里的 Source0/Source1/Timer/Observer 事件了：\n\n* Source0：触摸事件、`performSelector:onThread:` 方法\n* Source1：基于 Port 的线程间通信、系统事件捕捉\n* Timers：NSTimer、`performSelector:withObject:afterDelay:` 方法\n* Observers：用于监听 RunLoop 的状态、UI 刷新（BeforeWaiting）、Autorelease pool（BeforeWaiting）\n\nRunLoop 将 OC 代码转换成了 Sources0/Sources1/Timer/Observer，并且循环监测并执行它们。比如 UI 的刷新和Autorelease pool 的自动释放都是在进入休眠前完成的。\n\n### CFRunLoopSourceRef\n```\ntypedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef;\n\nstruct __CFRunLoopSource {\n    CFRuntimeBase _base;\n    uint32_t _bits;\n    pthread_mutex_t _lock;\n    CFIndex _order;\t\t\t/* immutable */\n    CFMutableBagRef _runLoops;\n    union {\n\tCFRunLoopSourceContext version0;\t/* immutable, except invalidation */\n        CFRunLoopSourceContext1 version1;\t/* immutable, except invalidation */\n    } _context;\n};\n```\n\n触摸事件：\n```\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__); //断点\n}\n@end\n```\n\n在断点处打印函数调用栈：\n![RunLoop06](RunLoop/RunLoop06.png)\n\n在打印出的函数调用栈里可以看到该事件是由 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__` 调用过来的。触摸事件先是由 Sources1 捕捉到后传递给 Sources0。\n\n### CFRunLoopObserverRef\n实现：\n```\ntypedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef;\n\nstruct __CFRunLoopObserver {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\n    CFRunLoopRef _runLoop;\n    CFIndex _rlCount;\n    CFOptionFlags _activities;\t\t//RunLoop 状态枚举\n    CFIndex _order;\t\t\t/* immutable */\n    CFRunLoopObserverCallBack _callout;\t/* immutable */\n    CFRunLoopObserverContext _context;\t/* immutable, except invalidation */\n};\n```\n\n`__CFRunLoopObserver` 的 `_activities` 是一个枚举，包含以下状态：\n![RunLoop05](RunLoop/RunLoop05.png)\n\n#### CFRunLoopObserverCreateWithHandler()\n\n使用 CFRunLoopObserverCreateWithHandler() 方法监听 RunLoop：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:\n                NSLog(@\"kCFRunLoopEntry\");\n                break;\n            case kCFRunLoopBeforeTimers:\n                NSLog(@\"kCFRunLoopBeforeTimers\");\n                break;\n            case kCFRunLoopBeforeSources:\n                NSLog(@\"kCFRunLoopBeforeSources\");\n                break;\n            case kCFRunLoopBeforeWaiting:\n                NSLog(@\"kCFRunLoopBeforeWaiting\");\n                break;\n            case kCFRunLoopAfterWaiting:\n                NSLog(@\"kCFRunLoopAfterWaiting\");\n                break;\n            case kCFRunLoopExit:\n                NSLog(@\"kCFRunLoopExit\");\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n#### 点击事件唤醒 RunLoop\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__);\n}\n```\n\n点击屏幕打印结果：\n```\n2020-07-04 21:11:18.429011+0800 RunLoop-test1[7880:206615] kCFRunLoopAfterWaiting\n2020-07-04 21:11:18.429138+0800 RunLoop-test1[7880:206615] kCFRunLoopBeforeTimers\n2020-07-04 21:11:18.429218+0800 RunLoop-test1[7880:206615] kCFRunLoopBeforeSources\n2020-07-04 21:11:18.430235+0800 RunLoop-test1[7880:206615] -[ViewController touchesBegan:withEvent:]\n\n......\n```\n\n从打印结果可以看到，在处理点击事件前，RunLoop 先进入到了 kCFRunLoopBeforeSources 状态，表明即将处理 sources。 \n\n#### NSTimer 唤醒 RunLoop\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [NSTimer scheduledTimerWithTimeInterval:3.0 repeats:NO block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"------- 定时器 -------\");\n    }];\n}\n```\n\n点击屏幕打印结果：\n```\n......\n\n2020-07-04 21:01:17.901246+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeWaiting\n2020-07-04 21:01:20.832895+0800 RunLoop-test1[7611:196926] kCFRunLoopAfterWaiting\n2020-07-04 21:01:20.833116+0800 RunLoop-test1[7611:196926] ------- 定时器 -------\n2020-07-04 21:01:20.833258+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeTimers\n2020-07-04 21:01:20.833354+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeSources\n2020-07-04 21:01:20.833450+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeWaiting\n\n......\n```\n\n从打印结果可以看到，RunLoop 在17秒处进入了 kCFRunLoopBeforeWaiting（休眠）状态，20秒处进入了 kCFRunLoopAfterWaiting（唤醒）状态，同时执行了代码块打印出了结果。\n\n#### CFRunLoopObserverCreate()\n\n使用 CFRunLoopObserverCreate() 方法监听 RunLoop：\n```\n@implementation ViewController\n\nvoid observerCallBackAllActivities(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n     switch (activity) {\n         case kCFRunLoopEntry:\n             NSLog(@\"kCFRunLoopEntry\");\n             break;\n         case kCFRunLoopBeforeTimers:\n             NSLog(@\"kCFRunLoopBeforeTimers\");\n             break;\n         case kCFRunLoopBeforeSources:\n             NSLog(@\"kCFRunLoopBeforeSources\");\n             break;\n         case kCFRunLoopBeforeWaiting:\n             NSLog(@\"kCFRunLoopBeforeWaiting\");\n             break;\n         case kCFRunLoopAfterWaiting:\n             NSLog(@\"kCFRunLoopAfterWaiting\");\n             break;\n         case kCFRunLoopExit:\n             NSLog(@\"kCFRunLoopExit\");\n             break;\n         default:\n             break;\n     }\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observerCallBackAllActivities, nil);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n## 常见的2种 Mode\nkCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行。  \nUITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。（只有主线程需要考虑这种 mode）\n\nRunLoop 的模式切换：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:{\n                CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n                NSLog(@\"kCFRunLoopEntry - %@\", mode);\n                CFRelease(mode);\n            }\n            case kCFRunLoopExit:{\n                CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n                NSLog(@\"kCFRunLoopExit - %@\", mode);\n                CFRelease(mode);\n            }\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n添加监听后，在页面上添一个 UITextView。  \n\n开始滚动 UITextView 时的打印：\n```\nkCFRunLoopExit - kCFRunLoopDefaultMode\nkCFRunLoopEntry - UITrackingRunLoopMode\n```\n\n停止滚动 UITextView 时的打印：\n```\nkCFRunLoopExit - UITrackingRunLoopMode\nkCFRunLoopEntry - kCFRunLoopDefaultMode\n```\n\n从打印结果可以看到，操作 textView 时 RunLoop 进行了模式切换：  \n在开始滚动 textView 时，RunLoop 先退出了 kCFRunLoopDefaultMode 再进入了 UITrackingRunLoopMode。  \n在停止滚动 textView 时，RunLoop 先退出了 UITrackingRunLoopMode 再进入 kCFRunLoopDefaultMode。\n\n\n# RunLoop 源码分析\n\nRunLoop 执行流程图：\n![RunLoop07](RunLoop/RunLoop07.png)\n\n## RunLoop 的实现原理\n\n找到 RunLoop 的入口：\n```\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__); //断点\n}\n@end\n```\n\n断点处查看函数调用栈：\n![RunLoop09](RunLoop/RunLoop09.png)\n从图中可以看到，RunLoop 先通过 `CFRunLoopRunSpecific()` 方法调用了 `__CFRunLoopRun()` 方法，`__CFRunLoopRun` 方法调用了 `__CFRunLoopDoSources0()` 方法，所以 `CFRunLoopRunSpecific` 就是 RunLoop 的入口。\n\n### CFRunLoopRunSpecific \n实现：\n```\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {\n    CHECK_FOR_FORK();\n    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;\n    __CFRunLoopLock(rl);\n    /// 根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {\n        Boolean did = false;\n        if (currentMode) __CFRunLoopModeUnlock(currentMode);\n        __CFRunLoopUnlock(rl);\n        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;\n    }\n    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);\n    CFRunLoopModeRef previousMode = rl->_currentMode;\n    rl->_currentMode = currentMode;\n    int32_t result = kCFRunLoopRunFinished;\n    \n    /// 通知 Observers：进入 Loop\n\tif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n    /// 具体要做的事情\n\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n    /// 通知 Observers：退出 Loop\n\tif (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n        __CFRunLoopModeUnlock(currentMode);\n        __CFRunLoopPopPerRunData(rl, previousPerRun);\n\trl->_currentMode = previousMode;\n    __CFRunLoopUnlock(rl);\n    return result;\n}\n```\n\n简化后：\n```\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {\n    /// 通知 Observers：进入 Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n\t\n    /// 具体要做的事情\n    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n\t\n    /// 通知 Observers：退出 Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n    return result;\n}\n```\n\n`CFRunLoopRunSpecific()` 方法内部调用了 `__CFRunLoopRun()` 方法来实现 RunLoop 的具体处理逻辑。\n\n### __CFRunLoopRun\n在 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 找到 RunLoop.c 文件，再找到 `__CFRunLoopRun()` 方法。简化后：\n```\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    int32_t retVal = 0;\n    do {\n        /// 通知 Observers：即将处理 Timers\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        /// 通知 Observers：即将处理 Sources\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        /// 处理 Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 处理 Sources0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n            // 处理 Blocks\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        /// 判断有无 Sources1\n        if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n            // 如果有 Sources1，就直接跳转到 handle_msg👇\n            goto handle_msg;\n        }\n        \n        /// 通知 Observers：即将休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        __CFRunLoopSetSleeping(rl);\n        \n        do {\n            /// 等待消息唤醒当前线程（进入休眠，不会执行任何代码，也不会消耗CPU）\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1); // 循环内部的 RunLoop 会阻塞 while 循环，RunLoop 退出后，while 循环的阻塞消失，再次创建一个新的 RunLoop 阻塞 while 循环，保证一直会有一个 RunLoop 存在\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n        __CFRunLoopUnsetSleeping(rl);\n        /// 通知 Observers：结束休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n    ///（👉 如果有 Sources1，会直接跳转到这里。没有 Sources1，就等上面的代码走走完了再来到这里）\n    handle_msg:;\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            /// 被timer唤醒\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            /// 处理 Timers\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n        else if (livePort == dispatchPort) {\n            /// 被gcd唤醒\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            /// 处理gcd\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else {\n            /// 被 Sources1 唤醒\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            /// 处理 Sources1\n            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n        }\n        \n        /// 处理 Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 设置返回值\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n        \n        voucher_mach_msg_revert(voucherState);\n        os_release(voucherCopy);\n        \n    } while (0 == retVal); //是否继续执行\n    \n    return retVal;\n}\n```\n\n可以看到 RunLoop 主要做了以下6件事（有序）：\n1. `__CFRunLoopDoObservers()` 通知 observers\n2. `__CFRunLoopDoBlocks()` 处理 blocks\n3. `__CFRunLoopDoSources0()` 处理 sources0\n4. `__CFRunLoopDoTimers()` 处理 timers\n5. `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 处理 GCD\n6. `__CFRunLoopDoSource1()` 处理 sources1\n\n除了处理 GCD 的方法外，其它的5个方法，在调用到 Foundation 框架的函数前，还会调用一个 Core Foundation 框架的函数：\n\n### __CFRunLoopDoObservers()\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {\n    if (func) {\n        func(observer, activity, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) {\n    ......\n    \n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo->_callout, rlo, activity, rlo->_context.info);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop10](RunLoop/RunLoop10.png)\n\n### __CFRunLoopDoBlocks()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(void (^block)(void)) {\n    if (block) {\n        block();\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) {\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop11](RunLoop/RunLoop11.png)\n\n### __CFRunLoopDoSources0()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) {\n    if (perform) {\n        perform(info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) {\t\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls->_context.version0.perform, rls->_context.version0.info);\n\t\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop12](RunLoop/RunLoop12.png)\n\n### __CFRunLoopDoTimers()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, void *info) {\n    if (func) {\n        func(timer, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {\n    ......\n\n    Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);\n\n    ......\n}\n\nstatic Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) {\n    ......\n\n\t__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt->_callout, rlt, context_info);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop13](RunLoop/RunLoop13.png)\n\n### __CFRunLoopDoSource1()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(\n    void *(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info), mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply, void *info) {\n    if (perform) {\n        *reply = perform(msg, size, kCFAllocatorSystemDefault, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls, mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply) {\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls->_context.version1.perform, msg, size, reply, rls->_context.version1.info);\n\n    ......\n}\n```\n\n### \\_\\_CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__\n```\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(void *msg) {\n    _dispatch_main_queue_callback_4CF(msg);\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n```\n\nGCD 和 RunLoop 是相对独立的，只在一种情况下会调用到 RunLoop 的 `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 方法：\n![RunLoop14](RunLoop/RunLoop14.png)\n\n## 文字版流程图\n![RunLoop08](RunLoop/RunLoop08.png)\n图中的 block 是通过 `CFRunLoopPerformBlock()` 添加的任务。\n```\nCFRunLoopPerformBlock(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^{\n        \n});\n```\n\n## RunLoop 休眠的实现原理\n```\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    ......\n\n    do {\n        // 等待消息唤醒当前线程（进入休眠，不会执行任何代码，也不会消耗CPU）\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n    } while (1);\n\n    ......\n}\n\nstatic Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) {\n    ......\n\n    ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg->msgh_size, port, timeout, MACH_PORT_NULL);\n\n    ......\n}\n```\n\n在 `__CFRunLoopRun()` 方法中调用了 `__CFRunLoopServiceMachPort()` 方法，`__CFRunLoopServiceMachPort()` 方法内部又调用了 `mach_msg()` 方法，使得 RunLoop 进入休眠状态。此时当前线程不再执行，while 循环会停止在 `__CFRunLoopServiceMachPort()` 方法这里，同时 RunLoop 会释放在 CPU 占用的资源，不再执行任何代码，直到有消息唤醒时才会继续执行当前线程（while 循环，以及 while 循环下面省略掉的代码），充分做到了节省资源。RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 \n\n`mach_msg()` 方法会调用到内核层级的 API，该 API 对应的函数主要功能是等待消息，实现逻辑包括：  \n* 没有消息的时候让线程休眠  \n* 有消息的时候唤醒线程\n\n![RunLoop16](RunLoop/RunLoop16.png)\n\n苹果官方将整个系统大致划分为上述4个层次：\n* Cocoa 层：是直接向iOS应用程序提供各种基础功能的支持。其中的UIKit框架提供各种可视化控件供应用程序使用，如窗口、视图、视图控制器与各种用户控件等。另外UIKit也定义了应用程序的默认行为和事件处理结构。  \n* Media层：依赖于Core Services层提供的功能，主要负责图形与多媒体服务。它包含了CoreGraphics、Core Text、OpenGL ES、Core Animation、AVFoundation、Core Audio等与图形、视频和音频相关的功能模块。  \n* Core Services层：可称之为核心服务层，顾名思义，它提供诸如字符串管理、集合管理、网络操作、URL实用工具、联系人管理、偏好设置等服务。除此之外，它还提供很多基于硬件特性的服务，如GPS、加速仪、陀螺仪等。该层包含了Core Location、Core Motion、SystemConfiguration、Foundation与Core Foundation子模块。其中Foundation与Core Foundation子模块提供了对公共数据类型(字符串、集合等)的抽象，Core Foundation中的Core Data子模块可以实现对象图形管理与对象持久化。  \n* Core OS层：位于baiiOS框架的最底层，主要du包含内核、文件系统、网zhi络基础架构、安全管理、电源管理、设备驱动、线程管理、内存管理等。简而言之，该层提供了最低级的、系统级的服务。  \n* Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 [opensource.apple.com](https://opensource.apple.com/) 里找到。\n\nOC 的 API 有很多个层级，开发者可以调用的属于用户层级的 API，向 _mach_msg() 这种属于内核层级的 API。\n![RunLoop15](RunLoop/RunLoop15.png)\n\n# RunLoop 在实际开中的应用\n\n## NSTimer 失效\n```\n@interface ViewController : UIViewController\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    static int count = 0;\n    [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"%d\", ++count);\n    }];\n}\n@end\n```\n\n在控制器上加一个 UITextView 并上下拖拽，打印结果：\n```\n00:34:43.342490+0800 RunLoop-test1[5939:131757] 1\n00:34:44.341608+0800 RunLoop-test1[5939:131757] 2\n00:34:45.341603+0800 RunLoop-test1[5939:131757] 3\n00:34:55.169027+0800 RunLoop-test1[5939:131757] 4\n00:34:55.341906+0800 RunLoop-test1[5939:131757] 5\n00:34:56.341997+0800 RunLoop-test1[5939:131757] 6\n......\n```\n\n会发现定时器的打印在拖拽 TextView 时停止了，停止拖拽后，定时器的打印又继续进行了。这是因为 `+scheduledTimerWithTimeInterval:repeats:block:` 方法会自动将创建的 timer 添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 `kCFRunLoopDefaultMode`，而拖拽 TextView 使用的是 `UITrackingRunLoopMode`，但是 RunLoop 在同一时间只会执行一种 Mode，所以在拖拽 TextView 时 RunLoop 将 currentMode 切换成了 `UITrackingRunLoopMode`，NSTimer 自然就停止了。\n\n解决方案：  \n通过 `+timerWithTimeInterval:repeats:block:` 方法创建 timer，然后手动添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 NSRunLoopCommonModes。这个时候拖拽 TextView 就不会影响到 timer 了：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"%d\", ++count);\n    }];\n\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; //也可以用 CFRunLoopAddTimer(CFRunLoopGetCurrent(), timer, kCFRunLoopCommonModes);\n}\n@end\n```\n\n👉 思考：  \n为什么将 NSTimer 的 RunLoop 的 mode 设置为 NSRunLoopCommonModes 就可以正常执行了？NSRunLoopCommonModes 跟 UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 有什么区别？\n\n### NSRunLoopCommonModes\n```\nstruct __CFRunLoop {\n    ......\n\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes; //保存着 UITrackingRunLoopMode 和 kCFRunLoopDefaultMode\n    CFMutableSetRef _commonModeItems; //保存着 NSRunLoopCommonModes 类型的任务（timer）\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n\n    ......\n};\n\nstruct __CFRunLoopMode {\n    ......\n\n    CFStringRef _name;\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n\n    ......\n};\n```\n\nNSRunLoopCommonModes 并不是一个真正的模式，只是一个标记。UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 才是真正意义上的模式。\n\n一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n\n## 线程保活\n```\n@interface YQThread : NSThread\n@end\n\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    YQThread *thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [thread start];\n}\n\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n```\n\n点击屏幕，打印结果：\n```\n-[ViewController run] <YQThread: 0x600002375fc0>{number = 8, name = (null)}\n-[YQThread dealloc]\n-[ViewController run] <YQThread: 0x600002352c80>{number = 9, name = (null)}\n-[YQThread dealloc]\n```\n\n在线程中添加 RunLoop，可以保证线程不被释放，并在需要的时候工作，不需要的时候休眠。`-(void)run` 方法是线程调用的，所以在线程中添加 RunLoop 可以加在 `-(void)run` 方法中。RunLoop 不需要手动创建，在线程中第一次获取 RunLoop 的时候就会自动创建。\n```\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    [[NSRunLoop currentRunLoop] run];\n    NSLog(@\"--- end ---\");\n}\n```\n\n点击屏幕，打印结果：\n```\n-[ViewController run] <YQThread: 0x600000335f80>{number = 6, name = (null)}\n--- end ---\n-[YQThread dealloc]\n-[ViewController run] <YQThread: 0x60000033d380>{number = 7, name = (null)}\n--- end ---\n-[YQThread dealloc]\n```\n\n可以看到线程还是被销毁了，这是因为 RunLoop 没有找到 Sources0/Sources1/Timer/Observer 就退出了，所以需要向 RunLoop 中添加任务：\n```\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    // 在 RunLoop 中添加 Sources/timer/observer\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run]; //线程停留在这里，不会打印下面这句\n    NSLog(@\"--- end ---\");\n}\n```\n\n打印结果：\n```\n-[ViewController run] <YQThread: 0x60000101d000>{number = 6, name = (null)}\n-[ViewController run] <YQThread: 0x60000101b480>{number = 7, name = (null)}\n-[ViewController run] <YQThread: 0x600001077680>{number = 8, name = (null)}\n```\n\n从打印结果可以看到，线程停留在了 `[[NSRunLoop currentRunLoop] run];` 这一行，一直都没有打印 \"--- end ---\"。\n\n因为 port 是 sources1 类型的事件，添加到 RunLoop 中却没有什么事情可做，RunLoop 就进入了休眠等待任务唤醒（没有退出），即 RunLoop 阻塞住了线程保证了线程不被释放，所以一直没有打印 \"--- end ---\"。\n\n因为是在异步线程，所以不需要考虑 UITrackingRunLoopMode，直接设置为 NSDefaultRunLoopMode 就可以了。\n\n为一直存活的线程添加任务：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test {\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n// 这个方法的目的：线程保活\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    // 在 RunLoop 中添加 Sources/timer/observer\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    NSLog(@\"--- end ---\");\n}\n@end\n```\n\n点击屏幕，打印结果：\n```\n -[ViewController run] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n```\n\n从打印结果可以看到，线程一直存在，并且可以重复执行任务。\n\n上面👆的实现有以下几个问题：  \n1. NSThread 的初始化方法会对 self 进行强引用，导致 thread 和 self 循环引用问题。\n```\nself.thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) \n```\n\n2. RunLoop 进入休眠并没有退出，所以一直不会打印 \"--- end ---\"，线程也就无法结束。\n3. NSRunLoop 的 `-(void)run` 方法是无法停止的，它专门用于开启一个永不销毁的线程。`-(void)run` 方法内部在重复创建 RunLoop。while 循环在第一次循环时会创建一个 RunLoop1 阻塞住 while 循环，RunLoop1 会在有任务时执行任务，没任务时休眠。当调用退出方法让 RunLoop1 退出后，while 循环会再次启动并创建一个新的 RunLoop2，逻辑同 RunLoop1。即退出了当前的 RunLoop 还会创建一个新的 RunLoop。伪代码实现：\n```\nwhile (1) {\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n}\n```\n\n优化后的实现：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@property (nonatomic, assign, getter=isStop) BOOL stop; //停止RunLoop的标记\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    __weak typeof(self) weakSelf = self;\n    self.thread = [[YQThread alloc] initWithBlock:^{\n        NSLog(@\"%@--- begain ---\", [NSThread currentThread]);\n        /**--- 线程保活 ---*/\n        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n        while (!weakSelf.isStop) {\n            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        }\n        /**--- 线程保活 end ---*/\n        NSLog(@\"%@--- end ---\", [NSThread currentThread]);\n    }];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test \n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)stopThread\n{\n    // 设置停止线程标记\n    self.stop = YES;\n    // 停止RunLoop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    //停止 RunLoop 的方法需要在对应线程内执行，dealloc 方法在主线程，可以通过该方法调用到需要停止的线程里执行\n    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n@end\n```\n\n打印结果：\n```\n<YQThread: 0x60000372e200>{number = 7, name = (null)}--- begain ---\n-[ViewControllerNew test] <YQThread: 0x60000372e200>{number = 7, name = (null)}\n-[ViewControllerNew test] <YQThread: 0x60000372e200>{number = 7, name = (null)}\n-[ViewControllerNew dealloc]\n```\n\n`CFRunLoopStop(CFRunLoopGetCurrent())` 方法会退出当前的 RunLoop，此时 while 循环重新启动并在判断 isStop == YES 时停止循环，不会再创建新的 RunLoop。\n\n打印结果中没有打印 \"--- end ---\"，线程也没有释放，是因为上面👆的实现还有以下几个问题： \n1. `performSelector:onThread:waitUntilDone` 方法的第三个参数 waitUntilDone 表示是否需要当前线程等待方法执行完成后再继续执行下一行。如果设置为 NO，则表示不需要等待，那么在控制器的 `-(void)dealloc` 方法里在 self 调用 `performSelector:onThread:waitUntilDone` 后，`-(void)dealloc` 方法会继续往下执行，控制器被释放。那么在执行 `-(void)stopThread` 方法的时候再访问 self 就会出现坏内存访问的错误。\n2. `while (!weakSelf.isStop)` 在控制器被销毁后也是成立的（`while (!nil)` == `while (true)`），所以 while 循环又会创建新的 RunLoop，线程还是无法释放。\n\n最终实现：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@property (nonatomic, assign, getter=isStop) BOOL stop; //停止RunLoop的标记\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    __weak typeof(self) weakSelf = self;\n    self.thread = [[YQThread alloc] initWithBlock:^{\n        NSLog(@\"%@--- begain ---\", [NSThread currentThread]);\n        /**--- 线程保活 ---*/\n        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n        while (weakSelf && !weakSelf.isStop) {\n            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        }\n        /**--- 线程保活 end ---*/\n        NSLog(@\"%@--- end ---\", [NSThread currentThread]);\n    }];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test \n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)stopThread\n{\n    // 设置停止线程标记\n    self.stop = YES;\n    // 停止RunLoop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    // 停止 RunLoop 的方法需要在对应线程内执行，dealloc 方法在主线程，可以通过该方法调用到需要停止的线程里去执行\n    // waitUntilDone:YES，表示执行完该方法在向下执行，保证了在执行该方法时，控制器（self）不会被销毁\n    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n打印结果：\n```\n<YQThread: 0x600000c70100>{number = 6, name = (null)}--- begain ---\n-[ViewControllerNew test] <YQThread: 0x600000c70100>{number = 6, name = (null)}\n-[ViewControllerNew test] <YQThread: 0x600000c70100>{number = 6, name = (null)}\n-[ViewControllerNew dealloc]\n<YQThread: 0x600000c70100>{number = 6, name = (null)}--- end ---\n-[YQThread dealloc]\n```\n\n## 线程的封装\n\n为了方便使用，将线程封装成一个工具类，这样在使用的时候就不用管理线程的创建、保活和销毁了。\n\n### 接口设计\n\n方案一：创建一个 NSThread 的分类。这种方式需要用到关联对象创建 NSThread 对象，而且在外部使用时调用者可以调用 NSThread 提供的 API，封装性不够好。\n\n方案二：创建一个 NSObject 管理类，里面管理一个 NSThread 对象。不直接继承 NSThread 的原因同上，为了控制调用者不能去访问  NSThread 提供的 API，保证 NSThread 相关的操作（创建、保活和销毁）全部且只能在管理类的内部操作，调用者只能调用由管理类提供的 API，这样就保证了封装性。 \n\n定义接口：\n```\n@interface YQPermenantThread : NSObject\n/**\n 开启线程\n */\n- (void)run;\n/**\n 执行任务\n */\n- (void)executeTaskWithTarget:(id)target action:(SEL)action object:(id)object;\n/**\n结束线程\n*/\n- (void)stop;\n@end\n```\n\n调用：\n```\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n- (void)viewDidLoad\n{\n    [super view];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self.thread executeTaskWithTarget:self action:@selector(test) object:nil];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    [self.thread stop];\n}\n@end\n```\n\n执行任务的方法也可以设计成 Block 的形式，代码会更精简：\n```\n@interface YQPermenantThread : NSObject\n/**\n 开启线程\n */\n- (void)run;\n/**\n 执行任务\n */\n- (void)executeTask:(void (^)(void))task;\n/**\n结束线程\n*/\n- (void)stop;\n@end\n\n\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n- (void)viewDidLoad\n{\n    [super view];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    /**\n     [self.thread executeTask:^{\n         NSLog(@\"%@\", [NSThread currentThread]);\n     }];\n     */\n    __weak typeof(self) weakSelf = self;\n    [self.thread executeTask:^{\n        [weakSelf test];\n    }];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    [self.thread stop];\n}\n@end\n```\n\n### 内部实现\n```\n@interface YQThread : NSThread\n@end\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface YQPermenantThread()\n@property (nonatomic, strong) YQThread *innerThread;\n@property (nonatomic, assign, getter=isStopped) BOOL stopped; //停止RunLoop的标记\n@end\n\n@implementation YQPermenantThread\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.stopped = NO;\n        \n        __weak typeof(self) weakSelf = self;\n        self.innerThread = [[YQThread alloc] initWithBlock:^{\n            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n            while (weakSelf && !weakSelf.isStopped) {\n                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n            }\n        }];\n    }\n    return self;\n}\n\n- (void)run\n{\n    if (!self.innerThread) return;\n    \n    [self.innerThread start];\n}\n\n- (void)executeTask:(void (^)(void))task\n{\n    if (!self.innerThread || !task) return;\n    \n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];\n}\n\n- (void)stop\n{\n    if (!self.innerThread) return;\n    \n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self stop];\n}\n\n#pragma mark - private methods\n- (void)__stop\n{\n    self.stopped = YES;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void(^)(void))task\n{\n    task();\n}\n@end\n```\n\n调用：\n```\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.view.backgroundColor = [UIColor orangeColor];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    __weak typeof(self) weakSelf = self;\n    [self.thread executeTask:^{\n        [weakSelf test];\n    }];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewControllerNew test] <YQThread: 0x600000d76f00>{number = 9, name = (null)}\n-[ViewControllerNew dealloc]\n-[YQPermenantThread dealloc]\n-[YQThread dealloc]\n```\n\n### C语言方式实现\n```\n@interface YQThread : NSThread\n@end\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface YQPermenantThread()\n@property (nonatomic, strong) YQThread *innerThread;\n@end\n\n@implementation YQPermenantThread\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        __weak typeof(self) weakSelf = self;\n        self.innerThread = [[YQThread alloc] initWithBlock:^{\n            // 创建上下文\n            CFRunLoopSourceContext context = {0};\n\n            // 创建source\n            CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);\n\n            // 往RunLoop中添加source\n            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);\n\n            // 销毁source\n            CFRelease(source);\n\n            // 启动（ture：执行完source退出；false：执行完source不退出）\n            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);\n        }];\n    }\n    return self;\n}\n\n- (void)run\n{\n    if (!self.innerThread) return;\n    \n    [self.innerThread start];\n}\n\n- (void)executeTask:(void (^)(void))task\n{\n    if (!self.innerThread || !task) return;\n    \n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];\n}\n\n- (void)stop\n{\n    if (!self.innerThread) return;\n    \n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self stop];\n}\n\n#pragma mark - private methods\n- (void)__stop\n{\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void(^)(void))task\n{\n    task();\n}\n@end\n```\n\n打印结果：\n```\n-[ViewControllerNew dealloc]\n-[YQPermenantThread dealloc]\n-[YQThread dealloc]\n```\n\n👉注意：\n1. 在创建上下文时，CFRunLoopSourceContext 是一个结构体，如果没有进行初始化，context 的内部的值可能会是一堆乱码。只有添加了初始化方法`{0}`，才能保证结构里内部的值是正常的数值：\n```\nCFRunLoopSourceContext context = {0};\n```\n\n2. 启动 RunLoop 时，第三个参数传 true 表示执行完 source 立即退出，传 false 表示执行完 source 不退出。在这里传 false 等同于 OC 实现中的 while 循环的作用。\n```\nCFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);\n```\n\n# 总结\n\n* 讲讲 RunLoop，项目中有用到吗？  \n  1. RunLoop 保持程序的持续运行，没有 RunLoop 程序会马上退出，有了 RunLoop 程序并不会马上退出，而是保持运行状态；\n  2. RunLoop 处理App中的各种事件（如：定时器（Timer）、PerformSelector、GCD、事件响应、手势识别、界面刷新、网络请求和 AutoreleasePool 等）。这些事件的代码最终都变成了 RunLoop 里的执行任务（sources0/sources1/timers），由 RunLoop 监控和执行；\n  3. RunLoop 的休眠机制极大可能的节省了对CPU资源的占用，提高了程序性能；\n  4. 每条线程都有唯一的一个与之对应的 RunLoop 对象。RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value。线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建。RunLoop 会在线程结束时销毁。主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n  5. RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出。\n  6. RunLoop 有两种常见的 mode：  \n  kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行。  \n  UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。（只有主线程需要考虑这种 mode）  \n  NSRunLoopCommonModes：并不是一个真正的模式，只是一个标记。UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 才是真正意义上的模式。一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n  7. RunLoop 的休眠唤醒逻辑是通过调用一个内核方法 `mach_msg()` 实现的。  \n  \n    项目中使用 RunLoop 的地方比较少，主要有解决 NSTimer 失效问题，自定义线程保活。\n\n* RunLoop 内部实现逻辑？  \n  1. RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出。\n\n  2. RunLoop 的休眠唤醒逻辑是通过调用一个内核方法 `mach_msg()` 实现的。\n\n* RunLoop 和线程的关系？  \n每条线程都有唯一的一个与之对应的 RunLoop 对象。RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value。线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建。RunLoop 会在线程结束时销毁。主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n\n* timer 与 RunLoop 的关系？  \n一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n\n* 程序中添加每3秒响应一次的 NSTimer，当拖动 tableview 时 timer 可能无法响应要怎么解决？  \n通过 +timerWithTimeInterval:repeats:block: 方法创建 timer，然后手动添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 NSRunLoopCommonModes。这个时候拖拽 TextView 就不会影响到 timer 了。原因在上面“timer 与 RunLoop 的关系”。\n\n* RunLoop 是怎么响应用户操作的， 具体流程是什么样的？\n![RunLoop08](RunLoop/RunLoop08.png)\n\n* 说说 RunLoop 的几种状态  \n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),         //即将进入Loop\n    kCFRunLoopBeforeTimers = (1UL << 1),  //即将处理Timer\n    kCFRunLoopBeforeSources = (1UL << 2), //即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), //即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),  //刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),          //即将推出Loop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n* RunLoop 的 mode 作用是什么？  \nmode 是 RunLoop 的运行模式。RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。不同组（不同mode）的 Sources0/Sources1/Timer/Observer 能分隔开来，互不影响。如果 Mode 里没有任何 Sources0/Sources1/Timer/Observer，RunLoop 会立马退出。RunLoop 将 OC 代码转换成了 Sources0/Sources1/Timer/Observer 保存到不同的 mode 里，并且循环监测并执行它们。比如：定时器（Timer）、PerformSelector、GCD、事件响应、手势识别、界面刷新、网络请求和 AutoreleasePool 等都是在进入休眠前完成的。","source":"_posts/OC底层原理/RunLoop.md","raw":"---\ntitle: RunLoop\ndate: 2020-07-02 16:16:35\ntags: OC底层原理\n---\n\n思考：\n* 讲讲 RunLoop，项目中有用到吗？\n* RunLoop 内部实现逻辑？\n* RunLoop 和线程的关系？\n* timer 与 RunLoop 的关系？\n* 程序中添加每3秒响应一次的 NSTimer，当拖动 tableview 时 timer 可能无法响应要怎么解决？\n* RunLoop 是怎么响应用户操作的， 具体流程是什么样的？\n* 说说 RunLoop 的几种状态\n* RunLoop 的 mode 作用是什么？\n\n<!-- more -->\n\n# 什么是 RunLoop\n\n顾名思义：运行循环，在程序运行过程中循环做一些事情。\n\n应用范畴：\n1. 定时器（Timer）、PerformSelector  \n2. GCD Async Main Queue  \n3. 事件响应、手势识别、界面刷新  \n4. 网络请求  \n5. AutoreleasePool  \n![RunLoop01](RunLoop/RunLoop01.png)\n\n## 如果没有 RunLoop\n打印完“Hello, World!”后，执行完 return 方法会退出程序：\n```\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"Hello, World!\");\n    }\n    return 0; //退出程序\n}\n```\n\n## 如果有了 RunLoop\n程序并不会马上退出，而是保持运行状态。`UIApplicationMain()` 方法的内部创建了 RunLoop：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n## RunLoop 的基本作用\n* 保持程序的持续运行\n* 处理App中的各种事件（比如触摸事件、定时器事件等）\n* 节省CPU资源，提高程序性能：该做事时做事，该休息时休息  \n......\n\n## RunLoop 的实现原理（伪代码）\n```\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        int retVal = 0;\n        do {\n            // 没有任务时进入睡眠等待消息，不会执行下一行代码；有任务消息是被唤醒，执行下一行代码处理消息；\n            int message = sleep_and_wait(); \n            // 处理消息\n            retVal = process_message(message); \n        } while (0 == retVal);\n        return 0;\n    }\n}\n```\n\n# RunLoop 对象\n\n## 获取 RunLoop 对象\n\niOS 中有2套 API 来访问和使用 RunLoop：\n1. Foundation：NSRunLoop  \n2. Core Foundation：CFRunLoopRef\n\nFoundation\n```\n// 获取当前线程的 RunLoop 对象\nNSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop]; \n// 获取主线程的 RunLoop 对象\nNSRunLoop *mainRunLoop = [NSRunLoop mainRunLoop]; \nNSLog(@\"%p %p\", currentRunLoop, mainRunLoop);\n```\n\n打印结果：\n```\n0x600003a0e880 0x600003a0e880\n```\n\n因为是在主线程打印的，所以 `+currentRunLoop` 和 `+mainRunLoop` 获取的都是主线程的 RunLoop。\n\nCore Foundation\n```\n// 获取当前线程的 RunLoop 对象\nCFRunLoopRef currentCFRunLoop = CFRunLoopGetCurrent(); \n// 获取主线程的 RunLoop 对象\nCFRunLoopRef mainCFRunLoop = CFRunLoopGetMain(); \nNSLog(@\"%p %p\", currentCFRunLoop, mainCFRunLoop);\n```\n\n打印结果：\n```\n0x600002208500 0x600002208500\n```\n\n因为是在主线程打印的，所以 `CFRunLoopGetCurrent()` 和 `CFRunLoopGetMain()` 获取的都是主线程的 CFRunLoopRef。\n\n从打印结果可以看出，上面种方式在获取主线程的 RunLoop 时获取到的 `NSRunLoop` 和 `CFRunLoopRef` 内存地址不一样。NSRunLoop 和 CFRunLoopRef 都代表着 RunLoop 对象，但是 NSRunLoop 是基于 CFRunLoopRef 的一层 OC 包装，真正的 RunLoop 是里面的 `CFRunLoopRef`（如：NSArray 是基于 CFArrayRef 的封装，NSString 是基于 CFStringRef 的封装）。\n\n## RunLoop 与线程\n* 每条线程都有唯一的一个与之对应的 RunLoop 对象；\n* RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value；\n* 线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建；\n* RunLoop 会在线程结束时销毁；\n* 主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n\nCFRunLoopRef 是开源的，下载 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 。找到 CFRunLoop.c 文件里的 `_CFRunLoopGet0()` 方法：\n```\n/// 全局字典，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef __CFRunLoops = NULL;\n/// 获取一个 pthread 对应的 RunLoop\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n    if (pthread_equal(t, kNilPthreadT)) {\n        t = pthread_main_thread_np();\n    }\n    __CFLock(&loopsLock);\n    if (!__CFRunLoops) { //如果不存在就创建\n        __CFUnlock(&loopsLock);\n        ///初始化全局Dic\n        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n        ///为主线程创建一个 RunLoop\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n            CFRelease(dict);\n        }\n        CFRelease(mainLoop);\n        __CFLock(&loopsLock);\n    }\n    ///以 pthreadPointer(t) 为 key，在 __CFRunLoops 里查找 loop\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    __CFUnlock(&loopsLock);\n    if (!loop) {\n        ///如果 loop 不存在就创建新的 newLoop\n        CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFLock(&loopsLock);\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); \n        if (!loop) {\n            ///以 pthreadPointer(t) 为 key，newLoop 为 value 保存到 __CFRunLoops 里\n            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n            loop = newLoop;\n        }\n        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n        __CFUnlock(&loopsLock);\n        CFRelease(newLoop);\n    }\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}\n```\n\n从源码里可以看到线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。`_CFRunLoopGet0()` 先调用 `CFDictionaryGetValue()` 方法，以线程 pthreadPointer(t) 为 key 在 `__CFRunLoops` 里查找 loop。如果 loop 不存在，再通过 `__CFRunLoopCreate()` 方法创建新的 newLoop，并以线程 pthreadPointer(t) 为 key，newLoop 为 value 保存到 `__CFRunLoops` 里。\n\n## RunLoop 相关的类\n\nCore Foundation 中关于 RunLoop 的5个类：\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n查看 RunLoop 源码，找到 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 里的 RunLoop.c 文件：\n\n### CFRunLoopRef\nCFRunLoopRef：RunLoop 类对象的结构体。\n```\ntypedef struct __CFRunLoop * CFRunLoopRef;\n\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* locked for accessing mode list */\n    __CFPort _wakeUpPort;\t\t\t// used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};\n```\n\n 精简版\n ![RunLoop03](RunLoop/RunLoop02.png)\n\n_pthread：`__CFRunLoop` 对应的线程。  \n_currentMode：当前的 CFRunLoopModeRef。  \n_modes：装着 CFRunLoopModeRef 的集合。\n\nCFRunLoopModeRef 代表 RunLoop 的运行模式。RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。不同组（不同mode）的 Sources0/Sources1/Timer/Observer 能分隔开来，互不影响。  \n\n👉 注意：如果 Mode 里没有任何 Sources0/Sources1/Timer/Observer，RunLoop 会立马退出。\n![RunLoop04](RunLoop/RunLoop04.png) \n\n### CFRunLoopModeRef\nCFRunLoopModeRef：RunLoop 的运行模式。\n```\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\n\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n精简版\n![RunLoop03](RunLoop/RunLoop03.png)\n\n_sources0：装着 CFRunLoopSourceRef 的集合。  \n_sources1：装着 CFRunLoopSourceRef 的集合。  \n_observers：装着 CFRunLoopObserverRef 的集合。  \n_timers：装着 CFRunLoopTimerRef 的集合。\n\nRunLoop 在选择了某一种模式作为当前模式后，就开始处理当前模式里的 Source0/Source1/Timer/Observer 事件了：\n\n* Source0：触摸事件、`performSelector:onThread:` 方法\n* Source1：基于 Port 的线程间通信、系统事件捕捉\n* Timers：NSTimer、`performSelector:withObject:afterDelay:` 方法\n* Observers：用于监听 RunLoop 的状态、UI 刷新（BeforeWaiting）、Autorelease pool（BeforeWaiting）\n\nRunLoop 将 OC 代码转换成了 Sources0/Sources1/Timer/Observer，并且循环监测并执行它们。比如 UI 的刷新和Autorelease pool 的自动释放都是在进入休眠前完成的。\n\n### CFRunLoopSourceRef\n```\ntypedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef;\n\nstruct __CFRunLoopSource {\n    CFRuntimeBase _base;\n    uint32_t _bits;\n    pthread_mutex_t _lock;\n    CFIndex _order;\t\t\t/* immutable */\n    CFMutableBagRef _runLoops;\n    union {\n\tCFRunLoopSourceContext version0;\t/* immutable, except invalidation */\n        CFRunLoopSourceContext1 version1;\t/* immutable, except invalidation */\n    } _context;\n};\n```\n\n触摸事件：\n```\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__); //断点\n}\n@end\n```\n\n在断点处打印函数调用栈：\n![RunLoop06](RunLoop/RunLoop06.png)\n\n在打印出的函数调用栈里可以看到该事件是由 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__` 调用过来的。触摸事件先是由 Sources1 捕捉到后传递给 Sources0。\n\n### CFRunLoopObserverRef\n实现：\n```\ntypedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef;\n\nstruct __CFRunLoopObserver {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\n    CFRunLoopRef _runLoop;\n    CFIndex _rlCount;\n    CFOptionFlags _activities;\t\t//RunLoop 状态枚举\n    CFIndex _order;\t\t\t/* immutable */\n    CFRunLoopObserverCallBack _callout;\t/* immutable */\n    CFRunLoopObserverContext _context;\t/* immutable, except invalidation */\n};\n```\n\n`__CFRunLoopObserver` 的 `_activities` 是一个枚举，包含以下状态：\n![RunLoop05](RunLoop/RunLoop05.png)\n\n#### CFRunLoopObserverCreateWithHandler()\n\n使用 CFRunLoopObserverCreateWithHandler() 方法监听 RunLoop：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:\n                NSLog(@\"kCFRunLoopEntry\");\n                break;\n            case kCFRunLoopBeforeTimers:\n                NSLog(@\"kCFRunLoopBeforeTimers\");\n                break;\n            case kCFRunLoopBeforeSources:\n                NSLog(@\"kCFRunLoopBeforeSources\");\n                break;\n            case kCFRunLoopBeforeWaiting:\n                NSLog(@\"kCFRunLoopBeforeWaiting\");\n                break;\n            case kCFRunLoopAfterWaiting:\n                NSLog(@\"kCFRunLoopAfterWaiting\");\n                break;\n            case kCFRunLoopExit:\n                NSLog(@\"kCFRunLoopExit\");\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n#### 点击事件唤醒 RunLoop\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__);\n}\n```\n\n点击屏幕打印结果：\n```\n2020-07-04 21:11:18.429011+0800 RunLoop-test1[7880:206615] kCFRunLoopAfterWaiting\n2020-07-04 21:11:18.429138+0800 RunLoop-test1[7880:206615] kCFRunLoopBeforeTimers\n2020-07-04 21:11:18.429218+0800 RunLoop-test1[7880:206615] kCFRunLoopBeforeSources\n2020-07-04 21:11:18.430235+0800 RunLoop-test1[7880:206615] -[ViewController touchesBegan:withEvent:]\n\n......\n```\n\n从打印结果可以看到，在处理点击事件前，RunLoop 先进入到了 kCFRunLoopBeforeSources 状态，表明即将处理 sources。 \n\n#### NSTimer 唤醒 RunLoop\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [NSTimer scheduledTimerWithTimeInterval:3.0 repeats:NO block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"------- 定时器 -------\");\n    }];\n}\n```\n\n点击屏幕打印结果：\n```\n......\n\n2020-07-04 21:01:17.901246+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeWaiting\n2020-07-04 21:01:20.832895+0800 RunLoop-test1[7611:196926] kCFRunLoopAfterWaiting\n2020-07-04 21:01:20.833116+0800 RunLoop-test1[7611:196926] ------- 定时器 -------\n2020-07-04 21:01:20.833258+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeTimers\n2020-07-04 21:01:20.833354+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeSources\n2020-07-04 21:01:20.833450+0800 RunLoop-test1[7611:196926] kCFRunLoopBeforeWaiting\n\n......\n```\n\n从打印结果可以看到，RunLoop 在17秒处进入了 kCFRunLoopBeforeWaiting（休眠）状态，20秒处进入了 kCFRunLoopAfterWaiting（唤醒）状态，同时执行了代码块打印出了结果。\n\n#### CFRunLoopObserverCreate()\n\n使用 CFRunLoopObserverCreate() 方法监听 RunLoop：\n```\n@implementation ViewController\n\nvoid observerCallBackAllActivities(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n     switch (activity) {\n         case kCFRunLoopEntry:\n             NSLog(@\"kCFRunLoopEntry\");\n             break;\n         case kCFRunLoopBeforeTimers:\n             NSLog(@\"kCFRunLoopBeforeTimers\");\n             break;\n         case kCFRunLoopBeforeSources:\n             NSLog(@\"kCFRunLoopBeforeSources\");\n             break;\n         case kCFRunLoopBeforeWaiting:\n             NSLog(@\"kCFRunLoopBeforeWaiting\");\n             break;\n         case kCFRunLoopAfterWaiting:\n             NSLog(@\"kCFRunLoopAfterWaiting\");\n             break;\n         case kCFRunLoopExit:\n             NSLog(@\"kCFRunLoopExit\");\n             break;\n         default:\n             break;\n     }\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observerCallBackAllActivities, nil);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n## 常见的2种 Mode\nkCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行。  \nUITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。（只有主线程需要考虑这种 mode）\n\nRunLoop 的模式切换：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:{\n                CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n                NSLog(@\"kCFRunLoopEntry - %@\", mode);\n                CFRelease(mode);\n            }\n            case kCFRunLoopExit:{\n                CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n                NSLog(@\"kCFRunLoopExit - %@\", mode);\n                CFRelease(mode);\n            }\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n@end\n```\n\n添加监听后，在页面上添一个 UITextView。  \n\n开始滚动 UITextView 时的打印：\n```\nkCFRunLoopExit - kCFRunLoopDefaultMode\nkCFRunLoopEntry - UITrackingRunLoopMode\n```\n\n停止滚动 UITextView 时的打印：\n```\nkCFRunLoopExit - UITrackingRunLoopMode\nkCFRunLoopEntry - kCFRunLoopDefaultMode\n```\n\n从打印结果可以看到，操作 textView 时 RunLoop 进行了模式切换：  \n在开始滚动 textView 时，RunLoop 先退出了 kCFRunLoopDefaultMode 再进入了 UITrackingRunLoopMode。  \n在停止滚动 textView 时，RunLoop 先退出了 UITrackingRunLoopMode 再进入 kCFRunLoopDefaultMode。\n\n\n# RunLoop 源码分析\n\nRunLoop 执行流程图：\n![RunLoop07](RunLoop/RunLoop07.png)\n\n## RunLoop 的实现原理\n\n找到 RunLoop 的入口：\n```\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"%s\", __func__); //断点\n}\n@end\n```\n\n断点处查看函数调用栈：\n![RunLoop09](RunLoop/RunLoop09.png)\n从图中可以看到，RunLoop 先通过 `CFRunLoopRunSpecific()` 方法调用了 `__CFRunLoopRun()` 方法，`__CFRunLoopRun` 方法调用了 `__CFRunLoopDoSources0()` 方法，所以 `CFRunLoopRunSpecific` 就是 RunLoop 的入口。\n\n### CFRunLoopRunSpecific \n实现：\n```\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {\n    CHECK_FOR_FORK();\n    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;\n    __CFRunLoopLock(rl);\n    /// 根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {\n        Boolean did = false;\n        if (currentMode) __CFRunLoopModeUnlock(currentMode);\n        __CFRunLoopUnlock(rl);\n        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;\n    }\n    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);\n    CFRunLoopModeRef previousMode = rl->_currentMode;\n    rl->_currentMode = currentMode;\n    int32_t result = kCFRunLoopRunFinished;\n    \n    /// 通知 Observers：进入 Loop\n\tif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n    /// 具体要做的事情\n\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n    /// 通知 Observers：退出 Loop\n\tif (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n        __CFRunLoopModeUnlock(currentMode);\n        __CFRunLoopPopPerRunData(rl, previousPerRun);\n\trl->_currentMode = previousMode;\n    __CFRunLoopUnlock(rl);\n    return result;\n}\n```\n\n简化后：\n```\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {\n    /// 通知 Observers：进入 Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n\t\n    /// 具体要做的事情\n    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n\t\n    /// 通知 Observers：退出 Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n    return result;\n}\n```\n\n`CFRunLoopRunSpecific()` 方法内部调用了 `__CFRunLoopRun()` 方法来实现 RunLoop 的具体处理逻辑。\n\n### __CFRunLoopRun\n在 [CF-1153.18](https://opensource.apple.com/tarballs/CF/) 找到 RunLoop.c 文件，再找到 `__CFRunLoopRun()` 方法。简化后：\n```\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    int32_t retVal = 0;\n    do {\n        /// 通知 Observers：即将处理 Timers\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        /// 通知 Observers：即将处理 Sources\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        /// 处理 Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 处理 Sources0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n            // 处理 Blocks\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        /// 判断有无 Sources1\n        if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n            // 如果有 Sources1，就直接跳转到 handle_msg👇\n            goto handle_msg;\n        }\n        \n        /// 通知 Observers：即将休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        __CFRunLoopSetSleeping(rl);\n        \n        do {\n            /// 等待消息唤醒当前线程（进入休眠，不会执行任何代码，也不会消耗CPU）\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1); // 循环内部的 RunLoop 会阻塞 while 循环，RunLoop 退出后，while 循环的阻塞消失，再次创建一个新的 RunLoop 阻塞 while 循环，保证一直会有一个 RunLoop 存在\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n        __CFRunLoopUnsetSleeping(rl);\n        /// 通知 Observers：结束休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n    ///（👉 如果有 Sources1，会直接跳转到这里。没有 Sources1，就等上面的代码走走完了再来到这里）\n    handle_msg:;\n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            /// 被timer唤醒\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            /// 处理 Timers\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n        else if (livePort == dispatchPort) {\n            /// 被gcd唤醒\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            /// 处理gcd\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else {\n            /// 被 Sources1 唤醒\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            /// 处理 Sources1\n            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n        }\n        \n        /// 处理 Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 设置返回值\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n        \n        voucher_mach_msg_revert(voucherState);\n        os_release(voucherCopy);\n        \n    } while (0 == retVal); //是否继续执行\n    \n    return retVal;\n}\n```\n\n可以看到 RunLoop 主要做了以下6件事（有序）：\n1. `__CFRunLoopDoObservers()` 通知 observers\n2. `__CFRunLoopDoBlocks()` 处理 blocks\n3. `__CFRunLoopDoSources0()` 处理 sources0\n4. `__CFRunLoopDoTimers()` 处理 timers\n5. `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 处理 GCD\n6. `__CFRunLoopDoSource1()` 处理 sources1\n\n除了处理 GCD 的方法外，其它的5个方法，在调用到 Foundation 框架的函数前，还会调用一个 Core Foundation 框架的函数：\n\n### __CFRunLoopDoObservers()\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {\n    if (func) {\n        func(observer, activity, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) {\n    ......\n    \n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo->_callout, rlo, activity, rlo->_context.info);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop10](RunLoop/RunLoop10.png)\n\n### __CFRunLoopDoBlocks()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(void (^block)(void)) {\n    if (block) {\n        block();\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) {\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop11](RunLoop/RunLoop11.png)\n\n### __CFRunLoopDoSources0()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) {\n    if (perform) {\n        perform(info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) {\t\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls->_context.version0.perform, rls->_context.version0.info);\n\t\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop12](RunLoop/RunLoop12.png)\n\n### __CFRunLoopDoTimers()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, void *info) {\n    if (func) {\n        func(timer, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {\n    ......\n\n    Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);\n\n    ......\n}\n\nstatic Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) {\n    ......\n\n\t__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt->_callout, rlt, context_info);\n\n    ......\n}\n```\n\n函数调用栈：\n![RunLoop13](RunLoop/RunLoop13.png)\n\n### __CFRunLoopDoSource1()\n内部调用的是 `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__()` 方法：\n```\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(\n    void *(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info), mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply, void *info) {\n    if (perform) {\n        *reply = perform(msg, size, kCFAllocatorSystemDefault, info);\n    }\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n\nstatic Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls, mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply) {\n    ......\n\n    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls->_context.version1.perform, msg, size, reply, rls->_context.version1.info);\n\n    ......\n}\n```\n\n### \\_\\_CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__\n```\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() __attribute__((noinline));\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(void *msg) {\n    _dispatch_main_queue_callback_4CF(msg);\n    asm __volatile__(\"\"); // thwart tail-call optimization\n}\n```\n\nGCD 和 RunLoop 是相对独立的，只在一种情况下会调用到 RunLoop 的 `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 方法：\n![RunLoop14](RunLoop/RunLoop14.png)\n\n## 文字版流程图\n![RunLoop08](RunLoop/RunLoop08.png)\n图中的 block 是通过 `CFRunLoopPerformBlock()` 添加的任务。\n```\nCFRunLoopPerformBlock(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^{\n        \n});\n```\n\n## RunLoop 休眠的实现原理\n```\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    ......\n\n    do {\n        // 等待消息唤醒当前线程（进入休眠，不会执行任何代码，也不会消耗CPU）\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n    } while (1);\n\n    ......\n}\n\nstatic Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *voucherState, voucher_t *voucherCopy) {\n    ......\n\n    ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg->msgh_size, port, timeout, MACH_PORT_NULL);\n\n    ......\n}\n```\n\n在 `__CFRunLoopRun()` 方法中调用了 `__CFRunLoopServiceMachPort()` 方法，`__CFRunLoopServiceMachPort()` 方法内部又调用了 `mach_msg()` 方法，使得 RunLoop 进入休眠状态。此时当前线程不再执行，while 循环会停止在 `__CFRunLoopServiceMachPort()` 方法这里，同时 RunLoop 会释放在 CPU 占用的资源，不再执行任何代码，直到有消息唤醒时才会继续执行当前线程（while 循环，以及 while 循环下面省略掉的代码），充分做到了节省资源。RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 \n\n`mach_msg()` 方法会调用到内核层级的 API，该 API 对应的函数主要功能是等待消息，实现逻辑包括：  \n* 没有消息的时候让线程休眠  \n* 有消息的时候唤醒线程\n\n![RunLoop16](RunLoop/RunLoop16.png)\n\n苹果官方将整个系统大致划分为上述4个层次：\n* Cocoa 层：是直接向iOS应用程序提供各种基础功能的支持。其中的UIKit框架提供各种可视化控件供应用程序使用，如窗口、视图、视图控制器与各种用户控件等。另外UIKit也定义了应用程序的默认行为和事件处理结构。  \n* Media层：依赖于Core Services层提供的功能，主要负责图形与多媒体服务。它包含了CoreGraphics、Core Text、OpenGL ES、Core Animation、AVFoundation、Core Audio等与图形、视频和音频相关的功能模块。  \n* Core Services层：可称之为核心服务层，顾名思义，它提供诸如字符串管理、集合管理、网络操作、URL实用工具、联系人管理、偏好设置等服务。除此之外，它还提供很多基于硬件特性的服务，如GPS、加速仪、陀螺仪等。该层包含了Core Location、Core Motion、SystemConfiguration、Foundation与Core Foundation子模块。其中Foundation与Core Foundation子模块提供了对公共数据类型(字符串、集合等)的抽象，Core Foundation中的Core Data子模块可以实现对象图形管理与对象持久化。  \n* Core OS层：位于baiiOS框架的最底层，主要du包含内核、文件系统、网zhi络基础架构、安全管理、电源管理、设备驱动、线程管理、内存管理等。简而言之，该层提供了最低级的、系统级的服务。  \n* Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 [opensource.apple.com](https://opensource.apple.com/) 里找到。\n\nOC 的 API 有很多个层级，开发者可以调用的属于用户层级的 API，向 _mach_msg() 这种属于内核层级的 API。\n![RunLoop15](RunLoop/RunLoop15.png)\n\n# RunLoop 在实际开中的应用\n\n## NSTimer 失效\n```\n@interface ViewController : UIViewController\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    static int count = 0;\n    [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"%d\", ++count);\n    }];\n}\n@end\n```\n\n在控制器上加一个 UITextView 并上下拖拽，打印结果：\n```\n00:34:43.342490+0800 RunLoop-test1[5939:131757] 1\n00:34:44.341608+0800 RunLoop-test1[5939:131757] 2\n00:34:45.341603+0800 RunLoop-test1[5939:131757] 3\n00:34:55.169027+0800 RunLoop-test1[5939:131757] 4\n00:34:55.341906+0800 RunLoop-test1[5939:131757] 5\n00:34:56.341997+0800 RunLoop-test1[5939:131757] 6\n......\n```\n\n会发现定时器的打印在拖拽 TextView 时停止了，停止拖拽后，定时器的打印又继续进行了。这是因为 `+scheduledTimerWithTimeInterval:repeats:block:` 方法会自动将创建的 timer 添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 `kCFRunLoopDefaultMode`，而拖拽 TextView 使用的是 `UITrackingRunLoopMode`，但是 RunLoop 在同一时间只会执行一种 Mode，所以在拖拽 TextView 时 RunLoop 将 currentMode 切换成了 `UITrackingRunLoopMode`，NSTimer 自然就停止了。\n\n解决方案：  \n通过 `+timerWithTimeInterval:repeats:block:` 方法创建 timer，然后手动添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 NSRunLoopCommonModes。这个时候拖拽 TextView 就不会影响到 timer 了：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"%d\", ++count);\n    }];\n\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; //也可以用 CFRunLoopAddTimer(CFRunLoopGetCurrent(), timer, kCFRunLoopCommonModes);\n}\n@end\n```\n\n👉 思考：  \n为什么将 NSTimer 的 RunLoop 的 mode 设置为 NSRunLoopCommonModes 就可以正常执行了？NSRunLoopCommonModes 跟 UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 有什么区别？\n\n### NSRunLoopCommonModes\n```\nstruct __CFRunLoop {\n    ......\n\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes; //保存着 UITrackingRunLoopMode 和 kCFRunLoopDefaultMode\n    CFMutableSetRef _commonModeItems; //保存着 NSRunLoopCommonModes 类型的任务（timer）\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n\n    ......\n};\n\nstruct __CFRunLoopMode {\n    ......\n\n    CFStringRef _name;\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n\n    ......\n};\n```\n\nNSRunLoopCommonModes 并不是一个真正的模式，只是一个标记。UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 才是真正意义上的模式。\n\n一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n\n## 线程保活\n```\n@interface YQThread : NSThread\n@end\n\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    YQThread *thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [thread start];\n}\n\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n```\n\n点击屏幕，打印结果：\n```\n-[ViewController run] <YQThread: 0x600002375fc0>{number = 8, name = (null)}\n-[YQThread dealloc]\n-[ViewController run] <YQThread: 0x600002352c80>{number = 9, name = (null)}\n-[YQThread dealloc]\n```\n\n在线程中添加 RunLoop，可以保证线程不被释放，并在需要的时候工作，不需要的时候休眠。`-(void)run` 方法是线程调用的，所以在线程中添加 RunLoop 可以加在 `-(void)run` 方法中。RunLoop 不需要手动创建，在线程中第一次获取 RunLoop 的时候就会自动创建。\n```\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    [[NSRunLoop currentRunLoop] run];\n    NSLog(@\"--- end ---\");\n}\n```\n\n点击屏幕，打印结果：\n```\n-[ViewController run] <YQThread: 0x600000335f80>{number = 6, name = (null)}\n--- end ---\n-[YQThread dealloc]\n-[ViewController run] <YQThread: 0x60000033d380>{number = 7, name = (null)}\n--- end ---\n-[YQThread dealloc]\n```\n\n可以看到线程还是被销毁了，这是因为 RunLoop 没有找到 Sources0/Sources1/Timer/Observer 就退出了，所以需要向 RunLoop 中添加任务：\n```\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    // 在 RunLoop 中添加 Sources/timer/observer\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run]; //线程停留在这里，不会打印下面这句\n    NSLog(@\"--- end ---\");\n}\n```\n\n打印结果：\n```\n-[ViewController run] <YQThread: 0x60000101d000>{number = 6, name = (null)}\n-[ViewController run] <YQThread: 0x60000101b480>{number = 7, name = (null)}\n-[ViewController run] <YQThread: 0x600001077680>{number = 8, name = (null)}\n```\n\n从打印结果可以看到，线程停留在了 `[[NSRunLoop currentRunLoop] run];` 这一行，一直都没有打印 \"--- end ---\"。\n\n因为 port 是 sources1 类型的事件，添加到 RunLoop 中却没有什么事情可做，RunLoop 就进入了休眠等待任务唤醒（没有退出），即 RunLoop 阻塞住了线程保证了线程不被释放，所以一直没有打印 \"--- end ---\"。\n\n因为是在异步线程，所以不需要考虑 UITrackingRunLoopMode，直接设置为 NSDefaultRunLoopMode 就可以了。\n\n为一直存活的线程添加任务：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test {\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n// 这个方法的目的：线程保活\n- (void)run\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n    // 在 RunLoop 中添加 Sources/timer/observer\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    NSLog(@\"--- end ---\");\n}\n@end\n```\n\n点击屏幕，打印结果：\n```\n -[ViewController run] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n -[ViewController test] <YQThread: 0x600000d56640>{number = 6, name = (null)}\n```\n\n从打印结果可以看到，线程一直存在，并且可以重复执行任务。\n\n上面👆的实现有以下几个问题：  \n1. NSThread 的初始化方法会对 self 进行强引用，导致 thread 和 self 循环引用问题。\n```\nself.thread = [[YQThread alloc] initWithTarget:self selector:@selector(run) \n```\n\n2. RunLoop 进入休眠并没有退出，所以一直不会打印 \"--- end ---\"，线程也就无法结束。\n3. NSRunLoop 的 `-(void)run` 方法是无法停止的，它专门用于开启一个永不销毁的线程。`-(void)run` 方法内部在重复创建 RunLoop。while 循环在第一次循环时会创建一个 RunLoop1 阻塞住 while 循环，RunLoop1 会在有任务时执行任务，没任务时休眠。当调用退出方法让 RunLoop1 退出后，while 循环会再次启动并创建一个新的 RunLoop2，逻辑同 RunLoop1。即退出了当前的 RunLoop 还会创建一个新的 RunLoop。伪代码实现：\n```\nwhile (1) {\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n}\n```\n\n优化后的实现：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@property (nonatomic, assign, getter=isStop) BOOL stop; //停止RunLoop的标记\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    __weak typeof(self) weakSelf = self;\n    self.thread = [[YQThread alloc] initWithBlock:^{\n        NSLog(@\"%@--- begain ---\", [NSThread currentThread]);\n        /**--- 线程保活 ---*/\n        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n        while (!weakSelf.isStop) {\n            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        }\n        /**--- 线程保活 end ---*/\n        NSLog(@\"%@--- end ---\", [NSThread currentThread]);\n    }];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test \n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)stopThread\n{\n    // 设置停止线程标记\n    self.stop = YES;\n    // 停止RunLoop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    //停止 RunLoop 的方法需要在对应线程内执行，dealloc 方法在主线程，可以通过该方法调用到需要停止的线程里执行\n    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n@end\n```\n\n打印结果：\n```\n<YQThread: 0x60000372e200>{number = 7, name = (null)}--- begain ---\n-[ViewControllerNew test] <YQThread: 0x60000372e200>{number = 7, name = (null)}\n-[ViewControllerNew test] <YQThread: 0x60000372e200>{number = 7, name = (null)}\n-[ViewControllerNew dealloc]\n```\n\n`CFRunLoopStop(CFRunLoopGetCurrent())` 方法会退出当前的 RunLoop，此时 while 循环重新启动并在判断 isStop == YES 时停止循环，不会再创建新的 RunLoop。\n\n打印结果中没有打印 \"--- end ---\"，线程也没有释放，是因为上面👆的实现还有以下几个问题： \n1. `performSelector:onThread:waitUntilDone` 方法的第三个参数 waitUntilDone 表示是否需要当前线程等待方法执行完成后再继续执行下一行。如果设置为 NO，则表示不需要等待，那么在控制器的 `-(void)dealloc` 方法里在 self 调用 `performSelector:onThread:waitUntilDone` 后，`-(void)dealloc` 方法会继续往下执行，控制器被释放。那么在执行 `-(void)stopThread` 方法的时候再访问 self 就会出现坏内存访问的错误。\n2. `while (!weakSelf.isStop)` 在控制器被销毁后也是成立的（`while (!nil)` == `while (true)`），所以 while 循环又会创建新的 RunLoop，线程还是无法释放。\n\n最终实现：\n```\n@interface ViewController ()\n@property (nonatomic, strong) YQThread *thread;\n@property (nonatomic, assign, getter=isStop) BOOL stop; //停止RunLoop的标记\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    __weak typeof(self) weakSelf = self;\n    self.thread = [[YQThread alloc] initWithBlock:^{\n        NSLog(@\"%@--- begain ---\", [NSThread currentThread]);\n        /**--- 线程保活 ---*/\n        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n        while (weakSelf && !weakSelf.isStop) {\n            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        }\n        /**--- 线程保活 end ---*/\n        NSLog(@\"%@--- end ---\", [NSThread currentThread]);\n    }];\n    [self.thread start];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n\n// 子线程的任务\n- (void)test \n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)stopThread\n{\n    // 设置停止线程标记\n    self.stop = YES;\n    // 停止RunLoop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    // 停止 RunLoop 的方法需要在对应线程内执行，dealloc 方法在主线程，可以通过该方法调用到需要停止的线程里去执行\n    // waitUntilDone:YES，表示执行完该方法在向下执行，保证了在执行该方法时，控制器（self）不会被销毁\n    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n打印结果：\n```\n<YQThread: 0x600000c70100>{number = 6, name = (null)}--- begain ---\n-[ViewControllerNew test] <YQThread: 0x600000c70100>{number = 6, name = (null)}\n-[ViewControllerNew test] <YQThread: 0x600000c70100>{number = 6, name = (null)}\n-[ViewControllerNew dealloc]\n<YQThread: 0x600000c70100>{number = 6, name = (null)}--- end ---\n-[YQThread dealloc]\n```\n\n## 线程的封装\n\n为了方便使用，将线程封装成一个工具类，这样在使用的时候就不用管理线程的创建、保活和销毁了。\n\n### 接口设计\n\n方案一：创建一个 NSThread 的分类。这种方式需要用到关联对象创建 NSThread 对象，而且在外部使用时调用者可以调用 NSThread 提供的 API，封装性不够好。\n\n方案二：创建一个 NSObject 管理类，里面管理一个 NSThread 对象。不直接继承 NSThread 的原因同上，为了控制调用者不能去访问  NSThread 提供的 API，保证 NSThread 相关的操作（创建、保活和销毁）全部且只能在管理类的内部操作，调用者只能调用由管理类提供的 API，这样就保证了封装性。 \n\n定义接口：\n```\n@interface YQPermenantThread : NSObject\n/**\n 开启线程\n */\n- (void)run;\n/**\n 执行任务\n */\n- (void)executeTaskWithTarget:(id)target action:(SEL)action object:(id)object;\n/**\n结束线程\n*/\n- (void)stop;\n@end\n```\n\n调用：\n```\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n- (void)viewDidLoad\n{\n    [super view];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [self.thread executeTaskWithTarget:self action:@selector(test) object:nil];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    [self.thread stop];\n}\n@end\n```\n\n执行任务的方法也可以设计成 Block 的形式，代码会更精简：\n```\n@interface YQPermenantThread : NSObject\n/**\n 开启线程\n */\n- (void)run;\n/**\n 执行任务\n */\n- (void)executeTask:(void (^)(void))task;\n/**\n结束线程\n*/\n- (void)stop;\n@end\n\n\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n- (void)viewDidLoad\n{\n    [super view];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    /**\n     [self.thread executeTask:^{\n         NSLog(@\"%@\", [NSThread currentThread]);\n     }];\n     */\n    __weak typeof(self) weakSelf = self;\n    [self.thread executeTask:^{\n        [weakSelf test];\n    }];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    [self.thread stop];\n}\n@end\n```\n\n### 内部实现\n```\n@interface YQThread : NSThread\n@end\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface YQPermenantThread()\n@property (nonatomic, strong) YQThread *innerThread;\n@property (nonatomic, assign, getter=isStopped) BOOL stopped; //停止RunLoop的标记\n@end\n\n@implementation YQPermenantThread\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.stopped = NO;\n        \n        __weak typeof(self) weakSelf = self;\n        self.innerThread = [[YQThread alloc] initWithBlock:^{\n            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n            while (weakSelf && !weakSelf.isStopped) {\n                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n            }\n        }];\n    }\n    return self;\n}\n\n- (void)run\n{\n    if (!self.innerThread) return;\n    \n    [self.innerThread start];\n}\n\n- (void)executeTask:(void (^)(void))task\n{\n    if (!self.innerThread || !task) return;\n    \n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];\n}\n\n- (void)stop\n{\n    if (!self.innerThread) return;\n    \n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self stop];\n}\n\n#pragma mark - private methods\n- (void)__stop\n{\n    self.stopped = YES;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void(^)(void))task\n{\n    task();\n}\n@end\n```\n\n调用：\n```\n@interface ViewControllerNew ()\n@property (nonatomic, strong) YQPermenantThread *thread;\n@end\n\n@implementation ViewControllerNew\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.view.backgroundColor = [UIColor orangeColor];\n    \n    self.thread = [[YQPermenantThread alloc] init];\n    [self.thread run];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    __weak typeof(self) weakSelf = self;\n    [self.thread executeTask:^{\n        [weakSelf test];\n    }];\n}\n\n- (void)test\n{\n    NSLog(@\"%s %@\", __func__, [NSThread currentThread]);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewControllerNew test] <YQThread: 0x600000d76f00>{number = 9, name = (null)}\n-[ViewControllerNew dealloc]\n-[YQPermenantThread dealloc]\n-[YQThread dealloc]\n```\n\n### C语言方式实现\n```\n@interface YQThread : NSThread\n@end\n@implementation YQThread\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface YQPermenantThread()\n@property (nonatomic, strong) YQThread *innerThread;\n@end\n\n@implementation YQPermenantThread\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        __weak typeof(self) weakSelf = self;\n        self.innerThread = [[YQThread alloc] initWithBlock:^{\n            // 创建上下文\n            CFRunLoopSourceContext context = {0};\n\n            // 创建source\n            CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);\n\n            // 往RunLoop中添加source\n            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);\n\n            // 销毁source\n            CFRelease(source);\n\n            // 启动（ture：执行完source退出；false：执行完source不退出）\n            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);\n        }];\n    }\n    return self;\n}\n\n- (void)run\n{\n    if (!self.innerThread) return;\n    \n    [self.innerThread start];\n}\n\n- (void)executeTask:(void (^)(void))task\n{\n    if (!self.innerThread || !task) return;\n    \n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];\n}\n\n- (void)stop\n{\n    if (!self.innerThread) return;\n    \n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self stop];\n}\n\n#pragma mark - private methods\n- (void)__stop\n{\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void(^)(void))task\n{\n    task();\n}\n@end\n```\n\n打印结果：\n```\n-[ViewControllerNew dealloc]\n-[YQPermenantThread dealloc]\n-[YQThread dealloc]\n```\n\n👉注意：\n1. 在创建上下文时，CFRunLoopSourceContext 是一个结构体，如果没有进行初始化，context 的内部的值可能会是一堆乱码。只有添加了初始化方法`{0}`，才能保证结构里内部的值是正常的数值：\n```\nCFRunLoopSourceContext context = {0};\n```\n\n2. 启动 RunLoop 时，第三个参数传 true 表示执行完 source 立即退出，传 false 表示执行完 source 不退出。在这里传 false 等同于 OC 实现中的 while 循环的作用。\n```\nCFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);\n```\n\n# 总结\n\n* 讲讲 RunLoop，项目中有用到吗？  \n  1. RunLoop 保持程序的持续运行，没有 RunLoop 程序会马上退出，有了 RunLoop 程序并不会马上退出，而是保持运行状态；\n  2. RunLoop 处理App中的各种事件（如：定时器（Timer）、PerformSelector、GCD、事件响应、手势识别、界面刷新、网络请求和 AutoreleasePool 等）。这些事件的代码最终都变成了 RunLoop 里的执行任务（sources0/sources1/timers），由 RunLoop 监控和执行；\n  3. RunLoop 的休眠机制极大可能的节省了对CPU资源的占用，提高了程序性能；\n  4. 每条线程都有唯一的一个与之对应的 RunLoop 对象。RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value。线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建。RunLoop 会在线程结束时销毁。主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n  5. RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出。\n  6. RunLoop 有两种常见的 mode：  \n  kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行。  \n  UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。（只有主线程需要考虑这种 mode）  \n  NSRunLoopCommonModes：并不是一个真正的模式，只是一个标记。UITrackingRunLoopMode 和 kCFRunLoopDefaultMode 才是真正意义上的模式。一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n  7. RunLoop 的休眠唤醒逻辑是通过调用一个内核方法 `mach_msg()` 实现的。  \n  \n    项目中使用 RunLoop 的地方比较少，主要有解决 NSTimer 失效问题，自定义线程保活。\n\n* RunLoop 内部实现逻辑？  \n  1. RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出。\n\n  2. RunLoop 的休眠唤醒逻辑是通过调用一个内核方法 `mach_msg()` 实现的。\n\n* RunLoop 和线程的关系？  \n每条线程都有唯一的一个与之对应的 RunLoop 对象。RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value。线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建。RunLoop 会在线程结束时销毁。主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop；\n\n* timer 与 RunLoop 的关系？  \n一般情况下添加 timer 到 RunLoop 时 mode 设置为 kCFRunLoopDefaultMode，timer 运行在 RunLoop 的 _modes 里的模式下，同时 timer 被保存到 mode 里的 _timers 中。当添加 timer 到 RunLoop 将 mode 设置为 NSRunLoopCommonModes 标记时，那么 timer 能在 _commonModes 里的模式下运行，同时 timer 被保存到了 RunLoop 的 _commonModeItems 中。\n\n* 程序中添加每3秒响应一次的 NSTimer，当拖动 tableview 时 timer 可能无法响应要怎么解决？  \n通过 +timerWithTimeInterval:repeats:block: 方法创建 timer，然后手动添加到 RunLoop 中，并将 RunLoop 的 mode 设置为 NSRunLoopCommonModes。这个时候拖拽 TextView 就不会影响到 timer 了。原因在上面“timer 与 RunLoop 的关系”。\n\n* RunLoop 是怎么响应用户操作的， 具体流程是什么样的？\n![RunLoop08](RunLoop/RunLoop08.png)\n\n* 说说 RunLoop 的几种状态  \n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),         //即将进入Loop\n    kCFRunLoopBeforeTimers = (1UL << 1),  //即将处理Timer\n    kCFRunLoopBeforeSources = (1UL << 2), //即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), //即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),  //刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),          //即将推出Loop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n* RunLoop 的 mode 作用是什么？  \nmode 是 RunLoop 的运行模式。RunLoop 启动时只能选择其中一个 Mode，作为 _currentMode。如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Sources0/Sources1/Timer/Observer。不同组（不同mode）的 Sources0/Sources1/Timer/Observer 能分隔开来，互不影响。如果 Mode 里没有任何 Sources0/Sources1/Timer/Observer，RunLoop 会立马退出。RunLoop 将 OC 代码转换成了 Sources0/Sources1/Timer/Observer 保存到不同的 mode 里，并且循环监测并执行它们。比如：定时器（Timer）、PerformSelector、GCD、事件响应、手势识别、界面刷新、网络请求和 AutoreleasePool 等都是在进入休眠前完成的。","slug":"OC底层原理/RunLoop","published":1,"updated":"2023-08-22T09:52:13.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgsn000uaq7kedfkgchk"},{"title":"关联对象","date":"2020-05-26T03:16:15.000Z","_content":"思考：\n* Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？\n* 类对象可以关联对象吗？\n* 关联对象存储在什么位置？\n* 对象及其关联对象之间有强引用关系吗？\n* 对象释放后，关联对象会被释放吗？\n\n<!-- more -->\n\n# Category 的成员变量\n## _category_t 结构体\n```\nstruct _category_t {\n    const char *name; //类名\n    struct _class_t *cls; //父类\n    const struct _method_list_t *instance_methods; //对象方法列表\n    const struct _method_list_t *class_methods; //类方法列表\n    const struct _protocol_list_t *protocols; //协议列表\n    const struct _prop_list_t *properties; //属性列表\n};\n```\n\n从 _category_t 的结构体可以看出，Category 中并没有存放成员变量的容器，所以 Category 本身是不支持添加成员变量的。\n\n## 在 Persion.h 中定义属性\n```\n@interface Persion : NSObject\n@property (nonatomic, assign) int age;\n@end\n```\n\n在 Persion.h 中定义了属性后，系统会在 Persion.m 里自动做三件事：\n```\n@implementation Persion\n{\n    int _age; //第一件事：定义成员变量\n}\n//第二件事：实现 age 的 set 方法\n- (void)setAge:(int)age { \n    _age = age;\n}\n//第三件事：实现 age 的 get 方法\n- (int)age { \n    return _age;\n}\n@end\n```\n\n## 在 Persion+Test.h 中定义属性\n```\n@interface Persion (Test)\n@property (nonatomic, assign) int weight;\n@end\n```\n\n在 Persion+Test.h 中定义了属性后，系统会在 Persion+Test.h 里自动是实现两件事：\n```\n@interface Persion (Test)\n//第一件事：生成 weight 的 set 方法的声明\n- (void)setWeight:(int)weight;\n//第二件事：生成 weight 的 get 方法的声明\n- (int)weight;\n@end\n```\n\n在分类里定义的属性，并没有对应的成员变量和 set/get 方法的实现。如果尝试手动添加，系统会报错。\n![关联对象01](关联对象/关联对象01.png)\n\n## 定义全局变量 int weight_\n```\nint weight_;\n@implementation Persion (Test)\n- (void)setWeight:(int)weight {\n    weight_ = weight;\n}\n- (int)weight {\n    return weight_;\n}\n@end\n```\n\n通过定义全局变量 _weight 的方式可以实现成员变量的效果，但是 _weight 是全局变量，所有的实例对象 person 会共用同一个 _weight。这样会导致所有的实例对象 person 都可以修改 _weight，无法保证单个实例对象 person 与 _weight 一一对应关系。\n\n## 定义全局变量 NSMutableDictionary *weights_\n```\nNSMutableDictionary *weights_;\n@implementation Persion (Test)\n+ (void)load {\n    weights_ = [NSMutableDictionary dictionary];\n}\n- (void)setWeight:(int)weight {\n    NSString *key = [NSString stringWithFormat:@\"%p\", self];\n    weights_[key] = @(weight);\n}\n\n- (int)weight {\n    NSString *key = [NSString stringWithFormat:@\"%p\", self];\n    return [weights_[key] intValue];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.age = 10;\n        persion1.weight = 20;\n        \n        Persion *persion2 = [[Persion alloc] init];\n        persion2.age = 30;\n        persion2.weight = 40;\n        \n        NSLog(@\"persion1.age = %d, persion1.wight = %d\", persion1.age, persion1.weight);\n        NSLog(@\"persion2.age = %d, persion2.wight = %d\",persion2.age, persion2.weight);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\npersion1.age = 10, persion1.wight = 20\npersion2.age = 30, persion2.wight = 40\n```\n\n* 注意：  \n10和30是存储在 persion 对象的内部，20和40是存放在全局的字典 weights_ 对象里面。\n\n优点：通过定义全局变量字典，以 persion 对象的地址作 key，属性 weight 作 value，保证了 persion 对象与 weight 的一一对相应关系。  \n缺点：这种方式可能会有线程问题，在 `- (void)setWeight:(int)weight` 方法里需要加锁。另外每添加一个属性就要定义一个新的全局变量字典。\n\n## 小结\n因为分类底层结构的限制，不能直接添加成员变量到分类中，但是可以通过关联对象来间接实现。\n\n# 基本用法\n\n## 方法列表\n参数：  \nid _Nonnull object：需要添加关联对象的对象（通常写法传 self）;  \nconst void * _Nonnull key：指针类型，保存关联对象的key；  \nid _Nullable value：关联对象；  \nobjc_AssociationPolicy policy：关联策略；\n\n添加关联对象：\n```\nOBJC_EXPORT void\nobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,\n                         id _Nullable value, objc_AssociationPolicy policy)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n获取关联对象：\n```\nOBJC_EXPORT id _Nullable\nobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n移除所有的关联对象：\n```\nOBJC_EXPORT void\nobjc_removeAssociatedObjects(id _Nonnull object)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n### 关联策略 objc_AssociationPolicy\n```\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n关联策略 objc_AssociationPolicy 类似于定义属性时设置的参数，确定要关联的对象的内存内存管理方式。\n\n![关联对象02](关联对象/关联对象02.png)\n\n关联策略中没有 week，因为关联对象的实现并没有弱引用效果：\n\n![关联对象05](关联对象/关联对象05.png)\n\n👆通过 OBJC_ASSOCIATION_ASSIGN 策略关联了对象 persion3，此时在 ObjcAssociation 对象里的 value 记住的是关联对象 persion3 的地址值，当关联对象 persion3 离开大括号销毁后，value 依然保存着关联对象的地址值。如果这个时候再通过 value 去访问关联对象就会出现坏内存访问的错误。\n\n## key的常见用法\n先添加打印：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.name = @\"persion1\";\n        persion1.weight = 20;\n        \n        Persion *persion2 = [[Persion alloc] init];\n        persion2.name = @\"persion2\";\n        persion2.weight = 40;\n        \n        NSLog(@\"persion1.name = %@, persion1.wight = %d\", persion1.name, persion1.weight);\n        NSLog(@\"persion2.name = %@, persion2.wight = %d\",persion2.name, persion2.weight);\n    }\n    return 0;\n}\n```\n\n### 用法一：static const void *Key = &Key;\n#### const void *Key;\n```\n@interface Person (Test)\n@property (copy, nonatomic) NSString *name;\n@property (assign, nonatomic) int weight;\n@end\n\n@implementation Person (Test)\nconst void *NameKey;\nconst void *WeightKey;\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, WeightKey) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = 20, persion1.wight = 20\npersion2.name = 40, persion2.wight = 40\n```\n\n因为这种方式定义的 NameKey/WeightKey 没有赋值，都是 NULL。这样 name 和 weight 在赋值或取值的时候用的 key 都是 NULL，所以打印结果 name == weight。\n\n#### const void *Key = &Key;\n修改 NameKey/WeightKey 的定义：\n```\nconst void *NameKey = &NameKey;\nconst void *WeightKey = &WeightKey;\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n这样定义的 NameKey/WeightKey 内部存储的分别是 NameKey/WeightKey 的地址值，这样保证了 name 和 weight 在赋值或取值的时候用的 key 是不同的值。但是这种方式定义的 NameKey/WeightKey 是全局变量，在其它文件可以通过 exten 访问到：\n```\nextern const void *NameKey;\nextern const void *WeightKey;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"NameKey = %p, WeightKey = %p\", NameKey, WeightKey);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nNameKey = 0x100002338, WeightKey = 0x100002340\n```\n\n#### static const void *Key = &Key;\n使用 static，限定全局变量的作用域，修改 NameKey/WeightKey 的定义：\n```\n@implementation Person (Test)\nstatic const void *NameKey = &NameKey;\nstatic const void *WeightKey = &WeightKey;\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, WeightKey) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n这个时候再使用 extern 的方式查找全局变量 NameKey/WeightKey 就会报错：  \n![关联对象03](关联对象/关联对象03.png)\n\n#### 小结 \n\n* static：保证了全局变量的作用域仅限于当前文件。  \n* `Key = &Key`：Key 内部存储的是 Key 的地址值。\n\n### 用法二：static const char Key;\n\n#### static const int Key;\n`const void * _Nonnull key` 要求的参数是指针（地址值），所以可以定义一个 int Key，传入 &Key。\n```\n@implementation Persion (Test)\nstatic const int NameKey; //占用4个字节\nstatic const int WeightKey; //占用4个字节\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, &NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, &NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, &WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, &WeightKey) intValue];\n}\n\n@end\n```\n\n#### static const char Key;\nint 类型在内存中占用4个字节，既然只是要求指针，也可以定义一个 char Key，传入 &Key，这样就只占用1个字节了👇。\n```\n@implementation Persion (Test)\nstatic const char NameKey; //占用1个字节\nstatic const char WeightKey; //占用1个字节\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, &NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, &NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, &WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, &WeightKey) intValue];\n}\n\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n### 用法三：使用属性名作为 key\n使用属性名作为 key 可以很好的增加代码的可读性：\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @\"name\", name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, @\"name\");\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @\"weight\", @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, @\"weight\") intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n#### @\"name\" 与 const void * _Nonnull key。  \n定义一个字符串：\n```\nNSString *str = @\"name\";\n```\n\nstr 里装的就是 @\"name\" 的地址值。因为 str == @\"name\"，所以字符串 @\"name\" 就是其地址值，可以直接让字符串 @\"name\" 作 key。  \n\n字符串 @\"name\" 是放在内存常量区的，所以不同位置的字符串 @\"name\" 都是同一个字符串，这样也能保证了存储和读取时传入的 key 是同一个地址值👇 :\n```\n@implementation Persion (Test)\n- (void)logName\n{\n    NSLog(@\"%p\", @\"name\");\n    NSLog(@\"%p\", @\"name\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main - %p\", @\"name\");\n        NSLog(@\"main - %p\", @\"name\");\n\n        Persion *persion1 = [[Persion alloc] init];\n        [persion1 logName];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nmain - 0x100001080\nmain - 0x100001080\nPersion+Test - 0x100001080\nPersion+Test - 0x100001080\n```\n\n## 用法四：使用 get 方法的 @selecor 作为 key\n\n### @selecor\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, @selector(name));\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, @selector(weight)) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n`@selector()` 方法是一个指向结构体的指针，即返回某个结构体的指针，方法名相同的 `@selector()` 地址值相等：\n```\n- (void)setName:(NSString *)name\n{\n    NSLog(@\"selector(name) = %p\", @selector(name));\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    NSLog(@\"selector(name) = %p\", @selector(name));\n    return objc_getAssociatedObject(self, @selector(name));\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.name = @\"persion1\";\n        persion1.weight = 20;\n\n        NSLog(@\"persion1.name = %@, persion1.wight = %d\", persion1.name, persion1.weight);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nselector(name) = 0x7fff2e86480f\nselector(name) = 0x7fff2e86480f\nersion1.name = persion1, persion1.wight = 20\n```\n\n使用 `@selector()` 作为 key，即增加可读性，又在编写时会有代码提示，如果写错了还会出现方法不存在的警告。\n\n### _cmd\n在 get 方法里可以使用 _cmd 替换 @selecor(方法名)：\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, _cmd);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, _cmd) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n隐式参数：OC 方法在被调用的时候，有两个隐式的参数传入，self 和 _cmd。_cmd 就是当前方法的 SEL，即 @selecor(name)：\n```\n- (NSString *)name:(id)self _cmd:(SEL)_cmd\n```\n\n因为 set 方法中的 `_cmd == @selecor(setName:)`，get 方法中的 `_cmd == @selecor(name)`，所以为了保证存储和读取时用到的 key 是同一个，set 方法和 get 方法不能同时使用 _cmd。\n\n## 类对象添加关联对象\n\n类对象只有一个，不同的实例对象在修改和读取被新关联的对象时，都是在操作类对象关联的这个对象，这样又会出现实例对象和关联对象不是一一对应的关系。\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject([Persion class], @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject([Persion class], _cmd);\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion2, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n# 关联对象的原理\n\n实现关联对象技术的核心对象有：\n* AssociationsManager：关联对象管理类，内部管理着所有的 AssociationsHashMap； \n* AssociationsHashMap：存储着所有添加了关联对象的对象，及其添加的关联对象的信息；  \n* ObjectAssociationMap：存储着某一个关联对象的 key、value 和 policy 信息；  \n* ObjcAssociation：存储着某一个关联对象的 value 和 policy 信息；\n\n![关联对象04](关联对象/关联对象04.png)\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，找到 _base_objc_setAssociatedObject 方法的实现👇：\n## _base_objc_setAssociatedObject\n```\nstatic void\n_base_objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n{\n  _object_set_associative_reference(object, key, value, policy);\n}\n```\n\n找到 objc-references.mm 文件里的 _object_set_associative_reference，\nJump To Definition -> _object_set_associative_reference：\n```\nvoid\n_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)\n{\n    // This code used to work when nil was passed for object and key. Some code\n    // probably relies on that to not crash. Check and handle it explicitly.\n    // rdar://problem/44094390\n    if (!object && !value) return;\n\n    if (object->getIsa()->forbidsAssociatedObjects())\n        _objc_fatal(\"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects\", object, object_getClassName(object));\n\n    DisguisedPtr<objc_object> disguised{(objc_object *)object}; //根据传入的 object 封装成 DisguisedPtr，作为读写 ObjectAssociationMap 的 key\n    ObjcAssociation association{policy, value}; //根据 policy 和 value 生成 ObjcAssociation 对象\n\n    // retain the new value (if any) outside the lock.\n    association.acquireValue();\n\n    {\n        AssociationsManager manager; //关联对象管理类\n        AssociationsHashMap &associations(manager.get()); //获取关联对象管理类里的 AssociationsHashMap，AssociationsHashMap 保存了所有对象的关联对象信息\n\n        if (value) { //传入的关联对象有值（value != nil）\n            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap{}); //如果键不在 associations 中，则将键和值对插入到 associations 中\n            if (refs_result.second) {\n                /* it's the first association we make */\n                object->setHasAssociatedObjects(); //标记其被关联状态\n            }\n\n            /* establish or replace the association */\n            auto &refs = refs_result.first->second; //生成 ObjectAssociationMap 对象\n            auto result = refs.try_emplace(key, std::move(association)); //如果键不在 refs 中，则将键和值对插入到 refs 中\n            if (!result.second) { //如果键在 refs 中，更新 ObjectAssociation\n                association.swap(result.first->second);\n            }\n        } else { //传入的关联对象没有值（value == nil）\n            auto refs_it = associations.find(disguised); //找到 ObjectAssociationMap 的遍历器\n            if (refs_it != associations.end()) {\n                auto &refs = refs_it->second; //找到 ObjectAssociationMap 对象\n                auto it = refs.find(key); //找到 key 对应的 ObjcAssociation 遍历器\n                if (it != refs.end()) {\n                    association.swap(it->second);\n                    refs.erase(it); //擦除 ObjcAssociation 对象\n                    if (refs.size() == 0) { \n                        associations.erase(refs_it); //如果遍历器 refs 里数据为空，即 ObjectAssociationMap 里的数据为空，则擦除掉 ObjectAssociationMap 对象\n\n                    }\n                }\n            }\n        }\n    }\n\n    // release the old value (outside of the lock).\n    association.releaseHeldValue();\n}\n```\n\n### AssociationsManager\n```\nclass AssociationsManager {\n    using Storage = ExplicitInitDenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap>; \n    static Storage _mapStorage; //声明 AssociationsHashMap 对象\n\npublic:\n    AssociationsManager()   { AssociationsManagerLock.lock(); }\n    ~AssociationsManager()  { AssociationsManagerLock.unlock(); }\n\n    AssociationsHashMap &get() {\n        return _mapStorage.get(); //获取 AssociationsHashMap 对象\n    }\n\n    static void init() {\n        _mapStorage.init();\n    }\n};\n```\n\n### AssociationsHashMap\n可以看到 AssociationsManager 中有一个 AssociationsHashMap 对象，并且 AssociationsHashMap 对象是一个通过 DenseMap 定义的，DenseMap 是以 DisguisedPtr<objc_object> 为 key，ObjectAssociationMap 为 value 的字典。ExplicitInitDenseMap：\n\n```\nclass ExplicitInitDenseMap : public ExplicitInit<DenseMap<Key, Value>> { };\n```\n\n### ObjectAssociationMap\n```\ntypedef DenseMap<const void *, ObjcAssociation> ObjectAssociationMap;\n```\n\n👆从 ObjectAssociationMap 的定义可以看出，ObjectAssociationMap 是一个通过 DenseMap 定义的，以指针(地址值)为 key，ObjcAssociation 为 value 的字典。ObjcAssociation：\n\n### ObjcAssociation\n```\nclass ObjcAssociation {\n    uintptr_t _policy; //关联策略\n    id _value; //关联对象\npublic:\n    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}\n    ObjcAssociation() : _policy(0), _value(nil) {}\n    ObjcAssociation(const ObjcAssociation &other) = default;\n    ObjcAssociation &operator=(const ObjcAssociation &other) = default;\n    ObjcAssociation(ObjcAssociation &&other) : ObjcAssociation() {\n        swap(other);\n    }\n\n    inline void swap(ObjcAssociation &other) {\n        std::swap(_policy, other._policy);\n        std::swap(_value, other._value);\n    }\n\n    inline uintptr_t policy() const { return _policy; }\n    inline id value() const { return _value; }\n\n    inline void acquireValue() {\n        if (_value) {\n            switch (_policy & 0xFF) {\n            case OBJC_ASSOCIATION_SETTER_RETAIN:\n                _value = objc_retain(_value);\n                break;\n            case OBJC_ASSOCIATION_SETTER_COPY:\n                _value = ((id(*)(id, SEL))objc_msgSend)(_value, @selector(copy));\n                break;\n            }\n        }\n    }\n\n    inline void releaseHeldValue() {\n        if (_value && (_policy & OBJC_ASSOCIATION_SETTER_RETAIN)) {\n            objc_release(_value);\n        }\n    }\n\n    inline void retainReturnedValue() {\n        if (_value && (_policy & OBJC_ASSOCIATION_GETTER_RETAIN)) {\n            objc_retain(_value);\n        }\n    }\n\n    inline id autoreleaseReturnedValue() {\n        if (slowpath(_value && (_policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE))) {\n            return objc_autorelease(_value);\n        }\n        return _value;\n    }\n};\n```\n\n可以看出 ObjcAssociation 有两个变量 _policy 和 _value。\n\n\n## objc_getAssociatedObject\n```\nid\nobjc_getAssociatedObject(id object, const void *key)\n{\n    return _object_get_associative_reference(object, key);\n}\n```\n\n找到 objc-references.mm 文件里的 _object_get_associative_reference，\nJump To Definition -> _object_get_associative_reference：\n```\nid\n_object_get_associative_reference(id object, const void *key)\n{\n    ObjcAssociation association{};\n\n    {\n        AssociationsManager manager; //关联对象管理类\n        AssociationsHashMap &associations(manager.get()); //获取关联对象管理类里的 AssociationsHashMap，AssociationsHashMap 保存了所有对象的关联对象信息\n        AssociationsHashMap::iterator i = associations.find((objc_object *)object); //根据 object 找到 ObjectAssociationMap 遍历器 \n        if (i != associations.end()) {\n            ObjectAssociationMap &refs = i->second; //获取到 ObjectAssociationMap 对象\n            ObjectAssociationMap::iterator j = refs.find(key); //根据 key 找到 ObjcAssociation 遍历器\n            if (j != refs.end()) {\n                association = j->second;\n                association.retainReturnedValue();\n            }\n        }\n    }\n\n    return association.autoreleaseReturnedValue();\n}\n```\n\n# 总结\n* Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？  \n因为分类底层结构的限制，不能直接添加成员变量到分类中，但是可以通过关联对象来间接实现。  \n给 Category 添加成员变量的方式有很多，不过主要是通过下面两个方法添加成员变量：  \n```\n//添加关联对象\nobjc_setAssociatedObject();\n//获取关联对象\nobjc_getAssociatedObject();\n```\n\n* 类对象可以关联对象吗？  \n关联对象方法可以给任何对象关联新的对象，类对象自然也是可以关联对象的。但是类对象只有一个，不同的实例对象在修改和读取被新关联的对象时，都是在操作类对象关联的这个对象，这样又会出现实例对象和关联对象不是一一对应的关系。\n\n* 关联对象存储在什么位置？  \n关联对象并不是存储在被关联对象本身内存中，关联对象存储在全局的统一的一个 AssociationsManager 中。\n\n* 对象及其关联对象之间有强引用关系吗？  \n不存在。在 set 方法中并没有直接使用传入的 object 对象，而是通过的 disguised 方法将传入的 object 对象生成了 DisguisedPtr 对象，并作为 key。\n\n* 对象释放后，关联对象会被释放吗？  \n会释放。参考内存管理-release。\n\n* 设置关联对象为nil，就相当于是移除关联对象。","source":"_posts/OC底层原理/关联对象.md","raw":"---\ntitle: 关联对象\ndate: 2020-05-26 11:16:15\ntags: OC底层原理\n---\n思考：\n* Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？\n* 类对象可以关联对象吗？\n* 关联对象存储在什么位置？\n* 对象及其关联对象之间有强引用关系吗？\n* 对象释放后，关联对象会被释放吗？\n\n<!-- more -->\n\n# Category 的成员变量\n## _category_t 结构体\n```\nstruct _category_t {\n    const char *name; //类名\n    struct _class_t *cls; //父类\n    const struct _method_list_t *instance_methods; //对象方法列表\n    const struct _method_list_t *class_methods; //类方法列表\n    const struct _protocol_list_t *protocols; //协议列表\n    const struct _prop_list_t *properties; //属性列表\n};\n```\n\n从 _category_t 的结构体可以看出，Category 中并没有存放成员变量的容器，所以 Category 本身是不支持添加成员变量的。\n\n## 在 Persion.h 中定义属性\n```\n@interface Persion : NSObject\n@property (nonatomic, assign) int age;\n@end\n```\n\n在 Persion.h 中定义了属性后，系统会在 Persion.m 里自动做三件事：\n```\n@implementation Persion\n{\n    int _age; //第一件事：定义成员变量\n}\n//第二件事：实现 age 的 set 方法\n- (void)setAge:(int)age { \n    _age = age;\n}\n//第三件事：实现 age 的 get 方法\n- (int)age { \n    return _age;\n}\n@end\n```\n\n## 在 Persion+Test.h 中定义属性\n```\n@interface Persion (Test)\n@property (nonatomic, assign) int weight;\n@end\n```\n\n在 Persion+Test.h 中定义了属性后，系统会在 Persion+Test.h 里自动是实现两件事：\n```\n@interface Persion (Test)\n//第一件事：生成 weight 的 set 方法的声明\n- (void)setWeight:(int)weight;\n//第二件事：生成 weight 的 get 方法的声明\n- (int)weight;\n@end\n```\n\n在分类里定义的属性，并没有对应的成员变量和 set/get 方法的实现。如果尝试手动添加，系统会报错。\n![关联对象01](关联对象/关联对象01.png)\n\n## 定义全局变量 int weight_\n```\nint weight_;\n@implementation Persion (Test)\n- (void)setWeight:(int)weight {\n    weight_ = weight;\n}\n- (int)weight {\n    return weight_;\n}\n@end\n```\n\n通过定义全局变量 _weight 的方式可以实现成员变量的效果，但是 _weight 是全局变量，所有的实例对象 person 会共用同一个 _weight。这样会导致所有的实例对象 person 都可以修改 _weight，无法保证单个实例对象 person 与 _weight 一一对应关系。\n\n## 定义全局变量 NSMutableDictionary *weights_\n```\nNSMutableDictionary *weights_;\n@implementation Persion (Test)\n+ (void)load {\n    weights_ = [NSMutableDictionary dictionary];\n}\n- (void)setWeight:(int)weight {\n    NSString *key = [NSString stringWithFormat:@\"%p\", self];\n    weights_[key] = @(weight);\n}\n\n- (int)weight {\n    NSString *key = [NSString stringWithFormat:@\"%p\", self];\n    return [weights_[key] intValue];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.age = 10;\n        persion1.weight = 20;\n        \n        Persion *persion2 = [[Persion alloc] init];\n        persion2.age = 30;\n        persion2.weight = 40;\n        \n        NSLog(@\"persion1.age = %d, persion1.wight = %d\", persion1.age, persion1.weight);\n        NSLog(@\"persion2.age = %d, persion2.wight = %d\",persion2.age, persion2.weight);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\npersion1.age = 10, persion1.wight = 20\npersion2.age = 30, persion2.wight = 40\n```\n\n* 注意：  \n10和30是存储在 persion 对象的内部，20和40是存放在全局的字典 weights_ 对象里面。\n\n优点：通过定义全局变量字典，以 persion 对象的地址作 key，属性 weight 作 value，保证了 persion 对象与 weight 的一一对相应关系。  \n缺点：这种方式可能会有线程问题，在 `- (void)setWeight:(int)weight` 方法里需要加锁。另外每添加一个属性就要定义一个新的全局变量字典。\n\n## 小结\n因为分类底层结构的限制，不能直接添加成员变量到分类中，但是可以通过关联对象来间接实现。\n\n# 基本用法\n\n## 方法列表\n参数：  \nid _Nonnull object：需要添加关联对象的对象（通常写法传 self）;  \nconst void * _Nonnull key：指针类型，保存关联对象的key；  \nid _Nullable value：关联对象；  \nobjc_AssociationPolicy policy：关联策略；\n\n添加关联对象：\n```\nOBJC_EXPORT void\nobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,\n                         id _Nullable value, objc_AssociationPolicy policy)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n获取关联对象：\n```\nOBJC_EXPORT id _Nullable\nobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n移除所有的关联对象：\n```\nOBJC_EXPORT void\nobjc_removeAssociatedObjects(id _Nonnull object)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);\n```\n\n### 关联策略 objc_AssociationPolicy\n```\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n关联策略 objc_AssociationPolicy 类似于定义属性时设置的参数，确定要关联的对象的内存内存管理方式。\n\n![关联对象02](关联对象/关联对象02.png)\n\n关联策略中没有 week，因为关联对象的实现并没有弱引用效果：\n\n![关联对象05](关联对象/关联对象05.png)\n\n👆通过 OBJC_ASSOCIATION_ASSIGN 策略关联了对象 persion3，此时在 ObjcAssociation 对象里的 value 记住的是关联对象 persion3 的地址值，当关联对象 persion3 离开大括号销毁后，value 依然保存着关联对象的地址值。如果这个时候再通过 value 去访问关联对象就会出现坏内存访问的错误。\n\n## key的常见用法\n先添加打印：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.name = @\"persion1\";\n        persion1.weight = 20;\n        \n        Persion *persion2 = [[Persion alloc] init];\n        persion2.name = @\"persion2\";\n        persion2.weight = 40;\n        \n        NSLog(@\"persion1.name = %@, persion1.wight = %d\", persion1.name, persion1.weight);\n        NSLog(@\"persion2.name = %@, persion2.wight = %d\",persion2.name, persion2.weight);\n    }\n    return 0;\n}\n```\n\n### 用法一：static const void *Key = &Key;\n#### const void *Key;\n```\n@interface Person (Test)\n@property (copy, nonatomic) NSString *name;\n@property (assign, nonatomic) int weight;\n@end\n\n@implementation Person (Test)\nconst void *NameKey;\nconst void *WeightKey;\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, WeightKey) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = 20, persion1.wight = 20\npersion2.name = 40, persion2.wight = 40\n```\n\n因为这种方式定义的 NameKey/WeightKey 没有赋值，都是 NULL。这样 name 和 weight 在赋值或取值的时候用的 key 都是 NULL，所以打印结果 name == weight。\n\n#### const void *Key = &Key;\n修改 NameKey/WeightKey 的定义：\n```\nconst void *NameKey = &NameKey;\nconst void *WeightKey = &WeightKey;\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n这样定义的 NameKey/WeightKey 内部存储的分别是 NameKey/WeightKey 的地址值，这样保证了 name 和 weight 在赋值或取值的时候用的 key 是不同的值。但是这种方式定义的 NameKey/WeightKey 是全局变量，在其它文件可以通过 exten 访问到：\n```\nextern const void *NameKey;\nextern const void *WeightKey;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"NameKey = %p, WeightKey = %p\", NameKey, WeightKey);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nNameKey = 0x100002338, WeightKey = 0x100002340\n```\n\n#### static const void *Key = &Key;\n使用 static，限定全局变量的作用域，修改 NameKey/WeightKey 的定义：\n```\n@implementation Person (Test)\nstatic const void *NameKey = &NameKey;\nstatic const void *WeightKey = &WeightKey;\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, WeightKey) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n这个时候再使用 extern 的方式查找全局变量 NameKey/WeightKey 就会报错：  \n![关联对象03](关联对象/关联对象03.png)\n\n#### 小结 \n\n* static：保证了全局变量的作用域仅限于当前文件。  \n* `Key = &Key`：Key 内部存储的是 Key 的地址值。\n\n### 用法二：static const char Key;\n\n#### static const int Key;\n`const void * _Nonnull key` 要求的参数是指针（地址值），所以可以定义一个 int Key，传入 &Key。\n```\n@implementation Persion (Test)\nstatic const int NameKey; //占用4个字节\nstatic const int WeightKey; //占用4个字节\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, &NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, &NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, &WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, &WeightKey) intValue];\n}\n\n@end\n```\n\n#### static const char Key;\nint 类型在内存中占用4个字节，既然只是要求指针，也可以定义一个 char Key，传入 &Key，这样就只占用1个字节了👇。\n```\n@implementation Persion (Test)\nstatic const char NameKey; //占用1个字节\nstatic const char WeightKey; //占用1个字节\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, &NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, &NameKey);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, &WeightKey, @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, &WeightKey) intValue];\n}\n\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n### 用法三：使用属性名作为 key\n使用属性名作为 key 可以很好的增加代码的可读性：\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @\"name\", name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, @\"name\");\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @\"weight\", @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, @\"weight\") intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n#### @\"name\" 与 const void * _Nonnull key。  \n定义一个字符串：\n```\nNSString *str = @\"name\";\n```\n\nstr 里装的就是 @\"name\" 的地址值。因为 str == @\"name\"，所以字符串 @\"name\" 就是其地址值，可以直接让字符串 @\"name\" 作 key。  \n\n字符串 @\"name\" 是放在内存常量区的，所以不同位置的字符串 @\"name\" 都是同一个字符串，这样也能保证了存储和读取时传入的 key 是同一个地址值👇 :\n```\n@implementation Persion (Test)\n- (void)logName\n{\n    NSLog(@\"%p\", @\"name\");\n    NSLog(@\"%p\", @\"name\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"main - %p\", @\"name\");\n        NSLog(@\"main - %p\", @\"name\");\n\n        Persion *persion1 = [[Persion alloc] init];\n        [persion1 logName];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nmain - 0x100001080\nmain - 0x100001080\nPersion+Test - 0x100001080\nPersion+Test - 0x100001080\n```\n\n## 用法四：使用 get 方法的 @selecor 作为 key\n\n### @selecor\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, @selector(name));\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, @selector(weight)) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n`@selector()` 方法是一个指向结构体的指针，即返回某个结构体的指针，方法名相同的 `@selector()` 地址值相等：\n```\n- (void)setName:(NSString *)name\n{\n    NSLog(@\"selector(name) = %p\", @selector(name));\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    NSLog(@\"selector(name) = %p\", @selector(name));\n    return objc_getAssociatedObject(self, @selector(name));\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Persion *persion1 = [[Persion alloc] init];\n        persion1.name = @\"persion1\";\n        persion1.weight = 20;\n\n        NSLog(@\"persion1.name = %@, persion1.wight = %d\", persion1.name, persion1.weight);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nselector(name) = 0x7fff2e86480f\nselector(name) = 0x7fff2e86480f\nersion1.name = persion1, persion1.wight = 20\n```\n\n使用 `@selector()` 作为 key，即增加可读性，又在编写时会有代码提示，如果写错了还会出现方法不存在的警告。\n\n### _cmd\n在 get 方法里可以使用 _cmd 替换 @selecor(方法名)：\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject(self, _cmd);\n}\n- (void)setWeight:(int)weight\n{\n    objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n- (int)weight\n{\n    return [objc_getAssociatedObject(self, _cmd) intValue];\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion1, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n隐式参数：OC 方法在被调用的时候，有两个隐式的参数传入，self 和 _cmd。_cmd 就是当前方法的 SEL，即 @selecor(name)：\n```\n- (NSString *)name:(id)self _cmd:(SEL)_cmd\n```\n\n因为 set 方法中的 `_cmd == @selecor(setName:)`，get 方法中的 `_cmd == @selecor(name)`，所以为了保证存储和读取时用到的 key 是同一个，set 方法和 get 方法不能同时使用 _cmd。\n\n## 类对象添加关联对象\n\n类对象只有一个，不同的实例对象在修改和读取被新关联的对象时，都是在操作类对象关联的这个对象，这样又会出现实例对象和关联对象不是一一对应的关系。\n```\n@implementation Persion (Test)\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject([Persion class], @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n- (NSString *)name\n{\n    return objc_getAssociatedObject([Persion class], _cmd);\n}\n@end\n```\n\n打印结果：\n```\npersion1.name = persion2, persion1.wight = 20\npersion2.name = persion2, persion2.wight = 40\n```\n\n# 关联对象的原理\n\n实现关联对象技术的核心对象有：\n* AssociationsManager：关联对象管理类，内部管理着所有的 AssociationsHashMap； \n* AssociationsHashMap：存储着所有添加了关联对象的对象，及其添加的关联对象的信息；  \n* ObjectAssociationMap：存储着某一个关联对象的 key、value 和 policy 信息；  \n* ObjcAssociation：存储着某一个关联对象的 value 和 policy 信息；\n\n![关联对象04](关联对象/关联对象04.png)\n\n打开 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/)，找到 _base_objc_setAssociatedObject 方法的实现👇：\n## _base_objc_setAssociatedObject\n```\nstatic void\n_base_objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n{\n  _object_set_associative_reference(object, key, value, policy);\n}\n```\n\n找到 objc-references.mm 文件里的 _object_set_associative_reference，\nJump To Definition -> _object_set_associative_reference：\n```\nvoid\n_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)\n{\n    // This code used to work when nil was passed for object and key. Some code\n    // probably relies on that to not crash. Check and handle it explicitly.\n    // rdar://problem/44094390\n    if (!object && !value) return;\n\n    if (object->getIsa()->forbidsAssociatedObjects())\n        _objc_fatal(\"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects\", object, object_getClassName(object));\n\n    DisguisedPtr<objc_object> disguised{(objc_object *)object}; //根据传入的 object 封装成 DisguisedPtr，作为读写 ObjectAssociationMap 的 key\n    ObjcAssociation association{policy, value}; //根据 policy 和 value 生成 ObjcAssociation 对象\n\n    // retain the new value (if any) outside the lock.\n    association.acquireValue();\n\n    {\n        AssociationsManager manager; //关联对象管理类\n        AssociationsHashMap &associations(manager.get()); //获取关联对象管理类里的 AssociationsHashMap，AssociationsHashMap 保存了所有对象的关联对象信息\n\n        if (value) { //传入的关联对象有值（value != nil）\n            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap{}); //如果键不在 associations 中，则将键和值对插入到 associations 中\n            if (refs_result.second) {\n                /* it's the first association we make */\n                object->setHasAssociatedObjects(); //标记其被关联状态\n            }\n\n            /* establish or replace the association */\n            auto &refs = refs_result.first->second; //生成 ObjectAssociationMap 对象\n            auto result = refs.try_emplace(key, std::move(association)); //如果键不在 refs 中，则将键和值对插入到 refs 中\n            if (!result.second) { //如果键在 refs 中，更新 ObjectAssociation\n                association.swap(result.first->second);\n            }\n        } else { //传入的关联对象没有值（value == nil）\n            auto refs_it = associations.find(disguised); //找到 ObjectAssociationMap 的遍历器\n            if (refs_it != associations.end()) {\n                auto &refs = refs_it->second; //找到 ObjectAssociationMap 对象\n                auto it = refs.find(key); //找到 key 对应的 ObjcAssociation 遍历器\n                if (it != refs.end()) {\n                    association.swap(it->second);\n                    refs.erase(it); //擦除 ObjcAssociation 对象\n                    if (refs.size() == 0) { \n                        associations.erase(refs_it); //如果遍历器 refs 里数据为空，即 ObjectAssociationMap 里的数据为空，则擦除掉 ObjectAssociationMap 对象\n\n                    }\n                }\n            }\n        }\n    }\n\n    // release the old value (outside of the lock).\n    association.releaseHeldValue();\n}\n```\n\n### AssociationsManager\n```\nclass AssociationsManager {\n    using Storage = ExplicitInitDenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap>; \n    static Storage _mapStorage; //声明 AssociationsHashMap 对象\n\npublic:\n    AssociationsManager()   { AssociationsManagerLock.lock(); }\n    ~AssociationsManager()  { AssociationsManagerLock.unlock(); }\n\n    AssociationsHashMap &get() {\n        return _mapStorage.get(); //获取 AssociationsHashMap 对象\n    }\n\n    static void init() {\n        _mapStorage.init();\n    }\n};\n```\n\n### AssociationsHashMap\n可以看到 AssociationsManager 中有一个 AssociationsHashMap 对象，并且 AssociationsHashMap 对象是一个通过 DenseMap 定义的，DenseMap 是以 DisguisedPtr<objc_object> 为 key，ObjectAssociationMap 为 value 的字典。ExplicitInitDenseMap：\n\n```\nclass ExplicitInitDenseMap : public ExplicitInit<DenseMap<Key, Value>> { };\n```\n\n### ObjectAssociationMap\n```\ntypedef DenseMap<const void *, ObjcAssociation> ObjectAssociationMap;\n```\n\n👆从 ObjectAssociationMap 的定义可以看出，ObjectAssociationMap 是一个通过 DenseMap 定义的，以指针(地址值)为 key，ObjcAssociation 为 value 的字典。ObjcAssociation：\n\n### ObjcAssociation\n```\nclass ObjcAssociation {\n    uintptr_t _policy; //关联策略\n    id _value; //关联对象\npublic:\n    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}\n    ObjcAssociation() : _policy(0), _value(nil) {}\n    ObjcAssociation(const ObjcAssociation &other) = default;\n    ObjcAssociation &operator=(const ObjcAssociation &other) = default;\n    ObjcAssociation(ObjcAssociation &&other) : ObjcAssociation() {\n        swap(other);\n    }\n\n    inline void swap(ObjcAssociation &other) {\n        std::swap(_policy, other._policy);\n        std::swap(_value, other._value);\n    }\n\n    inline uintptr_t policy() const { return _policy; }\n    inline id value() const { return _value; }\n\n    inline void acquireValue() {\n        if (_value) {\n            switch (_policy & 0xFF) {\n            case OBJC_ASSOCIATION_SETTER_RETAIN:\n                _value = objc_retain(_value);\n                break;\n            case OBJC_ASSOCIATION_SETTER_COPY:\n                _value = ((id(*)(id, SEL))objc_msgSend)(_value, @selector(copy));\n                break;\n            }\n        }\n    }\n\n    inline void releaseHeldValue() {\n        if (_value && (_policy & OBJC_ASSOCIATION_SETTER_RETAIN)) {\n            objc_release(_value);\n        }\n    }\n\n    inline void retainReturnedValue() {\n        if (_value && (_policy & OBJC_ASSOCIATION_GETTER_RETAIN)) {\n            objc_retain(_value);\n        }\n    }\n\n    inline id autoreleaseReturnedValue() {\n        if (slowpath(_value && (_policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE))) {\n            return objc_autorelease(_value);\n        }\n        return _value;\n    }\n};\n```\n\n可以看出 ObjcAssociation 有两个变量 _policy 和 _value。\n\n\n## objc_getAssociatedObject\n```\nid\nobjc_getAssociatedObject(id object, const void *key)\n{\n    return _object_get_associative_reference(object, key);\n}\n```\n\n找到 objc-references.mm 文件里的 _object_get_associative_reference，\nJump To Definition -> _object_get_associative_reference：\n```\nid\n_object_get_associative_reference(id object, const void *key)\n{\n    ObjcAssociation association{};\n\n    {\n        AssociationsManager manager; //关联对象管理类\n        AssociationsHashMap &associations(manager.get()); //获取关联对象管理类里的 AssociationsHashMap，AssociationsHashMap 保存了所有对象的关联对象信息\n        AssociationsHashMap::iterator i = associations.find((objc_object *)object); //根据 object 找到 ObjectAssociationMap 遍历器 \n        if (i != associations.end()) {\n            ObjectAssociationMap &refs = i->second; //获取到 ObjectAssociationMap 对象\n            ObjectAssociationMap::iterator j = refs.find(key); //根据 key 找到 ObjcAssociation 遍历器\n            if (j != refs.end()) {\n                association = j->second;\n                association.retainReturnedValue();\n            }\n        }\n    }\n\n    return association.autoreleaseReturnedValue();\n}\n```\n\n# 总结\n* Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？  \n因为分类底层结构的限制，不能直接添加成员变量到分类中，但是可以通过关联对象来间接实现。  \n给 Category 添加成员变量的方式有很多，不过主要是通过下面两个方法添加成员变量：  \n```\n//添加关联对象\nobjc_setAssociatedObject();\n//获取关联对象\nobjc_getAssociatedObject();\n```\n\n* 类对象可以关联对象吗？  \n关联对象方法可以给任何对象关联新的对象，类对象自然也是可以关联对象的。但是类对象只有一个，不同的实例对象在修改和读取被新关联的对象时，都是在操作类对象关联的这个对象，这样又会出现实例对象和关联对象不是一一对应的关系。\n\n* 关联对象存储在什么位置？  \n关联对象并不是存储在被关联对象本身内存中，关联对象存储在全局的统一的一个 AssociationsManager 中。\n\n* 对象及其关联对象之间有强引用关系吗？  \n不存在。在 set 方法中并没有直接使用传入的 object 对象，而是通过的 disguised 方法将传入的 object 对象生成了 DisguisedPtr 对象，并作为 key。\n\n* 对象释放后，关联对象会被释放吗？  \n会释放。参考内存管理-release。\n\n* 设置关联对象为nil，就相当于是移除关联对象。","slug":"OC底层原理/关联对象","published":1,"updated":"2023-08-22T09:52:13.988Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgsv000xaq7k1h3g9xr8"},{"title":"架构设计","date":"2020-09-02T07:02:50.000Z","_content":"\n思考：  \n* 讲讲 MVC、MVVM、MVP，以及你在项目里具体是怎么写的？\n* 你自己用过哪些设计模式？\n* 一般开始做一个项目，你的架构是如何思考的？\n<!-- more -->\n\n# 架构\n架构（Architecture），软件开发中的设计方案。类与类之间的关系、模块与模块之间的关系、客户端与服务端的关系。\n\n经常听到的架构名词：MVC、MVP、MVVM、VIPER、CDD、三层架构、四层架构......\n\n## MVC - Apple版\nModel-View-Controller\n![架构设计01](架构设计/架构设计01.png)\n优点：View、Model可以重复利用，可以独立使用；  \n缺点：Controller的代码过于臃肿；\n\nController 拥有 Model 和 View，并负责处理 Model 和 View 的逻辑。Model 和 View 不需要知道对方的存在。\n\n示例代码：\n![架构设计08](架构设计/架构设计08.png)\n\n![架构设计07](架构设计/架构设计07.png)\n\n拥有关系：在使用 MVC 设计模式里，TableView 是最经典的了。从示例代码可以看到，Controller 同时拥有 News 和 NewsCell，但是 News 和 NewsCell 互相不知道对方的存在。\n\n数据：Controller 成为 TableView 的代理，并在 `cellForRowAtIndexPath:` 方法里将 News 传递给了 NewsCell，在 NewsCell 内部处理数据。  \n\n事件：Controller 成为 TableView 的代理，并在 `didSelectRowAtIndexPath:` 方法里处理 NewCell 的点击事件。\n\n优点：因为 NewsCell 不需要 News，只需要在 `cellForRowAtIndexPath:` 方法里获取需要展示的数据，所以 Controller 里的 News 不是必要条件，也可以使用其它的 Model 跟当前的 Controller 和 NewsCell 组成 MVC 结构。比如新建 替换掉 News：\n![架构设计09](架构设计/架构设计09.png)\n\n![架构设计11](架构设计/架构设计11.png)\n\n缺点：因为 Controller 要负责将 Model 里的数据传递给 View 用于展示，所以在 View 比较多的情况下，Controller 就会变得臃肿。在实际开发中同一个 TableView 往往会有多种 Cell，或者 Cell 的功能非常复杂，需要处理的数据和逻辑很多，所以一般不会在 Controller 里处理 Cell 数据相关的逻辑，就衍生出了下面这种设计模式👇。\n\n## MVC – 变种\nModel-View-Controller\n![架构设计02](架构设计/架构设计02.png)\n优点：对 Controller 进行瘦身，将 View 内部的细节封装起来了，外界不知道 View 内部的具体实现；\n缺点：View 依赖于 Model；\n\nController 拥有 Model 和 View。View 拥有 Model，在 View 内部处理 Model。\n\n### 示例代码一\n```\n// Model\n@interface News : NSObject\n@property (nonatomic, copy) NSString *title;\n@property (nonatomic, copy) NSString *content;\n@end\n\n@implementation News\n@end\n\n// View\n@interface NewsTableViewCell : UITableViewCell\n@property (nonatomic, strong) News *news;\n@end\n\n@implementation NewsTableViewCell\n- (void)setNews:(News *)news\n{\n    _news = news;\n    self.textLabel.text = _news.title;\n    self.detailTextLabel.text = _news.content;\n}\n@end\n\n// Controller\n@interface NewsTableViewController ()\n@property (nonatomic, strong) NSMutableArray *newsData;\n@end\n\n@implementation NewsTableViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadNews];\n}\n\n- (void)loadNews\n{\n    self.newsData = [NSMutableArray array];\n    for (int i = 0; i < 20; i++) {\n        News *news = [[News alloc] init];\n        news.title = [NSString stringWithFormat:@\"标题%d\", i];\n        news.content = [NSString stringWithFormat:@\"内容%d\", i];\n        [self.newsData addObject:news];\n    }\n}\n\n#pragma mark - Table view data source\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.newsData.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    NewsTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"NewsTableViewCell\"];\n    if (!cell) {\n        cell = [[NewsTableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@\"NewsTableViewCell\"];\n    }\n    News *news = self.newsData[indexPath.row];\n    cell.news = news;\n    return cell;\n}\n\n#pragma mark - Table view delegate\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    NSLog(@\"点击标题%ld\", (long)indexPath.row);\n}\n@end\n```\n\n![架构设计07](架构设计/架构设计07.png)\n\n拥有关系：从示例代码可以看到，Controller 同时拥有 News 和 NewsCell，NewsCell 拥有 News。  \n\n数据：Controller 成为 TableView 的代理，并在 `cellForRowAtIndexPath:` 方法里将 News 传递给了 NewsCell，在 NewsCell 内部处理数据。  \n\n事件：Controller 成为 TableView 的代理，并在 `didSelectRowAtIndexPath:` 方法里处理 NewCell 的点击事件。\n\n### 示例代码二\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *image;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation App\n@end\n\n// View\n@class App, AppView;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n@property (nonatomic, strong) App *app;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        iconView.contentMode = UIViewContentModeScaleAspectFill;\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 30);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setApp:(App *)app\n{\n    _app = app;\n    self.iconView.image = [UIImage imageNamed:app.image];\n    self.nameLabel.text = app.name;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// Controller\n@interface ViewController ()<AppViewDelegate>\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 拥有View\n    AppView *appView = [[AppView alloc] init];\n    appView.frame = CGRectMake(100, 100, 100, 150);\n    appView.delegate = self;\n    [self.view addSubview:appView];\n    \n    // 拥有Model\n    App *app = [[App alloc] init];\n    app.name = @\"Boxfish\";\n    app.image = @\"Boxfish\";\n    \n    // 数据传递\n    appView.app = app;\n}\n\n#pragma mark - AppViewDelegate\n- (void)appViewDidClick:(AppView *)appView\n{\n    NSLog(@\"控制器监听到AppView的点击\");\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 同时拥有 App 和 AppView，AppView 拥有 App。  \n\n数据：Controller 将 App 传递给了 AppView 并在 AppView 内部处理数据。  \n\n事件：Controller 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## MVP\nModel-View-Presenter\n![架构设计03](架构设计/架构设计03.png)\n\nMVP 和 MVC 很像，他们的相同点是都要求 Model 和 View 不需要知道对方的存在。他们的区别在于：  \n在 MVC 中，Controller 拥有 Model 和 View，并负责处理 Model 和 View 的逻辑。  \n在 MVP 中，Controller 里的逻辑代码挪到了 Presenter 里，由 Presenter 负责处理 Model 和 View 的逻辑，Controller 不需要知道 Model 和 View 的存在。\n\n示例代码：\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *image;\n@end\n\n@implementation App\n@end\n\n// View\n@class AppView;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n- (void)setName:(NSString *)name andImage:(NSString *)image;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 30);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setName:(NSString *)name andImage:(NSString *)image\n{\n    _iconView.image = [UIImage imageNamed:image];\n    _nameLabel.text = name;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// Presenter\n@interface AppPresenter : NSObject\n- (instancetype)initWithController:(UIViewController *)controller;\n@end\n\n@interface AppPresenter()<AppViewDelegate>\n@property (nonatomic, weak) UIViewController *controller;\n@end\n\n@implementation AppPresenter\n- (instancetype)initWithController:(UIViewController *)controller\n{\n    self = [super init];\n    if (self) {\n        self.controller = controller;\n        \n        AppView *appView = [[AppView alloc] init];\n        appView.frame = CGRectMake(100, 100, 100, 100);\n        appView.delegate = self;\n        [controller.view addSubview:appView];\n        \n        App *app = [[App alloc] init];\n        app.name = @\"Boxfish\";\n        app.image = @\"Boxfish\";\n        \n        [appView setName:app.name andImage:app.image];\n    }\n    return self;\n}\n\n#pragma mark - AppViewDelegate\n- (void)appViewDidClick:(AppView *)appView\n{\n    NSLog(@\"presenter 监听到了 appView 的点击\");\n}\n@end\n\n// Controller\n@interface ViewController ()\n@property (nonatomic, strong) AppPresenter *appPresenter;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n     \n    self.appPresenter = [[AppPresenter alloc] initWithController:self];\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 拥有 AppPresenter，AppPresenter 拥有 Controller、App 和 AppView，Controller、App 和 AppView 不知道对方的存在。  \n\n数据：AppPresenter 将 App 的数据传递给了 AppView。  \n\n事件：AppPresenter 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## MVVM\nModel-View-ViewModel\n![架构设计04](架构设计/架构设计04.png)\n\n👉 [KVOController](https://github.com/facebookarchive/KVOController)\n\n示例代码：\n![架构设计12](架构设计/架构设计12.png)\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *image;\n@end\n\n@implementation App\n@end\n\n// AppView\n@class AppView,AppViewModel;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n@property (nonatomic, weak) AppViewModel *viewModel;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 100);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setViewModel:(AppViewModel *)viewModel\n{\n    _viewModel = viewModel;\n    \n    /// MVVM设计模式的核心代码，这里使用了 FaceBook 的开源项目 KVOController\n    __weak typeof(self) weakSelf = self;\n    [self.KVOController observe:viewModel keyPath:@\"name\" options:NSKeyValueObservingOptionNew block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n        weakSelf.nameLabel.text = change[NSKeyValueChangeNewKey];\n    }];\n    \n    [self.KVOController observe:viewModel keyPath:@\"image\" options:NSKeyValueObservingOptionNew block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n        weakSelf.iconView.image = [UIImage imageNamed:change[NSKeyValueChangeNewKey]];\n    }];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// ViewModel\n@interface AppViewModel : NSObject\n- (instancetype)initWithController:(UIViewController *)controller;\n@end\n\n@interface AppViewModel() <AppViewDelegate>\n@property (nonatomic, weak) UIViewController *controller;\n@property (nonatomic, weak) NSString *name;\n@property (nonatomic, weak) NSString *image;\n@end\n\n@implementation AppViewModel\n- (instancetype)initWithController:(UIViewController *)controller\n{\n    self = [super init];\n    if (self) {\n        self.controller = controller;\n        \n        /// 拥有View\n        AppView *appView = [[AppView alloc] init];\n        appView.frame = CGRectMake(100, 100, 100, 100);\n        appView.delegate = self;\n        appView.viewModel = self;\n        [controller.view addSubview:appView];\n        \n        /// 拥有Model\n        App *app = [[App alloc] init];\n        app.name = @\"Boxfish\";\n        app.image = @\"Boxfish\";\n        \n        /// 处理逻辑\n        self.name = app.name;\n        self.image = app.image;\n    }\n    return self;\n}\n@end\n\n// View（在MVVM中，Controller被看做View）\n@interface ViewController ()\n@property (nonatomic, strong) AppViewModel *appViewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.appViewModel = [[AppViewModel alloc] initWithController:self];\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 拥有 AppViewModel，AppViewModel 拥有 Controller、App 和 AppView，AppView 拥有 AppViewModel，Controller、App 和 AppView 不知道对方的存在。  \n\n数据：AppView 监听 AppViewModel 中的属性，在属性发生改变时，获取到 AppViewModel 中的属性的数据。  \n\n事件：AppViewModel 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## 三层结构\n![架构设计05](架构设计/架构设计05.png)\n\n## 四层结构\n![架构设计06](架构设计/架构设计06.png)\n\n# 设计模式\n\n设计模式（Design Pattern），是一套被反复使用、代码设计经验的总结。使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性。一般与编程语言无关，是一套比较成熟的编程思想。\n\n设计模式可以分为三大类：\n* 创建型模式：对象实例化的模式，用于解耦对象的实例化过程。单例模式、工厂方法模式，等等。\n* 结构型模式：把类或对象结合在一起形成一个更大的结构。代理模式、适配器模式、组合模式、装饰模式，等等。\n* 行为型模式：类或对象之间如何交互，及划分责任和算法。观察者模式、命令模式、责任链模式，等等。\n\n\n\n相关阅读：  \n[三层架构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/11031448?fr=aladdin)\n[三层结构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84/5091466?fr=aladdin)\n\n\n\n\n\n\n\n\n","source":"_posts/OC底层原理/架构设计.md","raw":"---\ntitle: 架构设计\ndate: 2020-09-02 15:02:50\ntags: OC底层原理\n---\n\n思考：  \n* 讲讲 MVC、MVVM、MVP，以及你在项目里具体是怎么写的？\n* 你自己用过哪些设计模式？\n* 一般开始做一个项目，你的架构是如何思考的？\n<!-- more -->\n\n# 架构\n架构（Architecture），软件开发中的设计方案。类与类之间的关系、模块与模块之间的关系、客户端与服务端的关系。\n\n经常听到的架构名词：MVC、MVP、MVVM、VIPER、CDD、三层架构、四层架构......\n\n## MVC - Apple版\nModel-View-Controller\n![架构设计01](架构设计/架构设计01.png)\n优点：View、Model可以重复利用，可以独立使用；  \n缺点：Controller的代码过于臃肿；\n\nController 拥有 Model 和 View，并负责处理 Model 和 View 的逻辑。Model 和 View 不需要知道对方的存在。\n\n示例代码：\n![架构设计08](架构设计/架构设计08.png)\n\n![架构设计07](架构设计/架构设计07.png)\n\n拥有关系：在使用 MVC 设计模式里，TableView 是最经典的了。从示例代码可以看到，Controller 同时拥有 News 和 NewsCell，但是 News 和 NewsCell 互相不知道对方的存在。\n\n数据：Controller 成为 TableView 的代理，并在 `cellForRowAtIndexPath:` 方法里将 News 传递给了 NewsCell，在 NewsCell 内部处理数据。  \n\n事件：Controller 成为 TableView 的代理，并在 `didSelectRowAtIndexPath:` 方法里处理 NewCell 的点击事件。\n\n优点：因为 NewsCell 不需要 News，只需要在 `cellForRowAtIndexPath:` 方法里获取需要展示的数据，所以 Controller 里的 News 不是必要条件，也可以使用其它的 Model 跟当前的 Controller 和 NewsCell 组成 MVC 结构。比如新建 替换掉 News：\n![架构设计09](架构设计/架构设计09.png)\n\n![架构设计11](架构设计/架构设计11.png)\n\n缺点：因为 Controller 要负责将 Model 里的数据传递给 View 用于展示，所以在 View 比较多的情况下，Controller 就会变得臃肿。在实际开发中同一个 TableView 往往会有多种 Cell，或者 Cell 的功能非常复杂，需要处理的数据和逻辑很多，所以一般不会在 Controller 里处理 Cell 数据相关的逻辑，就衍生出了下面这种设计模式👇。\n\n## MVC – 变种\nModel-View-Controller\n![架构设计02](架构设计/架构设计02.png)\n优点：对 Controller 进行瘦身，将 View 内部的细节封装起来了，外界不知道 View 内部的具体实现；\n缺点：View 依赖于 Model；\n\nController 拥有 Model 和 View。View 拥有 Model，在 View 内部处理 Model。\n\n### 示例代码一\n```\n// Model\n@interface News : NSObject\n@property (nonatomic, copy) NSString *title;\n@property (nonatomic, copy) NSString *content;\n@end\n\n@implementation News\n@end\n\n// View\n@interface NewsTableViewCell : UITableViewCell\n@property (nonatomic, strong) News *news;\n@end\n\n@implementation NewsTableViewCell\n- (void)setNews:(News *)news\n{\n    _news = news;\n    self.textLabel.text = _news.title;\n    self.detailTextLabel.text = _news.content;\n}\n@end\n\n// Controller\n@interface NewsTableViewController ()\n@property (nonatomic, strong) NSMutableArray *newsData;\n@end\n\n@implementation NewsTableViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadNews];\n}\n\n- (void)loadNews\n{\n    self.newsData = [NSMutableArray array];\n    for (int i = 0; i < 20; i++) {\n        News *news = [[News alloc] init];\n        news.title = [NSString stringWithFormat:@\"标题%d\", i];\n        news.content = [NSString stringWithFormat:@\"内容%d\", i];\n        [self.newsData addObject:news];\n    }\n}\n\n#pragma mark - Table view data source\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.newsData.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    NewsTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"NewsTableViewCell\"];\n    if (!cell) {\n        cell = [[NewsTableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@\"NewsTableViewCell\"];\n    }\n    News *news = self.newsData[indexPath.row];\n    cell.news = news;\n    return cell;\n}\n\n#pragma mark - Table view delegate\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    NSLog(@\"点击标题%ld\", (long)indexPath.row);\n}\n@end\n```\n\n![架构设计07](架构设计/架构设计07.png)\n\n拥有关系：从示例代码可以看到，Controller 同时拥有 News 和 NewsCell，NewsCell 拥有 News。  \n\n数据：Controller 成为 TableView 的代理，并在 `cellForRowAtIndexPath:` 方法里将 News 传递给了 NewsCell，在 NewsCell 内部处理数据。  \n\n事件：Controller 成为 TableView 的代理，并在 `didSelectRowAtIndexPath:` 方法里处理 NewCell 的点击事件。\n\n### 示例代码二\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *image;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation App\n@end\n\n// View\n@class App, AppView;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n@property (nonatomic, strong) App *app;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        iconView.contentMode = UIViewContentModeScaleAspectFill;\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 30);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setApp:(App *)app\n{\n    _app = app;\n    self.iconView.image = [UIImage imageNamed:app.image];\n    self.nameLabel.text = app.name;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// Controller\n@interface ViewController ()<AppViewDelegate>\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 拥有View\n    AppView *appView = [[AppView alloc] init];\n    appView.frame = CGRectMake(100, 100, 100, 150);\n    appView.delegate = self;\n    [self.view addSubview:appView];\n    \n    // 拥有Model\n    App *app = [[App alloc] init];\n    app.name = @\"Boxfish\";\n    app.image = @\"Boxfish\";\n    \n    // 数据传递\n    appView.app = app;\n}\n\n#pragma mark - AppViewDelegate\n- (void)appViewDidClick:(AppView *)appView\n{\n    NSLog(@\"控制器监听到AppView的点击\");\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 同时拥有 App 和 AppView，AppView 拥有 App。  \n\n数据：Controller 将 App 传递给了 AppView 并在 AppView 内部处理数据。  \n\n事件：Controller 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## MVP\nModel-View-Presenter\n![架构设计03](架构设计/架构设计03.png)\n\nMVP 和 MVC 很像，他们的相同点是都要求 Model 和 View 不需要知道对方的存在。他们的区别在于：  \n在 MVC 中，Controller 拥有 Model 和 View，并负责处理 Model 和 View 的逻辑。  \n在 MVP 中，Controller 里的逻辑代码挪到了 Presenter 里，由 Presenter 负责处理 Model 和 View 的逻辑，Controller 不需要知道 Model 和 View 的存在。\n\n示例代码：\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *image;\n@end\n\n@implementation App\n@end\n\n// View\n@class AppView;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n- (void)setName:(NSString *)name andImage:(NSString *)image;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 30);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setName:(NSString *)name andImage:(NSString *)image\n{\n    _iconView.image = [UIImage imageNamed:image];\n    _nameLabel.text = name;\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// Presenter\n@interface AppPresenter : NSObject\n- (instancetype)initWithController:(UIViewController *)controller;\n@end\n\n@interface AppPresenter()<AppViewDelegate>\n@property (nonatomic, weak) UIViewController *controller;\n@end\n\n@implementation AppPresenter\n- (instancetype)initWithController:(UIViewController *)controller\n{\n    self = [super init];\n    if (self) {\n        self.controller = controller;\n        \n        AppView *appView = [[AppView alloc] init];\n        appView.frame = CGRectMake(100, 100, 100, 100);\n        appView.delegate = self;\n        [controller.view addSubview:appView];\n        \n        App *app = [[App alloc] init];\n        app.name = @\"Boxfish\";\n        app.image = @\"Boxfish\";\n        \n        [appView setName:app.name andImage:app.image];\n    }\n    return self;\n}\n\n#pragma mark - AppViewDelegate\n- (void)appViewDidClick:(AppView *)appView\n{\n    NSLog(@\"presenter 监听到了 appView 的点击\");\n}\n@end\n\n// Controller\n@interface ViewController ()\n@property (nonatomic, strong) AppPresenter *appPresenter;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n     \n    self.appPresenter = [[AppPresenter alloc] initWithController:self];\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 拥有 AppPresenter，AppPresenter 拥有 Controller、App 和 AppView，Controller、App 和 AppView 不知道对方的存在。  \n\n数据：AppPresenter 将 App 的数据传递给了 AppView。  \n\n事件：AppPresenter 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## MVVM\nModel-View-ViewModel\n![架构设计04](架构设计/架构设计04.png)\n\n👉 [KVOController](https://github.com/facebookarchive/KVOController)\n\n示例代码：\n![架构设计12](架构设计/架构设计12.png)\n```\n// Model\n@interface App : NSObject\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *image;\n@end\n\n@implementation App\n@end\n\n// AppView\n@class AppView,AppViewModel;\n@protocol AppViewDelegate <NSObject>\n@optional\n- (void)appViewDidClick:(AppView *)appView;\n@end\n\n@interface AppView : UIView\n@property (nonatomic, weak) AppViewModel *viewModel;\n@property (nonatomic, weak) id<AppViewDelegate> delegate;\n@end\n\n@interface AppView()\n@property (nonatomic, weak) UIImageView *iconView;\n@property (nonatomic, weak) UILabel *nameLabel;\n@end\n\n@implementation AppView\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        UIImageView *iconView = [[UIImageView alloc] init];\n        iconView.frame = CGRectMake(0, 0, 100, 100);\n        [self addSubview:iconView];\n        _iconView = iconView;\n        \n        UILabel *nameLabel = [[UILabel alloc] init];\n        nameLabel.frame = CGRectMake(0, 100, 100, 100);\n        nameLabel.textAlignment = NSTextAlignmentCenter;\n        [self addSubview:nameLabel];\n        _nameLabel = nameLabel;\n    }\n    return self;\n}\n\n- (void)setViewModel:(AppViewModel *)viewModel\n{\n    _viewModel = viewModel;\n    \n    /// MVVM设计模式的核心代码，这里使用了 FaceBook 的开源项目 KVOController\n    __weak typeof(self) weakSelf = self;\n    [self.KVOController observe:viewModel keyPath:@\"name\" options:NSKeyValueObservingOptionNew block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n        weakSelf.nameLabel.text = change[NSKeyValueChangeNewKey];\n    }];\n    \n    [self.KVOController observe:viewModel keyPath:@\"image\" options:NSKeyValueObservingOptionNew block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n        weakSelf.iconView.image = [UIImage imageNamed:change[NSKeyValueChangeNewKey]];\n    }];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    if ([self.delegate respondsToSelector:@selector(appViewDidClick:)]) {\n        [self.delegate appViewDidClick:self];\n    }\n}\n@end\n\n// ViewModel\n@interface AppViewModel : NSObject\n- (instancetype)initWithController:(UIViewController *)controller;\n@end\n\n@interface AppViewModel() <AppViewDelegate>\n@property (nonatomic, weak) UIViewController *controller;\n@property (nonatomic, weak) NSString *name;\n@property (nonatomic, weak) NSString *image;\n@end\n\n@implementation AppViewModel\n- (instancetype)initWithController:(UIViewController *)controller\n{\n    self = [super init];\n    if (self) {\n        self.controller = controller;\n        \n        /// 拥有View\n        AppView *appView = [[AppView alloc] init];\n        appView.frame = CGRectMake(100, 100, 100, 100);\n        appView.delegate = self;\n        appView.viewModel = self;\n        [controller.view addSubview:appView];\n        \n        /// 拥有Model\n        App *app = [[App alloc] init];\n        app.name = @\"Boxfish\";\n        app.image = @\"Boxfish\";\n        \n        /// 处理逻辑\n        self.name = app.name;\n        self.image = app.image;\n    }\n    return self;\n}\n@end\n\n// View（在MVVM中，Controller被看做View）\n@interface ViewController ()\n@property (nonatomic, strong) AppViewModel *appViewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.appViewModel = [[AppViewModel alloc] initWithController:self];\n}\n@end\n```\n\n![架构设计10](架构设计/架构设计10.png)\n\n拥有关系：从示例代码可以看到，Controller 拥有 AppViewModel，AppViewModel 拥有 Controller、App 和 AppView，AppView 拥有 AppViewModel，Controller、App 和 AppView 不知道对方的存在。  \n\n数据：AppView 监听 AppViewModel 中的属性，在属性发生改变时，获取到 AppViewModel 中的属性的数据。  \n\n事件：AppViewModel 成为 AppView 的代理，并在代理方法 `appViewDidClick:` 里 AppView 的点击事件。\n\n## 三层结构\n![架构设计05](架构设计/架构设计05.png)\n\n## 四层结构\n![架构设计06](架构设计/架构设计06.png)\n\n# 设计模式\n\n设计模式（Design Pattern），是一套被反复使用、代码设计经验的总结。使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性。一般与编程语言无关，是一套比较成熟的编程思想。\n\n设计模式可以分为三大类：\n* 创建型模式：对象实例化的模式，用于解耦对象的实例化过程。单例模式、工厂方法模式，等等。\n* 结构型模式：把类或对象结合在一起形成一个更大的结构。代理模式、适配器模式、组合模式、装饰模式，等等。\n* 行为型模式：类或对象之间如何交互，及划分责任和算法。观察者模式、命令模式、责任链模式，等等。\n\n\n\n相关阅读：  \n[三层架构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/11031448?fr=aladdin)\n[三层结构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84/5091466?fr=aladdin)\n\n\n\n\n\n\n\n\n","slug":"OC底层原理/架构设计","published":1,"updated":"2023-08-22T09:52:14.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgsz000zaq7kcu22re62"},{"title":"性能优化","date":"2020-08-31T03:37:02.000Z","_content":"\n思考：\n* 你在项目中是怎么优化内存的？\n* 优化你是从哪几方面着手？\n* 列表卡顿的原因可能有哪些？你平时是怎么优化的？\n* 遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？\n<!-- more -->\n\n# 卡顿\n\n## CPU和GPU\n在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n* CPU（Central Processing Unit，中央处理器）  \n  对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）\n\n* GPU（Graphics Processing Unit，图形处理器）  \n  纹理的渲染\n\n在iOS中是双缓冲机制，有前帧缓存、后帧缓存。\n![性能优化01](性能优化/性能优化01.png)\n\n## 屏幕成像原理\n显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，显示器，都有2种同步参数——水平同步和垂直同步。\n\n水平同步脉冲（Horizontal synchronization pulse, Hsync）加在两个扫描行之间。它是一个短小的脉冲，在一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时它也指示着下一行将要开始。 水平同步脉冲出现后，会有一小段叫horizontal back porch的时间，这段时间里的像素信号是不会被显示出来，过了这一小段时间之后，电子枪就开始扫描新的一行，将要显示的内容扫描到显示器上。\n\n垂直同步脉冲（Vertical synchronization, Vsync）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲，可能持续一行或几行的扫描时间，但在这段时间内，没有像素信号出现。\n![性能优化02](性能优化/性能优化02.png)\n\n## 卡顿产生的原因\n红色箭头表示CPU处理过程，蓝色箭头表示GPU处理过程，箭头的长短代表处理时间的长短。按照60FPS的刷帧率，每隔 16ms 就会有一次 VSync 信号：\n![性能优化03](性能优化/性能优化03.png)\n\n在图像渲染的过程中主要有三种情况（图中从左至右）：  \n第一种情况：CPU和GPU处理完成后，正好有一次 VSync 信号，将刚刚处理好的帧数据渲染到屏幕上；  \n第二种情况：CPU和GPU处理完成后，因为用时较短，VSync 信号过了一会才到，将刚刚处理好的帧数据渲染到屏幕上； \n第三种情况：CPU和GPU处理完成后，因为用时较长错过了一次 VSync 信号，这条被错过的 VSync 信号只能将之前处理好的帧数据再次渲染到屏幕上，而这一次处理好的帧数据就要等下一次 VSync 信号才能渲染到屏幕上；\n\n第三种情况就是卡顿产生的原因。分析第三种情况可以看出，卡顿产生的主要原因是CPU、GPU处理时间的长短，那么解决卡顿的主要思路就是尽可能减少CPU、GPU资源消耗。\n\n## 卡顿优化\n\n### CPU\n* 尽量用轻量级的对象\n  比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView；\n  基本数据类型能用 int 的就不要用 NSNumber；\n\n* 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改；\n* 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性；\n* Autolayout 会比直接设置 frame 消耗更多的 CPU 资源；\n* 图片的 size 最好刚好跟 UIImageView 的 size 保持一致；（避免CPU对不同size的图片进行伸缩计算）\n* 控制一下线程的最大并发数量；\n* 尽量把耗时的操作放到子线程，如：文本处理（尺寸计算、绘制）、图片处理（解码、绘制）；\n\n子线程绘制图片：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImageView *imageView = [[UIImageView alloc] init];\n    imageView.frame = CGRectMake(50, 100, 300, 300);\n    [self initImageWithName:@\"test\" completion:^(UIImage *image) {\n        imageView.image = image;\n    }];\n    [self.view addSubview:imageView];\n}\n\n- (void)initImageWithName:(NSString *)imageName completion:(void(^)(UIImage *image))completion\n{\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        // 获取网络图片\n        // CGImageRef cgImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:@\"imageUrlString\"]]].CGImage;\n        // 获取CGImage\n        CGImageRef cgImage = [UIImage imageNamed:imageName].CGImage;\n\n        // alphaInfo\n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask;\n        BOOL hasAlpha = NO;\n        if (alphaInfo == kCGImageAlphaPremultipliedLast ||\n            alphaInfo == kCGImageAlphaPremultipliedFirst ||\n            alphaInfo == kCGImageAlphaLast ||\n            alphaInfo == kCGImageAlphaFirst) {\n            hasAlpha = YES;\n        }\n\n        // bitmapInfo\n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n\n        // size\n        size_t width = CGImageGetWidth(cgImage);\n        size_t height = CGImageGetHeight(cgImage);\n\n        // context\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n\n        // draw\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);\n\n        // get CGImage\n        cgImage = CGBitmapContextCreateImage(context);\n\n        // into UIImage\n        UIImage *newImage = [UIImage imageWithCGImage:cgImage];\n\n        // release\n        CGContextRelease(context);\n        CGImageRelease(cgImage);\n\n        // back to the main thread\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(newImage);\n            }\n        });\n    });\n}\n@end\n```\n\n![性能优化07](性能优化/性能优化07.png)\n\n### GPU\n* 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示；\n* GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸；\n* 尽量减少视图数量和层次；\n* 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES；\n* 尽量避免出现离屏渲染；\n\n### 离屏渲染\n\n* 在 OpenGL 中，GPU 有2种渲染方式  \n  On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作；  \n  Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作；\n\n* 离屏渲染消耗性能的原因  \n  1.需要创建新的缓冲区；  \n  2.离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕；\n\n* 哪些操作会触发离屏渲染？  \n  1.光栅化，`layer.shouldRasterize = YES`；  \n  2.遮罩，`layer.mask`；  \n  3.圆角，同时设置 `layer.masksToBounds = YES`、`layer.cornerRadius` 大于0；（考虑通过 CoreGraphics 绘制裁剪圆角，或者叫美工提供圆角图片）  \n  4.阴影，`layer.shadowXXX`；（如果设置了 `layer.shadowPath` 就不会产生离屏渲染）\n\n添加圆角：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImageView *imageView = [[UIImageView alloc] init];\n    imageView.frame = CGRectMake(50, 100, 300, 300);\n    [self initImageWithName:@\"test\" completion:^(UIImage *image) {\n        imageView.image = image;\n        [self setCornerRadius:150 forImageView:imageView];\n    }];\n//    [self addShadowForImageView:imageView];\n    [self.view addSubview:imageView];\n}\n\n/**\n使用 CAShapeLayer 与 UIBezierPath 配合画圆角\n*/\n- (void)addCornerRadius:(CGFloat)radius forImageView:(UIImageView *)imageView\n{\n    // 开启图片上下文\n    // UIGraphicsBeginImageContext(imageView.bounds.size);\n    // 一般使用下面的方法\n    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0);\n    // 绘制贝塞尔曲线\n    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:100];\n    // 按绘制的贝塞尔曲线剪切\n    [bezierPath addClip];\n    // 画图\n    [imageView drawRect:imageView.bounds];\n    // 获取上下文中的图片\n    imageView.image = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭图片上下文\n    UIGraphicsEndImageContext();\n}\n\n/**\n使用 Core Graphics 画圆角\n*/\n- (void)setCornerRadius:(CGFloat)radius forImageView:(UIImageView *)imageView\n{\n    // NO代表透明\n    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0.0);\n    // 获得上下文\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 添加一个圆\n    CGRect rect = CGRectMake(0, 0, imageView.bounds.size.width, imageView.bounds.size.height);\n    CGContextAddEllipseInRect(context, rect);\n    // 裁剪\n    CGContextClip(context);\n    // 将图片画上去\n    [imageView.image drawInRect:rect];\n    imageView.image = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭上下文\n    UIGraphicsEndImageContext();\n}\n```\n\n![性能优化08](性能优化/性能优化08.png)\n\n## 卡顿检测\n平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作，可以添加 Observer 到主线程 RunLoop 中，通过监听 RunLoop 状态切换的耗时，以达到监控卡顿的目的。\n\n![性能优化09](性能优化/性能优化09.png)\n\nNSRunLoop 调用方法主要就是在 06 ~> 05 的循环，如果这段时间内耗时太长，就说明这段时间主线程出现卡顿。\n\n### LXDAppFluecyMonitor\n使用 [LXDAppFluecyMonitor](https://github.com/UIControl/LXDAppFluecyMonitor) 监测卡顿：\n```\n@interface ViewController ()<UITableViewDelegate, UITableViewDataSource>\n@property (weak, nonatomic) IBOutlet UITableView *tableView;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [[LXDAppFluecyMonitor sharedMonitor] startMonitoring];\n    [self.tableView registerClass: [UITableViewCell class] forCellReuseIdentifier: @\"cell\"];\n}\n\n#pragma mark - UITableViewDataSource\n- (NSInteger)tableView: (UITableView *)tableView numberOfRowsInSection: (NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: @\"cell\"];\n    cell.textLabel.text = [NSString stringWithFormat: @\"%lu\", indexPath.row];\n    if (indexPath.row > 0 && indexPath.row % 30 == 0) {\n        usleep(2000000);\n    }\n    return cell;\n}\n@end\n```\n\n打印结果：\n```\n\n2020-09-01 18:26:51.657686+0800 LXDAppFluecyMonitor[17096:323364] Backtrace of Thread 771:\n======================================================================================\nlibsystem_kernel.dylib         0x7fff52208756 __semwait_signal + 10\nlibsystem_c.dylib              0x7fff52198510 usleep + 53\nLXDAppFluecyMonitor            0x10876d58f -[ViewController tableView:cellForRowAtIndexPath:] + 351\nUIKitCore                      0x7fff4953de96 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 867\nUIKitCore                      0x7fff49507522 -[UITableView _updateVisibleCellsNow:] + 3010\nUIKitCore                      0x7fff4952724e -[UITableView layoutSubviews] + 194\nUIKitCore                      0x7fff4982d5f4 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 2478\nQuartzCore                     0x7fff2b4e9260 -[CALayer layoutSublayers] + 255\nQuartzCore                     0x7fff2b4ef3eb _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 523\nQuartzCore                     0x7fff2b4faa8a _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 80\nQuartzCore                     0x7fff2b443a7c _ZN2CA7Context18commit_transactionEPNS_11TransactionEd + 324\nQuartzCore                     0x7fff2b477467 _ZN2CA11Transaction6commitEv + 649\nQuartzCore                     0x7fff2b3a4305 _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 921\nQuartzCore                     0x7fff2b47b768 _ZL22display_timer_callbackP12__CFMachPortPvlS1_ + 299\nCoreFoundation                 0x7fff23d627dd __CFMachPortPerform + 157\nCoreFoundation                 0x7fff23da2449 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 41\nCoreFoundation                 0x7fff23da1a48 __CFRunLoopDoSource1 + 472\nCoreFoundation                 0x7fff23d9c474 __CFRunLoopRun + 2228\nCoreFoundation                 0x7fff23d9b8a4 CFRunLoopRunSpecific + 404\nGraphicsServices               0x7fff38c39bbe GSEventRunModal + 139\nUIKitCore                      0x7fff49325968 UIApplicationMain + 1605\nLXDAppFluecyMonitor            0x10876ea40 main + 112\nlibdyld.dylib                  0x7fff520ce1fd start + 1\n\n======================================================================================\n```\n\n`LXDAppFluecyMonitor` 的核心代码：\n```\nstatic void lxdRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n    SHAREDMONITOR.currentActivity = activity;\n    dispatch_semaphore_signal(SHAREDMONITOR.semphore); // semphore加1\n};\n\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    // 注册RunLoop状态观察\n    CFRunLoopObserverContext context = {\n        0,\n        (__bridge void *)self,\n        NULL,\n        NULL\n    };\n    /** 创建RunLoop observer对象\n     分配内存\n     设置要关注的事件\n     标识在第一次进入run loop时执行还是每次进入run loop处理时均执行\n     设置优先级\n     设置回调函数\n     设置运行环境\n     */\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &lxdRunLoopObserverCallback, &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    dispatch_async(lxd_event_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            // kCFRunLoopBeforeWaiting - 即将进入休眠\n            if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO;\n                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); // eventSemphore加1\n                });\n                [NSThread sleepForTimeInterval: lxd_time_out_interval]; // 当前线程睡1s\n                if (timeOut) { // 1s后主线程还没有将timeOut修改为NO，默认主线程阻塞\n                    [LXDBacktraceLogger lxd_logMain]; // 打印日志\n                }\n                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); // eventSemphore减1\n            }\n        }\n    });\n    \n    dispatch_async(lxd_fluecy_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            // semphore减1（等待200s，semphore == 0 或者“超时”会继续向下执行）\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); \n            if (waitTime != LXD_SEMPHORE_SUCCESS) {\n                // 信号量超时了（runloop 的状态长时间没有发生变更,长期处于某一个状态下）\n                if (!SHAREDMONITOR.observer) { // 异常处理\n                    SHAREDMONITOR.timeOut = 0;\n                    [SHAREDMONITOR stopMonitoring];\n                    continue;\n                }\n                // kCFRunLoopBeforeSources - 即将处理source\n                // kCFRunLoopAfterWaiting - 刚从休眠中唤醒\n                if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++SHAREDMONITOR.timeOut < 5) {\n                        continue; // timeOut标记信号量超时次数，不足5次则停止当次循环开启下一次循环\n                    }\n                    [LXDBacktraceLogger lxd_logMain]; // 打印日志\n                    [NSThread sleepForTimeInterval: lxd_restore_interval]; // 当前线程睡1s\n                }\n            }\n            SHAREDMONITOR.timeOut = 0; // 将 timeOut 置为0\n        }\n    });\n}\n\n- (void)stopMonitoring {\n    if (!_isMonitoring) { return; }\n    _isMonitoring = NO;\n    \n    CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    CFRelease(_observer);\n    _observer = nil;\n}\n```\n\n# 耗电\n\n## 耗电的主要来源\n![性能优化04](性能优化/性能优化04.png)\n* CPU处理，Processing\n* 网络，Networking\n* 定位，Location\n* 图像，Graphics\n\n## 耗电优化\n尽可能降低CPU、GPU功耗：\n* 少用定时器\n\n* 优化I/O操作  \n  1.尽量不要频繁写入小数据，最好批量一次性写入；  \n  2.读写大量重要数据时，考虑用 `dispatch_io`，其提供了基于GCD的异步操作文件 `I/O` 的API。用 `dispatch_io` 系统会优化磁盘访问；  \n  3.数据量比较大的，建议使用数据库（比如SQLite、CoreData）；\n\n* 网络优化  \n  1.减少、压缩网络数据；  \n  2.如果多次请求的结果是相同的，尽量使用缓存；  \n  3.使用断点续传，否则网络不稳定时可能多次传输相同的内容；  \n  4.网络不可用时，不要尝试执行网络请求；  \n  5.让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间；  \n  6.批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载；\n\n* 定位优化  \n  1.如果只是需要快速确定用户位置，最好用 `CLLocationManager` 的 `requestLocation` 方法。定位完成后，会自动让定位硬件断电；  \n  2.如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务；  \n  3.尽量降低定位精度，比如尽量不要使用精度最高的 `kCLLocationAccuracyBest`；  \n  4.需要后台定位时，尽量设置 `pausesLocationUpdatesAutomatically` 为YES，如果用户不太可能移动的时候系统会自动暂停位置更新；  \n  5.尽量不要使用 `startMonitoringSignificantLocationChanges`，优先考虑 `startMonitoringForRegion:`；\n\n* 硬件检测优化\n  1.用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件；\n\n# 启动\n\n## APP的启动\n* APP的启动可以分为2种\n  冷启动（Cold Launch）：从零开始启动APP；\n  热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP；\n\n* APP启动时间的优化，主要是针对冷启动进行优化\n\n* 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -> Run -> Arguments）  \n  1.`DYLD_PRINT_STATISTICS` 设置为1；\n  ```\n  Total pre-main time:  59.28 milliseconds (100.0%)\n         dylib loading time:  52.30 milliseconds (88.2%)\n        rebase/binding time: 126687488.9 seconds (190140774.5%)\n            ObjC setup time:   7.95 milliseconds (13.4%)\n           initializer time:  34.35 milliseconds (57.9%)\n           slowest intializers :\n             libSystem.B.dylib :   2.69 milliseconds (4.5%)\n   libBacktraceRecording.dylib :   5.37 milliseconds (9.0%)\n    libMainThreadChecker.dylib :  23.06 milliseconds (38.8%)\n  ```\n\n  2.如果需要更详细的信息，那就将 `DYLD_PRINT_STATISTICS_DETAILS` 设置为1；\n  ```\n  total time: 433.28 milliseconds (100.0%)\n  total images loaded:  318 (311 from dyld shared cache)\n  total segments mapped: 21, into 385 pages\n  total images loading time: 299.19 milliseconds (69.0%)\n  total load time in ObjC:   9.88 milliseconds (2.2%)\n  total debugger pause time: 145.67 milliseconds (33.6%)\n  total dtrace DOF registration time:   0.14 milliseconds (0.0%)\n  total rebase fixups:  18,196\n  total rebase fixups time:   0.32 milliseconds (0.0%)\n  total binding fixups: 436,908\n  total binding fixups time:  86.76 milliseconds (20.0%)\n  total weak binding fixups time:   0.01 milliseconds (0.0%)\n  total redo shared cached bindings time: 130.32 milliseconds (30.0%)\n  total bindings lazily fixed up: 0 of 0\n  total time in initializers and ObjC +load:  36.94 milliseconds (8.5%)\n                         libSystem.B.dylib :   2.94 milliseconds (0.6%)\n               libBacktraceRecording.dylib :   6.00 milliseconds (1.3%)\n                           libobjc.A.dylib :   0.86 milliseconds (0.1%)\n                            CoreFoundation :   0.86 milliseconds (0.2%)\n                libMainThreadChecker.dylib :  24.27 milliseconds (5.6%)\n  total symbol trie searches:    1056780\n  total symbol table binary searches:    0\n  total images defining weak symbols:  32\n  total images using weak symbols:  84\n  ```\n\n* APP的冷启动可以概括为3大阶段：dyld、runtime 和 main\n\n![性能优化05](性能优化/性能优化05.png)\n\n### dyld\ndyld（dynamic link editor），Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）。启动APP时，dyld 所做的事情有：  \n1.装载APP的可执行文件，同时会递归加载所有依赖的动态库； \n2.当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理；\n![性能优化10](性能优化/性能优化10.png)\n显示包内容：\n![性能优化11](性能优化/性能优化11.png)\n\n### runtime\n启动APP时，runtime 所做的事情有：\n1.调用 `map_images` 进行可执行文件内容的解析和处理；\n2.在 `load_images` 中调用 `call_load_methods`，调用所有 Class 和 Category 的 `+load` 方法；  \n3.进行各种objc结构的初始化（注册Objc类 、初始化类对象等等）；  \n4.调用C++静态初始化器和 `__attribute__((constructor))` 修饰的函数；(被 `__attribute__((constructor))` 修饰的函数在程序启动时，系统会自动调用该函数)\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    environ_init();\n    tls_init();\n    static_init();\n    runtime_init();\n    exception_init();\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    // 调用 map_images 和 load_images\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image);\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n上面就是 APP 启动时 dyld 和 runtime 全部的处理内容了，到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理。\n\n### main\n1.APP 的启动由 dyld 主导，将可执行文件加载到内存，顺便加载所有依赖的动态库；\n2.并由 runtime 负责加载成 objc 定义的结构；\n3.所有初始化工作结束后，dyld 就会调用 main 函数；\n4.接下来就是 UIApplicationMain 函数，AppDelegate 的 `application:didFinishLaunchingWithOptions:` 方法；\n\n## APP的启动优化\n按照不同的阶段\n* dyld\n  1.减少动态库、合并一些动态库（定期清理不必要的动态库）；\n  2.减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）；\n  3.减少C++虚函数数量；\n  4.Swift尽量使用struct；\n\n* runtime\n  1.用 `+initialize` 方法和 `dispatch_once` 取代所有的 `__attribute__((constructor))`、C++静态构造器、ObjC的 `+load`；\n\n* main  \n  1.在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在 `application:didFinishLaunchingWithOptions:` 方法中；\n  2.按需加载\n\n# 安装包瘦身\n\n安装包（IPA）主要由可执行文件、资源组成：\n\n## 资源\n资源：图片、音频、视频等。\n\n1.采取无损压缩；  \n2.去除没有用到的资源，工具 [LSUnusedResources](https://github.com/tinymind/LSUnusedResources)；\n\n## 可执行文件瘦身\n* 编译器优化：  \n  1.Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES；  \n  2.去掉异常支持，`Enable C++ Exceptions`、`Enable Objective-C Exceptions` 设置为NO， `Other C Flags` 添加 `-fno-exceptions`；\n* 利用 [AppCode](https://www.jetbrains.com/objc/) 检测未使用的代码：菜单栏 -> Code -> Inspect Code；\n* 编写 LLVM 插件检测出重复代码、未被调用的代码；\n* 生成 LinkMap 文件，可以查看可执行文件的具体组成\n![性能优化06](性能优化/性能优化06.png)\n可借助第三方工具解析LinkMap文件，工具 [LinkMap](https://github.com/huanxsd/LinkMap)\n![性能优化12](性能优化/性能优化12.png)\n\n# 相关阅读  \n[手机GPU](https://baike.baidu.com/item/%E6%89%8B%E6%9C%BAGPU/4688178?fr=aladdin)\n[图形处理器](https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8/8694767?fromtitle=gpu&fromid=105524&fr=aladdin)\n[iOS应用千万级架构：性能优化与卡顿监控](https://www.cnblogs.com/jys509/p/13296128.html)\n[CPU和GPU的设计区别](https://www.cnblogs.com/biglucky/p/4223565.html)\n[iOS 图像渲染原理](http://chuquan.me/2018/09/25/ios-graphics-render-principle/)\n[Matrix-iOS 卡顿监控](https://cloud.tencent.com/developer/article/1427933)\n\n\n","source":"_posts/OC底层原理/性能优化.md","raw":"---\ntitle: 性能优化\ndate: 2020-08-31 11:37:02\ntags: OC底层原理\n---\n\n思考：\n* 你在项目中是怎么优化内存的？\n* 优化你是从哪几方面着手？\n* 列表卡顿的原因可能有哪些？你平时是怎么优化的？\n* 遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？\n<!-- more -->\n\n# 卡顿\n\n## CPU和GPU\n在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n* CPU（Central Processing Unit，中央处理器）  \n  对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）\n\n* GPU（Graphics Processing Unit，图形处理器）  \n  纹理的渲染\n\n在iOS中是双缓冲机制，有前帧缓存、后帧缓存。\n![性能优化01](性能优化/性能优化01.png)\n\n## 屏幕成像原理\n显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，显示器，都有2种同步参数——水平同步和垂直同步。\n\n水平同步脉冲（Horizontal synchronization pulse, Hsync）加在两个扫描行之间。它是一个短小的脉冲，在一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时它也指示着下一行将要开始。 水平同步脉冲出现后，会有一小段叫horizontal back porch的时间，这段时间里的像素信号是不会被显示出来，过了这一小段时间之后，电子枪就开始扫描新的一行，将要显示的内容扫描到显示器上。\n\n垂直同步脉冲（Vertical synchronization, Vsync）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲，可能持续一行或几行的扫描时间，但在这段时间内，没有像素信号出现。\n![性能优化02](性能优化/性能优化02.png)\n\n## 卡顿产生的原因\n红色箭头表示CPU处理过程，蓝色箭头表示GPU处理过程，箭头的长短代表处理时间的长短。按照60FPS的刷帧率，每隔 16ms 就会有一次 VSync 信号：\n![性能优化03](性能优化/性能优化03.png)\n\n在图像渲染的过程中主要有三种情况（图中从左至右）：  \n第一种情况：CPU和GPU处理完成后，正好有一次 VSync 信号，将刚刚处理好的帧数据渲染到屏幕上；  \n第二种情况：CPU和GPU处理完成后，因为用时较短，VSync 信号过了一会才到，将刚刚处理好的帧数据渲染到屏幕上； \n第三种情况：CPU和GPU处理完成后，因为用时较长错过了一次 VSync 信号，这条被错过的 VSync 信号只能将之前处理好的帧数据再次渲染到屏幕上，而这一次处理好的帧数据就要等下一次 VSync 信号才能渲染到屏幕上；\n\n第三种情况就是卡顿产生的原因。分析第三种情况可以看出，卡顿产生的主要原因是CPU、GPU处理时间的长短，那么解决卡顿的主要思路就是尽可能减少CPU、GPU资源消耗。\n\n## 卡顿优化\n\n### CPU\n* 尽量用轻量级的对象\n  比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView；\n  基本数据类型能用 int 的就不要用 NSNumber；\n\n* 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改；\n* 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性；\n* Autolayout 会比直接设置 frame 消耗更多的 CPU 资源；\n* 图片的 size 最好刚好跟 UIImageView 的 size 保持一致；（避免CPU对不同size的图片进行伸缩计算）\n* 控制一下线程的最大并发数量；\n* 尽量把耗时的操作放到子线程，如：文本处理（尺寸计算、绘制）、图片处理（解码、绘制）；\n\n子线程绘制图片：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImageView *imageView = [[UIImageView alloc] init];\n    imageView.frame = CGRectMake(50, 100, 300, 300);\n    [self initImageWithName:@\"test\" completion:^(UIImage *image) {\n        imageView.image = image;\n    }];\n    [self.view addSubview:imageView];\n}\n\n- (void)initImageWithName:(NSString *)imageName completion:(void(^)(UIImage *image))completion\n{\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        // 获取网络图片\n        // CGImageRef cgImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:@\"imageUrlString\"]]].CGImage;\n        // 获取CGImage\n        CGImageRef cgImage = [UIImage imageNamed:imageName].CGImage;\n\n        // alphaInfo\n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask;\n        BOOL hasAlpha = NO;\n        if (alphaInfo == kCGImageAlphaPremultipliedLast ||\n            alphaInfo == kCGImageAlphaPremultipliedFirst ||\n            alphaInfo == kCGImageAlphaLast ||\n            alphaInfo == kCGImageAlphaFirst) {\n            hasAlpha = YES;\n        }\n\n        // bitmapInfo\n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n\n        // size\n        size_t width = CGImageGetWidth(cgImage);\n        size_t height = CGImageGetHeight(cgImage);\n\n        // context\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n\n        // draw\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);\n\n        // get CGImage\n        cgImage = CGBitmapContextCreateImage(context);\n\n        // into UIImage\n        UIImage *newImage = [UIImage imageWithCGImage:cgImage];\n\n        // release\n        CGContextRelease(context);\n        CGImageRelease(cgImage);\n\n        // back to the main thread\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(newImage);\n            }\n        });\n    });\n}\n@end\n```\n\n![性能优化07](性能优化/性能优化07.png)\n\n### GPU\n* 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示；\n* GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸；\n* 尽量减少视图数量和层次；\n* 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES；\n* 尽量避免出现离屏渲染；\n\n### 离屏渲染\n\n* 在 OpenGL 中，GPU 有2种渲染方式  \n  On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作；  \n  Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作；\n\n* 离屏渲染消耗性能的原因  \n  1.需要创建新的缓冲区；  \n  2.离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕；\n\n* 哪些操作会触发离屏渲染？  \n  1.光栅化，`layer.shouldRasterize = YES`；  \n  2.遮罩，`layer.mask`；  \n  3.圆角，同时设置 `layer.masksToBounds = YES`、`layer.cornerRadius` 大于0；（考虑通过 CoreGraphics 绘制裁剪圆角，或者叫美工提供圆角图片）  \n  4.阴影，`layer.shadowXXX`；（如果设置了 `layer.shadowPath` 就不会产生离屏渲染）\n\n添加圆角：\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImageView *imageView = [[UIImageView alloc] init];\n    imageView.frame = CGRectMake(50, 100, 300, 300);\n    [self initImageWithName:@\"test\" completion:^(UIImage *image) {\n        imageView.image = image;\n        [self setCornerRadius:150 forImageView:imageView];\n    }];\n//    [self addShadowForImageView:imageView];\n    [self.view addSubview:imageView];\n}\n\n/**\n使用 CAShapeLayer 与 UIBezierPath 配合画圆角\n*/\n- (void)addCornerRadius:(CGFloat)radius forImageView:(UIImageView *)imageView\n{\n    // 开启图片上下文\n    // UIGraphicsBeginImageContext(imageView.bounds.size);\n    // 一般使用下面的方法\n    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0);\n    // 绘制贝塞尔曲线\n    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:100];\n    // 按绘制的贝塞尔曲线剪切\n    [bezierPath addClip];\n    // 画图\n    [imageView drawRect:imageView.bounds];\n    // 获取上下文中的图片\n    imageView.image = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭图片上下文\n    UIGraphicsEndImageContext();\n}\n\n/**\n使用 Core Graphics 画圆角\n*/\n- (void)setCornerRadius:(CGFloat)radius forImageView:(UIImageView *)imageView\n{\n    // NO代表透明\n    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0.0);\n    // 获得上下文\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 添加一个圆\n    CGRect rect = CGRectMake(0, 0, imageView.bounds.size.width, imageView.bounds.size.height);\n    CGContextAddEllipseInRect(context, rect);\n    // 裁剪\n    CGContextClip(context);\n    // 将图片画上去\n    [imageView.image drawInRect:rect];\n    imageView.image = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭上下文\n    UIGraphicsEndImageContext();\n}\n```\n\n![性能优化08](性能优化/性能优化08.png)\n\n## 卡顿检测\n平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作，可以添加 Observer 到主线程 RunLoop 中，通过监听 RunLoop 状态切换的耗时，以达到监控卡顿的目的。\n\n![性能优化09](性能优化/性能优化09.png)\n\nNSRunLoop 调用方法主要就是在 06 ~> 05 的循环，如果这段时间内耗时太长，就说明这段时间主线程出现卡顿。\n\n### LXDAppFluecyMonitor\n使用 [LXDAppFluecyMonitor](https://github.com/UIControl/LXDAppFluecyMonitor) 监测卡顿：\n```\n@interface ViewController ()<UITableViewDelegate, UITableViewDataSource>\n@property (weak, nonatomic) IBOutlet UITableView *tableView;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [[LXDAppFluecyMonitor sharedMonitor] startMonitoring];\n    [self.tableView registerClass: [UITableViewCell class] forCellReuseIdentifier: @\"cell\"];\n}\n\n#pragma mark - UITableViewDataSource\n- (NSInteger)tableView: (UITableView *)tableView numberOfRowsInSection: (NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: @\"cell\"];\n    cell.textLabel.text = [NSString stringWithFormat: @\"%lu\", indexPath.row];\n    if (indexPath.row > 0 && indexPath.row % 30 == 0) {\n        usleep(2000000);\n    }\n    return cell;\n}\n@end\n```\n\n打印结果：\n```\n\n2020-09-01 18:26:51.657686+0800 LXDAppFluecyMonitor[17096:323364] Backtrace of Thread 771:\n======================================================================================\nlibsystem_kernel.dylib         0x7fff52208756 __semwait_signal + 10\nlibsystem_c.dylib              0x7fff52198510 usleep + 53\nLXDAppFluecyMonitor            0x10876d58f -[ViewController tableView:cellForRowAtIndexPath:] + 351\nUIKitCore                      0x7fff4953de96 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 867\nUIKitCore                      0x7fff49507522 -[UITableView _updateVisibleCellsNow:] + 3010\nUIKitCore                      0x7fff4952724e -[UITableView layoutSubviews] + 194\nUIKitCore                      0x7fff4982d5f4 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 2478\nQuartzCore                     0x7fff2b4e9260 -[CALayer layoutSublayers] + 255\nQuartzCore                     0x7fff2b4ef3eb _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 523\nQuartzCore                     0x7fff2b4faa8a _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 80\nQuartzCore                     0x7fff2b443a7c _ZN2CA7Context18commit_transactionEPNS_11TransactionEd + 324\nQuartzCore                     0x7fff2b477467 _ZN2CA11Transaction6commitEv + 649\nQuartzCore                     0x7fff2b3a4305 _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 921\nQuartzCore                     0x7fff2b47b768 _ZL22display_timer_callbackP12__CFMachPortPvlS1_ + 299\nCoreFoundation                 0x7fff23d627dd __CFMachPortPerform + 157\nCoreFoundation                 0x7fff23da2449 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 41\nCoreFoundation                 0x7fff23da1a48 __CFRunLoopDoSource1 + 472\nCoreFoundation                 0x7fff23d9c474 __CFRunLoopRun + 2228\nCoreFoundation                 0x7fff23d9b8a4 CFRunLoopRunSpecific + 404\nGraphicsServices               0x7fff38c39bbe GSEventRunModal + 139\nUIKitCore                      0x7fff49325968 UIApplicationMain + 1605\nLXDAppFluecyMonitor            0x10876ea40 main + 112\nlibdyld.dylib                  0x7fff520ce1fd start + 1\n\n======================================================================================\n```\n\n`LXDAppFluecyMonitor` 的核心代码：\n```\nstatic void lxdRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n    SHAREDMONITOR.currentActivity = activity;\n    dispatch_semaphore_signal(SHAREDMONITOR.semphore); // semphore加1\n};\n\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    // 注册RunLoop状态观察\n    CFRunLoopObserverContext context = {\n        0,\n        (__bridge void *)self,\n        NULL,\n        NULL\n    };\n    /** 创建RunLoop observer对象\n     分配内存\n     设置要关注的事件\n     标识在第一次进入run loop时执行还是每次进入run loop处理时均执行\n     设置优先级\n     设置回调函数\n     设置运行环境\n     */\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &lxdRunLoopObserverCallback, &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    dispatch_async(lxd_event_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            // kCFRunLoopBeforeWaiting - 即将进入休眠\n            if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO;\n                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); // eventSemphore加1\n                });\n                [NSThread sleepForTimeInterval: lxd_time_out_interval]; // 当前线程睡1s\n                if (timeOut) { // 1s后主线程还没有将timeOut修改为NO，默认主线程阻塞\n                    [LXDBacktraceLogger lxd_logMain]; // 打印日志\n                }\n                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); // eventSemphore减1\n            }\n        }\n    });\n    \n    dispatch_async(lxd_fluecy_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            // semphore减1（等待200s，semphore == 0 或者“超时”会继续向下执行）\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); \n            if (waitTime != LXD_SEMPHORE_SUCCESS) {\n                // 信号量超时了（runloop 的状态长时间没有发生变更,长期处于某一个状态下）\n                if (!SHAREDMONITOR.observer) { // 异常处理\n                    SHAREDMONITOR.timeOut = 0;\n                    [SHAREDMONITOR stopMonitoring];\n                    continue;\n                }\n                // kCFRunLoopBeforeSources - 即将处理source\n                // kCFRunLoopAfterWaiting - 刚从休眠中唤醒\n                if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++SHAREDMONITOR.timeOut < 5) {\n                        continue; // timeOut标记信号量超时次数，不足5次则停止当次循环开启下一次循环\n                    }\n                    [LXDBacktraceLogger lxd_logMain]; // 打印日志\n                    [NSThread sleepForTimeInterval: lxd_restore_interval]; // 当前线程睡1s\n                }\n            }\n            SHAREDMONITOR.timeOut = 0; // 将 timeOut 置为0\n        }\n    });\n}\n\n- (void)stopMonitoring {\n    if (!_isMonitoring) { return; }\n    _isMonitoring = NO;\n    \n    CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    CFRelease(_observer);\n    _observer = nil;\n}\n```\n\n# 耗电\n\n## 耗电的主要来源\n![性能优化04](性能优化/性能优化04.png)\n* CPU处理，Processing\n* 网络，Networking\n* 定位，Location\n* 图像，Graphics\n\n## 耗电优化\n尽可能降低CPU、GPU功耗：\n* 少用定时器\n\n* 优化I/O操作  \n  1.尽量不要频繁写入小数据，最好批量一次性写入；  \n  2.读写大量重要数据时，考虑用 `dispatch_io`，其提供了基于GCD的异步操作文件 `I/O` 的API。用 `dispatch_io` 系统会优化磁盘访问；  \n  3.数据量比较大的，建议使用数据库（比如SQLite、CoreData）；\n\n* 网络优化  \n  1.减少、压缩网络数据；  \n  2.如果多次请求的结果是相同的，尽量使用缓存；  \n  3.使用断点续传，否则网络不稳定时可能多次传输相同的内容；  \n  4.网络不可用时，不要尝试执行网络请求；  \n  5.让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间；  \n  6.批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载；\n\n* 定位优化  \n  1.如果只是需要快速确定用户位置，最好用 `CLLocationManager` 的 `requestLocation` 方法。定位完成后，会自动让定位硬件断电；  \n  2.如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务；  \n  3.尽量降低定位精度，比如尽量不要使用精度最高的 `kCLLocationAccuracyBest`；  \n  4.需要后台定位时，尽量设置 `pausesLocationUpdatesAutomatically` 为YES，如果用户不太可能移动的时候系统会自动暂停位置更新；  \n  5.尽量不要使用 `startMonitoringSignificantLocationChanges`，优先考虑 `startMonitoringForRegion:`；\n\n* 硬件检测优化\n  1.用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件；\n\n# 启动\n\n## APP的启动\n* APP的启动可以分为2种\n  冷启动（Cold Launch）：从零开始启动APP；\n  热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP；\n\n* APP启动时间的优化，主要是针对冷启动进行优化\n\n* 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -> Run -> Arguments）  \n  1.`DYLD_PRINT_STATISTICS` 设置为1；\n  ```\n  Total pre-main time:  59.28 milliseconds (100.0%)\n         dylib loading time:  52.30 milliseconds (88.2%)\n        rebase/binding time: 126687488.9 seconds (190140774.5%)\n            ObjC setup time:   7.95 milliseconds (13.4%)\n           initializer time:  34.35 milliseconds (57.9%)\n           slowest intializers :\n             libSystem.B.dylib :   2.69 milliseconds (4.5%)\n   libBacktraceRecording.dylib :   5.37 milliseconds (9.0%)\n    libMainThreadChecker.dylib :  23.06 milliseconds (38.8%)\n  ```\n\n  2.如果需要更详细的信息，那就将 `DYLD_PRINT_STATISTICS_DETAILS` 设置为1；\n  ```\n  total time: 433.28 milliseconds (100.0%)\n  total images loaded:  318 (311 from dyld shared cache)\n  total segments mapped: 21, into 385 pages\n  total images loading time: 299.19 milliseconds (69.0%)\n  total load time in ObjC:   9.88 milliseconds (2.2%)\n  total debugger pause time: 145.67 milliseconds (33.6%)\n  total dtrace DOF registration time:   0.14 milliseconds (0.0%)\n  total rebase fixups:  18,196\n  total rebase fixups time:   0.32 milliseconds (0.0%)\n  total binding fixups: 436,908\n  total binding fixups time:  86.76 milliseconds (20.0%)\n  total weak binding fixups time:   0.01 milliseconds (0.0%)\n  total redo shared cached bindings time: 130.32 milliseconds (30.0%)\n  total bindings lazily fixed up: 0 of 0\n  total time in initializers and ObjC +load:  36.94 milliseconds (8.5%)\n                         libSystem.B.dylib :   2.94 milliseconds (0.6%)\n               libBacktraceRecording.dylib :   6.00 milliseconds (1.3%)\n                           libobjc.A.dylib :   0.86 milliseconds (0.1%)\n                            CoreFoundation :   0.86 milliseconds (0.2%)\n                libMainThreadChecker.dylib :  24.27 milliseconds (5.6%)\n  total symbol trie searches:    1056780\n  total symbol table binary searches:    0\n  total images defining weak symbols:  32\n  total images using weak symbols:  84\n  ```\n\n* APP的冷启动可以概括为3大阶段：dyld、runtime 和 main\n\n![性能优化05](性能优化/性能优化05.png)\n\n### dyld\ndyld（dynamic link editor），Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）。启动APP时，dyld 所做的事情有：  \n1.装载APP的可执行文件，同时会递归加载所有依赖的动态库； \n2.当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理；\n![性能优化10](性能优化/性能优化10.png)\n显示包内容：\n![性能优化11](性能优化/性能优化11.png)\n\n### runtime\n启动APP时，runtime 所做的事情有：\n1.调用 `map_images` 进行可执行文件内容的解析和处理；\n2.在 `load_images` 中调用 `call_load_methods`，调用所有 Class 和 Category 的 `+load` 方法；  \n3.进行各种objc结构的初始化（注册Objc类 、初始化类对象等等）；  \n4.调用C++静态初始化器和 `__attribute__((constructor))` 修饰的函数；(被 `__attribute__((constructor))` 修饰的函数在程序启动时，系统会自动调用该函数)\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    environ_init();\n    tls_init();\n    static_init();\n    runtime_init();\n    exception_init();\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    // 调用 map_images 和 load_images\n    _dyld_objc_notify_register(&map_images, load_images, unmap_image);\n\n#if __OBJC2__\n    didCallDyldNotifyRegister = true;\n#endif\n}\n```\n\n上面就是 APP 启动时 dyld 和 runtime 全部的处理内容了，到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理。\n\n### main\n1.APP 的启动由 dyld 主导，将可执行文件加载到内存，顺便加载所有依赖的动态库；\n2.并由 runtime 负责加载成 objc 定义的结构；\n3.所有初始化工作结束后，dyld 就会调用 main 函数；\n4.接下来就是 UIApplicationMain 函数，AppDelegate 的 `application:didFinishLaunchingWithOptions:` 方法；\n\n## APP的启动优化\n按照不同的阶段\n* dyld\n  1.减少动态库、合并一些动态库（定期清理不必要的动态库）；\n  2.减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）；\n  3.减少C++虚函数数量；\n  4.Swift尽量使用struct；\n\n* runtime\n  1.用 `+initialize` 方法和 `dispatch_once` 取代所有的 `__attribute__((constructor))`、C++静态构造器、ObjC的 `+load`；\n\n* main  \n  1.在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在 `application:didFinishLaunchingWithOptions:` 方法中；\n  2.按需加载\n\n# 安装包瘦身\n\n安装包（IPA）主要由可执行文件、资源组成：\n\n## 资源\n资源：图片、音频、视频等。\n\n1.采取无损压缩；  \n2.去除没有用到的资源，工具 [LSUnusedResources](https://github.com/tinymind/LSUnusedResources)；\n\n## 可执行文件瘦身\n* 编译器优化：  \n  1.Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES；  \n  2.去掉异常支持，`Enable C++ Exceptions`、`Enable Objective-C Exceptions` 设置为NO， `Other C Flags` 添加 `-fno-exceptions`；\n* 利用 [AppCode](https://www.jetbrains.com/objc/) 检测未使用的代码：菜单栏 -> Code -> Inspect Code；\n* 编写 LLVM 插件检测出重复代码、未被调用的代码；\n* 生成 LinkMap 文件，可以查看可执行文件的具体组成\n![性能优化06](性能优化/性能优化06.png)\n可借助第三方工具解析LinkMap文件，工具 [LinkMap](https://github.com/huanxsd/LinkMap)\n![性能优化12](性能优化/性能优化12.png)\n\n# 相关阅读  \n[手机GPU](https://baike.baidu.com/item/%E6%89%8B%E6%9C%BAGPU/4688178?fr=aladdin)\n[图形处理器](https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8/8694767?fromtitle=gpu&fromid=105524&fr=aladdin)\n[iOS应用千万级架构：性能优化与卡顿监控](https://www.cnblogs.com/jys509/p/13296128.html)\n[CPU和GPU的设计区别](https://www.cnblogs.com/biglucky/p/4223565.html)\n[iOS 图像渲染原理](http://chuquan.me/2018/09/25/ios-graphics-render-principle/)\n[Matrix-iOS 卡顿监控](https://cloud.tencent.com/developer/article/1427933)\n\n\n","slug":"OC底层原理/性能优化","published":1,"updated":"2023-08-22T09:52:14.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgt30011aq7k17iusbax"},{"title":"Hexo安装笔记","date":"2018-08-08T08:27:04.000Z","_content":"\n## Hexo-NEXT常用操作命令\n\n### 部署命令行\n\n```js\nhexo clean && hexo g && hexo d\n```\n\n### 写作\n\n```js\nhexo new “title”\n```\n\n### 标签\n\n```js\n---\ntitle: 多线程 — GCD\ndate: 2016-06-14 \ntags: OC //标签\n---\n```\n\n### 文章内添加图片\n\n1. 把图片放到  source/_posts/自定义文件夹/image.png\n2. 文章中插入图片\n\n```js\n![image](自定义文件夹/image.png)\n```\n\n### 设置头像\n\n1. 把图片放入 themes/next/source/images\n2. 修改头像\n\n```js\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.jpg\n# in site  directory(source/uploads): /uploads/avatar.jpg\navatar: http://example.com/avatar.png\n```\n\n## 本地头像\n\n```js\navatar: /images/avatar.gif\n```\n\nPs：图片格式我用.jpeg时加载不出了，改成.gif可以正常显示\n\n## Hexo 安装手记\n\n* 2018/08/08\n\n### 一、安装 Node.js\n\n[下载Node.js](https://nodejs.org)\n\n### 二、安装HEXO\n\n执行命令行，报错\n\n```js\nnpm install -g hexo-cli\n```\n\n![Hexo安装笔记01](Hexo安装笔记/Hexo安装笔记01.png)\n\n改用👇，成功\n\n```js\nsudo npm install -g hexo \n```\n\n### 三、初始化HEXO\n\ncd 所在文件夹，执行命令👇，初始化\n\n```js\nhexo init\n```\n\n![Hexo安装笔记02](Hexo安装笔记/Hexo安装笔记02.png)\n￼\n`Permission denied (publickey).` 问题解决：\n\n```js\ngit config --global user.email “yagnqi_office@163.com”\ngit config --global user.name “KevinYangGit”\n\nssh-keygen -t rsa -C \"yangqi_office@163.com\"\n```\n\n更新 github 里的 SSH\n\n### 四、安装插件\n\n执行👇，安装插件\n\n```js\nnpm install hexo-deployer-git --save\n```\n\n### 五、常用复合命令\n\n```js\n// （第一次要输入用户名和密码）\nhexo deploy -g \nhexo server -g\n```\n\n简写：\n\n`hexo n` == `hexo new`\n`hexo g` == `hexo generate`\n`hexo s` == `hexo server`\n`hexo d` == `hexo deploy`\n\n## Hexo常见问题解决方案\n\n[[http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88]]\n\n[[https://cnodejs.org/topic/5502652573263b0e4eef9b26]]\n\n[[http://stackoverflow.com/questions/9484829/npm-cant-find-package-json]]\n\n[[http://www.jianshu.com/p/98e993305653]]\n\n## 博客样式\n\n[[https://github.com/hexojs/hexo/wiki/Themes]]\n\n[[https://github.com/daisygao/hexo-themes-cover]]\n\n[[https://github.com/A-limon/pacman]]\n\n[[https://github.com/TryGhost/Casper]]\n\n[[https://github.com/huangjunhui/concise.git]]\n","source":"_posts/Other/Hexo安装笔记.md","raw":"---\ntitle: Hexo安装笔记\ndate: 2018-08-08 16:27:04\ntags: Other\n---\n\n## Hexo-NEXT常用操作命令\n\n### 部署命令行\n\n```js\nhexo clean && hexo g && hexo d\n```\n\n### 写作\n\n```js\nhexo new “title”\n```\n\n### 标签\n\n```js\n---\ntitle: 多线程 — GCD\ndate: 2016-06-14 \ntags: OC //标签\n---\n```\n\n### 文章内添加图片\n\n1. 把图片放到  source/_posts/自定义文件夹/image.png\n2. 文章中插入图片\n\n```js\n![image](自定义文件夹/image.png)\n```\n\n### 设置头像\n\n1. 把图片放入 themes/next/source/images\n2. 修改头像\n\n```js\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.jpg\n# in site  directory(source/uploads): /uploads/avatar.jpg\navatar: http://example.com/avatar.png\n```\n\n## 本地头像\n\n```js\navatar: /images/avatar.gif\n```\n\nPs：图片格式我用.jpeg时加载不出了，改成.gif可以正常显示\n\n## Hexo 安装手记\n\n* 2018/08/08\n\n### 一、安装 Node.js\n\n[下载Node.js](https://nodejs.org)\n\n### 二、安装HEXO\n\n执行命令行，报错\n\n```js\nnpm install -g hexo-cli\n```\n\n![Hexo安装笔记01](Hexo安装笔记/Hexo安装笔记01.png)\n\n改用👇，成功\n\n```js\nsudo npm install -g hexo \n```\n\n### 三、初始化HEXO\n\ncd 所在文件夹，执行命令👇，初始化\n\n```js\nhexo init\n```\n\n![Hexo安装笔记02](Hexo安装笔记/Hexo安装笔记02.png)\n￼\n`Permission denied (publickey).` 问题解决：\n\n```js\ngit config --global user.email “yagnqi_office@163.com”\ngit config --global user.name “KevinYangGit”\n\nssh-keygen -t rsa -C \"yangqi_office@163.com\"\n```\n\n更新 github 里的 SSH\n\n### 四、安装插件\n\n执行👇，安装插件\n\n```js\nnpm install hexo-deployer-git --save\n```\n\n### 五、常用复合命令\n\n```js\n// （第一次要输入用户名和密码）\nhexo deploy -g \nhexo server -g\n```\n\n简写：\n\n`hexo n` == `hexo new`\n`hexo g` == `hexo generate`\n`hexo s` == `hexo server`\n`hexo d` == `hexo deploy`\n\n## Hexo常见问题解决方案\n\n[[http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88]]\n\n[[https://cnodejs.org/topic/5502652573263b0e4eef9b26]]\n\n[[http://stackoverflow.com/questions/9484829/npm-cant-find-package-json]]\n\n[[http://www.jianshu.com/p/98e993305653]]\n\n## 博客样式\n\n[[https://github.com/hexojs/hexo/wiki/Themes]]\n\n[[https://github.com/daisygao/hexo-themes-cover]]\n\n[[https://github.com/A-limon/pacman]]\n\n[[https://github.com/TryGhost/Casper]]\n\n[[https://github.com/huangjunhui/concise.git]]\n","slug":"Other/Hexo安装笔记","published":1,"updated":"2023-08-22T09:52:14.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgt80014aq7kw3y0yvui"},{"title":"Apple官方文档阅读指南","date":"2022-10-13T08:08:08.000Z","_content":"\n* [Documentation](https://developer.apple.com/documentation/)\n* [Documentation Technologies](https://developer.apple.com/documentation/technologies)\n* [Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n* [Opensource Srource](https://opensource.apple.com/source/)\n* [Opensource tarballs](https://opensource.apple.com/tarballs/)\n* [Opensource](https://opensource.apple.com/)\n* [Github Of Apple](https://github.com/apple)\n* [Swift Book](https://docs.swift.org/swift-book/)\n* [Develop](https://developer.apple.com/develop/)\n\n<!-- more -->\n\n# 苹果Xcode帮助文档阅读指南/官方文档\n\n转自：[苹果Xcode帮助文档阅读指南/官方文档](https://blog.csdn.net/YLGWHYH/article/details/41806103)\n\n## Xcode文档的结构\n\n![21](Apple官方文档阅读指南/21.png)\n\n如上图，打开文档后，整个文档界面由 **左面的侧栏** 和 **右面的内容区域** 构成。左面的侧栏可以选择不同的文档库，右面的内容区域是对应文档库的所有文档列表。你的 Xcode 里面一般来说有一组不同版本的 iOS 文档库、一组不同版本的 OS X 文档库，以及一个 Xcode 文档库。\n\n如果这里没有你要查看的文档库，你可以选择 Xcode 的 Preferences 菜单，然后选择 **Downloads -> Documentation**。在这里可以看到已经下载安装了的文档库，还没有下载的文档库，可以酌情选择。如下图：\n\n![22](Apple官方文档阅读指南/22.png)\n\n然后我们看，文档内容区域的左侧导航区域，这里揭示了**文档库的结构**。如下图：\n\n![23](Apple官方文档阅读指南/23.png)\n\n### 文档库侧栏\n\n#### Resource Types\n\n首先是 **Resource Types**，也就是资源类型，标签。文档库里面所有的文档是属于不同类型的，该类型是以下这几种类型中的一种：\n\n* **Getting Started** -- 新手入门。一般来说，是给完全的新手看的。建议初学者看看，这里面有一些建立观念的东西，有了这些建立观念的东西，后面的学习就比较容易了。\n\n* **Guides** -- 指南。指南是 Xcode 里面最酷最好的部分，学会看指南则大多数情况完全不用买书。Xcode 文档里面的指南，就是一个一个问题的，从一个问题或者系统的一个方面出发，一步一步详细介绍怎么使用 Cocoa 库的文档。一般程序员比较熟悉的是 Reference，就是你查某个类、方法、函数的文档时候，冒出来的东西（`option +`）。那些其实是一点一点的细碎知识，光看那些东西就完全没有脉络。而 Guides 就是帮你整理好的学习的脉络。\n\n* **Reference** -- 参考资料。一个一个框架一个一个类组织起来的文档，包含了每个方法的使用方法。\n\n* **Release Notes** -- 发布说明。一个 iOS 新版本带来了哪些新特性，这样的信息，熟悉新 iOS，比较不同 iOS 版本 API 不同，都需要参考这些文档。\n\n* **Sample Code** -- 示例代码。苹果官方提供的一些示例代码，帮助你学习某些技术某些 API。非常强烈建议学习的时候参考，一方面光看文档有时候还是很难弄明白具体实现是怎么回事儿。另外一方面这些示例代码都是苹果的工程师写的，你从示例代码的变迁可以看到苹果官方推荐的代码风格变化。\n\n* **Technical Notes** -- 技术说明。一些技术主题文章，有空的时候可以浏览一下。往往会有一些收获。\n\n* **Technical Q&A** -- 常见技术问答。这是技术社区里面一些常见问题以及回答的整理。\n\n* **Video** -- 视频。目前主要是 WWDC 的视频，实际上是登录到开发者网站上去浏览的，这里就是快捷方式。想深入学习的话，一定不能错过，大量的看，不仅可以学好技术，还可以练好英文。\n\n总结一下，这里面的 `Reference、Release Notes、Sample Code、Technical Notes、Technical Q&A`，一般来说只是备查的。主要要看的是 `Getting Started` 和 `Guides`。\n\n#### Topics\n\n然后下面是 Topics，也就是话题，被分为：\n\n1. **Audio & Video** -- 音视频\n2. **Languages & Utilities** -- 语言和工具，Objective-C 的一些知识，App Store 的管理工具等。\n3. **Mathematical Computation** -- 数学计算。\n4. **Xcode**\n5. **Data Management** -- 数据管理。\n6. **General** -- 一般性的问题。\n7. **Graphics & Animation** -- 图形和动画。\n8. **Networking & Internet** -- 网络问题。\n9. **Performance** -- 性能。\n10. **Security** -- 安全。\n11. **User Experience** -- 用户体验。\n\n这里不多说，大多数都是顾名思义的问题。但是值得一提的就是有很多初学者说，我想好好了解下图形和动画的技术，但是文档里面找不到，这就只能说，你睁着大大的眼睛，为毛左看右看看不到呢？\n\n#### Frameworks\n\n最下面是 **Frameworks**（框架），分为：\n\n1. **Cocoa Touch Layer**\n2. **Media Layer**\n3. **Core Services Layer**\n4. **Core OS Layer**\n\n这里我们先不讨论这个东西，后面会仔细讲。\n\n总体来说左边的导航区域就是用三种不同的维度，来帮你精准定位你需要的内容。\n\n## 内容区域\n现在我们看内容区域的右边。**注意上面的文档过滤器**。如下图：\n\n![24](Apple官方文档阅读指南/24.png)\n\n假设，你现在想看关于性能方面的 Guides，那么你应该做的就是在左面的导航，点击 **Topics -> Performance**，然后在右边的文档过滤器上面输入 **Guides**。\n\n或者你也可以在左边的导航，点击 **Resource Types -> Guides**，然后在文档过滤器里面输入 **Performance**。\n\n熟练使用导航和文档过滤器的话，学习就会非常方便快捷。\n\n## 文档导读\n\n前面我们讲 Xcode 的文档结构是在介绍如何能够快速定位到你要找的内容。但是很多人的问题可能是一开始就根本不知道要读什么。\n\n这里我们就介绍自学 iOS 开发应该遵循或者说我们推荐的必读文档的阅读顺序。\n\n阅读顺序：\n\n1. **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》**\n2. **《Your First iOS App》**\n3. **《Your Second iOS App: Storyboards》**\n4. **《Your Third iOS App: iCloud》**\n5. **《iOS Technology Overview》**\n6. **《iOS Human Interface Guidelines》**\n7. **《Learning Objective-C: A Primer》** 和 **《Programming with Objective-C》**\n8. **《iOS App Programming Guide》**\n9. **《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》**\n10. **《Table View Programming Guide for iOS》**\n\n### 马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》\n\n首先应该看的是 **Getting Started** 里面的 **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》**（中英文版本皆有，苹果官方的翻译）。这个文档讲的很浅，但是是建立概念的文档，你以后在开发里面经常遇到的概念，在这里都有包含，特别注 意是，这个文档看起来简单，但是每页下面的相关文章，不是选读，都是必读。\n\n即使是很多做了 iOS 开发很久的同学，其实也有很多概念上的误解，现代程序开发越来越简单，工具越来越强大，往往有些误解也可以继续前行，但是实际上不建立扎实的基础是很吃亏的，往往后面理解和解决一个不难解决小问题都要付出很多辛苦。\n\n阅读这个文档的目的和检测标准是，以后你看到iOS开发中的基本概念，都大致所有了解。\n\n### 《Your First iOS App》\n\n读完 **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》** 后，应该去看 **Your XXX iOS App** 系列这个系列不是什么很难的文章，你也不必着急先去学习 Objective-C，学什么 C 语言就更不要着急。我推荐的学习方法是有成就的逐步学习法。在学习系统体系架构、Objective-C之 前，你可以先按照文档写一个全天下最简单的 App，完成学习过程中第一个里程碑。在这个过程中不用担心 有什么疑问，有什么不懂，先照着做就是。\n\n阅读这三个文档的目的和检测标准是，把这三个 Demo App 做出来在模拟器上跑起来。\n\n在这个过程中，你对开发工具的基本认识就建立起来了，也有了成就感，去了魅（就是消除了对 iOS 开发的神秘感）。\n\n### 《iOS Technology Overview》\n\n再往下，建议你去看 **《iOS Technology Overview》**（iOS技术概览），iOS 不是一个技术，而是一堆技术，前一篇讲到文档导航区域的分类，框架分类的时候，我说不细讲的原因就在于此， 你要做一个动画应该用 Core Animation 还是 OpenGL？你要做一些文本相关操作应该用 Core Text 还是什么，就是看这里。\n\n学习现代的程序开发，语言和框架并重。我们 Tiny4Cocoa 叫做这个名字的原因就是，iOS/Mac 开发者的代表往往就是这个 Cocoa 框架，就是这个 SDK。大多数你所需要的功能都躺在框架里面，你知道框架的结构，你才知道怎么去寻找相关的技术资料。\n\n阅读这个文档的目的和检测标准是，遇到具体问题，知道应该去看哪方面的文档。\n\n### 《iOS Human Interface Guidelines》\n\n再下来，建议阅读的是 **《iOS Human Interface Guidelines》**，Mac/iOS 平台虽然也是百花齐放各类程序、App都有，但是总体看来，大多数优秀 App 的 UI 看起来都和整个系统很协调。这 和 Windows 以及很多其他平台完全不同。这是为什么呢？\n\n很大程度就归功于 **《Human Interface Guidelines》** 文化，所谓 Human Interface Guidelines 就是用户界面的规范，在苹果它还专门有一个缩写叫做 HIG，是天条一样的东西。所有的 App 都推荐遵循 HIG，遵循了 HIG，你做的东西用户看起来就会觉得和整个系统很协调。即使是你要做一些创新的设计，你势必会打破 HIG 的限制，但是你这个时候仍旧应该遵循 HIG 的精神。\n\n此外，你阅读 HIG 的很重要一点是了解整个 UI 结构和 UE 行为的逻辑机理，这样才能在你设计界面的时候有所依据。\n\n阅读这个文档的目的和检测标准是，看到任何一个App，你可以知道它的任何一个 UI 是系统控件，还是自定义控件，它的层次关系等等。\n\n### 《Learning Objective-C: A Primer》 和 《Programming with Objective-C》\n\n**《Learning Objective-C: A Primer》** 是非常初级和简单的入门，适合先阅读。**《Programming with Objective-C》** 超微复杂一点点，适合后阅读。\n\n一般人建议先学习语言，我反之建议先做了一个App，然后再学习语言。原因有几个，首先现代开发工具，往往不是用来开发控制台程序的，上来就会有框架，光懂语言不会使用 IDE，甚至可能会更麻烦。再其次就是，其实现代语言发展到了面向对象以后，库往往比语言更复杂，更重要，或者说更多的时候，我们是在学习库，而不是语言，语言只是库的一个载体。\n\n比如，Delegate 和 Block 等等都和 Cocoa 的 UI 异步机制关系紧密，光看代码，这些语言元素非常难以学习，也完全不知道其意义在哪里。\n\n阅读这个文档的目的和检测标准是，看得懂基本的 Objective-C 代码，方便后面的学习和阅读各种示例代码。\n\n### 《iOS App Programming Guide》\n\n**《iOS App Programming Guide》** 基本上介绍的就是开发一个 App 的完整流程，包括 App 的生命周期、休眠、激活等等，里面介绍的细节颇多。正式开发第一个上线的 App 之前必看。或者开发了一个 App，临到提交前必看的文档。\n\n阅读这个文档的目的和检测标准是，了解全部流程和很多细节问题。\n\n### 《View Programming Guide for iOS》 和 《View Controller Programming Guide for iOS》\n\n**《View Programming Guide for iOS》** 和 **《View Controller Programming Guide for iOS》** 非常重要。View 是整个图形界面里面最重要的概念。所有的图形、界面绘制都基于 View。你看到的一切复杂的用户界面，就是各种不同的View 的组合堆叠。\n\nView Controller 是 View 和某种逻辑在一起的组合，本质上这种组合不是必须的，但是是大大降低编程复杂度的一种设计。很多人不懂什么是 View 什么是 View Controller，这样写起代码来就很痛苦。\n\n阅读这个文档的目的和检测标准是，深刻理解什么是 View，什么是 View Controller，理解什么情况用 View，什么情况用 View Controller。\n\nUITableView 是最重要的一个控件，是最常用的 UI 界面元素。在 UICollectionView 出现之前，大量的内容列表展示的自定义控件都是基于 UITableView，比如很多书架、图片 Grid 其实都是 UITableView 做的。\n\n所以 **《Table View Programming Guide for iOS》** 非常重要，一定要好好阅读。\n\n阅读这个文档的目的和检测标准是，深刻理解 UITableView／UITableViewController 的理论和使用方法。\n\n我推荐的必读文档就这么多，仔细看的话，最多也就是今天就看完了。学习一个东西，如果有一点点耐心，有正确的方法其实不难，不是说脑子非要很聪明，大多数人都可以做到一个星期就学会 iOS 开发，其实就是读完这些文档，大多数人就会了。\n\n就像我强调了无数次，阅读英文文档不难，我自己从当年看英文文档非常吃力，必须查词典开始，认真的看英文文档，不会就查词典，一个多月过去，读英文文档就完全不需要查词典了。\n\n我们公司主程 @sycx 老师，也说他原来英语也很不好，甚至现在英语仍旧很烂，但是看英文文档完全没有问题，也就是几个星期的认真学习以后就突破了。\n\n其实学习iOS也如此。当然我不是说你看懂这10组文档就再也不用看别的了。而是说，如果你看懂了这10组文档，你就从初学者，或者是虽然会写一些程序，但是对iOS其实还不懂的状态，变成了一个入门者。\n\n我不希望这个文章可以一句一句的帮你学会iOS是什么，这个文章的目的是帮你快速入门。一旦你入门了，你再遇到问题该看什么，你就不需要我讲了，你自己就知道了。一旦入门了，你就会发现，Xcode里面别的文档讲的内容虽然不同，但是结构你已经很清楚了，你学习起来很方便。\n\n阅读本文的目的和检测标准是，遇到问题，知道看什么文档，想提升自己技术的时候，知道按照什么脉络自己组织阅读。\n\n## 如何查询文档\n\n### Quick Help\n\n最快捷的查询帮助文档的方法是不需要键入任何关键词的。你只需要在 Xcode 代码编辑器里，按住 **Option 键**，然后点击你想查询的关键词，就会获得关键词的帮助信息。如下图：\n\n![25](Apple官方文档阅读指南/25.png)\n\n帮助信息会包括，一些简单的描述、哪个 iOS 操作系统开始提供，头文件，参考文档。头文件和参考文档是可以直接点击的。\n\n即使你点击的关键字不是 Cocoa 库的内容，是自己代码里面的类或者方法，也可以获得相关的定义信息。如下图：\n\n![26](Apple官方文档阅读指南/26.png)\n\n与之相关的热键是 **Command 键加鼠标点击**，即可跳到任何一个类名或者方法名的所定义的头文件。\n\n快速查询帮助的另外一个方法是直接打开 **Quick Help** 栏，如下图，首先找到“**右侧栏开关**”，然后找到“**Quick Help**”开关即可打开。\n\n![27](Apple官方文档阅读指南/27.png)\n\n**Quick Help** 栏的作用机制是，只要它在打开状态，只要输入光标在什么关键字上，**Quick Help** 栏就会显示跟关键字相关的简要帮助信息，跟 **Option 键加点击** 的信息基本一致，但可能略微丰富一点。\n\n写代码的时候，在大多数情况下，查询下快速帮助，看看头文件，就足以了。\n\n### 搜索帮助\n\n文档阅读界面最左面的上端的放大镜按钮就是搜索界面。下图是我们搜索 `uiimage`，得到的搜索结果。\n\n![28](Apple官方文档阅读指南/28.png)\n\n首先值得注意的是，结果也是分类的，分为 **Reference、System Guides、Tools Guides、Sample Code** 这四类。类别很利于我们快速找到我们需要的信息。前面已经介绍过类别，跟那个基本一致，参照即可。\n\n另外需要注意的是，搜索框下面的选项，首先是 **Hits Must**（什么样的结果才会命中），包含了三项：\n\n1. **contain search term** -- 这是最常见的就是结果包含搜索词\n2. **start with search term** -- 由搜索词开始\n3. **match search term** -- 必须完全匹配搜索词\n\n然后是 **Languages**（语言选项），包含 Javascript、C++、Java、Objective-C、C 语言。\n\n然后是，**Find in**（在哪些文档库搜索），包含了你 Xcode 里面安装的全部文档库。\n\n### 阅读文档\n\n最后，我们简单介绍下怎么阅读文档。文档的阅读界面如下图：\n\n![29](Apple官方文档阅读指南/29.png)\n\n值得注意的是，标题下面这几样：\n\n1. **Inherits from** -- 继承关系，继承自\n2. **Conforms to** -- 遵循什么协议\n3. **Framework** -- 属于什么框架\n4. **Availability** -- 从什么iOS版本开始支持\n5. **Declared in** -- 头文件\n6. **Related sample code** -- 相关例子代码\n7. **Companion guide** -- 相关的指南（`UIImage` 没有，很多其他的类有）\n\n在其次一个很重要的东西，其实是标题上面那一条窄窄的导航栏，那是一个多层树状导航栏，看文档的时候，可以点击那个栏的不同位置浏览。\n\n其实这个栏包含了整个文档库的组织结构树状图，可惜只有在这个界面才能浏览。有兴趣的可以慢慢浏览，里面信息量其实非常大。\n\n# 《苹果官方文档》\n\n* [Documentation](https://developer.apple.com/documentation/)\n* [Documentation Technologies](https://developer.apple.com/documentation/technologies)\n* [Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n* [Opensource Srource](https://opensource.apple.com/source/)\n* [Opensource tarballs](https://opensource.apple.com/tarballs/)\n* [Opensource](https://opensource.apple.com/)\n* [Github Of Apple](https://github.com/apple)\n* [Swift Book](https://docs.swift.org/swift-book/)\n* [Develop](https://developer.apple.com/develop/)\n\n\n转自：[苹果官方文档](https://blog.csdn.net/rccrx/article/details/115405502)\n\n## Documentation\n\n跳转链接：[Documentation](https://developer.apple.com/documentation/)\n\n点击右边搜索按钮，搜索结果比较细节，基本是标题中包含关键字才搜到却不一定匹配这个主题比如 `runtime`，结果指向综合框架文档下的其中一篇文档。而且这个搜索区分大小写，比如 `AVfoundation` 和 `avfoundation` 的搜索结果数量不一样。\n\n![01](Apple官方文档阅读指南/01.png)\n\n点击左边的“**Documentation**”文字进行搜索 Technologies，其实是过滤筛选下面的238个框架文档中匹配关键字的框架，搜索结果指向概论，可以从概论链接跳转到细节。\n\n![02](Apple官方文档阅读指南/02.png)\n\nDocumentation 基本上是**框架、类、方法**的说明文档，也会有文章加代码片段指导如何开发，也会有一些编程示例可供下载。（Documentation 首页，也是点击右边 **Featured** 显示的页面，第一张图片就有指示“Apple Developer Documentation —— Browse the latest developer documentation, including tutorials, sample code, articles, and API reference.”）\n\nDocumentation 首页的最下方有4个链接，最后一个是“**Documentation Archive**”，并且说明了归档是一些不会再更新的文档和示例代码。\n\n![03](Apple官方文档阅读指南/03.png)\n\n## Documentation Archive\n\n跳转链接：[Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n\n在 **Documents 旁边的搜索框**搜索文档，例如输入 `runtime` 选择 Objective-C Runtime Programming Guide。输入 `loop` 选择 **Run Loops**（打开会提示该文章已经被取代了，去 Threading Programming Guide 查看 run loop 信息）。**Documents 旁边的搜索框**，可以根据关键字筛选5219篇文档中的匹配文档。Safari 输入文字时很卡，Chrome 不卡。\n\n在上方搜索框 **Search Documentation Archive** 搜索，结果和在 Documentation 搜索一样。\n\n![04](Apple官方文档阅读指南/04.png)\n\n主要是一些编程指导 Programming Guide，但是这些文档比较旧且不再更新（点击进去一个文档最下面显示最后更新时间 `Updated: 2009-10-19`），Archive 首页也有提示“This library is no longer being updated. Find the latest API reference, articles, and sample code on our Developer Documentation page.”去 **Documentation** 查看最新文档。\n\n**有的文章只在 Archive 不在 Documentation**，比如 《Objective-C Runtime Programming Guide》 和 《Run Loops》，而且 Documentation 搜索结果总是搜不到专题总是细化到一个不一定相关的类，而去 Technologies 搜索专题也不一定有，所以**一般先去 Archive 搜索专题文档，然后去 Documentation 查看相关框架和类的最新文档**。\n\n### Archive 和 Documentation 比较\n\n1. AVFoundation 框架：Documentation 的示例使用 [PHPhotoLibrary](https://developer.apple.com/documentation/avfoundation/photo_capture/capturing_photos_in_raw_and_apple_proraw_formats?language=objc)，而 Archive 使用过期的 [ALAssetsLibrary](https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html)；\n\n2. Runtime：Archive 有而 Documentation 没有，但是 Documentation 的 **See Also** 下有跳转到 Archive 的链接。\n3. **Archive 基本都是专题文章**（Programming Guide），比如 Runtime 会描述运行时机制、消息传递、类型编码等；而 **Documentation 基本都是类和方法的说明**（API Reference），比如 Runtime 会说明有哪些运行时相关的方法函数，开发者可以调用的方法，Archive 的代码示例中用到的方法。\n\n## 开源代码\n\n* [https://opensource.apple.com/source/](https://opensource.apple.com/source/)：在线查看源码，比如查找 `objc4` 可以找到 runtime 源码。\n\n搜索 `objc4`：\n![05](Apple官方文档阅读指南/05.png)\n\n进入目录 `objc4`：\n![06](Apple官方文档阅读指南/06.png)\n\n* [https://opensource.apple.com/tarballs](https://opensource.apple.com/tarballs)：源码压缩包，可下载。\n\n* [https://opensource.apple.com](https://opensource.apple.com)：可以按操作系统和版本号导航开源代码，例如Release->macOS->11.0->11.2，打开页面中的“objc4-818.2”，Runtime的源码在macOS而不是iOS。\n\n* [https://github.com/apple](https://github.com/apple)：比如darwin-xnu。\n\n* [https://developer.apple.com/opensource/](https://developer.apple.com/opensource/)\n\n## Xcode 中的文档\n\n* **Developer Documentation**（是离线版的 Documentation，内容基本一样），可以利用左边的导航视图找到所需框架，也可以点击搜索框搜索。\n\n![07](Apple官方文档阅读指南/07.png)\n\n* [Swift Programing Language Book](https://docs.swift.org/swift-book/)\n\n* Xcode使用“**Control+Command+鼠标点击**”一个类名，跳到类头文件中，查看文件中方法和属性的注释（和官方文档 Documentation 中的说明差不多且包含各个参数说明，而类头文件对整个类的注释说明不够详细，看 Documentation 更能知道这个类的作用）。\n\n## Develop\n\n[https://developer.apple.com/develop/](https://developer.apple.com/develop/)：最下方的 Media and Web 的“Audio”、“AVFoundation”、“HTTP Live Streaming”有这些开发文档的链接；点击最上方的“Documentation”可以跳到文档搜索中心。\n\n![08](Apple官方文档阅读指南/08.png)\n\n\n\n\n","source":"_posts/Other/Apple官方文档阅读指南.md","raw":"---\ntitle: Apple官方文档阅读指南\ndate: 2022-10-13 16:08:08\ntags: Other\n---\n\n* [Documentation](https://developer.apple.com/documentation/)\n* [Documentation Technologies](https://developer.apple.com/documentation/technologies)\n* [Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n* [Opensource Srource](https://opensource.apple.com/source/)\n* [Opensource tarballs](https://opensource.apple.com/tarballs/)\n* [Opensource](https://opensource.apple.com/)\n* [Github Of Apple](https://github.com/apple)\n* [Swift Book](https://docs.swift.org/swift-book/)\n* [Develop](https://developer.apple.com/develop/)\n\n<!-- more -->\n\n# 苹果Xcode帮助文档阅读指南/官方文档\n\n转自：[苹果Xcode帮助文档阅读指南/官方文档](https://blog.csdn.net/YLGWHYH/article/details/41806103)\n\n## Xcode文档的结构\n\n![21](Apple官方文档阅读指南/21.png)\n\n如上图，打开文档后，整个文档界面由 **左面的侧栏** 和 **右面的内容区域** 构成。左面的侧栏可以选择不同的文档库，右面的内容区域是对应文档库的所有文档列表。你的 Xcode 里面一般来说有一组不同版本的 iOS 文档库、一组不同版本的 OS X 文档库，以及一个 Xcode 文档库。\n\n如果这里没有你要查看的文档库，你可以选择 Xcode 的 Preferences 菜单，然后选择 **Downloads -> Documentation**。在这里可以看到已经下载安装了的文档库，还没有下载的文档库，可以酌情选择。如下图：\n\n![22](Apple官方文档阅读指南/22.png)\n\n然后我们看，文档内容区域的左侧导航区域，这里揭示了**文档库的结构**。如下图：\n\n![23](Apple官方文档阅读指南/23.png)\n\n### 文档库侧栏\n\n#### Resource Types\n\n首先是 **Resource Types**，也就是资源类型，标签。文档库里面所有的文档是属于不同类型的，该类型是以下这几种类型中的一种：\n\n* **Getting Started** -- 新手入门。一般来说，是给完全的新手看的。建议初学者看看，这里面有一些建立观念的东西，有了这些建立观念的东西，后面的学习就比较容易了。\n\n* **Guides** -- 指南。指南是 Xcode 里面最酷最好的部分，学会看指南则大多数情况完全不用买书。Xcode 文档里面的指南，就是一个一个问题的，从一个问题或者系统的一个方面出发，一步一步详细介绍怎么使用 Cocoa 库的文档。一般程序员比较熟悉的是 Reference，就是你查某个类、方法、函数的文档时候，冒出来的东西（`option +`）。那些其实是一点一点的细碎知识，光看那些东西就完全没有脉络。而 Guides 就是帮你整理好的学习的脉络。\n\n* **Reference** -- 参考资料。一个一个框架一个一个类组织起来的文档，包含了每个方法的使用方法。\n\n* **Release Notes** -- 发布说明。一个 iOS 新版本带来了哪些新特性，这样的信息，熟悉新 iOS，比较不同 iOS 版本 API 不同，都需要参考这些文档。\n\n* **Sample Code** -- 示例代码。苹果官方提供的一些示例代码，帮助你学习某些技术某些 API。非常强烈建议学习的时候参考，一方面光看文档有时候还是很难弄明白具体实现是怎么回事儿。另外一方面这些示例代码都是苹果的工程师写的，你从示例代码的变迁可以看到苹果官方推荐的代码风格变化。\n\n* **Technical Notes** -- 技术说明。一些技术主题文章，有空的时候可以浏览一下。往往会有一些收获。\n\n* **Technical Q&A** -- 常见技术问答。这是技术社区里面一些常见问题以及回答的整理。\n\n* **Video** -- 视频。目前主要是 WWDC 的视频，实际上是登录到开发者网站上去浏览的，这里就是快捷方式。想深入学习的话，一定不能错过，大量的看，不仅可以学好技术，还可以练好英文。\n\n总结一下，这里面的 `Reference、Release Notes、Sample Code、Technical Notes、Technical Q&A`，一般来说只是备查的。主要要看的是 `Getting Started` 和 `Guides`。\n\n#### Topics\n\n然后下面是 Topics，也就是话题，被分为：\n\n1. **Audio & Video** -- 音视频\n2. **Languages & Utilities** -- 语言和工具，Objective-C 的一些知识，App Store 的管理工具等。\n3. **Mathematical Computation** -- 数学计算。\n4. **Xcode**\n5. **Data Management** -- 数据管理。\n6. **General** -- 一般性的问题。\n7. **Graphics & Animation** -- 图形和动画。\n8. **Networking & Internet** -- 网络问题。\n9. **Performance** -- 性能。\n10. **Security** -- 安全。\n11. **User Experience** -- 用户体验。\n\n这里不多说，大多数都是顾名思义的问题。但是值得一提的就是有很多初学者说，我想好好了解下图形和动画的技术，但是文档里面找不到，这就只能说，你睁着大大的眼睛，为毛左看右看看不到呢？\n\n#### Frameworks\n\n最下面是 **Frameworks**（框架），分为：\n\n1. **Cocoa Touch Layer**\n2. **Media Layer**\n3. **Core Services Layer**\n4. **Core OS Layer**\n\n这里我们先不讨论这个东西，后面会仔细讲。\n\n总体来说左边的导航区域就是用三种不同的维度，来帮你精准定位你需要的内容。\n\n## 内容区域\n现在我们看内容区域的右边。**注意上面的文档过滤器**。如下图：\n\n![24](Apple官方文档阅读指南/24.png)\n\n假设，你现在想看关于性能方面的 Guides，那么你应该做的就是在左面的导航，点击 **Topics -> Performance**，然后在右边的文档过滤器上面输入 **Guides**。\n\n或者你也可以在左边的导航，点击 **Resource Types -> Guides**，然后在文档过滤器里面输入 **Performance**。\n\n熟练使用导航和文档过滤器的话，学习就会非常方便快捷。\n\n## 文档导读\n\n前面我们讲 Xcode 的文档结构是在介绍如何能够快速定位到你要找的内容。但是很多人的问题可能是一开始就根本不知道要读什么。\n\n这里我们就介绍自学 iOS 开发应该遵循或者说我们推荐的必读文档的阅读顺序。\n\n阅读顺序：\n\n1. **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》**\n2. **《Your First iOS App》**\n3. **《Your Second iOS App: Storyboards》**\n4. **《Your Third iOS App: iCloud》**\n5. **《iOS Technology Overview》**\n6. **《iOS Human Interface Guidelines》**\n7. **《Learning Objective-C: A Primer》** 和 **《Programming with Objective-C》**\n8. **《iOS App Programming Guide》**\n9. **《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》**\n10. **《Table View Programming Guide for iOS》**\n\n### 马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》\n\n首先应该看的是 **Getting Started** 里面的 **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》**（中英文版本皆有，苹果官方的翻译）。这个文档讲的很浅，但是是建立概念的文档，你以后在开发里面经常遇到的概念，在这里都有包含，特别注 意是，这个文档看起来简单，但是每页下面的相关文章，不是选读，都是必读。\n\n即使是很多做了 iOS 开发很久的同学，其实也有很多概念上的误解，现代程序开发越来越简单，工具越来越强大，往往有些误解也可以继续前行，但是实际上不建立扎实的基础是很吃亏的，往往后面理解和解决一个不难解决小问题都要付出很多辛苦。\n\n阅读这个文档的目的和检测标准是，以后你看到iOS开发中的基本概念，都大致所有了解。\n\n### 《Your First iOS App》\n\n读完 **《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》** 后，应该去看 **Your XXX iOS App** 系列这个系列不是什么很难的文章，你也不必着急先去学习 Objective-C，学什么 C 语言就更不要着急。我推荐的学习方法是有成就的逐步学习法。在学习系统体系架构、Objective-C之 前，你可以先按照文档写一个全天下最简单的 App，完成学习过程中第一个里程碑。在这个过程中不用担心 有什么疑问，有什么不懂，先照着做就是。\n\n阅读这三个文档的目的和检测标准是，把这三个 Demo App 做出来在模拟器上跑起来。\n\n在这个过程中，你对开发工具的基本认识就建立起来了，也有了成就感，去了魅（就是消除了对 iOS 开发的神秘感）。\n\n### 《iOS Technology Overview》\n\n再往下，建议你去看 **《iOS Technology Overview》**（iOS技术概览），iOS 不是一个技术，而是一堆技术，前一篇讲到文档导航区域的分类，框架分类的时候，我说不细讲的原因就在于此， 你要做一个动画应该用 Core Animation 还是 OpenGL？你要做一些文本相关操作应该用 Core Text 还是什么，就是看这里。\n\n学习现代的程序开发，语言和框架并重。我们 Tiny4Cocoa 叫做这个名字的原因就是，iOS/Mac 开发者的代表往往就是这个 Cocoa 框架，就是这个 SDK。大多数你所需要的功能都躺在框架里面，你知道框架的结构，你才知道怎么去寻找相关的技术资料。\n\n阅读这个文档的目的和检测标准是，遇到具体问题，知道应该去看哪方面的文档。\n\n### 《iOS Human Interface Guidelines》\n\n再下来，建议阅读的是 **《iOS Human Interface Guidelines》**，Mac/iOS 平台虽然也是百花齐放各类程序、App都有，但是总体看来，大多数优秀 App 的 UI 看起来都和整个系统很协调。这 和 Windows 以及很多其他平台完全不同。这是为什么呢？\n\n很大程度就归功于 **《Human Interface Guidelines》** 文化，所谓 Human Interface Guidelines 就是用户界面的规范，在苹果它还专门有一个缩写叫做 HIG，是天条一样的东西。所有的 App 都推荐遵循 HIG，遵循了 HIG，你做的东西用户看起来就会觉得和整个系统很协调。即使是你要做一些创新的设计，你势必会打破 HIG 的限制，但是你这个时候仍旧应该遵循 HIG 的精神。\n\n此外，你阅读 HIG 的很重要一点是了解整个 UI 结构和 UE 行为的逻辑机理，这样才能在你设计界面的时候有所依据。\n\n阅读这个文档的目的和检测标准是，看到任何一个App，你可以知道它的任何一个 UI 是系统控件，还是自定义控件，它的层次关系等等。\n\n### 《Learning Objective-C: A Primer》 和 《Programming with Objective-C》\n\n**《Learning Objective-C: A Primer》** 是非常初级和简单的入门，适合先阅读。**《Programming with Objective-C》** 超微复杂一点点，适合后阅读。\n\n一般人建议先学习语言，我反之建议先做了一个App，然后再学习语言。原因有几个，首先现代开发工具，往往不是用来开发控制台程序的，上来就会有框架，光懂语言不会使用 IDE，甚至可能会更麻烦。再其次就是，其实现代语言发展到了面向对象以后，库往往比语言更复杂，更重要，或者说更多的时候，我们是在学习库，而不是语言，语言只是库的一个载体。\n\n比如，Delegate 和 Block 等等都和 Cocoa 的 UI 异步机制关系紧密，光看代码，这些语言元素非常难以学习，也完全不知道其意义在哪里。\n\n阅读这个文档的目的和检测标准是，看得懂基本的 Objective-C 代码，方便后面的学习和阅读各种示例代码。\n\n### 《iOS App Programming Guide》\n\n**《iOS App Programming Guide》** 基本上介绍的就是开发一个 App 的完整流程，包括 App 的生命周期、休眠、激活等等，里面介绍的细节颇多。正式开发第一个上线的 App 之前必看。或者开发了一个 App，临到提交前必看的文档。\n\n阅读这个文档的目的和检测标准是，了解全部流程和很多细节问题。\n\n### 《View Programming Guide for iOS》 和 《View Controller Programming Guide for iOS》\n\n**《View Programming Guide for iOS》** 和 **《View Controller Programming Guide for iOS》** 非常重要。View 是整个图形界面里面最重要的概念。所有的图形、界面绘制都基于 View。你看到的一切复杂的用户界面，就是各种不同的View 的组合堆叠。\n\nView Controller 是 View 和某种逻辑在一起的组合，本质上这种组合不是必须的，但是是大大降低编程复杂度的一种设计。很多人不懂什么是 View 什么是 View Controller，这样写起代码来就很痛苦。\n\n阅读这个文档的目的和检测标准是，深刻理解什么是 View，什么是 View Controller，理解什么情况用 View，什么情况用 View Controller。\n\nUITableView 是最重要的一个控件，是最常用的 UI 界面元素。在 UICollectionView 出现之前，大量的内容列表展示的自定义控件都是基于 UITableView，比如很多书架、图片 Grid 其实都是 UITableView 做的。\n\n所以 **《Table View Programming Guide for iOS》** 非常重要，一定要好好阅读。\n\n阅读这个文档的目的和检测标准是，深刻理解 UITableView／UITableViewController 的理论和使用方法。\n\n我推荐的必读文档就这么多，仔细看的话，最多也就是今天就看完了。学习一个东西，如果有一点点耐心，有正确的方法其实不难，不是说脑子非要很聪明，大多数人都可以做到一个星期就学会 iOS 开发，其实就是读完这些文档，大多数人就会了。\n\n就像我强调了无数次，阅读英文文档不难，我自己从当年看英文文档非常吃力，必须查词典开始，认真的看英文文档，不会就查词典，一个多月过去，读英文文档就完全不需要查词典了。\n\n我们公司主程 @sycx 老师，也说他原来英语也很不好，甚至现在英语仍旧很烂，但是看英文文档完全没有问题，也就是几个星期的认真学习以后就突破了。\n\n其实学习iOS也如此。当然我不是说你看懂这10组文档就再也不用看别的了。而是说，如果你看懂了这10组文档，你就从初学者，或者是虽然会写一些程序，但是对iOS其实还不懂的状态，变成了一个入门者。\n\n我不希望这个文章可以一句一句的帮你学会iOS是什么，这个文章的目的是帮你快速入门。一旦你入门了，你再遇到问题该看什么，你就不需要我讲了，你自己就知道了。一旦入门了，你就会发现，Xcode里面别的文档讲的内容虽然不同，但是结构你已经很清楚了，你学习起来很方便。\n\n阅读本文的目的和检测标准是，遇到问题，知道看什么文档，想提升自己技术的时候，知道按照什么脉络自己组织阅读。\n\n## 如何查询文档\n\n### Quick Help\n\n最快捷的查询帮助文档的方法是不需要键入任何关键词的。你只需要在 Xcode 代码编辑器里，按住 **Option 键**，然后点击你想查询的关键词，就会获得关键词的帮助信息。如下图：\n\n![25](Apple官方文档阅读指南/25.png)\n\n帮助信息会包括，一些简单的描述、哪个 iOS 操作系统开始提供，头文件，参考文档。头文件和参考文档是可以直接点击的。\n\n即使你点击的关键字不是 Cocoa 库的内容，是自己代码里面的类或者方法，也可以获得相关的定义信息。如下图：\n\n![26](Apple官方文档阅读指南/26.png)\n\n与之相关的热键是 **Command 键加鼠标点击**，即可跳到任何一个类名或者方法名的所定义的头文件。\n\n快速查询帮助的另外一个方法是直接打开 **Quick Help** 栏，如下图，首先找到“**右侧栏开关**”，然后找到“**Quick Help**”开关即可打开。\n\n![27](Apple官方文档阅读指南/27.png)\n\n**Quick Help** 栏的作用机制是，只要它在打开状态，只要输入光标在什么关键字上，**Quick Help** 栏就会显示跟关键字相关的简要帮助信息，跟 **Option 键加点击** 的信息基本一致，但可能略微丰富一点。\n\n写代码的时候，在大多数情况下，查询下快速帮助，看看头文件，就足以了。\n\n### 搜索帮助\n\n文档阅读界面最左面的上端的放大镜按钮就是搜索界面。下图是我们搜索 `uiimage`，得到的搜索结果。\n\n![28](Apple官方文档阅读指南/28.png)\n\n首先值得注意的是，结果也是分类的，分为 **Reference、System Guides、Tools Guides、Sample Code** 这四类。类别很利于我们快速找到我们需要的信息。前面已经介绍过类别，跟那个基本一致，参照即可。\n\n另外需要注意的是，搜索框下面的选项，首先是 **Hits Must**（什么样的结果才会命中），包含了三项：\n\n1. **contain search term** -- 这是最常见的就是结果包含搜索词\n2. **start with search term** -- 由搜索词开始\n3. **match search term** -- 必须完全匹配搜索词\n\n然后是 **Languages**（语言选项），包含 Javascript、C++、Java、Objective-C、C 语言。\n\n然后是，**Find in**（在哪些文档库搜索），包含了你 Xcode 里面安装的全部文档库。\n\n### 阅读文档\n\n最后，我们简单介绍下怎么阅读文档。文档的阅读界面如下图：\n\n![29](Apple官方文档阅读指南/29.png)\n\n值得注意的是，标题下面这几样：\n\n1. **Inherits from** -- 继承关系，继承自\n2. **Conforms to** -- 遵循什么协议\n3. **Framework** -- 属于什么框架\n4. **Availability** -- 从什么iOS版本开始支持\n5. **Declared in** -- 头文件\n6. **Related sample code** -- 相关例子代码\n7. **Companion guide** -- 相关的指南（`UIImage` 没有，很多其他的类有）\n\n在其次一个很重要的东西，其实是标题上面那一条窄窄的导航栏，那是一个多层树状导航栏，看文档的时候，可以点击那个栏的不同位置浏览。\n\n其实这个栏包含了整个文档库的组织结构树状图，可惜只有在这个界面才能浏览。有兴趣的可以慢慢浏览，里面信息量其实非常大。\n\n# 《苹果官方文档》\n\n* [Documentation](https://developer.apple.com/documentation/)\n* [Documentation Technologies](https://developer.apple.com/documentation/technologies)\n* [Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n* [Opensource Srource](https://opensource.apple.com/source/)\n* [Opensource tarballs](https://opensource.apple.com/tarballs/)\n* [Opensource](https://opensource.apple.com/)\n* [Github Of Apple](https://github.com/apple)\n* [Swift Book](https://docs.swift.org/swift-book/)\n* [Develop](https://developer.apple.com/develop/)\n\n\n转自：[苹果官方文档](https://blog.csdn.net/rccrx/article/details/115405502)\n\n## Documentation\n\n跳转链接：[Documentation](https://developer.apple.com/documentation/)\n\n点击右边搜索按钮，搜索结果比较细节，基本是标题中包含关键字才搜到却不一定匹配这个主题比如 `runtime`，结果指向综合框架文档下的其中一篇文档。而且这个搜索区分大小写，比如 `AVfoundation` 和 `avfoundation` 的搜索结果数量不一样。\n\n![01](Apple官方文档阅读指南/01.png)\n\n点击左边的“**Documentation**”文字进行搜索 Technologies，其实是过滤筛选下面的238个框架文档中匹配关键字的框架，搜索结果指向概论，可以从概论链接跳转到细节。\n\n![02](Apple官方文档阅读指南/02.png)\n\nDocumentation 基本上是**框架、类、方法**的说明文档，也会有文章加代码片段指导如何开发，也会有一些编程示例可供下载。（Documentation 首页，也是点击右边 **Featured** 显示的页面，第一张图片就有指示“Apple Developer Documentation —— Browse the latest developer documentation, including tutorials, sample code, articles, and API reference.”）\n\nDocumentation 首页的最下方有4个链接，最后一个是“**Documentation Archive**”，并且说明了归档是一些不会再更新的文档和示例代码。\n\n![03](Apple官方文档阅读指南/03.png)\n\n## Documentation Archive\n\n跳转链接：[Documentation Archive](https://developer.apple.com/library/archive/navigation/)\n\n在 **Documents 旁边的搜索框**搜索文档，例如输入 `runtime` 选择 Objective-C Runtime Programming Guide。输入 `loop` 选择 **Run Loops**（打开会提示该文章已经被取代了，去 Threading Programming Guide 查看 run loop 信息）。**Documents 旁边的搜索框**，可以根据关键字筛选5219篇文档中的匹配文档。Safari 输入文字时很卡，Chrome 不卡。\n\n在上方搜索框 **Search Documentation Archive** 搜索，结果和在 Documentation 搜索一样。\n\n![04](Apple官方文档阅读指南/04.png)\n\n主要是一些编程指导 Programming Guide，但是这些文档比较旧且不再更新（点击进去一个文档最下面显示最后更新时间 `Updated: 2009-10-19`），Archive 首页也有提示“This library is no longer being updated. Find the latest API reference, articles, and sample code on our Developer Documentation page.”去 **Documentation** 查看最新文档。\n\n**有的文章只在 Archive 不在 Documentation**，比如 《Objective-C Runtime Programming Guide》 和 《Run Loops》，而且 Documentation 搜索结果总是搜不到专题总是细化到一个不一定相关的类，而去 Technologies 搜索专题也不一定有，所以**一般先去 Archive 搜索专题文档，然后去 Documentation 查看相关框架和类的最新文档**。\n\n### Archive 和 Documentation 比较\n\n1. AVFoundation 框架：Documentation 的示例使用 [PHPhotoLibrary](https://developer.apple.com/documentation/avfoundation/photo_capture/capturing_photos_in_raw_and_apple_proraw_formats?language=objc)，而 Archive 使用过期的 [ALAssetsLibrary](https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html)；\n\n2. Runtime：Archive 有而 Documentation 没有，但是 Documentation 的 **See Also** 下有跳转到 Archive 的链接。\n3. **Archive 基本都是专题文章**（Programming Guide），比如 Runtime 会描述运行时机制、消息传递、类型编码等；而 **Documentation 基本都是类和方法的说明**（API Reference），比如 Runtime 会说明有哪些运行时相关的方法函数，开发者可以调用的方法，Archive 的代码示例中用到的方法。\n\n## 开源代码\n\n* [https://opensource.apple.com/source/](https://opensource.apple.com/source/)：在线查看源码，比如查找 `objc4` 可以找到 runtime 源码。\n\n搜索 `objc4`：\n![05](Apple官方文档阅读指南/05.png)\n\n进入目录 `objc4`：\n![06](Apple官方文档阅读指南/06.png)\n\n* [https://opensource.apple.com/tarballs](https://opensource.apple.com/tarballs)：源码压缩包，可下载。\n\n* [https://opensource.apple.com](https://opensource.apple.com)：可以按操作系统和版本号导航开源代码，例如Release->macOS->11.0->11.2，打开页面中的“objc4-818.2”，Runtime的源码在macOS而不是iOS。\n\n* [https://github.com/apple](https://github.com/apple)：比如darwin-xnu。\n\n* [https://developer.apple.com/opensource/](https://developer.apple.com/opensource/)\n\n## Xcode 中的文档\n\n* **Developer Documentation**（是离线版的 Documentation，内容基本一样），可以利用左边的导航视图找到所需框架，也可以点击搜索框搜索。\n\n![07](Apple官方文档阅读指南/07.png)\n\n* [Swift Programing Language Book](https://docs.swift.org/swift-book/)\n\n* Xcode使用“**Control+Command+鼠标点击**”一个类名，跳到类头文件中，查看文件中方法和属性的注释（和官方文档 Documentation 中的说明差不多且包含各个参数说明，而类头文件对整个类的注释说明不够详细，看 Documentation 更能知道这个类的作用）。\n\n## Develop\n\n[https://developer.apple.com/develop/](https://developer.apple.com/develop/)：最下方的 Media and Web 的“Audio”、“AVFoundation”、“HTTP Live Streaming”有这些开发文档的链接；点击最上方的“Documentation”可以跳到文档搜索中心。\n\n![08](Apple官方文档阅读指南/08.png)\n\n\n\n\n","slug":"Other/Apple官方文档阅读指南","published":1,"updated":"2023-08-22T09:52:14.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgtd0016aq7kjrq3x05e"},{"title":"Math","date":"2021-04-14T02:40:11.000Z","mathjax":true,"_content":"\n$\\mathbf{a*x^2+b*x+c}$\n\n\n$$x={\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}$$\n\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$\n\n\n$\\sqrt{ab}$、$\\sqrt[n]{ab}$、$\\log_{a}{b}$、$\\lg{ab}$、$a^{b}$、$a_{b}$、$x_a^b$、$\\int$、$\\int_{a}^{b}$、$\\oint$、$\\oint_a^b$、$\\sum$、$\\sum_a^b$、$\\coprod$、$\\coprod_a^b$、$\\prod$、$\\prod_a^b$、$\\bigcap$、$\\bigcap_a^b$、$\\bigcup$、$\\bigcup_a^b$、$\\bigsqcup$、$\\bigsqcup_a^b$、$\\bigvee$、$\\bigvee_a^b$、$\\bigwedge$、$\\bigwedge_a^b$、$\\widetilde{ab}$、$\\widehat{ab}$、$\\overleftarrow{ab}$、$\\overrightarrow{ab}$、$\\overbrace{ab}$、$\\underbrace{ab}$、$\\underline{ab}$、$\\overline{ab}$、$\\frac{ab}{cd}$、$\\frac{\\partial a}{\\partial b}$、$\\frac{\\text{d}x}{\\text{d}y}$、$\\lim_{a \\rightarrow b}$\n\n","source":"_posts/Other/Math.md","raw":"---\ntitle: Math\ndate: 2021-04-14 10:40:11\ntags: Math\nmathjax: true\n---\n\n$\\mathbf{a*x^2+b*x+c}$\n\n\n$$x={\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}$$\n\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$\n\n\n$\\sqrt{ab}$、$\\sqrt[n]{ab}$、$\\log_{a}{b}$、$\\lg{ab}$、$a^{b}$、$a_{b}$、$x_a^b$、$\\int$、$\\int_{a}^{b}$、$\\oint$、$\\oint_a^b$、$\\sum$、$\\sum_a^b$、$\\coprod$、$\\coprod_a^b$、$\\prod$、$\\prod_a^b$、$\\bigcap$、$\\bigcap_a^b$、$\\bigcup$、$\\bigcup_a^b$、$\\bigsqcup$、$\\bigsqcup_a^b$、$\\bigvee$、$\\bigvee_a^b$、$\\bigwedge$、$\\bigwedge_a^b$、$\\widetilde{ab}$、$\\widehat{ab}$、$\\overleftarrow{ab}$、$\\overrightarrow{ab}$、$\\overbrace{ab}$、$\\underbrace{ab}$、$\\underline{ab}$、$\\overline{ab}$、$\\frac{ab}{cd}$、$\\frac{\\partial a}{\\partial b}$、$\\frac{\\text{d}x}{\\text{d}y}$、$\\lim_{a \\rightarrow b}$\n\n","slug":"Other/Math","published":1,"updated":"2023-08-22T09:52:14.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgtj0019aq7k1asw0j9q"},{"title":"诗和远方","date":"2022-10-19T03:55:28.000Z","_content":"\nLife is not only about compromise, but also peoms and dreams.\n\n<!-- more -->\n\n## 20230609\n\n![20230608_th](诗和远方/20230608_th.jpeg)\n\n### Cappadocia, Turkey\n\nIf you're traveling to Turkey, be sure to check out Cappadocia, a historic site in central Turkey. A magical moment in Cappadocia is watching dozens of hot air balloons rise into the dawn sky. If you're feeling adventurous, you can also hop on a hot air balloon ride. Cappadocia is dotted with mysterious towering rock formations up to 130 feet tall that were formed by volcanic eruptions millions of years ago and are known as \"fairy chimneys.\" Another attraction you won't see from a hot air balloon is the underground city of Delinkuyu, whose houses, markets, offices and public spaces are completely underground, dating back to 1400 BC. This underground city once provided shelter for citizens from plunder and invasion. As you experience the ancient wonders of Cappadocia, you'll have a better understanding of how old the world is.\n\n### 卡帕多西亚，土耳其\n\n如果你去土耳其旅行，一定要去卡帕多西亚打卡，这是一个位于土耳其中部的历史名胜古迹。卡帕多西亚的一个神奇时刻是观看几十个热气球升入黎明的天空。如果你喜欢冒险，你还可以坐上热气球观光。卡帕多西亚遍布着神秘的高耸岩层，高可达130英尺，由数百万年前火山喷发而形成，被称为“精灵烟囟”。这里还有一个你从热气球上无法看到景点，那就是地下城德林库尤，德林库尤的房屋、市场、办公室以及公共场所完全位于地下，整座城市的历史可以追溯到公元前1400年。这座地下城曾为市民提供庇护，让他们免受掠夺和入侵。在你体验卡帕多西亚的古代奇观时，你会更容易理解这个世界有多古老。\n\n## 202211016\n\n![20221115_th](诗和远方/20221115_th.jpeg)\n\n### 50th anniversary of the Convention concerning the Protection of the World Cultural and Natural Heritage\n\nOn 16 November 1972, UNESCO adopted the Convention concerning the Protection of the World Cultural and Natural Heritage, linking the concepts of nature conservation and cultural heritage conservation for the first time. The origin of this convention dates back to the early 60s of the last century, when Egypt built the Aswan Dam, the Nile water will flood the original site of the Abu Simbel Temple, in order to protect the historical witness and cultural treasure of human civilization, the world has actively cooperated, and finally the Convention for the Protection of the World Cultural and Natural Heritage was born.\n\nMesa Verde National Park, where the Pueblo people lived for seven centuries, was listed as one of the first World Heritage Sites by UNESCO in 1978.\n\n### 《保护世界文化和自然遗产公约》50周年\n\n1972年11月16日，联合国教科文组织通过了《保护世界文化和自然遗产公约》，首次将自然保护和文化遗产保护的概念联系起来。这个公约的起源要追溯到上世纪60年代初，埃及修建阿斯旺大坝时，尼罗河水将淹没阿布辛贝勒神庙的原址，为保护这个人类文明的历史见证和文化瑰宝，世界各国展开了积极合作，最终《保护世界文化和自然遗产公约》诞生了。\n\n梅萨维德国家公园是普韦布洛人生活了七个世纪的地方，在1978年被联合国教科文组织列为首批世界遗产之一。\n\n## 20221107\n\n![20221106_th](诗和远方/20221106_th.jpeg)\n\n### Beautiful view of Lushan Mountain in winter\n\nToday is November 7th, which coincides with the beginning of winter. Lidong is the first solar term of winter in the Chinese lunar calendar. Winter lasts from November 7 or 8 to 22 or 23. Like the beginning of spring, summer and autumn, the beginning of winter also marks the beginning of a new season.\n\nWe still maintain the custom of eating food at the beginning of winter. In southern China, people eat chicken, duck, fish and meat to celebrate this festival; In northern China, especially Beijing and Tianjin, people like to eat dumplings, which herald the arrival of winter.\n\n### 冬天的庐山美景\n\n今天是11月7日，正好是立冬时节。立冬是中国农历中冬季的第一个节气。每年立冬从11月7日或8日持续到22日或23日。跟立春、立夏、立秋一样，立冬也标志着一个新季节的开始。\n\n我们仍然保留了立冬时节吃美食的习俗。在中国南方，人们会吃鸡鸭鱼肉来庆祝这一节日；在中国北方，尤其是北京和天津，人们则喜欢吃饺子，它预示着冬天已经来临。\n\n## 20221103\n\n![20221103_th](诗和远方/20221103_th.jpeg)\n\n### Peto Lake, Banff National Park\n\nPeyto Lake is difficult to reach compared to other lakes within Banff National Park, which is elongated in a narrow shape and surrounded by steep cliffs and dense forests. The rising sun in the morning, dying the peaks of the mountains surrounding the lake golden, the cliffs and forests casting beautiful reflections in the lake, and the birds singing in the forest, this is the perfect time to see Lake Peto. Nature captivates people with its pristine appearance and conquers people's senses.\n\nSummer is the best time to visit Peito Lake to enjoy the scenery, as there is a hiking trail leading to Bow Peak, which has an observation deck with views of Peto Lake. In winter, Lake Peto freezes and the surrounding mountains are covered in snow and snow. However, be aware that the area is covered in snow from November to May each year, and the snow on the roads (including bus routes) makes it difficult to walk on foot and requires extensive snow travel experience.\n\n### 沛托湖, 班夫国家公园\n\n与班夫国家公园（Banff National Park）内的其他湖泊相比，佩托湖（Peyto Lake）是很难到达的，它呈狭长形状，被陡峭的山崖和茂密的森林包围着。清晨的旭日缓缓升起，将围绕湖水的群山山顶染成金色，峭壁和森林在湖中投下美丽的倒影，鸟儿在森林里歌唱，这是欣赏沛托湖绝佳时机。大自然用它原始的样貌吸引着人们，征服着人们的感官。\n\n夏季是来沛托湖欣赏美景的最好时机，因为会有一徒步旅行的小路通向弓峰，这里拥有一个欣赏沛托湖美景的瞭望台。冬天，佩托湖会结冰，周围的群山也被冰雪覆盖，满目皆是白雪皑皑的景色。不过冬季想要饱览这里的冰雪美景需要注意，该地区被积雪覆盖的时间是每年的11月到5月，路上的积雪很厚（包括巴士线路在内），很难徒步行走，需要有丰富的雪地旅行经验。\n\n## 20221101\n  \n![20221101_th](诗和远方/20221101_th.jpeg)\n\n### Munard, India\n\nLocated in the Iduki district of Kerala, India, Munar is known as the \"Kashmir of South India\", at an altitude of 1600 meters, and was once the summer residence of the British royal family. Today Munnar is a popular honeymoon resort and tourist destination. When one thinks of Munnar, one immediately reminds one of the local tea plantations. Our photo today is of Munnar's tea plantations.\n\nLocated in the mountains of the Western Ghats, Munar is a great place to visit all year round. There are countless tea plantations, beautiful valleys, winding mountain roads, exotic flora and fauna, picturesque towns and waterfalls. It's all tempting you to stop, take a break in the embrace of nature and have a cup of hot tea by the way. Sounds tempting.\n\n### 慕纳尔，印度\n\n慕纳尔位于印度喀拉拉邦的伊杜基区，素有“南印度的克什米尔”的美名，海拔1600米，曾一度是英国王室的避暑地。今天的慕纳尔是一个热门的蜜月度假地和旅游胜地。一提起慕纳尔，人们还会马上联想起当地漫山遍野的茶叶种植园。我们今天的照片便是慕纳尔的茶园。\n\n慕纳尔位于西高止山脉的群山之中，一年四季都是个旅游的好去处。这里有着数不尽的茶园、美丽的山谷、蜿蜒的山路、奇特的异域动植物、风景如画的小镇以及瀑布。这一切都在蛊惑你停下来，在大自然的怀抱中歇一下，顺便喝杯热茶。听起来确实挺诱人呢。\n\n## 20221018\n\n![20221018_th](诗和远方/20221018_th.jpeg)\n\n### Waterburg and Thuringian Forest, Germany\n\nAs you admire the beauty of the Thuringian forest in Germany in today's photo, pay attention to the castle in the distance. That's Waterburg, built in the Middle Ages. Martin Luther translated the New Testament into German at Waterburg while in exile. It is the most popular tourist destination in the region and is known worldwide for its typical medieval architectural features.\n\nThe name of Waterburg comes from a play on words. \"Warte\" means both \"watchtower\" and \"etc.\" in German. It is said that the builders of the castle exclaimed \"Warte, Berg—du sollst mir eine Burg tragen!\" when they saw the site, meaning \"Wait, there must be a castle on this hill!\" The \"berg\" and \"burg\" in this sentence mean mountains and fortresses, respectively. The name Wartburg was born.\n\nIf castles aren't your thing, the Thuringian Forest known as the green heart of Germany is also attractive. The Reynsteink Trail is Germany's oldest and most popular long-distance hike, with about 110 miles of forest spanning. On the way, you will feel the tranquility and fresh, pollution-free air here. You might even happen to crash into the small villages dotted around the area and feel their hospitality.\n\n### 瓦特堡与图林根森林，德国\n\n在你欣赏今天照片里德国图林根森林的美景时，请注意远处的城堡。那是瓦特堡，建于中世纪。马丁·路德流亡期间就在瓦特堡将《新约》翻译成了德语。它是该地区最受欢迎的旅游胜地，并因其典型的中世纪建筑特色而闻名于世。\n\n瓦特堡名字的来源于一场文字游戏。“瓦特（Warte）”在德语中既有“瞭望塔”的意思，也有“等等”的意思。据说，城堡的修建者在看到这个地点时惊呼“Warte, Berg—du sollst mir eine Burg tragen!”，意思是“等等，这山上得有座城堡！”这句话中的“berg”和“burg”，分别意为山和堡垒。瓦特堡（Wartburg）这个名字就此诞生了。\n\n如果你对城堡没兴趣，那么被称为德国绿色心脏的图林根森林也是充满吸引力的。雷恩施泰克登山道是德国最古老、最受欢迎的长途徒步路线，它在森林中蔓延约110英里。你会在途中感受到这里的宁静和清新、无污染的空气。说不定你还会碰巧撞进遍布该区域的小村庄，感受他们的热情好客。","source":"_posts/Other/诗和远方.md","raw":"---\ntitle: 诗和远方\ndate: 2022-10-19 11:55:28\ntags:\n---\n\nLife is not only about compromise, but also peoms and dreams.\n\n<!-- more -->\n\n## 20230609\n\n![20230608_th](诗和远方/20230608_th.jpeg)\n\n### Cappadocia, Turkey\n\nIf you're traveling to Turkey, be sure to check out Cappadocia, a historic site in central Turkey. A magical moment in Cappadocia is watching dozens of hot air balloons rise into the dawn sky. If you're feeling adventurous, you can also hop on a hot air balloon ride. Cappadocia is dotted with mysterious towering rock formations up to 130 feet tall that were formed by volcanic eruptions millions of years ago and are known as \"fairy chimneys.\" Another attraction you won't see from a hot air balloon is the underground city of Delinkuyu, whose houses, markets, offices and public spaces are completely underground, dating back to 1400 BC. This underground city once provided shelter for citizens from plunder and invasion. As you experience the ancient wonders of Cappadocia, you'll have a better understanding of how old the world is.\n\n### 卡帕多西亚，土耳其\n\n如果你去土耳其旅行，一定要去卡帕多西亚打卡，这是一个位于土耳其中部的历史名胜古迹。卡帕多西亚的一个神奇时刻是观看几十个热气球升入黎明的天空。如果你喜欢冒险，你还可以坐上热气球观光。卡帕多西亚遍布着神秘的高耸岩层，高可达130英尺，由数百万年前火山喷发而形成，被称为“精灵烟囟”。这里还有一个你从热气球上无法看到景点，那就是地下城德林库尤，德林库尤的房屋、市场、办公室以及公共场所完全位于地下，整座城市的历史可以追溯到公元前1400年。这座地下城曾为市民提供庇护，让他们免受掠夺和入侵。在你体验卡帕多西亚的古代奇观时，你会更容易理解这个世界有多古老。\n\n## 202211016\n\n![20221115_th](诗和远方/20221115_th.jpeg)\n\n### 50th anniversary of the Convention concerning the Protection of the World Cultural and Natural Heritage\n\nOn 16 November 1972, UNESCO adopted the Convention concerning the Protection of the World Cultural and Natural Heritage, linking the concepts of nature conservation and cultural heritage conservation for the first time. The origin of this convention dates back to the early 60s of the last century, when Egypt built the Aswan Dam, the Nile water will flood the original site of the Abu Simbel Temple, in order to protect the historical witness and cultural treasure of human civilization, the world has actively cooperated, and finally the Convention for the Protection of the World Cultural and Natural Heritage was born.\n\nMesa Verde National Park, where the Pueblo people lived for seven centuries, was listed as one of the first World Heritage Sites by UNESCO in 1978.\n\n### 《保护世界文化和自然遗产公约》50周年\n\n1972年11月16日，联合国教科文组织通过了《保护世界文化和自然遗产公约》，首次将自然保护和文化遗产保护的概念联系起来。这个公约的起源要追溯到上世纪60年代初，埃及修建阿斯旺大坝时，尼罗河水将淹没阿布辛贝勒神庙的原址，为保护这个人类文明的历史见证和文化瑰宝，世界各国展开了积极合作，最终《保护世界文化和自然遗产公约》诞生了。\n\n梅萨维德国家公园是普韦布洛人生活了七个世纪的地方，在1978年被联合国教科文组织列为首批世界遗产之一。\n\n## 20221107\n\n![20221106_th](诗和远方/20221106_th.jpeg)\n\n### Beautiful view of Lushan Mountain in winter\n\nToday is November 7th, which coincides with the beginning of winter. Lidong is the first solar term of winter in the Chinese lunar calendar. Winter lasts from November 7 or 8 to 22 or 23. Like the beginning of spring, summer and autumn, the beginning of winter also marks the beginning of a new season.\n\nWe still maintain the custom of eating food at the beginning of winter. In southern China, people eat chicken, duck, fish and meat to celebrate this festival; In northern China, especially Beijing and Tianjin, people like to eat dumplings, which herald the arrival of winter.\n\n### 冬天的庐山美景\n\n今天是11月7日，正好是立冬时节。立冬是中国农历中冬季的第一个节气。每年立冬从11月7日或8日持续到22日或23日。跟立春、立夏、立秋一样，立冬也标志着一个新季节的开始。\n\n我们仍然保留了立冬时节吃美食的习俗。在中国南方，人们会吃鸡鸭鱼肉来庆祝这一节日；在中国北方，尤其是北京和天津，人们则喜欢吃饺子，它预示着冬天已经来临。\n\n## 20221103\n\n![20221103_th](诗和远方/20221103_th.jpeg)\n\n### Peto Lake, Banff National Park\n\nPeyto Lake is difficult to reach compared to other lakes within Banff National Park, which is elongated in a narrow shape and surrounded by steep cliffs and dense forests. The rising sun in the morning, dying the peaks of the mountains surrounding the lake golden, the cliffs and forests casting beautiful reflections in the lake, and the birds singing in the forest, this is the perfect time to see Lake Peto. Nature captivates people with its pristine appearance and conquers people's senses.\n\nSummer is the best time to visit Peito Lake to enjoy the scenery, as there is a hiking trail leading to Bow Peak, which has an observation deck with views of Peto Lake. In winter, Lake Peto freezes and the surrounding mountains are covered in snow and snow. However, be aware that the area is covered in snow from November to May each year, and the snow on the roads (including bus routes) makes it difficult to walk on foot and requires extensive snow travel experience.\n\n### 沛托湖, 班夫国家公园\n\n与班夫国家公园（Banff National Park）内的其他湖泊相比，佩托湖（Peyto Lake）是很难到达的，它呈狭长形状，被陡峭的山崖和茂密的森林包围着。清晨的旭日缓缓升起，将围绕湖水的群山山顶染成金色，峭壁和森林在湖中投下美丽的倒影，鸟儿在森林里歌唱，这是欣赏沛托湖绝佳时机。大自然用它原始的样貌吸引着人们，征服着人们的感官。\n\n夏季是来沛托湖欣赏美景的最好时机，因为会有一徒步旅行的小路通向弓峰，这里拥有一个欣赏沛托湖美景的瞭望台。冬天，佩托湖会结冰，周围的群山也被冰雪覆盖，满目皆是白雪皑皑的景色。不过冬季想要饱览这里的冰雪美景需要注意，该地区被积雪覆盖的时间是每年的11月到5月，路上的积雪很厚（包括巴士线路在内），很难徒步行走，需要有丰富的雪地旅行经验。\n\n## 20221101\n  \n![20221101_th](诗和远方/20221101_th.jpeg)\n\n### Munard, India\n\nLocated in the Iduki district of Kerala, India, Munar is known as the \"Kashmir of South India\", at an altitude of 1600 meters, and was once the summer residence of the British royal family. Today Munnar is a popular honeymoon resort and tourist destination. When one thinks of Munnar, one immediately reminds one of the local tea plantations. Our photo today is of Munnar's tea plantations.\n\nLocated in the mountains of the Western Ghats, Munar is a great place to visit all year round. There are countless tea plantations, beautiful valleys, winding mountain roads, exotic flora and fauna, picturesque towns and waterfalls. It's all tempting you to stop, take a break in the embrace of nature and have a cup of hot tea by the way. Sounds tempting.\n\n### 慕纳尔，印度\n\n慕纳尔位于印度喀拉拉邦的伊杜基区，素有“南印度的克什米尔”的美名，海拔1600米，曾一度是英国王室的避暑地。今天的慕纳尔是一个热门的蜜月度假地和旅游胜地。一提起慕纳尔，人们还会马上联想起当地漫山遍野的茶叶种植园。我们今天的照片便是慕纳尔的茶园。\n\n慕纳尔位于西高止山脉的群山之中，一年四季都是个旅游的好去处。这里有着数不尽的茶园、美丽的山谷、蜿蜒的山路、奇特的异域动植物、风景如画的小镇以及瀑布。这一切都在蛊惑你停下来，在大自然的怀抱中歇一下，顺便喝杯热茶。听起来确实挺诱人呢。\n\n## 20221018\n\n![20221018_th](诗和远方/20221018_th.jpeg)\n\n### Waterburg and Thuringian Forest, Germany\n\nAs you admire the beauty of the Thuringian forest in Germany in today's photo, pay attention to the castle in the distance. That's Waterburg, built in the Middle Ages. Martin Luther translated the New Testament into German at Waterburg while in exile. It is the most popular tourist destination in the region and is known worldwide for its typical medieval architectural features.\n\nThe name of Waterburg comes from a play on words. \"Warte\" means both \"watchtower\" and \"etc.\" in German. It is said that the builders of the castle exclaimed \"Warte, Berg—du sollst mir eine Burg tragen!\" when they saw the site, meaning \"Wait, there must be a castle on this hill!\" The \"berg\" and \"burg\" in this sentence mean mountains and fortresses, respectively. The name Wartburg was born.\n\nIf castles aren't your thing, the Thuringian Forest known as the green heart of Germany is also attractive. The Reynsteink Trail is Germany's oldest and most popular long-distance hike, with about 110 miles of forest spanning. On the way, you will feel the tranquility and fresh, pollution-free air here. You might even happen to crash into the small villages dotted around the area and feel their hospitality.\n\n### 瓦特堡与图林根森林，德国\n\n在你欣赏今天照片里德国图林根森林的美景时，请注意远处的城堡。那是瓦特堡，建于中世纪。马丁·路德流亡期间就在瓦特堡将《新约》翻译成了德语。它是该地区最受欢迎的旅游胜地，并因其典型的中世纪建筑特色而闻名于世。\n\n瓦特堡名字的来源于一场文字游戏。“瓦特（Warte）”在德语中既有“瞭望塔”的意思，也有“等等”的意思。据说，城堡的修建者在看到这个地点时惊呼“Warte, Berg—du sollst mir eine Burg tragen!”，意思是“等等，这山上得有座城堡！”这句话中的“berg”和“burg”，分别意为山和堡垒。瓦特堡（Wartburg）这个名字就此诞生了。\n\n如果你对城堡没兴趣，那么被称为德国绿色心脏的图林根森林也是充满吸引力的。雷恩施泰克登山道是德国最古老、最受欢迎的长途徒步路线，它在森林中蔓延约110英里。你会在途中感受到这里的宁静和清新、无污染的空气。说不定你还会碰巧撞进遍布该区域的小村庄，感受他们的热情好客。","slug":"Other/诗和远方","published":1,"updated":"2023-08-22T09:52:14.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgto001baq7k1cabrxw2"},{"title":"Swift简介","date":"2022-09-29T06:24:40.000Z","_content":"\n[Swift 当前版本](https://github.com/apple/swift/releases)\n\n[Swift 源码](https://github.com/apple/swift)\n\n<!-- more -->\n\n## Swift 版本历史\n\n![Swift01](Swift简介/Swift01.png)\n\nSwift 从2014年至今发布了多个版本，其中有 5 大版本，[查看当前版本](https://github.com/apple/swift/releases)。而 Objective-C 从80年代至今，只有两个版本。2015年12月 Swift 正式[开源](https://github.com/apple/swift)。\n\n* Swift 2\n\n  * Error handling 增强\n  * guard 语法\n  * 协议支持扩展\n\n* Swift 3\n\n  * 新的 GCD 和 Core Graphics\n  * NS 前缀从老的 Foundation 类型中移除\n  * 内联序列函数 sequence\n  * 新增 filePrivate 和 open 两个权限控制\n  * 移除了诸多弃用的特性，如 `++`、`--`运算符等\n\n* Swift4\n\n  * extension 中可以访问 private 的属性\n  * 类型和协议的组合类型\n  * Associated Type 可以追加 Where 约束语句\n  * 新的 Key Paths 语法\n  * 下标支持泛型\n  * 字符串增强\n\n* Swift5\n\n  * ABI 稳定\n  * Raw strings\n  * 标准库新增 Result\n  * 定义了与 Python 或 Ruby 等脚本语言互操作的动态可调用类型\n\n## Swift VS Objective-C\n\n### 编程范式\n\n* Swift 可以面向协议编程、函数式编程、面向对象编程。\n* Objective-C 以面向对象编程为主，当然也可以通过引入 ReactiveCocoa 类库进行函数式编程。\n\n### 类型安全\n\n* Swift 是一门类型安全的语言，在代码中要求清楚明确值的类型。Swift 会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。如果代码中使用一个字符串 String，在传递一个整型 Int 给它时，编译器就会报错。\n* Objective-C 虽然在编译时也会做类型检查，但是只会给出警告提示，并不会报错。比如声明一个 NSString 变量，可以传一个 NSNumber 给它，并且可以将它作为 NSNumber 用。\n\n### 值类型增强\n\n* 在 Swift 中，struct、enum 和 tuple 都是值类型，并且 Int、Double、Float、String、Array、Dictionary、Set 也都是用结构体实现的，都是值类型。\n* Objective-C 中，NSNumber、NSString 以及集合类对象都是指针类型。\n\n### 枚举增强\n\n* Swift 的枚举可以使用整型、浮点型、字符串等，还能拥有属性和方法，甚至支持泛型、协议、扩展等等。\n* Objective-C 里面的枚举则没有这些功能。\n\n### 泛型\n\n* Swift 中支持泛型，也支持泛型的类型约束等特性。\n* 苹果推出了 Swift2.0 版本时，也为 Objective-C 带来了 泛型支持。\n\n### 协议和扩展\n\n* Swift 对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时，Swift 中的 Protocol 还可以用于值类型，如结构体和枚举。\n* Objective-C 的协议缺乏强约束，提供的 optional 特性往往成为很多问题的来源，而如果放弃 optional 又会让实现代价过大，每次调用代理方法前，都需要判断代理方法是否实现。\n\n### 函数和闭包\n\n* Swift 里函数是一等公民，可以直接定义函数类型变量，可以作为其它函数参数传递，可以作为函数返回值返回。\n* Objective-C 里函数是次等公民，需要 selector 封装或者使用 block 才能模拟 Swift 中类似的效果。\n\n## Swift 命令行编译\n\n![Swift02](Swift简介/Swift02.png)\n\n### LLVM  \n\n![Swift04](Swift简介/Swift04.png)\n\n上图是经典的 LLVM 三段式架构，分为前端（Frontend）、优化器（Optimizer）和后端（Backend）。当需要支持新语言时，只需要实现实现前端部分，需要支持新的架构只需要实现后端部分，而前后端的连接枢纽就是 IR（Intermediate Representation），IR 独立于编程语言和机器架构，所以 IR 阶段的优化可以做到抽象而通用。\n\nLLVM 是架构编译器的框架系统，以 C++ 编写而成，用于优化任意程序语言编写的程序的编译时间（compile-time）、链接时间（link-time）、运行时间（run-time）以及空闲时间（idle-time）。对开发者保持开放，并兼容已有脚本。  \n\n对于 iOS 系统，Objective-C 语言前端使用 Clang 编译器，而 Swift 语言前端使用 Swiftc 编译器。编译器将代码编译成 IR 中间代码，交给 LLVM 进行优化，接着交给代码生成器生成机器语言，最终生成 .o 机器执行文件。\n\n### 编译过程\n\n![Swift03](Swift简介/Swift03.png)\n\n### Swiftc\n\n第一步：编译生成可执行文件\n\n```swift\nswiftc -o main.out main.swift\n```\n\n第二步：生成抽象语法树（Swift Abstract Syntax Tree 【AST】）\n\n```swift\nswiftc main.swift -dump-ast\n```\n\n第三步：生成中间语言（Swift Intermediate Language 【SIL】）\n\n```swift\nswiftc main.swift -emit-sil\n```\n\n第四步：生成中间表示层语言（LLVM Intermediate Representation 【LLVM IR】）\n\n```swift\nswiftc main.swift -emit-ir\n```\n\n第五步：生成汇编语言（Assembly Language）\n\n```swift\nswiftc main.swift -emit-assembly\n```\n\n## Swift REPL\n\nRead Eval PrintLoop，简称 REPL。是 Xcode 6.1 引入的另外一种以交互式的方式体验 Swift 的方法。\n\n进入 REPL：\n![Swift05](Swift简介/Swift05.png)\n\n运行代码：\n![Swift06](Swift简介/Swift06.png)\n\n定义函数实现和函数调用：\n![Swift07](Swift简介/Swift07.png)\n\nps：在函数实现部分，如果需要换行，使用 `Control + enter`。大括号需要敲一个，回车后编写完代码，在敲入最后一个。\n\n### 常用命令\n\n* 退出 `:quit`\n* 帮助 `:help`\n* 将光标移动到当前行的开始处 `Control+A`\n* 将光标移动到当前行的结束处 `Control+E`  \n\n![Swift08](Swift简介/Swift08.png)\n\n## Playground\n\n创建 `File->New->Playground` 或者 `option+shift+command+N`\n![Swift12](Swift简介/12.png)\n![Swift13](Swift简介/13.png)\n![Swift14](Swift简介/14.png)\n\n新建 Playground Page\n![Swift15](Swift简介/15.png)\n\n自定义命名\n![Swift16](Swift简介/16.png)\n![Swift17](Swift简介/17.png)\n\n## Playground 能力\n\n![Swift18](Swift简介/18.png)\n\n## 创建 Swift 项目\n\n![Swift09](Swift简介/Swift09.png)\n\n![Swift10](Swift简介/Swift10.png)\n\n## SwiftUI\n\n![Swift11](Swift简介/Swift11.png)\n\n参考博文：  \n\n[Swift：编译流程](https://www.jianshu.com/p/ba7b80f181f6)  \n[Swift编译流程 & Swift类](https://www.jianshu.com/p/e917bf0e8a7d)  \n[Swift 编译过程](https://www.jianshu.com/p/771604d38f0e)","source":"_posts/Swift/Swift简介.md","raw":"---\ntitle: Swift简介\ndate: 2022-09-29 14:24:40\ntags: Swift\n---\n\n[Swift 当前版本](https://github.com/apple/swift/releases)\n\n[Swift 源码](https://github.com/apple/swift)\n\n<!-- more -->\n\n## Swift 版本历史\n\n![Swift01](Swift简介/Swift01.png)\n\nSwift 从2014年至今发布了多个版本，其中有 5 大版本，[查看当前版本](https://github.com/apple/swift/releases)。而 Objective-C 从80年代至今，只有两个版本。2015年12月 Swift 正式[开源](https://github.com/apple/swift)。\n\n* Swift 2\n\n  * Error handling 增强\n  * guard 语法\n  * 协议支持扩展\n\n* Swift 3\n\n  * 新的 GCD 和 Core Graphics\n  * NS 前缀从老的 Foundation 类型中移除\n  * 内联序列函数 sequence\n  * 新增 filePrivate 和 open 两个权限控制\n  * 移除了诸多弃用的特性，如 `++`、`--`运算符等\n\n* Swift4\n\n  * extension 中可以访问 private 的属性\n  * 类型和协议的组合类型\n  * Associated Type 可以追加 Where 约束语句\n  * 新的 Key Paths 语法\n  * 下标支持泛型\n  * 字符串增强\n\n* Swift5\n\n  * ABI 稳定\n  * Raw strings\n  * 标准库新增 Result\n  * 定义了与 Python 或 Ruby 等脚本语言互操作的动态可调用类型\n\n## Swift VS Objective-C\n\n### 编程范式\n\n* Swift 可以面向协议编程、函数式编程、面向对象编程。\n* Objective-C 以面向对象编程为主，当然也可以通过引入 ReactiveCocoa 类库进行函数式编程。\n\n### 类型安全\n\n* Swift 是一门类型安全的语言，在代码中要求清楚明确值的类型。Swift 会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。如果代码中使用一个字符串 String，在传递一个整型 Int 给它时，编译器就会报错。\n* Objective-C 虽然在编译时也会做类型检查，但是只会给出警告提示，并不会报错。比如声明一个 NSString 变量，可以传一个 NSNumber 给它，并且可以将它作为 NSNumber 用。\n\n### 值类型增强\n\n* 在 Swift 中，struct、enum 和 tuple 都是值类型，并且 Int、Double、Float、String、Array、Dictionary、Set 也都是用结构体实现的，都是值类型。\n* Objective-C 中，NSNumber、NSString 以及集合类对象都是指针类型。\n\n### 枚举增强\n\n* Swift 的枚举可以使用整型、浮点型、字符串等，还能拥有属性和方法，甚至支持泛型、协议、扩展等等。\n* Objective-C 里面的枚举则没有这些功能。\n\n### 泛型\n\n* Swift 中支持泛型，也支持泛型的类型约束等特性。\n* 苹果推出了 Swift2.0 版本时，也为 Objective-C 带来了 泛型支持。\n\n### 协议和扩展\n\n* Swift 对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时，Swift 中的 Protocol 还可以用于值类型，如结构体和枚举。\n* Objective-C 的协议缺乏强约束，提供的 optional 特性往往成为很多问题的来源，而如果放弃 optional 又会让实现代价过大，每次调用代理方法前，都需要判断代理方法是否实现。\n\n### 函数和闭包\n\n* Swift 里函数是一等公民，可以直接定义函数类型变量，可以作为其它函数参数传递，可以作为函数返回值返回。\n* Objective-C 里函数是次等公民，需要 selector 封装或者使用 block 才能模拟 Swift 中类似的效果。\n\n## Swift 命令行编译\n\n![Swift02](Swift简介/Swift02.png)\n\n### LLVM  \n\n![Swift04](Swift简介/Swift04.png)\n\n上图是经典的 LLVM 三段式架构，分为前端（Frontend）、优化器（Optimizer）和后端（Backend）。当需要支持新语言时，只需要实现实现前端部分，需要支持新的架构只需要实现后端部分，而前后端的连接枢纽就是 IR（Intermediate Representation），IR 独立于编程语言和机器架构，所以 IR 阶段的优化可以做到抽象而通用。\n\nLLVM 是架构编译器的框架系统，以 C++ 编写而成，用于优化任意程序语言编写的程序的编译时间（compile-time）、链接时间（link-time）、运行时间（run-time）以及空闲时间（idle-time）。对开发者保持开放，并兼容已有脚本。  \n\n对于 iOS 系统，Objective-C 语言前端使用 Clang 编译器，而 Swift 语言前端使用 Swiftc 编译器。编译器将代码编译成 IR 中间代码，交给 LLVM 进行优化，接着交给代码生成器生成机器语言，最终生成 .o 机器执行文件。\n\n### 编译过程\n\n![Swift03](Swift简介/Swift03.png)\n\n### Swiftc\n\n第一步：编译生成可执行文件\n\n```swift\nswiftc -o main.out main.swift\n```\n\n第二步：生成抽象语法树（Swift Abstract Syntax Tree 【AST】）\n\n```swift\nswiftc main.swift -dump-ast\n```\n\n第三步：生成中间语言（Swift Intermediate Language 【SIL】）\n\n```swift\nswiftc main.swift -emit-sil\n```\n\n第四步：生成中间表示层语言（LLVM Intermediate Representation 【LLVM IR】）\n\n```swift\nswiftc main.swift -emit-ir\n```\n\n第五步：生成汇编语言（Assembly Language）\n\n```swift\nswiftc main.swift -emit-assembly\n```\n\n## Swift REPL\n\nRead Eval PrintLoop，简称 REPL。是 Xcode 6.1 引入的另外一种以交互式的方式体验 Swift 的方法。\n\n进入 REPL：\n![Swift05](Swift简介/Swift05.png)\n\n运行代码：\n![Swift06](Swift简介/Swift06.png)\n\n定义函数实现和函数调用：\n![Swift07](Swift简介/Swift07.png)\n\nps：在函数实现部分，如果需要换行，使用 `Control + enter`。大括号需要敲一个，回车后编写完代码，在敲入最后一个。\n\n### 常用命令\n\n* 退出 `:quit`\n* 帮助 `:help`\n* 将光标移动到当前行的开始处 `Control+A`\n* 将光标移动到当前行的结束处 `Control+E`  \n\n![Swift08](Swift简介/Swift08.png)\n\n## Playground\n\n创建 `File->New->Playground` 或者 `option+shift+command+N`\n![Swift12](Swift简介/12.png)\n![Swift13](Swift简介/13.png)\n![Swift14](Swift简介/14.png)\n\n新建 Playground Page\n![Swift15](Swift简介/15.png)\n\n自定义命名\n![Swift16](Swift简介/16.png)\n![Swift17](Swift简介/17.png)\n\n## Playground 能力\n\n![Swift18](Swift简介/18.png)\n\n## 创建 Swift 项目\n\n![Swift09](Swift简介/Swift09.png)\n\n![Swift10](Swift简介/Swift10.png)\n\n## SwiftUI\n\n![Swift11](Swift简介/Swift11.png)\n\n参考博文：  \n\n[Swift：编译流程](https://www.jianshu.com/p/ba7b80f181f6)  \n[Swift编译流程 & Swift类](https://www.jianshu.com/p/e917bf0e8a7d)  \n[Swift 编译过程](https://www.jianshu.com/p/771604d38f0e)","slug":"Swift/Swift简介","published":1,"updated":"2023-08-22T09:52:14.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgtt001eaq7kkx2dmwco"},{"title":"函数和闭包","date":"2023-03-15T07:04:35.000Z","_content":"\n* [函数的定义](#函数的定义)\n* [函数实际参数标签和形式参数名](#函数实际参数标签和形式参数名)\n* [函数类型和内嵌函数](#函数类型和内嵌函数)\n* [闭包](#闭包)\n* [高阶函数](#高阶函数)\n* [函数式编程](#函数式编程)\n* [并行](#并行)\n\n<!-- more -->\n\n## 函数的定义\n\n函数是一个独立的代码块，用来执行特定的任务。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来“调用”函数执行它的任务。\n\n### 定义和调用函数\n\n在定义一个函数时，可以定义一个或者多个被命名的分类的值，作为函数的输入（形式参数）。在函数完成后，也可以定义将要传回的值作为输出的类型（返回类型）。\n\n每一个函数都有一个函数名，它描述了函数执行的任务。要使用一个函数，可以通过“调用”函数的名字并且传入符合函数形式参数类型的输入值（实际参数）来调用这个函数。给函数提供的实际参数的顺序必须符合函数的形式参数列表顺序。\n\n```swift\nimport Foundation\n\nfunc greet(person: String) -> String {\n    let greeting = \"Hello, \" + person + \"!\"\n    return greeting\n}\n\ngreet(person: \"zhangsan\")\n// Prints 'Hello, zhangsan!'\n```\n\n### 无形式参数的函数\n\n函数没有要求必须输入一个参数，可以没有形式参数。函数的定义需要在名字后边加一个圆括号`()`，即使在不接受形式参数时也得这样做。当函数被调用的时候同样要在函数的名字后边加一个空的圆括号`()`。\n\n```swift\nfunc sayHello() -> String {\n    return \"hello\"\n}\nprint(sayHello())\n// Prints 'hello'\n```\n\n### 多形式参数的函数\n\n函数可以输入多个形式参数，写在函数后边的圆括号内，用逗号分隔。\n\n```swift\nfunc greetAgain(person: String) -> String {\n    return \"Hello again, \\(person)\"\n}\n\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)\"\n}\n\nfunc greet(person: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return greetAgain(person: person)\n    } else {\n        return greet(person: person)\n    }\n}\n\nprint(greet(person: \"Kevin\", alreadyGreeted: true))\n// Prints 'Hello again, Kevin'\n```\n\n### 无返回值的函数\n\n函数定义中没有要求必须有一个返回类型。不需要返回值，函数在定义的时候就没有包含返回箭头`->`或者返回类型。\n\n严格来讲，尽管函数 `greet(person:)`没有定义返回值，但是它还是有一个返回值的。没有定义返回类型的函数实际上会返回一个特殊的类型 `Void`，它是一个空的元组，作用相当于没有元素的元组，可以写作 `()`。\n\n```swift\nfunc greet(person: String) {\n    print(\"Hello, \\(person)\")\n}\n\nprint(greet(person: \"kevin\"))\n```\n\n打印结果：\n\n```js\nHello, kevin\n()\n```\n\n### 多返回值的函数\n\n为了让函数返回多个值作为一个复合的返回值，可以使用元组类型作为返回类型。\n\n```swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 711]) {\n    print(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n}\n// Prints 'min is -6 and max is 711'\n```\n\n### 可选元组返回类型\n\n如果函数返回的元组可能“没有值”，可以用一个**可选元组返回类型**来表示整个元组可能是 `nil`。写法是在可选元组类型的圆括号后边添加一个问号`?`，例如：`(Int, Int)?` 或者 `(String, Int, Bool)?`。\n\n```swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.count == 0 {\n        return nil\n    }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nprint(minMax(array: []))\n// Prints 'nil'\n```\n\n### 隐式返回的函数\n\n如果整个函数体是一个单一表达式，那么函数隐式返回这个表达式，不需要 return 关键字。\n\n```swift\nfunc greeting(for person: String) -> String {\n    \"Hello, \" + person + \"!\"\n}\nprint(greeting(for: \"Kevin\"))\n// Prints 'Hello, Kevin!'\n```\n\n上面的写法等价于👇\n\n```swift\nfunc anotherGreeting(for person: String) -> String {\n    return \"Hello, \" + person + \"!\"\n}\nprint(anotherGreeting(for: \"Kevin\"))\n// Prints 'Hello, Kevin!'\n```\n\n## 函数实际参数标签和形式参数名\n\n形式参数：值形式参数、变量形式参数。函数或过程**定义时的参数**为形式参数。\n实际参数：函数或过程**调用时的参数**为实际参数。\n\n### 实参标签和形参名\n\n每一个函数的**形式参数**都包含**实际参数标签**和**形式参数名**。实际参数标签用在调用函数的时候，在调用函数的时候每一个**实际参数**前边都要写**实际参数标签**。形式参数名用在函数的实现当中，默认情况下，形式参数使用**形式参数名**作为**实际参数标签**。所有的形式参数必须有唯一的名字。尽管多个形式参数拥有相同的实际参数标签也是有可能的，但是唯一的实际参数标签有助于让代码更加易读。\n\n参数由形式参数名代替实际参数标签👇\n\n![01](../Swift/函数和闭包/01.png)\n\n```swift\nfunc someFunction(【形式参数名】: Int, 【形式参数名】: Int) {\n    print(\"\\(【形式参数名】), \\(【形式参数名】)\")\n}\n\nsomeFunction(【形式参数名】：【实际参数】, 【形式参数名】：【实际参数】)\n```\n\n### 指定实际参数标签\n\n在提供形式参数名之前写实际参数标签，用空格分隔。如果为一个形式参数提供了实际参数标签，那么这个实际参数就必须在调用函数的时候使用标签。实际参数标签的使用能够让函数的调用更加明确，更像是自然语句，同时还能提供更可读的函数体并更清晰的表达函数的意图。\n\n```swift\nfunc greet(person: String, from hometown: String) -> String {\n    return \"Hello \\(person)! Glad you could visit from \\(hometown).\"\n}\n\nprint(greet(person: \"Kevin\", from: \"Cupertion\"))\n// Prints 'Hello Kevin! Glad you could visit from Cupertion.'\n```\n\n```swift\nfunc greet(【形式参数名】: String, 【实际参数标签】【形式参数名】: String) -> String {\n    return \"Hello \\(【形式参数名】)! Glad you could visit from \\(【形式参数名】).\"\n}\n\nsomeFunction(【形式参数名】：【实际参数】, 【实际参数标签】：【实际参数】)\n```\n\n### 省略实际参数标签\n\n如果对于函数的形式参数不想使用实际参数标签的话，可以**利用下划线 `_` 来代替显示的实际参数标签**。\n\n第一个参数不使用实际参数标签，第二个参数由形式参数名代替实际参数标签👇\n\n![02](../Swift/函数和闭包/02.png)\n\n```swift\nfunc someFunction(_ firstParameterName: Int, secondParameterName: Int) {\n    print(firstParameterName, secondParameterName)\n}\n\nsomeFunction(1, secondParameterName: 2)\n// Prints '1 2'\n```\n\n### 默认形式参数值\n\n给形式参数定义默认值：在形式参数类型后赋一个值作为默认值。如果定义了默认值，在调用函数时可以省略这个形式参数。\n\n![03](../Swift/函数和闭包/03.png)\n\n```swift\nfunc someFunction(parameterWithDefault: Int = 12) {\n    print(parameterWithDefault)\n}\n\nsomeFunction(parameterWithDefault: 6) // Prints '6'\nsomeFunction() // Prints '12'\n```\n\n### 可变形式参数\n\n在形式参数的**类型名称后边**插入三个点符号`...`来书写可变形式参数。`...`（可变形式参数）声明形式参数可以被传入值的数量是可变的。一个可变形式参数可以接受零或者多个特定类型的值，传入到可变参数中的值在函数体内被当作是对应类型的数组。\n\n![04](../Swift/函数和闭包/04.png)\n\n```swift\nfunc arithmeticMean(_ numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\n\nprint(arithmeticMean(1, 2, 3, 4, 5)) //Prints '3.0'\nprint(arithmeticMean(3, 8.25, 18.75)) //Prints '10.0'\n```\n\n### 输入输出形式参数\n\n在定义形式参数时，**在前边添加一个 `inout`** 关键字可以定义一个输入输出形式参数。输入输出形式参数有一个能输入给函数的值，函数能对其进行修改，还能输出到函数外边替换原来的值。**只能把变量作为输入输出形式参数的实际参数**。在调用函数时，将变量作为实际参数传递给输入输出形式参数，直接在它前边添加一个和符号`&`来明确可以被函数修改。**输入输出形式参数不能有默认值，可变形式参数不能标记 inout**。\n\n```swift\nfunc swapTowInts(_ a: inout Int, _ b: inout Int) {\n    let temp = a\n    a = b\n    b = temp\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTowInts(&someInt, &anotherInt)\nprint(\"someInt is \\(someInt), anotherInt is \\(anotherInt)\")\n//Prints 'someInt is 107, anotherInt is 3'\n```\n\n### 值形式参数\n\n值形式参数也可以叫做常量形式参数。\n\n值形式参数的作用：值形参从与它位置对应的实参中接收数据，并把数据传送到所在的函数中。\n\n📢注意：当函数被调用时，系统为每个值形参开辟临时的存储单元，并按从左到右的顺序，把实在参数的值——赋给对应位置上的形式参数。值形参作为子程序的局部变量，当函数返回程序后，值形参的存储单元释放。\n\n### 变量形式参数\n\n必须在形参名的前面加上 `var`。\n\n变量形参的作用：变量形参可以将子程序调用过程中产生的值返回调用它的程序。\n\n📢注意：当函数被调用时，系统并不会为变量形参开辟临时的存储单元，而是让它们和对应的实参共用存储单元。也就是说，调用函数时是将实参的地址传递给对应的变量形参。\n\n### 值形式参数和变量形式参数的区别\n\n1. 在函数调用时，值形式参数所对应的实参必须有确定的值，而变量形参所对应的实参的值是否确定并不会影响调用的执行。\n2. 子啊函数被调用后，值形参所对应的实参的值保持不变，而变量形参所对应的实参的值会发生改变。\n\n## 函数类型和内嵌函数\n\n### 函数类型\n\n每一个函数都有一个特定的函数类型，它由**形式参数类型**和**返回类型**组成。\n\n![05](../Swift/函数和闭包/05.png)\n\n### 使用函数类型\n\n使用函数类型和使用Swift中的其他类型一样，可以给一个变量或者常量定义一个函数类型，并且为该常量或变量指定一个相应的函数。\n\n```swift\nfunc addTwoNumber(num1: Int, num2: Int) -> Int {\n    return num1 + num2;\n}\n\nvar mathFunction: (Int, Int) -> Int = addTwoNumber\nprint(mathFunction(1, 1));\n```\n\n### 函数类型作为形式参数类型\n\n可以使用一个函数的类型例如 `(Int, Int) -> Int` 作为其他函数的形式参数类型。这种方式允许开发者预留函数的部分实现，从而让函数的调用者在调用函数的时候提供。\n\n```swift\nfunc printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {\n    print(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 1, 1) //Prints 'Result: 2'\n\nfunc addTwoInts(num1: Int, num2: Int) -> Int {\n    num1 + num2\n}\n```\n\n### 函数类型作为返回类型\n\n可以使用函数的类型作为另一个函数的返回类型。写法是在函数的返回箭头`->`后立即写一个完整的函数类型。\n\n```swift\nfunc stepForward(_ input: Int) -> Int {\n    return input + 1\n}\n\nfunc stepBackward(_ input: Int) -> Int {\n    return input - 1\n}\n\nfunc chooseStepFunction(backwards: Bool) -> (Int) -> Int {\n    return backwards ? stepBackward : stepForward\n}\n\nvar currentValue = 3\nlet moveNearerToZero = chooseStepFunction(backwards: currentValue > 0)\n\nprint(\"Counting to zero:\")\nwhile currentValue != 0 {\n    print(\"\\(currentValue)...\")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n```\n\n打印结果：\n\n```js\nCounting to zero:\n3...\n2...\n1...\nzero!\n```\n\n### 内嵌函数\n\n内嵌函数：在一个函数体内定义一个函数，称为内嵌函数。\n\n内嵌函数在默认情况下是对外隐藏的，可以通过包裹它们的函数来调用它们。同时包裹函数也可以返回它内部的内嵌函数，来实现在另外的范围使用它。\n\n```swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    func stepForward(input: Int) -> Int { return input + 1 }\n    func stepBackward(input: Int) -> Int { return input - 1}\n    return backward ? stepBackward : stepForward\n}\n\nvar currentValue = -4\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n\nprint(\"Counting to zero:\")\nwhile currentValue != 0 {\n    print(\"\\(currentValue)\")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n```\n\n打印结果：\n\n```js\nCounting to zero:\n-4\n-3\n-2\n-1\nzero!\n```\n\n## 闭包\n\n闭包是可以在代码中被传递和引用的功能性独立代码块。\n\n闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的**闭合并包裹**那些常量和变量，因此被称为“闭包”。Swift 能够处理所有关于捕获的内存管理的操作。\n\n在函数章节中介绍的全局和内嵌函数，实际上是特殊的闭包。闭包符合如下三种形式中的一种：\n\n1. 全局函数是一个**有名字**但**不能捕获值**的闭包；\n2. 内嵌函数是一个**有名字**且**能捕获值**（从其上层函数）的闭包；\n3. 闭包表达式是一个**没有名字**且**能捕获值**（其上下文中常量或变量的值）的闭包。\n\n### 闭包表达式\n\n闭包表达式是一种在简短行内就能写完闭包的语法。\n\n### 闭包表达式-从 sorted 函数说起\n\nSwfit 的标准库提供了一个叫做 `sorted(by:)` 的方法，该方法会根据调用者提供的排序闭包将已知类型的数组的值进行排序。在排序完成后，`sorted(by:)` 方法会返回与原数组类型大小完全相同的一个**新数组**，新数组的元素是已排序好的。原始数组不会被 `sorted(by:)` 方法修改。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfunc backward(_ s1: String, _ s2: String) -> Bool {\n    return s1 > s2\n}\n\nvar reversedNames = names.sorted(by: backward)\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 闭包表达式语法\n\n![06](../Swift/函数和闭包/06.png)\n\n闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。\n\n### 闭包表达式语法版本的backward\n\n将上面的 `backward(_:_:)` 函数改为闭包表达式版本：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 从语境中推断类型\n\n因为排序闭包作为实际参数传递给函数，所以 Swift 能推断函数的形式参数类型和返回类型。\n\n`sorted(by:)` 方法期望它的形式参数是一个 `(String, String) -> Bool` 类型的函数。这意味着 `(String, String)` 和 `Bool` 类型不需要被写成闭包表达式定义中的一部分。因为所有的类型都能被推断，所以**返回箭头 `->`** 和围绕在**形式参数名周围的括号**也能被省略。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { s1, s2 in\n    return s1 > s2\n})\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 从单表达式闭包隐式返回\n\n单表达式闭包能够从它们的声明中删掉 return 关键字，通过这种方式来隐式返回单个表达式的结果。\n\n同隐式返回的函数，如果整个函数体是一个单一表达式，那么函数隐式返回这个表达式，不需要 return 关键字。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { s1, s2 in\n    s1 > s2\n})\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n也可以简写为：\n\n```swift\nvar reversedNames = names.sorted(by: { s1, s2 in s1 > s2 })\n```\n\n### 简写实际参数名\n\nSwift 自动对行内闭包提供简写实际参数名，可以通过 `$0`，`$1`，`$2` 等名字来引用闭包的实际参数值。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { $0 > $1 })\nprint(reversedNames)\n```\n\n### 运算符函数\n\nSwift 的 String 类型定义了关于大于号 `>` 的特定字符串实现，让其作为一个有两个 String 类型形式参数的函数并返回一个 Bool 类型的值（`(String, String) -> Bool`）。这与 `sorted(by:)` 方法的形式参数需要的函数相匹配。因此，简单的传递一个大于号 `>`，Swift 将推断想使用大于号特殊字符串函数实现。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: > )\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 尾随闭包\n\n如果需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数，使用尾随闭包将增强函数的可读性。尾随闭包是一个被书写在函数形式参数的括号外面（后面）的闭包表达式。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted{ $0 > $1 }\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 捕获值\n\n一个闭包能够从上下文捕获已被定义的常量和变量。即使在定义这些常量和变量的原作用域已经不存在时，闭包仍能够在其函数体内引用和修改这些值。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\nincrementByTen() // 20\nincrementByTen() // 30\n```\n\n作为一种优化，**如果被捕获的值没有改变，Swift 会使用这个值的拷贝而不是捕获**。Swift 也处理了变量的内存管理操作，当变量不再需要时会被释放。\n\n如果建立了第二个 incrementer，它将会有一个新的、独立的 `runningTotal` 变量的引用。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\n\nlet incrementBySeven = makeIncrementer(forIncrement: 7)\nincrementBySeven() // 10\n\nincrementByTen() // 20\n```\n\n### 闭包是引用类型\n\n在 Swift 中，函数和闭包都是引用类型。当赋值一个函数或者闭包给一个常量或者变量时，其实是将常量和变量设置为对函数和闭包的引用。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\n\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen() // 20\n```\n\n📢注意：关于闭包的循环引用问题。如果分配一个闭包给类实例的属性，同时闭包通过引用该实例或者它的成员来捕获了该实例，则会在闭包和实例之间产生**循环引用**（实例持有闭包，闭包持有实例）。\n\n### 逃逸闭包和自动闭包\n\n#### 逃逸闭包\n\n当闭包作为一个实际参数传递给一个函数的时候，并且它会在函数返回之后调用，我们就说这个闭包逃逸了。声明一个函数，让它接收闭包作为形式参数时，可以在形式参数前写 `@escaping` 来明确闭包是允许逃逸的。\n\n逃逸闭包的一种实现方法——被存储在一个变量里，该变量定义于函数外。如异步任务完成后的回调，函数通过接收闭包作为实际参数，来实现在启动异步任务完成后的回调。函数在启动异步任务后就返回了，而闭包会在异步任务完成后才返回，即**为了稍后再调用，闭包需要逃逸**。\n\n```swift\n// 闭包容器\nvar completionHandlers: [() -> Void] = []\n// 添加逃逸闭包\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n\n// 直接调用闭包\nfunc someFunctionWithNoneEscapingClosure(closure: () -> Void) {\n    closure()\n}\n\nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure {\n            self.x = 100\n        }\n        someFunctionWithNoneEscapingClosure {\n            x = 200\n        }\n    }\n}\n\nlet instance = SomeClass()\ninstance.doSomething()\nprint(instance.x) \n//Prints '200'\n\n// 获取闭包容器中的第一个逃逸闭包，并调用（需要时才被调用的闭包——逃逸闭包）\ncompletionHandlers.first?()\nprint(instance.x) \n//Prints '100'\n```\n\n让闭包逃逸意味着必须在表中显示的引用 `self`，即让闭包持有 `self`，才能实现对 `self.x` 的修改。\n\n#### 自动闭包\n\n因为闭包允许延迟处理，所以闭包内部的代码块直到调用闭包的时候才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以控制代码何时才进行求值。\n\n```swift\nvar customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nprint(customersInLine.count)\n//Prints '5'\n\n// 创建闭包\nlet customerProvider = {\n    customersInLine.remove(at: 0)\n}\nprint(customersInLine.count)\n//Prints '5'\n\n// 调用闭包\nprint(\"Now serving \\(customerProvider())!\")\n//Prints 'Now serving Chris!'\n\nprint(customersInLine.count)\n//Prints '4'\n```\n\n在传一个闭包作为实际参数给函数的时候，会得到与延迟处理相同的行为。\n\n```swift\n// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: { customersInLine.remove(at: 0) })\n//Prints 'Now serving Alex!'\n```\n\n通过 `@autoclosure` 标记形式参数使用了自动闭包。使用 `@autoclosure` 标记后，调用函数传递参数更像是传递 String 实际参数一样，而不是在传递一个闭包。因为 `customerProvider` 形式参数的类型被标记为 `@autoclosure`，所以实际参数会自动转换为闭包（自动加上大括号`{ 实际参数 }`）。\n\n👇下面这种实现方式，跟上面相同👆：\n\n```swift\n// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: @autoclosure () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: customersInLine.remove(at: 0))\n//Prints 'Now serving Ewa!'\n```\n\n小结：\n\n1. 自动闭包是一种自动创建的闭包，用来把作为实际参数传递给函数的表达式打包成闭包。自动闭包不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。\n\n2. 这个语法的好处在于通过书写普通表达式代替显示闭包，从而省略包围形式参数的括号`{}`。\n\n#### 自动+逃逸\n\n```swift\n// customersInLine is [\"Barry\", \"Daniella\"]\nvar customerProviders: [() -> String] = []\nfunc collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {\n    // 逃逸\n    customerProviders.append(customerProvider)\n}\n// 自动\ncollectCustomerProviders(customersInLine.remove(at: 0))\ncollectCustomerProviders(customersInLine.remove(at: 0))\n\nprint(\"Collected \\(customerProviders.count) closures.\")\n// Prints \"Collected 2 closures.\"\n\nfor customerProvider in customerProviders {\n    print(\"Now serving \\(customerProvider())!\")\n}\n// Prints \"Now serving Barry!\"\n// Prints \"Now serving Daniella!\"\n```\n\n## 高阶函数\n\n### map\n\n实现：对于原始集合里的每一个元素，以一个变换后的元素替换它，形成一个**新的集合**。\n\n![07](../Swift/函数和闭包/07.png)\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.map { $0 * $0 })\n// Prints \"[4.0, 16.0, 25.0, 49.0]\"\n```\n\n📢注意：调用 `map` 函数返回的是一个新的集合。\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.map { $0 * 10 })\n// Prints \"[20.0, 40.0, 50.0, 70.0]\"\nprint(numbers)\n// Prints \"[2.0, 4.0, 5.0, 7.0]\"\n```\n\n### filter\n\n实现：对于原始集合里的每一个元素，通过判断来将其丢弃或者保存到新的集合里。\n\n![08](../Swift/函数和闭包/08.png)\n\n```swift\nlet numbers = [1, 4, 10, 15]\nprint(numbers.filter { $0 % 2 == 0 })\n// Prints \"[4, 10]\"\n```\n\n### reduce\n\n实现：对于原始集合里的每一个元素，作用于当前累计的结果上。\n\n![09](../Swift/函数和闭包/09.png)\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.reduce(10) { $0 + $1})\n// Prints \"28.0\"\n```\n\n### flatMap\n\n实现：对于二级集合（元素是集合的集合），可以得到单级的集合。\n\n```swift\nlet results = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n// 所有的元素乘以10\nlet allResults = results.flatMap { $0.map { $0 * 10 }}\n// 获取所有大于5的元素\nlet passMarks = results.flatMap { $0.filter { $0 > 5 }}\nprint(allResults)\n// Prints \"[10, 20, 30, 40, 50, 60, 70, 80, 90]\"\nprint(passMarks)\n// Prints \"[6, 7, 8, 9]\"\n```\n\n### compactMap\n\n实现：过滤空值。\n\n```swift\nlet keys: [String?] = [\"zhangsan\", nil, \"lisi\", \"wangwu\"]\n// 获取不为空的字符串\nlet validNames = keys.compactMap { $0 }\nprint(validNames)\n// Prints \"[\"zhangsan\", \"lisi\", \"wangwu\"]\"\n\n// 获取字符串长度\nlet counts = keys.compactMap { $0?.count }\nprint(counts)\n// Prints \"[8, 4, 6]\"\n```\n\n## 函数式编程\n\n### 函数式编程1\n\n#### 范式转换\n\n实现：读入一个文本文件，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表。\n\n>这道题目出自计算机科学史上的著名事件，当年 Communications of the ACM 杂志 “Programming Pearls” 专栏的作者 Jon Bentley 向计算机先去 Donald Knuth 提出的挑战。\n\n#### 传统解决方案\n\n```swift\nlet NON_WORDS: Set = [\"the\", \"and\", \"of\", \"to\", \"a\", \"i\", \"it\", \"in\", \"or\", \"is\", \"as\", \"so\", \"but\", \"be\"]\n\nfunc wordFreq(words: String) -> [String: Int] {\n    var wordDict: [String: Int] = [:]\n    let wordList = words.split(separator: \" \")\n    for word in wordList {\n        let lowerCaseWord = word.lowercased()\n        if !NON_WORDS.contains(lowerCaseWord) {\n            if let count = wordDict[lowerCaseWord] {\n                wordDict[lowerCaseWord] = count + 1;\n            } else {\n                wordDict[lowerCaseWord] = 1;\n            }\n        }\n    }\n    return wordDict\n}\n\nlet words = \"\"\"\nThere are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real Dream what you want to dream go where you want to go be what you want to be because you have only one life and one chance to do all the things you want to do\n\"\"\"\nprint(wordFreq(words: words))\n```\n\n打印结果：\n\n```js\n[\"chance\": 1, \"go\": 2, \"do\": 2, \"life\": 2, \"for\": 1, \"that\": 1, \"you\": 7, \"dreams\": 1, \"what\": 2, \"things\": 1, \"real\": 1, \"someone\": 1, \"have\": 1, \"them\": 2, \"much\": 1, \"pick\": 1, \"when\": 1, \"only\": 1, \"there\": 1, \"dream\": 2, \"want\": 5, \"moments\": 1, \"from\": 1, \"one\": 2, \"just\": 1, \"because\": 1, \"miss\": 1, \"are\": 1, \"your\": 1, \"hug\": 1, \"where\": 1, \"all\": 1]\n```\n\n#### 函数式\n\n```swift\nlet NON_WORDS: Set = [\"the\", \"and\", \"of\", \"to\", \"a\", \"i\", \"it\", \"in\", \"or\", \"is\", \"as\", \"so\", \"but\", \"be\"]\n\nfunc wordFreq(words: String) -> [String: Int] {\n    var wordDict : [String: Int] = [:]\n    let wordList = words.split(separator: \" \")\n    wordList.map { $0.lowercased()}\n        .filter { !NON_WORDS.contains($0) }\n        .forEach { word in\n            wordDict[word] = (wordDict[word] ?? 0) + 1\n        }\n    return wordDict\n}\nprint(wordFreq2(words: words))\n\nlet words = \"\"\"\nThere are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real Dream what you want to dream go where you want to go be what you want to be because you have only one life and one chance to do all the things you want to do\n\"\"\"\nprint(wordFreq(words: words))\n```\n\n打印结果：\n\n```js\n[\"because\": 1, \"moments\": 1, \"much\": 1, \"life\": 2, \"are\": 1, \"you\": 7, \"want\": 5, \"dream\": 2, \"dreams\": 1, \"your\": 1, \"from\": 1, \"things\": 1, \"hug\": 1, \"chance\": 1, \"do\": 2, \"miss\": 1, \"what\": 2, \"real\": 1, \"where\": 1, \"when\": 1, \"pick\": 1, \"for\": 1, \"all\": 1, \"just\": 1, \"there\": 1, \"them\": 2, \"that\": 1, \"go\": 2, \"only\": 1, \"one\": 2, \"someone\": 1, \"have\": 1]\n```\n\n#### 小结\n\n1. 命令式编程风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够**用一次循环来完成多个任务**。\n2. 函数式编程用 `map()`、`filter` 这些高阶函数，让开发者**站在更高的抽象层次上去考虑问题**，把问题看的更清楚。\n\n#### 简洁\n\n1. 面向对象编程通过**封装不确定因素**来是代码能够被人理解。函数式编程通过**尽量减少不确定因素**来是代码能被人理解。\n\n2. 在面向对象的命令式编程语言里面，重用的单元是类和类之间沟通用的消息。函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结构（如 list、set、map）上，运用针对这些数据结构高度优化过的操作，以此构成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式。\n\n3. 比起一味地创建新的类结构体系，把封装的单元降低到函数级别，更有利于达到**细粒度的、基础层面**的重用。函数式开发者喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。面向对象开发者喜欢**不断地创建新的数据结构和附属的操作**，因为压倒一切的面向对象编程范式就是穿件新的类和类间的消息。**把所有的数据结构都封装成类，一方面压制了方法层面的重用，另一方面鼓励大粒度的框架式的重用**。函数式编程的程序构造更方便**在比较细小的层面上重用代码**。\n\n### 函数式编程2\n\n实现：假设我们有一个名字列表，其中一些条目由单个字符串构成。现在的任务是，将除去单字符条目外的列表内容，放在一个逗号分隔的字符串里返回，且每个名字的首字母都要大写。\n\n#### 命令式解法\n\n命令式编程是按照“**程序是一系列改变状态的命令**”来建模的一种编程风格。传统的 for 循环是命令时风格的绝好例子：先确定初始状态，然后每次迭代都执行循环体中的一系列命令。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nfunc cleanNames(names: Array<String>) -> String {\n    var cleanedNames = \"\"\n    for name in names {\n        if name.count > 1 {\n            cleanedNames += name.capitalized + \",\"\n        }\n    }\n    cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex))\n    return cleanedNames\n}\nprint(cleanNames(names: employee))\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\n```\n\n#### 函数式解法\n\n函数式编程**将程序描述为表达式和变换**，以数学方程的形式建立模型，并且尽量避免可变的状态。函数式编程语言对问题的归类不同于命令式语言。如前面所用到的几种操作 `filter`、`transform`、`cover`，**每一种都作为一个逻辑分类，由不同的函数所代表**，这些函数实现了低层次的变换，但依赖于开发者定义的高阶函数作为参数来调整其低层次运转机构的运作。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nlet cleanedNames = employee.filter{ $0.count > 1}\n    .map{ $0.capitalized }\n    .joined(separator: \",\")\nprint(cleanedNames)\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\n```\n\n命令式解法在实现部分创建了一个 `cleanedNames` 对象，然后根据不同的判断对其进行修改。而函数式解法中并没有创建一个新的对象，而是通过执行不同的函数，将程序描述为变换，最后直接得到了结果。\n\n## 并行\n\n因为 Swift 的 map 不支持并行，所以上面的命令执行串行的。可以为 Swift 扩展一个串行遍历方法，实现 java 中并行 map 的功能。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nlet cleanedNames = employee.filter{ $0.count > 1}\n    .map{ $0.capitalized }\n    .joined(separator: \",\")\nprint(cleanedNames)\n\nextension Array where Element: Any {\n    func parallelMap<T>(_ transform: (Element) -> T) -> [T] {\n        let n = self.count\n        if n == 0 {\n            return []\n        }\n        \n        var result = ContiguousArray<T>()\n        result.reserveCapacity(n)\n        \n        // 将 iterations 次任务放入到队列中，异步执行。阻塞当前线程直到全部任务完成。\n        DispatchQueue.concurrentPerform(iterations: n) { (i) in\n            result.append(transform(self[i]))\n        }\n        \n        return Array<T>(result)\n    }\n}\n\nlet result = employee.filter{ $0.count > 1}\n    .parallelMap{ $0.capitalized }\n    .joined(separator: \",\")\nprint(result)\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\nStu,Neal,Bob,Rich,Ethan,Aiden,Liam,Mason,Jack,Lucas,Jacob\n```\n\n### 线程安全\n\n从打印结果可以看到 `parallelMap` 打印的结构丢了一个元素，这是因为 `parallelMap` 是非线程安全的。通过 NSLock 实现线程安全的 `parallelMap`：\n\n```swift\nextension Array where Element: Any {\n    \n    func parallelMap<T>(_ transform: (Element) -> T) -> [T] {\n        let n = self.count\n        if n == 0 {\n            return []\n        }\n\n        var result = ContiguousArray<T>()\n        result.reserveCapacity(n)\n        // 线程安全方案：加锁\n        var lock = NSLock()\n        // 将 iterations 次任务放入到队列中，异步执行。阻塞当前线程直到全部任务完成。\n        DispatchQueue.concurrentPerform(iterations: n) { (i) in\n            lock.lock()\n            result.append(transform(self[i]))\n            lock.unlock()\n        }\n\n        return Array<T>(result)\n    }\n}\n```\n\n## 总结\n\n1. 函数式编程中具有普遍意义的构造单元包括：筛选（`filter`）、映射（`map`）、折叠/化约（`foldLeft`/`reduce`）等等。\n\n2. Swift 统一的函数语法十分灵活，可以表达从简单的无形式参数的 C 风格函数，到复杂的每一个形式参数都带有局部和外部形式参数名的 Object-C 风格方法的任何内容。\n\n3. 形式参数能提供一个默认的值来简化函数的调用，也可以被当做输入输出形式参数被传递，它在函数执行完成时修改传递来的变量。\n\n4. Swfit 中的每一个函数都有类型，由函数的**形式参数类型**和**返回类型**组成，可以像 Swfit 中其它类型那样使用它。这使得能够方便的实现：\n   1. 将一个函数当作一个形式参数传递到另外的一个函数中；\n   2. 也可以在一个函数中返回另一个函数；\n   3. 函数同时也可以写在其它函数内部，在内嵌范围封装有用的功能。","source":"_posts/Swift/函数和闭包.md","raw":"---\ntitle: 函数和闭包\ndate: 2023-03-15 15:04:35\ntags: Swift\n---\n\n* [函数的定义](#函数的定义)\n* [函数实际参数标签和形式参数名](#函数实际参数标签和形式参数名)\n* [函数类型和内嵌函数](#函数类型和内嵌函数)\n* [闭包](#闭包)\n* [高阶函数](#高阶函数)\n* [函数式编程](#函数式编程)\n* [并行](#并行)\n\n<!-- more -->\n\n## 函数的定义\n\n函数是一个独立的代码块，用来执行特定的任务。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来“调用”函数执行它的任务。\n\n### 定义和调用函数\n\n在定义一个函数时，可以定义一个或者多个被命名的分类的值，作为函数的输入（形式参数）。在函数完成后，也可以定义将要传回的值作为输出的类型（返回类型）。\n\n每一个函数都有一个函数名，它描述了函数执行的任务。要使用一个函数，可以通过“调用”函数的名字并且传入符合函数形式参数类型的输入值（实际参数）来调用这个函数。给函数提供的实际参数的顺序必须符合函数的形式参数列表顺序。\n\n```swift\nimport Foundation\n\nfunc greet(person: String) -> String {\n    let greeting = \"Hello, \" + person + \"!\"\n    return greeting\n}\n\ngreet(person: \"zhangsan\")\n// Prints 'Hello, zhangsan!'\n```\n\n### 无形式参数的函数\n\n函数没有要求必须输入一个参数，可以没有形式参数。函数的定义需要在名字后边加一个圆括号`()`，即使在不接受形式参数时也得这样做。当函数被调用的时候同样要在函数的名字后边加一个空的圆括号`()`。\n\n```swift\nfunc sayHello() -> String {\n    return \"hello\"\n}\nprint(sayHello())\n// Prints 'hello'\n```\n\n### 多形式参数的函数\n\n函数可以输入多个形式参数，写在函数后边的圆括号内，用逗号分隔。\n\n```swift\nfunc greetAgain(person: String) -> String {\n    return \"Hello again, \\(person)\"\n}\n\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)\"\n}\n\nfunc greet(person: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return greetAgain(person: person)\n    } else {\n        return greet(person: person)\n    }\n}\n\nprint(greet(person: \"Kevin\", alreadyGreeted: true))\n// Prints 'Hello again, Kevin'\n```\n\n### 无返回值的函数\n\n函数定义中没有要求必须有一个返回类型。不需要返回值，函数在定义的时候就没有包含返回箭头`->`或者返回类型。\n\n严格来讲，尽管函数 `greet(person:)`没有定义返回值，但是它还是有一个返回值的。没有定义返回类型的函数实际上会返回一个特殊的类型 `Void`，它是一个空的元组，作用相当于没有元素的元组，可以写作 `()`。\n\n```swift\nfunc greet(person: String) {\n    print(\"Hello, \\(person)\")\n}\n\nprint(greet(person: \"kevin\"))\n```\n\n打印结果：\n\n```js\nHello, kevin\n()\n```\n\n### 多返回值的函数\n\n为了让函数返回多个值作为一个复合的返回值，可以使用元组类型作为返回类型。\n\n```swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 711]) {\n    print(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n}\n// Prints 'min is -6 and max is 711'\n```\n\n### 可选元组返回类型\n\n如果函数返回的元组可能“没有值”，可以用一个**可选元组返回类型**来表示整个元组可能是 `nil`。写法是在可选元组类型的圆括号后边添加一个问号`?`，例如：`(Int, Int)?` 或者 `(String, Int, Bool)?`。\n\n```swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.count == 0 {\n        return nil\n    }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nprint(minMax(array: []))\n// Prints 'nil'\n```\n\n### 隐式返回的函数\n\n如果整个函数体是一个单一表达式，那么函数隐式返回这个表达式，不需要 return 关键字。\n\n```swift\nfunc greeting(for person: String) -> String {\n    \"Hello, \" + person + \"!\"\n}\nprint(greeting(for: \"Kevin\"))\n// Prints 'Hello, Kevin!'\n```\n\n上面的写法等价于👇\n\n```swift\nfunc anotherGreeting(for person: String) -> String {\n    return \"Hello, \" + person + \"!\"\n}\nprint(anotherGreeting(for: \"Kevin\"))\n// Prints 'Hello, Kevin!'\n```\n\n## 函数实际参数标签和形式参数名\n\n形式参数：值形式参数、变量形式参数。函数或过程**定义时的参数**为形式参数。\n实际参数：函数或过程**调用时的参数**为实际参数。\n\n### 实参标签和形参名\n\n每一个函数的**形式参数**都包含**实际参数标签**和**形式参数名**。实际参数标签用在调用函数的时候，在调用函数的时候每一个**实际参数**前边都要写**实际参数标签**。形式参数名用在函数的实现当中，默认情况下，形式参数使用**形式参数名**作为**实际参数标签**。所有的形式参数必须有唯一的名字。尽管多个形式参数拥有相同的实际参数标签也是有可能的，但是唯一的实际参数标签有助于让代码更加易读。\n\n参数由形式参数名代替实际参数标签👇\n\n![01](../Swift/函数和闭包/01.png)\n\n```swift\nfunc someFunction(【形式参数名】: Int, 【形式参数名】: Int) {\n    print(\"\\(【形式参数名】), \\(【形式参数名】)\")\n}\n\nsomeFunction(【形式参数名】：【实际参数】, 【形式参数名】：【实际参数】)\n```\n\n### 指定实际参数标签\n\n在提供形式参数名之前写实际参数标签，用空格分隔。如果为一个形式参数提供了实际参数标签，那么这个实际参数就必须在调用函数的时候使用标签。实际参数标签的使用能够让函数的调用更加明确，更像是自然语句，同时还能提供更可读的函数体并更清晰的表达函数的意图。\n\n```swift\nfunc greet(person: String, from hometown: String) -> String {\n    return \"Hello \\(person)! Glad you could visit from \\(hometown).\"\n}\n\nprint(greet(person: \"Kevin\", from: \"Cupertion\"))\n// Prints 'Hello Kevin! Glad you could visit from Cupertion.'\n```\n\n```swift\nfunc greet(【形式参数名】: String, 【实际参数标签】【形式参数名】: String) -> String {\n    return \"Hello \\(【形式参数名】)! Glad you could visit from \\(【形式参数名】).\"\n}\n\nsomeFunction(【形式参数名】：【实际参数】, 【实际参数标签】：【实际参数】)\n```\n\n### 省略实际参数标签\n\n如果对于函数的形式参数不想使用实际参数标签的话，可以**利用下划线 `_` 来代替显示的实际参数标签**。\n\n第一个参数不使用实际参数标签，第二个参数由形式参数名代替实际参数标签👇\n\n![02](../Swift/函数和闭包/02.png)\n\n```swift\nfunc someFunction(_ firstParameterName: Int, secondParameterName: Int) {\n    print(firstParameterName, secondParameterName)\n}\n\nsomeFunction(1, secondParameterName: 2)\n// Prints '1 2'\n```\n\n### 默认形式参数值\n\n给形式参数定义默认值：在形式参数类型后赋一个值作为默认值。如果定义了默认值，在调用函数时可以省略这个形式参数。\n\n![03](../Swift/函数和闭包/03.png)\n\n```swift\nfunc someFunction(parameterWithDefault: Int = 12) {\n    print(parameterWithDefault)\n}\n\nsomeFunction(parameterWithDefault: 6) // Prints '6'\nsomeFunction() // Prints '12'\n```\n\n### 可变形式参数\n\n在形式参数的**类型名称后边**插入三个点符号`...`来书写可变形式参数。`...`（可变形式参数）声明形式参数可以被传入值的数量是可变的。一个可变形式参数可以接受零或者多个特定类型的值，传入到可变参数中的值在函数体内被当作是对应类型的数组。\n\n![04](../Swift/函数和闭包/04.png)\n\n```swift\nfunc arithmeticMean(_ numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\n\nprint(arithmeticMean(1, 2, 3, 4, 5)) //Prints '3.0'\nprint(arithmeticMean(3, 8.25, 18.75)) //Prints '10.0'\n```\n\n### 输入输出形式参数\n\n在定义形式参数时，**在前边添加一个 `inout`** 关键字可以定义一个输入输出形式参数。输入输出形式参数有一个能输入给函数的值，函数能对其进行修改，还能输出到函数外边替换原来的值。**只能把变量作为输入输出形式参数的实际参数**。在调用函数时，将变量作为实际参数传递给输入输出形式参数，直接在它前边添加一个和符号`&`来明确可以被函数修改。**输入输出形式参数不能有默认值，可变形式参数不能标记 inout**。\n\n```swift\nfunc swapTowInts(_ a: inout Int, _ b: inout Int) {\n    let temp = a\n    a = b\n    b = temp\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTowInts(&someInt, &anotherInt)\nprint(\"someInt is \\(someInt), anotherInt is \\(anotherInt)\")\n//Prints 'someInt is 107, anotherInt is 3'\n```\n\n### 值形式参数\n\n值形式参数也可以叫做常量形式参数。\n\n值形式参数的作用：值形参从与它位置对应的实参中接收数据，并把数据传送到所在的函数中。\n\n📢注意：当函数被调用时，系统为每个值形参开辟临时的存储单元，并按从左到右的顺序，把实在参数的值——赋给对应位置上的形式参数。值形参作为子程序的局部变量，当函数返回程序后，值形参的存储单元释放。\n\n### 变量形式参数\n\n必须在形参名的前面加上 `var`。\n\n变量形参的作用：变量形参可以将子程序调用过程中产生的值返回调用它的程序。\n\n📢注意：当函数被调用时，系统并不会为变量形参开辟临时的存储单元，而是让它们和对应的实参共用存储单元。也就是说，调用函数时是将实参的地址传递给对应的变量形参。\n\n### 值形式参数和变量形式参数的区别\n\n1. 在函数调用时，值形式参数所对应的实参必须有确定的值，而变量形参所对应的实参的值是否确定并不会影响调用的执行。\n2. 子啊函数被调用后，值形参所对应的实参的值保持不变，而变量形参所对应的实参的值会发生改变。\n\n## 函数类型和内嵌函数\n\n### 函数类型\n\n每一个函数都有一个特定的函数类型，它由**形式参数类型**和**返回类型**组成。\n\n![05](../Swift/函数和闭包/05.png)\n\n### 使用函数类型\n\n使用函数类型和使用Swift中的其他类型一样，可以给一个变量或者常量定义一个函数类型，并且为该常量或变量指定一个相应的函数。\n\n```swift\nfunc addTwoNumber(num1: Int, num2: Int) -> Int {\n    return num1 + num2;\n}\n\nvar mathFunction: (Int, Int) -> Int = addTwoNumber\nprint(mathFunction(1, 1));\n```\n\n### 函数类型作为形式参数类型\n\n可以使用一个函数的类型例如 `(Int, Int) -> Int` 作为其他函数的形式参数类型。这种方式允许开发者预留函数的部分实现，从而让函数的调用者在调用函数的时候提供。\n\n```swift\nfunc printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {\n    print(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 1, 1) //Prints 'Result: 2'\n\nfunc addTwoInts(num1: Int, num2: Int) -> Int {\n    num1 + num2\n}\n```\n\n### 函数类型作为返回类型\n\n可以使用函数的类型作为另一个函数的返回类型。写法是在函数的返回箭头`->`后立即写一个完整的函数类型。\n\n```swift\nfunc stepForward(_ input: Int) -> Int {\n    return input + 1\n}\n\nfunc stepBackward(_ input: Int) -> Int {\n    return input - 1\n}\n\nfunc chooseStepFunction(backwards: Bool) -> (Int) -> Int {\n    return backwards ? stepBackward : stepForward\n}\n\nvar currentValue = 3\nlet moveNearerToZero = chooseStepFunction(backwards: currentValue > 0)\n\nprint(\"Counting to zero:\")\nwhile currentValue != 0 {\n    print(\"\\(currentValue)...\")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n```\n\n打印结果：\n\n```js\nCounting to zero:\n3...\n2...\n1...\nzero!\n```\n\n### 内嵌函数\n\n内嵌函数：在一个函数体内定义一个函数，称为内嵌函数。\n\n内嵌函数在默认情况下是对外隐藏的，可以通过包裹它们的函数来调用它们。同时包裹函数也可以返回它内部的内嵌函数，来实现在另外的范围使用它。\n\n```swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    func stepForward(input: Int) -> Int { return input + 1 }\n    func stepBackward(input: Int) -> Int { return input - 1}\n    return backward ? stepBackward : stepForward\n}\n\nvar currentValue = -4\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n\nprint(\"Counting to zero:\")\nwhile currentValue != 0 {\n    print(\"\\(currentValue)\")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n```\n\n打印结果：\n\n```js\nCounting to zero:\n-4\n-3\n-2\n-1\nzero!\n```\n\n## 闭包\n\n闭包是可以在代码中被传递和引用的功能性独立代码块。\n\n闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的**闭合并包裹**那些常量和变量，因此被称为“闭包”。Swift 能够处理所有关于捕获的内存管理的操作。\n\n在函数章节中介绍的全局和内嵌函数，实际上是特殊的闭包。闭包符合如下三种形式中的一种：\n\n1. 全局函数是一个**有名字**但**不能捕获值**的闭包；\n2. 内嵌函数是一个**有名字**且**能捕获值**（从其上层函数）的闭包；\n3. 闭包表达式是一个**没有名字**且**能捕获值**（其上下文中常量或变量的值）的闭包。\n\n### 闭包表达式\n\n闭包表达式是一种在简短行内就能写完闭包的语法。\n\n### 闭包表达式-从 sorted 函数说起\n\nSwfit 的标准库提供了一个叫做 `sorted(by:)` 的方法，该方法会根据调用者提供的排序闭包将已知类型的数组的值进行排序。在排序完成后，`sorted(by:)` 方法会返回与原数组类型大小完全相同的一个**新数组**，新数组的元素是已排序好的。原始数组不会被 `sorted(by:)` 方法修改。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfunc backward(_ s1: String, _ s2: String) -> Bool {\n    return s1 > s2\n}\n\nvar reversedNames = names.sorted(by: backward)\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 闭包表达式语法\n\n![06](../Swift/函数和闭包/06.png)\n\n闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。\n\n### 闭包表达式语法版本的backward\n\n将上面的 `backward(_:_:)` 函数改为闭包表达式版本：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 从语境中推断类型\n\n因为排序闭包作为实际参数传递给函数，所以 Swift 能推断函数的形式参数类型和返回类型。\n\n`sorted(by:)` 方法期望它的形式参数是一个 `(String, String) -> Bool` 类型的函数。这意味着 `(String, String)` 和 `Bool` 类型不需要被写成闭包表达式定义中的一部分。因为所有的类型都能被推断，所以**返回箭头 `->`** 和围绕在**形式参数名周围的括号**也能被省略。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { s1, s2 in\n    return s1 > s2\n})\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 从单表达式闭包隐式返回\n\n单表达式闭包能够从它们的声明中删掉 return 关键字，通过这种方式来隐式返回单个表达式的结果。\n\n同隐式返回的函数，如果整个函数体是一个单一表达式，那么函数隐式返回这个表达式，不需要 return 关键字。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { s1, s2 in\n    s1 > s2\n})\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n也可以简写为：\n\n```swift\nvar reversedNames = names.sorted(by: { s1, s2 in s1 > s2 })\n```\n\n### 简写实际参数名\n\nSwift 自动对行内闭包提供简写实际参数名，可以通过 `$0`，`$1`，`$2` 等名字来引用闭包的实际参数值。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: { $0 > $1 })\nprint(reversedNames)\n```\n\n### 运算符函数\n\nSwift 的 String 类型定义了关于大于号 `>` 的特定字符串实现，让其作为一个有两个 String 类型形式参数的函数并返回一个 Bool 类型的值（`(String, String) -> Bool`）。这与 `sorted(by:)` 方法的形式参数需要的函数相匹配。因此，简单的传递一个大于号 `>`，Swift 将推断想使用大于号特殊字符串函数实现。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted(by: > )\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 尾随闭包\n\n如果需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数，使用尾随闭包将增强函数的可读性。尾随闭包是一个被书写在函数形式参数的括号外面（后面）的闭包表达式。\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nvar reversedNames = names.sorted{ $0 > $1 }\nprint(reversedNames)\n//Prints '[\"zhaoliu\", \"zhangsan\", \"wangwu\", \"lisi\"]'\n```\n\n### 捕获值\n\n一个闭包能够从上下文捕获已被定义的常量和变量。即使在定义这些常量和变量的原作用域已经不存在时，闭包仍能够在其函数体内引用和修改这些值。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\nincrementByTen() // 20\nincrementByTen() // 30\n```\n\n作为一种优化，**如果被捕获的值没有改变，Swift 会使用这个值的拷贝而不是捕获**。Swift 也处理了变量的内存管理操作，当变量不再需要时会被释放。\n\n如果建立了第二个 incrementer，它将会有一个新的、独立的 `runningTotal` 变量的引用。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\n\nlet incrementBySeven = makeIncrementer(forIncrement: 7)\nincrementBySeven() // 10\n\nincrementByTen() // 20\n```\n\n### 闭包是引用类型\n\n在 Swift 中，函数和闭包都是引用类型。当赋值一个函数或者闭包给一个常量或者变量时，其实是将常量和变量设置为对函数和闭包的引用。\n\n```swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runingTotal = 0\n    func incrementer() -> Int {\n        runingTotal += amount\n        return runingTotal\n    }\n    return incrementer\n}\n\nlet incrementByTen = makeIncrementer(forIncrement: 10)\nincrementByTen() // 10\n\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen() // 20\n```\n\n📢注意：关于闭包的循环引用问题。如果分配一个闭包给类实例的属性，同时闭包通过引用该实例或者它的成员来捕获了该实例，则会在闭包和实例之间产生**循环引用**（实例持有闭包，闭包持有实例）。\n\n### 逃逸闭包和自动闭包\n\n#### 逃逸闭包\n\n当闭包作为一个实际参数传递给一个函数的时候，并且它会在函数返回之后调用，我们就说这个闭包逃逸了。声明一个函数，让它接收闭包作为形式参数时，可以在形式参数前写 `@escaping` 来明确闭包是允许逃逸的。\n\n逃逸闭包的一种实现方法——被存储在一个变量里，该变量定义于函数外。如异步任务完成后的回调，函数通过接收闭包作为实际参数，来实现在启动异步任务完成后的回调。函数在启动异步任务后就返回了，而闭包会在异步任务完成后才返回，即**为了稍后再调用，闭包需要逃逸**。\n\n```swift\n// 闭包容器\nvar completionHandlers: [() -> Void] = []\n// 添加逃逸闭包\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n\n// 直接调用闭包\nfunc someFunctionWithNoneEscapingClosure(closure: () -> Void) {\n    closure()\n}\n\nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure {\n            self.x = 100\n        }\n        someFunctionWithNoneEscapingClosure {\n            x = 200\n        }\n    }\n}\n\nlet instance = SomeClass()\ninstance.doSomething()\nprint(instance.x) \n//Prints '200'\n\n// 获取闭包容器中的第一个逃逸闭包，并调用（需要时才被调用的闭包——逃逸闭包）\ncompletionHandlers.first?()\nprint(instance.x) \n//Prints '100'\n```\n\n让闭包逃逸意味着必须在表中显示的引用 `self`，即让闭包持有 `self`，才能实现对 `self.x` 的修改。\n\n#### 自动闭包\n\n因为闭包允许延迟处理，所以闭包内部的代码块直到调用闭包的时候才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以控制代码何时才进行求值。\n\n```swift\nvar customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nprint(customersInLine.count)\n//Prints '5'\n\n// 创建闭包\nlet customerProvider = {\n    customersInLine.remove(at: 0)\n}\nprint(customersInLine.count)\n//Prints '5'\n\n// 调用闭包\nprint(\"Now serving \\(customerProvider())!\")\n//Prints 'Now serving Chris!'\n\nprint(customersInLine.count)\n//Prints '4'\n```\n\n在传一个闭包作为实际参数给函数的时候，会得到与延迟处理相同的行为。\n\n```swift\n// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: { customersInLine.remove(at: 0) })\n//Prints 'Now serving Alex!'\n```\n\n通过 `@autoclosure` 标记形式参数使用了自动闭包。使用 `@autoclosure` 标记后，调用函数传递参数更像是传递 String 实际参数一样，而不是在传递一个闭包。因为 `customerProvider` 形式参数的类型被标记为 `@autoclosure`，所以实际参数会自动转换为闭包（自动加上大括号`{ 实际参数 }`）。\n\n👇下面这种实现方式，跟上面相同👆：\n\n```swift\n// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: @autoclosure () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: customersInLine.remove(at: 0))\n//Prints 'Now serving Ewa!'\n```\n\n小结：\n\n1. 自动闭包是一种自动创建的闭包，用来把作为实际参数传递给函数的表达式打包成闭包。自动闭包不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。\n\n2. 这个语法的好处在于通过书写普通表达式代替显示闭包，从而省略包围形式参数的括号`{}`。\n\n#### 自动+逃逸\n\n```swift\n// customersInLine is [\"Barry\", \"Daniella\"]\nvar customerProviders: [() -> String] = []\nfunc collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {\n    // 逃逸\n    customerProviders.append(customerProvider)\n}\n// 自动\ncollectCustomerProviders(customersInLine.remove(at: 0))\ncollectCustomerProviders(customersInLine.remove(at: 0))\n\nprint(\"Collected \\(customerProviders.count) closures.\")\n// Prints \"Collected 2 closures.\"\n\nfor customerProvider in customerProviders {\n    print(\"Now serving \\(customerProvider())!\")\n}\n// Prints \"Now serving Barry!\"\n// Prints \"Now serving Daniella!\"\n```\n\n## 高阶函数\n\n### map\n\n实现：对于原始集合里的每一个元素，以一个变换后的元素替换它，形成一个**新的集合**。\n\n![07](../Swift/函数和闭包/07.png)\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.map { $0 * $0 })\n// Prints \"[4.0, 16.0, 25.0, 49.0]\"\n```\n\n📢注意：调用 `map` 函数返回的是一个新的集合。\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.map { $0 * 10 })\n// Prints \"[20.0, 40.0, 50.0, 70.0]\"\nprint(numbers)\n// Prints \"[2.0, 4.0, 5.0, 7.0]\"\n```\n\n### filter\n\n实现：对于原始集合里的每一个元素，通过判断来将其丢弃或者保存到新的集合里。\n\n![08](../Swift/函数和闭包/08.png)\n\n```swift\nlet numbers = [1, 4, 10, 15]\nprint(numbers.filter { $0 % 2 == 0 })\n// Prints \"[4, 10]\"\n```\n\n### reduce\n\n实现：对于原始集合里的每一个元素，作用于当前累计的结果上。\n\n![09](../Swift/函数和闭包/09.png)\n\n```swift\nlet numbers = [2.0, 4.0, 5.0, 7.0]\nprint(numbers.reduce(10) { $0 + $1})\n// Prints \"28.0\"\n```\n\n### flatMap\n\n实现：对于二级集合（元素是集合的集合），可以得到单级的集合。\n\n```swift\nlet results = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n// 所有的元素乘以10\nlet allResults = results.flatMap { $0.map { $0 * 10 }}\n// 获取所有大于5的元素\nlet passMarks = results.flatMap { $0.filter { $0 > 5 }}\nprint(allResults)\n// Prints \"[10, 20, 30, 40, 50, 60, 70, 80, 90]\"\nprint(passMarks)\n// Prints \"[6, 7, 8, 9]\"\n```\n\n### compactMap\n\n实现：过滤空值。\n\n```swift\nlet keys: [String?] = [\"zhangsan\", nil, \"lisi\", \"wangwu\"]\n// 获取不为空的字符串\nlet validNames = keys.compactMap { $0 }\nprint(validNames)\n// Prints \"[\"zhangsan\", \"lisi\", \"wangwu\"]\"\n\n// 获取字符串长度\nlet counts = keys.compactMap { $0?.count }\nprint(counts)\n// Prints \"[8, 4, 6]\"\n```\n\n## 函数式编程\n\n### 函数式编程1\n\n#### 范式转换\n\n实现：读入一个文本文件，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表。\n\n>这道题目出自计算机科学史上的著名事件，当年 Communications of the ACM 杂志 “Programming Pearls” 专栏的作者 Jon Bentley 向计算机先去 Donald Knuth 提出的挑战。\n\n#### 传统解决方案\n\n```swift\nlet NON_WORDS: Set = [\"the\", \"and\", \"of\", \"to\", \"a\", \"i\", \"it\", \"in\", \"or\", \"is\", \"as\", \"so\", \"but\", \"be\"]\n\nfunc wordFreq(words: String) -> [String: Int] {\n    var wordDict: [String: Int] = [:]\n    let wordList = words.split(separator: \" \")\n    for word in wordList {\n        let lowerCaseWord = word.lowercased()\n        if !NON_WORDS.contains(lowerCaseWord) {\n            if let count = wordDict[lowerCaseWord] {\n                wordDict[lowerCaseWord] = count + 1;\n            } else {\n                wordDict[lowerCaseWord] = 1;\n            }\n        }\n    }\n    return wordDict\n}\n\nlet words = \"\"\"\nThere are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real Dream what you want to dream go where you want to go be what you want to be because you have only one life and one chance to do all the things you want to do\n\"\"\"\nprint(wordFreq(words: words))\n```\n\n打印结果：\n\n```js\n[\"chance\": 1, \"go\": 2, \"do\": 2, \"life\": 2, \"for\": 1, \"that\": 1, \"you\": 7, \"dreams\": 1, \"what\": 2, \"things\": 1, \"real\": 1, \"someone\": 1, \"have\": 1, \"them\": 2, \"much\": 1, \"pick\": 1, \"when\": 1, \"only\": 1, \"there\": 1, \"dream\": 2, \"want\": 5, \"moments\": 1, \"from\": 1, \"one\": 2, \"just\": 1, \"because\": 1, \"miss\": 1, \"are\": 1, \"your\": 1, \"hug\": 1, \"where\": 1, \"all\": 1]\n```\n\n#### 函数式\n\n```swift\nlet NON_WORDS: Set = [\"the\", \"and\", \"of\", \"to\", \"a\", \"i\", \"it\", \"in\", \"or\", \"is\", \"as\", \"so\", \"but\", \"be\"]\n\nfunc wordFreq(words: String) -> [String: Int] {\n    var wordDict : [String: Int] = [:]\n    let wordList = words.split(separator: \" \")\n    wordList.map { $0.lowercased()}\n        .filter { !NON_WORDS.contains($0) }\n        .forEach { word in\n            wordDict[word] = (wordDict[word] ?? 0) + 1\n        }\n    return wordDict\n}\nprint(wordFreq2(words: words))\n\nlet words = \"\"\"\nThere are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real Dream what you want to dream go where you want to go be what you want to be because you have only one life and one chance to do all the things you want to do\n\"\"\"\nprint(wordFreq(words: words))\n```\n\n打印结果：\n\n```js\n[\"because\": 1, \"moments\": 1, \"much\": 1, \"life\": 2, \"are\": 1, \"you\": 7, \"want\": 5, \"dream\": 2, \"dreams\": 1, \"your\": 1, \"from\": 1, \"things\": 1, \"hug\": 1, \"chance\": 1, \"do\": 2, \"miss\": 1, \"what\": 2, \"real\": 1, \"where\": 1, \"when\": 1, \"pick\": 1, \"for\": 1, \"all\": 1, \"just\": 1, \"there\": 1, \"them\": 2, \"that\": 1, \"go\": 2, \"only\": 1, \"one\": 2, \"someone\": 1, \"have\": 1]\n```\n\n#### 小结\n\n1. 命令式编程风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够**用一次循环来完成多个任务**。\n2. 函数式编程用 `map()`、`filter` 这些高阶函数，让开发者**站在更高的抽象层次上去考虑问题**，把问题看的更清楚。\n\n#### 简洁\n\n1. 面向对象编程通过**封装不确定因素**来是代码能够被人理解。函数式编程通过**尽量减少不确定因素**来是代码能被人理解。\n\n2. 在面向对象的命令式编程语言里面，重用的单元是类和类之间沟通用的消息。函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结构（如 list、set、map）上，运用针对这些数据结构高度优化过的操作，以此构成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式。\n\n3. 比起一味地创建新的类结构体系，把封装的单元降低到函数级别，更有利于达到**细粒度的、基础层面**的重用。函数式开发者喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。面向对象开发者喜欢**不断地创建新的数据结构和附属的操作**，因为压倒一切的面向对象编程范式就是穿件新的类和类间的消息。**把所有的数据结构都封装成类，一方面压制了方法层面的重用，另一方面鼓励大粒度的框架式的重用**。函数式编程的程序构造更方便**在比较细小的层面上重用代码**。\n\n### 函数式编程2\n\n实现：假设我们有一个名字列表，其中一些条目由单个字符串构成。现在的任务是，将除去单字符条目外的列表内容，放在一个逗号分隔的字符串里返回，且每个名字的首字母都要大写。\n\n#### 命令式解法\n\n命令式编程是按照“**程序是一系列改变状态的命令**”来建模的一种编程风格。传统的 for 循环是命令时风格的绝好例子：先确定初始状态，然后每次迭代都执行循环体中的一系列命令。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nfunc cleanNames(names: Array<String>) -> String {\n    var cleanedNames = \"\"\n    for name in names {\n        if name.count > 1 {\n            cleanedNames += name.capitalized + \",\"\n        }\n    }\n    cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex))\n    return cleanedNames\n}\nprint(cleanNames(names: employee))\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\n```\n\n#### 函数式解法\n\n函数式编程**将程序描述为表达式和变换**，以数学方程的形式建立模型，并且尽量避免可变的状态。函数式编程语言对问题的归类不同于命令式语言。如前面所用到的几种操作 `filter`、`transform`、`cover`，**每一种都作为一个逻辑分类，由不同的函数所代表**，这些函数实现了低层次的变换，但依赖于开发者定义的高阶函数作为参数来调整其低层次运转机构的运作。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nlet cleanedNames = employee.filter{ $0.count > 1}\n    .map{ $0.capitalized }\n    .joined(separator: \",\")\nprint(cleanedNames)\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\n```\n\n命令式解法在实现部分创建了一个 `cleanedNames` 对象，然后根据不同的判断对其进行修改。而函数式解法中并没有创建一个新的对象，而是通过执行不同的函数，将程序描述为变换，最后直接得到了结果。\n\n## 并行\n\n因为 Swift 的 map 不支持并行，所以上面的命令执行串行的。可以为 Swift 扩展一个串行遍历方法，实现 java 中并行 map 的功能。\n\n```swift\nlet employee = [\"neal\", \"s\", \"stu\", \"j\", \"rich\", \"bob\", \"aiden\", \"j\", \"ethan\", \"liam\", \"mason\", \"noah\", \"lucas\", \"jacob\", \"jack\"]\n\nlet cleanedNames = employee.filter{ $0.count > 1}\n    .map{ $0.capitalized }\n    .joined(separator: \",\")\nprint(cleanedNames)\n\nextension Array where Element: Any {\n    func parallelMap<T>(_ transform: (Element) -> T) -> [T] {\n        let n = self.count\n        if n == 0 {\n            return []\n        }\n        \n        var result = ContiguousArray<T>()\n        result.reserveCapacity(n)\n        \n        // 将 iterations 次任务放入到队列中，异步执行。阻塞当前线程直到全部任务完成。\n        DispatchQueue.concurrentPerform(iterations: n) { (i) in\n            result.append(transform(self[i]))\n        }\n        \n        return Array<T>(result)\n    }\n}\n\nlet result = employee.filter{ $0.count > 1}\n    .parallelMap{ $0.capitalized }\n    .joined(separator: \",\")\nprint(result)\n```\n\n打印结果：\n\n```js\nNeal,Stu,Rich,Bob,Aiden,Ethan,Liam,Mason,Noah,Lucas,Jacob,Jack\nStu,Neal,Bob,Rich,Ethan,Aiden,Liam,Mason,Jack,Lucas,Jacob\n```\n\n### 线程安全\n\n从打印结果可以看到 `parallelMap` 打印的结构丢了一个元素，这是因为 `parallelMap` 是非线程安全的。通过 NSLock 实现线程安全的 `parallelMap`：\n\n```swift\nextension Array where Element: Any {\n    \n    func parallelMap<T>(_ transform: (Element) -> T) -> [T] {\n        let n = self.count\n        if n == 0 {\n            return []\n        }\n\n        var result = ContiguousArray<T>()\n        result.reserveCapacity(n)\n        // 线程安全方案：加锁\n        var lock = NSLock()\n        // 将 iterations 次任务放入到队列中，异步执行。阻塞当前线程直到全部任务完成。\n        DispatchQueue.concurrentPerform(iterations: n) { (i) in\n            lock.lock()\n            result.append(transform(self[i]))\n            lock.unlock()\n        }\n\n        return Array<T>(result)\n    }\n}\n```\n\n## 总结\n\n1. 函数式编程中具有普遍意义的构造单元包括：筛选（`filter`）、映射（`map`）、折叠/化约（`foldLeft`/`reduce`）等等。\n\n2. Swift 统一的函数语法十分灵活，可以表达从简单的无形式参数的 C 风格函数，到复杂的每一个形式参数都带有局部和外部形式参数名的 Object-C 风格方法的任何内容。\n\n3. 形式参数能提供一个默认的值来简化函数的调用，也可以被当做输入输出形式参数被传递，它在函数执行完成时修改传递来的变量。\n\n4. Swfit 中的每一个函数都有类型，由函数的**形式参数类型**和**返回类型**组成，可以像 Swfit 中其它类型那样使用它。这使得能够方便的实现：\n   1. 将一个函数当作一个形式参数传递到另外的一个函数中；\n   2. 也可以在一个函数中返回另一个函数；\n   3. 函数同时也可以写在其它函数内部，在内嵌范围封装有用的功能。","slug":"Swift/函数和闭包","published":1,"updated":"2023-08-22T09:52:14.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgty001gaq7k67j43dfb"},{"title":"基本数据类型","date":"2022-09-30T02:51:22.000Z","_content":"\n* [常量和变量](#常量和变量)\n\n* [基本数据类型](#基本数据类型)\n\n* [Tuple](#tuple)\n\n* [Optional](#optional)\n\n* [字符串](#字符串)\n\n<!-- more -->\n\n## 常量和变量\n\n### 声明常量和变量\n\n1、使用关键字 `let` 来声明**常量**\n\n```swift\nlet maxNumber = 10\n```\n\n2、使用关键字 `var` 来声明**变量**\n\n```swift\nvar currentNumber = 0\n```\n\n3、可以在一行中声明多个变量或常量，用逗号分隔\n\n```swift\nvar x = 0.0, y = 0.0, z = 0.0\n```\n\n4、不可以修改常量\n![BasicDataType01](基本数据类型/BasicDataType01.png)\n\n### 类型标注\n\n**类型标注**：声明变量或常量的同时，指定其类型。在声明一个变量或常量的时候，通过提供类型标注，来明确该变量或常量能够储存值的类型。\n\n添加类型标注的方法：在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称（声明变量或常量的要素：**类型 + 变量名**）\n\n```swift\nvar name: String\n```\n\n可以在一行中定义多个变量为相同的类型，用逗号分隔，只要在最后的变量名字后边加上类型标注\n\n```swift\nvar name1, name2, name3: String\n```\n\n不可以给 String 类型的变量赋值 Int 类型的值：\n![BasicDataType02](基本数据类型/BasicDataType02.png)\n\n### 变量和常量命名\n\n常量和变量的名字几乎可以使用任何字符，包括 Unicode 字符。常量和变量的名字不能包含空白字符、数学符号、箭头、保留的（或者无效的）Unicode 码位、连线和制表符。虽然数字几乎可以使用在名字的任何位置，但是不能以数字开头。\n\n```swift\nlet π = 3.14159\nlet 你好 = \"你好世界\"\nlet 🐶🐮 = \"dogcow\"\n```\n\n### 打印常量和变量\n\n```swift\nlet 你好 = \"你好世界\"\nprint(\"欢迎语是\\(你好)\")\n```\n\n打印结果：\n\n```js\n欢迎语是你好世界\n```\n\n在Swift中使用`print(_:separator:terminator:)`作为打印方法。`\\()`是字符串插值，可以实现字符串的拼接。\n\n## 基本数据类型\n\n### 整数\n\nSwift 提供了 8，16，32 和 64 位编码的有符号和无符号整数，例如 8 位无符号整数的类型是 `UInt8`，32 位有符号整数的类型是 `Int32`。Swift 提供了一个额外的整数类型：`Int`，它拥有与当前平台的原生字相同的长度。同时 Swift 也提供 `UInt` 类型，来表示平台长度相关的无符号整数。**建议在用到整数的地方都是用 `Int`**。\n\n通过 `min` 和 `max` 属性来访问每个整数类型的**最小值**和**最大值**。\n\n### 浮点类型\n\n* `Double`：64 位浮点数，至少有 15 位数字的精度。\n\n* `Float`：32 位浮点数，至少有 6 位数字的精度。\n\n在两种类型都可以的情况下，推荐使用 `Double` 类型。\n\n### 数值范围\n\n![BasicDataType03](基本数据类型/BasicDataType03.png)\n\n### Bool\n\n`Bool`：`true` 和 `false`。Swift 的类型安全机制会阻止用一个非布尔量的值替换掉 `Bool`。如下图，不可以直接判断一个变量，而是需要写成判断的方式（`i == 1`）\n![BasicDataType04](基本数据类型/BasicDataType04.png)\n\n### 类型别名\n\n类型别名：为已存在类型定义一个可选择的名字。可以通过关键字 `typealias` 定义一个类型别名。\n\n如为一个已存在的类型定义一个新的名字，让其在上下文中看起来更合适、更具有表达性，用新的名字来引用这个已存在的类型：\n\n```swift\ntypealias AudioSample = UInt8\nlet sample: AudioSample = 32\n```\n\n## Tuple\n\n元组实现了**把多个值合并成一个复合型的值**。元组内的值可以是任何类型，而且可以不必是同一类型。\n\n### 元素命名\n\n元组中的每一个元素可以指定对应的**元素名称**：\n![BasicDataType07](基本数据类型/BasicDataType07.png)\n\n如果没有指定名称的元素也可以使用**下标**的方式来引用：\n![BasicDataType06](基本数据类型/BasicDataType06.png)\n\n### Tuple 修改\n\n用 `var` 定义的元组就是**可变元组**，`let` 定义的就是**不可变元组**。不管是可变还是不可变元组，元组在创建后就不能**增加和删除**元素。\n\n可以对可变元组的元素进行修改，但是**不能改变其类型**：\n![BasicDataType08](基本数据类型/BasicDataType08.png)\n\n`any` 类型可以改为任何类型：\n![BasicDataType09](基本数据类型/BasicDataType09.png)\n\n### Tuple 分解\n\n将一个元组的内容分解成单独的常量或变量：\n![BasicDataType10](基本数据类型/BasicDataType10.png)\n\n如果只需要使用其中的一部分数据，不需要的数据可以用下划线（ `_` ）代替：\n![BasicDataType11](基本数据类型/BasicDataType11.png)\n\n### 作为函数返回值\n\n可以使用 Tuple 为函数返回多个值，返回值的 Tuple 可以在函数的返回类型部分被命名：\n\n```swift\nfunc writeToFile(content: String) -> (errorCode: Int, errorMessage: String) {\n    return (1, \"没有权限\")\n}\n```\n\n## Optional\n\n* 为什么需要 Optional？  \n在 Objective-C 里，`nil` 是无类型指针，所有对象变量都可以为 `nil`，但是数组、字典、集合等不允许放入 `nil`。`nil` 只能用在对象上，而在其他地方又用其他特殊值表示值的缺失，例如 `NSNotFound`。\n\n### Swift 中的 Optional\n\n* 通过在变量后面加 `?` 表示：  \n  **这里有一个值，它等于 x**  或者  **这里根本没有值**  \n\n在 Swift 中，`nil` 不是指针，他是值缺失的一种特殊类型，**任何类型的可选项都可以设置成 `nil` 而不仅仅是对象类型**。\n\n可以给**可选变量**赋值 `nil` 将之设置为没有值，但是不可以给一个非可选变量赋值一个 `nil`：\n![BasicDataType12](基本数据类型/BasicDataType12.png)\n\n### Optional-if 语句以及强制展开\n\n可选项是没法直接使用的，需要用 `!` 展开之后才能使用：\n![BasicDataType15](基本数据类型/BasicDataType15.png)\n\n不可以在没有展开的情况下直接使用：\n![BasicDataType13](基本数据类型/BasicDataType13.png)\n\n报错信息：编译器不知道 str 是否有值，需要使用 `!` 告诉编译器 `str` 一定有值。\n![BasicDataType14](基本数据类型/BasicDataType14.png)\n\n#### 一、Optional-强制展开\n\n使用 `!` 来获取一个不存在的可选值会导致运行错误，在使用 `!` 强制展开之前必须确保可选项中包含一个非 `nil` 的值。\n\n![BasicDataType16](基本数据类型/BasicDataType16.png)\n\n#### 二、Optional-绑定\n\n使用可选项绑定来判断可选项是否包含值，如果包含就把值赋给一个临时的常量或者变量。\n\n![BasicDataType17](基本数据类型/BasicDataType17.png)\n\n可选绑定可以与 `if` 和 `while` 语句配合使用来检查可选项内部的值，并赋值给一个变量或常量：\n  \n```swift\nif let actualStr = str {\n    // TODO\n}\n```\n\n同一个 `if` 语句中包含多个可选项绑定，用逗号分隔即可。如果任一可选绑定结果是 `nil` 或者布尔值为 `false`，那么整个 `if` 判断会被看做 `false`\n  \n```swift\nif let actualStr = str, actualStr2 = str2 {\n    // TOD\n}\n```\n\n#### 三、Optional-隐式展开\n\n有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开。\n\n通过在声明的类型后边添加一个叹号（`String!`）而非问号（`String?`）来书写隐式展开可选项。隐式展开可选项主要被用在 Swift 类的初始化过程中。\n![BasicDataType18](基本数据类型/BasicDataType18.png)\n\n#### 四、Optional-可选链\n\n可选项后面加问号，如果可选项不为 `nil`，**返回一个可选项结果**，否则返回 `nil`。\n\n如 count 就是 str?.count 返回的可选项结果。因为系统不确定可选项 count 是否有值，所以使用时需要先展开。此处先确定了 count 有值后，使用了强制展开：\n![BasicDataType21](基本数据类型/BasicDataType21.png)\n\n如果没有展开直接使用，系统会因为不确定 count 是否有值而报错：\n![BasicDataType19](基本数据类型/BasicDataType19.png)\n\n报错信息：count 是一个可选项，无法确定是否有值。\n![BasicDataType20](基本数据类型/BasicDataType20.png)\n\n### Optional-实现探究\n\nOptional 其实是标准库里的一个枚举（`enum`）类型，Optional 是用标准库实现语言特性的典型。\n\n可以使用 `Optional<String>` 代替符号 `?` 定义可选值变量：\n![BasicDataType23](基本数据类型/BasicDataType23.png)\n\nOptional 的实现：\n\n* `Optional.none` 就是 nil\n\n* `Optional.some` 则包装了实际的值\n\n![BasicDataType22](基本数据类型/BasicDataType22.png)\n\n泛型属性 `unsafelyUnwrapped` 就是符号`!`：\n\n```swift\n/// The wrapped value of this instance, unwrapped without checking whether\n/// the instance is `nil`.\n///\n/// The `unsafelyUnwrapped` property provides the same value as the forced\n/// unwrap operator (postfix `!`). However, in optimized builds (`-O`), no\n/// check is performed to ensure that the current instance actually has a\n/// value. Accessing this property in the case of a `nil` value is a serious\n/// programming error and could lead to undefined behavior or a runtime\n/// error.\n///\n/// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same\n/// behavior as using the postfix `!` operator and triggers a runtime error\n/// if the instance is `nil`.\n///\n/// The `unsafelyUnwrapped` property is recommended over calling the\n/// `unsafeBitCast(_:)` function because the property is more restrictive\n/// and because accessing the property still performs checking in debug\n/// builds.\n///\n/// - Warning: This property trades safety for performance.  Use\n///   `unsafelyUnwrapped` only when you are confident that this instance\n///   will never be equal to `nil` and only after you've tried using the\n///   postfix `!` operator.\n@inlinable public var unsafelyUnwrapped: Wrapped { get }\n```\n\n理论上可以直接调用 `unsafelyUnwrapped` 获取可选项的值（`!`）\n![BasicDataType24](基本数据类型/BasicDataType24.png)\n\n## 字符串\n\n### 初始化空串\n\n1、字面量\n\n```swift\nvar emptyString = \"\"\n```\n\n2、初始化器语法\n\n```swift\nvar anotherEmptyString = String()\n```\n\n`isEmpty` 检查是否为空串\n\n```swift\nif emptyString.isEmpty {\n    print(\"Nothing to see here\")\n}\n```\n\n### 字面量\n\n字符串字面量是被双引号（`\"\"`）包裹的固定顺序文本字符，Swift 会为 `str` 常量推断类型为 `String` 👇\n\n```swift\nlet str = \"some string\"\n```\n\n#### 多行字面量\n\n多行字符串字面量是用三个双引号引起来的一系列字符\n\n```swift\nlet str = \"\"\"\nabc\n\"\"\"\n```\n\n#### 多行字面量包含换行\n\n多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符。当代码中在多行字符串字面量里面包含了换行，那个换行符同样会成为字符串里的值。\n\n多行字符串字面量，包含换行：\n\n```swift\nlet string = \"\"\"\nIn the Southern Hemisphere,\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\nthat means migrating south,\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\nfeeds on krill on the surface of the sea,\nand feeds through flocks of krill with their mouths open.\n\"\"\"\n\nprint(string)\n```\n\n打印结果：\n\n```swift\nIn the Southern Hemisphere,\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\nthat means migrating south,\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\nfeeds on krill on the surface of the sea,\nand feeds through flocks of krill with their mouths open.\n```\n\n#### 多行字面量不包含换行\n\n如果想要使用换行符来让代码易读，却不想让换行符成为字符串的值，那就在那些行的末尾使用反斜杠`\\`\n\n```swift\nlet string = \"\"\"\nIn the Southern Hemisphere,\\\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\\\nthat means migrating south,\\\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\\\nfeeds on krill on the surface of the sea,\\\nand feeds through flocks of krill with their mouths open.\n\"\"\"\n\nprint(string)\n```\n\n打印结果：\n\n```swift\nIn the Southern Hemisphere,the end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,that means migrating south,heading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,feeds on krill on the surface of the sea,and feeds through flocks of krill with their mouths open.\n```\n\n* 如果你在某行的空格超过了结束的双引号（`\"\"\"`），那么这些空格会被包含进字符串\n\n![BasicDataType25](基本数据类型/BasicDataType25.png)\n\n#### 多行字面量包含代码缩进\n\n要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行。\n\n多行字符串可以缩进已匹配周围的代码。双引号（`\"\"\"`）前的空格会告诉 Swift 其他行前应该有多少空白是需要忽略的。\n\n定义一个字符串，带有代码缩进，在起始和结束换行：\n\n```swift\n    let string = \"\"\"\n\n        In the Southern Hemisphere,\\\n    the end of September means a warm climate and the approaching of summer.\n\n        For this southern right whale off the coast of Argentina,\\\n    that means migrating south,\\\n    heading to Antarctica to feed.\n\n    The Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\\\n    feeds on krill on the surface of the sea,\\\n    and feeds through flocks of krill with their mouths open.\n\n    \"\"\"\n```\n\n打印结果：\n\n```swift\n\n    In the Southern Hemisphere,the end of September means a warm climate and the approaching of summer.\n\n    For this southern right whale off the coast of Argentina,that means migrating south,heading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,feeds on krill on the surface of the sea,and feeds through flocks of krill with their mouths open.\n\n```\n\n#### 字符串里的特殊字符\n\n* 转义特殊字符 `\\0`（空字符），`\\\\`（反斜杠），`\\t`（水平制表符），`\\n`（换行符），`\\r`（回车符），`\\\"`（双引号）以及`\\'`（单引号）\n\n* 在多行字符串字面量中包含双引号 `\"` 不需转义，要在多行字符串中包含文本 `\"\"\"`，转义至少一个双引号\n\n```swift\nlet string = \"\"\"\n\"\"\n\"\"\\\"\n\"\"\"\nprint(string)\n```\n\n打印结果：\n\n```swift\n\"\"\n\"\"\"\n```\n\n* 任意的 Unicode 标量，写作 `\\u{n}`，n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值\n\n![BasicDataType26](基本数据类型/BasicDataType26.png)\n\n#### 扩展字符串分隔符（Raw String）\n\n* 在字符串字面量中放置扩展分隔符，使字符串中包含的特殊字符不生效，可以把字符串放在双引号（`\"`）内并由井号（`#`）包裹\n\n* 如果字符串里有 `#` 则首尾需要两个井号 `##`\n\n* 如果需要字符串中某个特殊符号的效果，要使用与首尾井号数量相同的井号，并在井号前面写转义符号（`\\`），如 `str2`\n\n```swift\nlet str = #\"Line 1\\nLine 2 \"#\nlet str1 = #\"Line 3\\#nLine 4\"#\nlet str2 = ###\"Line 5\\###nLine 6\"###\nprint(str)\nprint(str1)\nprint(str2)\n```\n\n打印结果：\n\n```swift\nLine 1\\nLine 2 \nLine 3\nLine 4\nLine 5\nLine 6\n```\n\n### 字符串-操作\n\n#### 字符串的可变性\n\n* `var` 指定的可以修改\n\n* `let` 指定的不可以修改\n\n![BasicDataType27](基本数据类型/BasicDataType27.png)\n\n对比 Objective-C（`NSString` 和 `NSMutableString`）。\n\n#### 字符串是值类型\n\n`String` 值在传递给方法或者函数的时候会被复制过去，赋值给常量或者变量的时候也是一样。\n\nSwift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行。\n![BasicDataType28](基本数据类型/BasicDataType28.png)\n\n#### 操作字符\n\nfor-in 循环遍历 String 中的每一个独立的 Character，String 值可以通过传入 Character 数组来构造。\n![BasicDataType29](基本数据类型/BasicDataType29.png)\n\n#### 字符串拼接\n\n1、使用加运算符 `+` 创建新字符串\n\n```swift\nvar string = \"1\" + \"2\"\nprint(string) // 12\n```\n\n2、使用加赋值符号 `+=` 在已经存在的 String 值末尾追加一个 String 值\n\n```swift\nvar string = \"1\" + \"2\"\nstring += \"3\"\nprint(string) // 123\n```\n\n3、使用 String 类型的 `append()` 方法来可以给一个 String 变量的末尾追加 Character 值\n\n```swift\nvar string = \"1\" + \"2\"\nstring.append(contentsOf: \"3\")\nprint(string) // 123\n```\n\n#### 字符串插值\n\n字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法。\n\n使用方法：每一个插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀\n\n```swift\nlet str1 = \"world\"\nlet str2 = \"Hello \\(str1)\"\n```\n\n`\\()` 类似于 `NSString` 的 `stringWithFormat:` 方法，但是更加简便，更强大：\n![BasicDataType30](基本数据类型/BasicDataType30.png)\n\n* 可以在扩展字符串分隔符中创建一个包含在其他情况下会被当作字符串插值的字符，要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首位井号数量的井号：\n![BasicDataType31](基本数据类型/BasicDataType31.png)\n\n### 字符串-访问和修改\n\n#### 字符串索引\n\n每一个 String 值都有相关的索引类型 `String.index`，它相当于每个 Character 在字符串中的位置。\n\n* `startIndex` 属性用来访问 String 的第一个 Character 的位置。\n* `endIndex` 属性就是 String 中最后一个字符后的位置。\n\n`endIndex` 属性并不是字符串下标脚本的合法实际参数。如果 String 为空，则 `startIndex` 与 `endIndex` 相等。\n![BasicDataType32](基本数据类型/BasicDataType32.png)\n\n`Index` 是一个结构体，并不能像数组那样，使用数字访问对应下标下的字符：\n\n```swift\n/// A position of a character or code unit in a string.\n@frozen public struct Index : Sendable {\n}\n```\n\n![BasicDataType33](基本数据类型/BasicDataType33.png)\n\n* 使用 `index(before:)` 和 `index(after:)` 方法来访问给定索引的前后\n\n* 要访问给定索引更远的索引，可以使用 `index(_:offsetBy:)`\n\n* 使用 `indices` 属性来访问字符串中每个字符的索引\n\n![BasicDataType34](基本数据类型/BasicDataType34.png)\n\n#### 插入\n\n* `insert(_:at:)`：插入字符。\n\n* `insert(contentsOf:at:)`：插入另一个字符串的内容到特定的索引。\n\n![BasicDataType35](基本数据类型/BasicDataType35.png)\n\n#### 删除\n\n* `remove(at:)`：移除字符。\n\n* `removeSubrange(_:)`：移除一小段特定范围的字符串。\n\n![BasicDataType36](基本数据类型/BasicDataType36.png)\n\n### 字符串-子串和字符串比较\n\n#### 子字符串\n\n使用下标或者类似 `prefix(_:)` 的方法得到的子字符串是 `Substring` 类型，Substring 拥有 String 的大部分方法。Substring 可以通过 `String()` 方法转成 String 类型。\n\n![BasicDataType37](基本数据类型/BasicDataType37.png)\n\n子字符串重用一部分原字符串的内存，修改字符串或者子字符串之前都不需要花费拷贝内存的代价。\n![BasicDataType38](基本数据类型/BasicDataType38.png)\n\nString 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上能很方便地兼容所有接受 StringProtocol 值的字符串操作函数。\n\n\n#### 字符串比较\n\n* `==`和`!=`：字符串和字符相等性\n\n* `hasPrefix(_:)`：前缀相等性\n\n* `hasSuffix(_:)`：后缀相等性\n\n![BasicDataType39](基本数据类型/BasicDataType39.png)\n","source":"_posts/Swift/基本数据类型.md","raw":"---\ntitle: 基本数据类型\ndate: 2022-09-30 10:51:22\ntags: Swift\n---\n\n* [常量和变量](#常量和变量)\n\n* [基本数据类型](#基本数据类型)\n\n* [Tuple](#tuple)\n\n* [Optional](#optional)\n\n* [字符串](#字符串)\n\n<!-- more -->\n\n## 常量和变量\n\n### 声明常量和变量\n\n1、使用关键字 `let` 来声明**常量**\n\n```swift\nlet maxNumber = 10\n```\n\n2、使用关键字 `var` 来声明**变量**\n\n```swift\nvar currentNumber = 0\n```\n\n3、可以在一行中声明多个变量或常量，用逗号分隔\n\n```swift\nvar x = 0.0, y = 0.0, z = 0.0\n```\n\n4、不可以修改常量\n![BasicDataType01](基本数据类型/BasicDataType01.png)\n\n### 类型标注\n\n**类型标注**：声明变量或常量的同时，指定其类型。在声明一个变量或常量的时候，通过提供类型标注，来明确该变量或常量能够储存值的类型。\n\n添加类型标注的方法：在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称（声明变量或常量的要素：**类型 + 变量名**）\n\n```swift\nvar name: String\n```\n\n可以在一行中定义多个变量为相同的类型，用逗号分隔，只要在最后的变量名字后边加上类型标注\n\n```swift\nvar name1, name2, name3: String\n```\n\n不可以给 String 类型的变量赋值 Int 类型的值：\n![BasicDataType02](基本数据类型/BasicDataType02.png)\n\n### 变量和常量命名\n\n常量和变量的名字几乎可以使用任何字符，包括 Unicode 字符。常量和变量的名字不能包含空白字符、数学符号、箭头、保留的（或者无效的）Unicode 码位、连线和制表符。虽然数字几乎可以使用在名字的任何位置，但是不能以数字开头。\n\n```swift\nlet π = 3.14159\nlet 你好 = \"你好世界\"\nlet 🐶🐮 = \"dogcow\"\n```\n\n### 打印常量和变量\n\n```swift\nlet 你好 = \"你好世界\"\nprint(\"欢迎语是\\(你好)\")\n```\n\n打印结果：\n\n```js\n欢迎语是你好世界\n```\n\n在Swift中使用`print(_:separator:terminator:)`作为打印方法。`\\()`是字符串插值，可以实现字符串的拼接。\n\n## 基本数据类型\n\n### 整数\n\nSwift 提供了 8，16，32 和 64 位编码的有符号和无符号整数，例如 8 位无符号整数的类型是 `UInt8`，32 位有符号整数的类型是 `Int32`。Swift 提供了一个额外的整数类型：`Int`，它拥有与当前平台的原生字相同的长度。同时 Swift 也提供 `UInt` 类型，来表示平台长度相关的无符号整数。**建议在用到整数的地方都是用 `Int`**。\n\n通过 `min` 和 `max` 属性来访问每个整数类型的**最小值**和**最大值**。\n\n### 浮点类型\n\n* `Double`：64 位浮点数，至少有 15 位数字的精度。\n\n* `Float`：32 位浮点数，至少有 6 位数字的精度。\n\n在两种类型都可以的情况下，推荐使用 `Double` 类型。\n\n### 数值范围\n\n![BasicDataType03](基本数据类型/BasicDataType03.png)\n\n### Bool\n\n`Bool`：`true` 和 `false`。Swift 的类型安全机制会阻止用一个非布尔量的值替换掉 `Bool`。如下图，不可以直接判断一个变量，而是需要写成判断的方式（`i == 1`）\n![BasicDataType04](基本数据类型/BasicDataType04.png)\n\n### 类型别名\n\n类型别名：为已存在类型定义一个可选择的名字。可以通过关键字 `typealias` 定义一个类型别名。\n\n如为一个已存在的类型定义一个新的名字，让其在上下文中看起来更合适、更具有表达性，用新的名字来引用这个已存在的类型：\n\n```swift\ntypealias AudioSample = UInt8\nlet sample: AudioSample = 32\n```\n\n## Tuple\n\n元组实现了**把多个值合并成一个复合型的值**。元组内的值可以是任何类型，而且可以不必是同一类型。\n\n### 元素命名\n\n元组中的每一个元素可以指定对应的**元素名称**：\n![BasicDataType07](基本数据类型/BasicDataType07.png)\n\n如果没有指定名称的元素也可以使用**下标**的方式来引用：\n![BasicDataType06](基本数据类型/BasicDataType06.png)\n\n### Tuple 修改\n\n用 `var` 定义的元组就是**可变元组**，`let` 定义的就是**不可变元组**。不管是可变还是不可变元组，元组在创建后就不能**增加和删除**元素。\n\n可以对可变元组的元素进行修改，但是**不能改变其类型**：\n![BasicDataType08](基本数据类型/BasicDataType08.png)\n\n`any` 类型可以改为任何类型：\n![BasicDataType09](基本数据类型/BasicDataType09.png)\n\n### Tuple 分解\n\n将一个元组的内容分解成单独的常量或变量：\n![BasicDataType10](基本数据类型/BasicDataType10.png)\n\n如果只需要使用其中的一部分数据，不需要的数据可以用下划线（ `_` ）代替：\n![BasicDataType11](基本数据类型/BasicDataType11.png)\n\n### 作为函数返回值\n\n可以使用 Tuple 为函数返回多个值，返回值的 Tuple 可以在函数的返回类型部分被命名：\n\n```swift\nfunc writeToFile(content: String) -> (errorCode: Int, errorMessage: String) {\n    return (1, \"没有权限\")\n}\n```\n\n## Optional\n\n* 为什么需要 Optional？  \n在 Objective-C 里，`nil` 是无类型指针，所有对象变量都可以为 `nil`，但是数组、字典、集合等不允许放入 `nil`。`nil` 只能用在对象上，而在其他地方又用其他特殊值表示值的缺失，例如 `NSNotFound`。\n\n### Swift 中的 Optional\n\n* 通过在变量后面加 `?` 表示：  \n  **这里有一个值，它等于 x**  或者  **这里根本没有值**  \n\n在 Swift 中，`nil` 不是指针，他是值缺失的一种特殊类型，**任何类型的可选项都可以设置成 `nil` 而不仅仅是对象类型**。\n\n可以给**可选变量**赋值 `nil` 将之设置为没有值，但是不可以给一个非可选变量赋值一个 `nil`：\n![BasicDataType12](基本数据类型/BasicDataType12.png)\n\n### Optional-if 语句以及强制展开\n\n可选项是没法直接使用的，需要用 `!` 展开之后才能使用：\n![BasicDataType15](基本数据类型/BasicDataType15.png)\n\n不可以在没有展开的情况下直接使用：\n![BasicDataType13](基本数据类型/BasicDataType13.png)\n\n报错信息：编译器不知道 str 是否有值，需要使用 `!` 告诉编译器 `str` 一定有值。\n![BasicDataType14](基本数据类型/BasicDataType14.png)\n\n#### 一、Optional-强制展开\n\n使用 `!` 来获取一个不存在的可选值会导致运行错误，在使用 `!` 强制展开之前必须确保可选项中包含一个非 `nil` 的值。\n\n![BasicDataType16](基本数据类型/BasicDataType16.png)\n\n#### 二、Optional-绑定\n\n使用可选项绑定来判断可选项是否包含值，如果包含就把值赋给一个临时的常量或者变量。\n\n![BasicDataType17](基本数据类型/BasicDataType17.png)\n\n可选绑定可以与 `if` 和 `while` 语句配合使用来检查可选项内部的值，并赋值给一个变量或常量：\n  \n```swift\nif let actualStr = str {\n    // TODO\n}\n```\n\n同一个 `if` 语句中包含多个可选项绑定，用逗号分隔即可。如果任一可选绑定结果是 `nil` 或者布尔值为 `false`，那么整个 `if` 判断会被看做 `false`\n  \n```swift\nif let actualStr = str, actualStr2 = str2 {\n    // TOD\n}\n```\n\n#### 三、Optional-隐式展开\n\n有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开。\n\n通过在声明的类型后边添加一个叹号（`String!`）而非问号（`String?`）来书写隐式展开可选项。隐式展开可选项主要被用在 Swift 类的初始化过程中。\n![BasicDataType18](基本数据类型/BasicDataType18.png)\n\n#### 四、Optional-可选链\n\n可选项后面加问号，如果可选项不为 `nil`，**返回一个可选项结果**，否则返回 `nil`。\n\n如 count 就是 str?.count 返回的可选项结果。因为系统不确定可选项 count 是否有值，所以使用时需要先展开。此处先确定了 count 有值后，使用了强制展开：\n![BasicDataType21](基本数据类型/BasicDataType21.png)\n\n如果没有展开直接使用，系统会因为不确定 count 是否有值而报错：\n![BasicDataType19](基本数据类型/BasicDataType19.png)\n\n报错信息：count 是一个可选项，无法确定是否有值。\n![BasicDataType20](基本数据类型/BasicDataType20.png)\n\n### Optional-实现探究\n\nOptional 其实是标准库里的一个枚举（`enum`）类型，Optional 是用标准库实现语言特性的典型。\n\n可以使用 `Optional<String>` 代替符号 `?` 定义可选值变量：\n![BasicDataType23](基本数据类型/BasicDataType23.png)\n\nOptional 的实现：\n\n* `Optional.none` 就是 nil\n\n* `Optional.some` 则包装了实际的值\n\n![BasicDataType22](基本数据类型/BasicDataType22.png)\n\n泛型属性 `unsafelyUnwrapped` 就是符号`!`：\n\n```swift\n/// The wrapped value of this instance, unwrapped without checking whether\n/// the instance is `nil`.\n///\n/// The `unsafelyUnwrapped` property provides the same value as the forced\n/// unwrap operator (postfix `!`). However, in optimized builds (`-O`), no\n/// check is performed to ensure that the current instance actually has a\n/// value. Accessing this property in the case of a `nil` value is a serious\n/// programming error and could lead to undefined behavior or a runtime\n/// error.\n///\n/// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same\n/// behavior as using the postfix `!` operator and triggers a runtime error\n/// if the instance is `nil`.\n///\n/// The `unsafelyUnwrapped` property is recommended over calling the\n/// `unsafeBitCast(_:)` function because the property is more restrictive\n/// and because accessing the property still performs checking in debug\n/// builds.\n///\n/// - Warning: This property trades safety for performance.  Use\n///   `unsafelyUnwrapped` only when you are confident that this instance\n///   will never be equal to `nil` and only after you've tried using the\n///   postfix `!` operator.\n@inlinable public var unsafelyUnwrapped: Wrapped { get }\n```\n\n理论上可以直接调用 `unsafelyUnwrapped` 获取可选项的值（`!`）\n![BasicDataType24](基本数据类型/BasicDataType24.png)\n\n## 字符串\n\n### 初始化空串\n\n1、字面量\n\n```swift\nvar emptyString = \"\"\n```\n\n2、初始化器语法\n\n```swift\nvar anotherEmptyString = String()\n```\n\n`isEmpty` 检查是否为空串\n\n```swift\nif emptyString.isEmpty {\n    print(\"Nothing to see here\")\n}\n```\n\n### 字面量\n\n字符串字面量是被双引号（`\"\"`）包裹的固定顺序文本字符，Swift 会为 `str` 常量推断类型为 `String` 👇\n\n```swift\nlet str = \"some string\"\n```\n\n#### 多行字面量\n\n多行字符串字面量是用三个双引号引起来的一系列字符\n\n```swift\nlet str = \"\"\"\nabc\n\"\"\"\n```\n\n#### 多行字面量包含换行\n\n多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符。当代码中在多行字符串字面量里面包含了换行，那个换行符同样会成为字符串里的值。\n\n多行字符串字面量，包含换行：\n\n```swift\nlet string = \"\"\"\nIn the Southern Hemisphere,\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\nthat means migrating south,\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\nfeeds on krill on the surface of the sea,\nand feeds through flocks of krill with their mouths open.\n\"\"\"\n\nprint(string)\n```\n\n打印结果：\n\n```swift\nIn the Southern Hemisphere,\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\nthat means migrating south,\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\nfeeds on krill on the surface of the sea,\nand feeds through flocks of krill with their mouths open.\n```\n\n#### 多行字面量不包含换行\n\n如果想要使用换行符来让代码易读，却不想让换行符成为字符串的值，那就在那些行的末尾使用反斜杠`\\`\n\n```swift\nlet string = \"\"\"\nIn the Southern Hemisphere,\\\nthe end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,\\\nthat means migrating south,\\\nheading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\\\nfeeds on krill on the surface of the sea,\\\nand feeds through flocks of krill with their mouths open.\n\"\"\"\n\nprint(string)\n```\n\n打印结果：\n\n```swift\nIn the Southern Hemisphere,the end of September means a warm climate and the approaching of summer.\n\nFor this southern right whale off the coast of Argentina,that means migrating south,heading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,feeds on krill on the surface of the sea,and feeds through flocks of krill with their mouths open.\n```\n\n* 如果你在某行的空格超过了结束的双引号（`\"\"\"`），那么这些空格会被包含进字符串\n\n![BasicDataType25](基本数据类型/BasicDataType25.png)\n\n#### 多行字面量包含代码缩进\n\n要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行。\n\n多行字符串可以缩进已匹配周围的代码。双引号（`\"\"\"`）前的空格会告诉 Swift 其他行前应该有多少空白是需要忽略的。\n\n定义一个字符串，带有代码缩进，在起始和结束换行：\n\n```swift\n    let string = \"\"\"\n\n        In the Southern Hemisphere,\\\n    the end of September means a warm climate and the approaching of summer.\n\n        For this southern right whale off the coast of Argentina,\\\n    that means migrating south,\\\n    heading to Antarctica to feed.\n\n    The Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,\\\n    feeds on krill on the surface of the sea,\\\n    and feeds through flocks of krill with their mouths open.\n\n    \"\"\"\n```\n\n打印结果：\n\n```swift\n\n    In the Southern Hemisphere,the end of September means a warm climate and the approaching of summer.\n\n    For this southern right whale off the coast of Argentina,that means migrating south,heading to Antarctica to feed.\n\nThe Southern Right Whale is a subspecies of the Right Whale that inhabits the ocean south of the equator,feeds on krill on the surface of the sea,and feeds through flocks of krill with their mouths open.\n\n```\n\n#### 字符串里的特殊字符\n\n* 转义特殊字符 `\\0`（空字符），`\\\\`（反斜杠），`\\t`（水平制表符），`\\n`（换行符），`\\r`（回车符），`\\\"`（双引号）以及`\\'`（单引号）\n\n* 在多行字符串字面量中包含双引号 `\"` 不需转义，要在多行字符串中包含文本 `\"\"\"`，转义至少一个双引号\n\n```swift\nlet string = \"\"\"\n\"\"\n\"\"\\\"\n\"\"\"\nprint(string)\n```\n\n打印结果：\n\n```swift\n\"\"\n\"\"\"\n```\n\n* 任意的 Unicode 标量，写作 `\\u{n}`，n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值\n\n![BasicDataType26](基本数据类型/BasicDataType26.png)\n\n#### 扩展字符串分隔符（Raw String）\n\n* 在字符串字面量中放置扩展分隔符，使字符串中包含的特殊字符不生效，可以把字符串放在双引号（`\"`）内并由井号（`#`）包裹\n\n* 如果字符串里有 `#` 则首尾需要两个井号 `##`\n\n* 如果需要字符串中某个特殊符号的效果，要使用与首尾井号数量相同的井号，并在井号前面写转义符号（`\\`），如 `str2`\n\n```swift\nlet str = #\"Line 1\\nLine 2 \"#\nlet str1 = #\"Line 3\\#nLine 4\"#\nlet str2 = ###\"Line 5\\###nLine 6\"###\nprint(str)\nprint(str1)\nprint(str2)\n```\n\n打印结果：\n\n```swift\nLine 1\\nLine 2 \nLine 3\nLine 4\nLine 5\nLine 6\n```\n\n### 字符串-操作\n\n#### 字符串的可变性\n\n* `var` 指定的可以修改\n\n* `let` 指定的不可以修改\n\n![BasicDataType27](基本数据类型/BasicDataType27.png)\n\n对比 Objective-C（`NSString` 和 `NSMutableString`）。\n\n#### 字符串是值类型\n\n`String` 值在传递给方法或者函数的时候会被复制过去，赋值给常量或者变量的时候也是一样。\n\nSwift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行。\n![BasicDataType28](基本数据类型/BasicDataType28.png)\n\n#### 操作字符\n\nfor-in 循环遍历 String 中的每一个独立的 Character，String 值可以通过传入 Character 数组来构造。\n![BasicDataType29](基本数据类型/BasicDataType29.png)\n\n#### 字符串拼接\n\n1、使用加运算符 `+` 创建新字符串\n\n```swift\nvar string = \"1\" + \"2\"\nprint(string) // 12\n```\n\n2、使用加赋值符号 `+=` 在已经存在的 String 值末尾追加一个 String 值\n\n```swift\nvar string = \"1\" + \"2\"\nstring += \"3\"\nprint(string) // 123\n```\n\n3、使用 String 类型的 `append()` 方法来可以给一个 String 变量的末尾追加 Character 值\n\n```swift\nvar string = \"1\" + \"2\"\nstring.append(contentsOf: \"3\")\nprint(string) // 123\n```\n\n#### 字符串插值\n\n字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法。\n\n使用方法：每一个插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀\n\n```swift\nlet str1 = \"world\"\nlet str2 = \"Hello \\(str1)\"\n```\n\n`\\()` 类似于 `NSString` 的 `stringWithFormat:` 方法，但是更加简便，更强大：\n![BasicDataType30](基本数据类型/BasicDataType30.png)\n\n* 可以在扩展字符串分隔符中创建一个包含在其他情况下会被当作字符串插值的字符，要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首位井号数量的井号：\n![BasicDataType31](基本数据类型/BasicDataType31.png)\n\n### 字符串-访问和修改\n\n#### 字符串索引\n\n每一个 String 值都有相关的索引类型 `String.index`，它相当于每个 Character 在字符串中的位置。\n\n* `startIndex` 属性用来访问 String 的第一个 Character 的位置。\n* `endIndex` 属性就是 String 中最后一个字符后的位置。\n\n`endIndex` 属性并不是字符串下标脚本的合法实际参数。如果 String 为空，则 `startIndex` 与 `endIndex` 相等。\n![BasicDataType32](基本数据类型/BasicDataType32.png)\n\n`Index` 是一个结构体，并不能像数组那样，使用数字访问对应下标下的字符：\n\n```swift\n/// A position of a character or code unit in a string.\n@frozen public struct Index : Sendable {\n}\n```\n\n![BasicDataType33](基本数据类型/BasicDataType33.png)\n\n* 使用 `index(before:)` 和 `index(after:)` 方法来访问给定索引的前后\n\n* 要访问给定索引更远的索引，可以使用 `index(_:offsetBy:)`\n\n* 使用 `indices` 属性来访问字符串中每个字符的索引\n\n![BasicDataType34](基本数据类型/BasicDataType34.png)\n\n#### 插入\n\n* `insert(_:at:)`：插入字符。\n\n* `insert(contentsOf:at:)`：插入另一个字符串的内容到特定的索引。\n\n![BasicDataType35](基本数据类型/BasicDataType35.png)\n\n#### 删除\n\n* `remove(at:)`：移除字符。\n\n* `removeSubrange(_:)`：移除一小段特定范围的字符串。\n\n![BasicDataType36](基本数据类型/BasicDataType36.png)\n\n### 字符串-子串和字符串比较\n\n#### 子字符串\n\n使用下标或者类似 `prefix(_:)` 的方法得到的子字符串是 `Substring` 类型，Substring 拥有 String 的大部分方法。Substring 可以通过 `String()` 方法转成 String 类型。\n\n![BasicDataType37](基本数据类型/BasicDataType37.png)\n\n子字符串重用一部分原字符串的内存，修改字符串或者子字符串之前都不需要花费拷贝内存的代价。\n![BasicDataType38](基本数据类型/BasicDataType38.png)\n\nString 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上能很方便地兼容所有接受 StringProtocol 值的字符串操作函数。\n\n\n#### 字符串比较\n\n* `==`和`!=`：字符串和字符相等性\n\n* `hasPrefix(_:)`：前缀相等性\n\n* `hasSuffix(_:)`：后缀相等性\n\n![BasicDataType39](基本数据类型/BasicDataType39.png)\n","slug":"Swift/基本数据类型","published":1,"updated":"2023-08-22T09:52:14.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgu3001jaq7ksple8qhi"},{"title":"时间魔法 Swift篇","date":"2016-05-26T16:00:00.000Z","_content":"# 简介\n* NSDate 。在日期编程中，这个对象描述了日期和时间信息。可以把日期和时间看做是类中的普通属性，它不但用于日期，也用于时间处理。格式化，这个概念在直接处理 NSDate 对象时还用不到，只有在将日期对象转换为字符串对象时，才能用到格式化。\n* NSDateComponents 。这个类可以简单的看做是 NSDate 的“姐妹”类，因为它为开发者带来了许多关于日期的便捷操作。其中一项重要内容是：它可以将日期和时间分割成独立的属性，这样就可以直接访问每项属性，这在诸如日期计算之类的任务中非常有用。\n<!-- more -->\n 除了上面这些功能外， NSDateComponents 类在计算过去或未来的时间上也很有用。只需要简单的对某个子属性（年，月年等）执行加减操作，就可以算出未来或过去的一个时间。另外，NSDateComponents 类还适合查找两个日期之间的间隔。\n* NSCalendar 。这个类的功能并不在本文的讨论范围，但是，NSDate 和 NSDateComponents 之间的互相转换，却是由 NSCalendar 类来控制的，因为需要制定某个 NSCalendar 对象，才能完成转换。事实上，系统在进行转换时，需要知道使用的日历（历法）是哪个，然后才能获得正确的转换结果。要知道，世界上有许多不同的日历，其年月日的值是各不相同的。\n*  NSDateFormatter 。这个类会帮助我们将 NSDate 对象转换为字符串对象，也可以将字符串对象转换为 NSDate 对象。通过它，可以将 NSDate 对象按照预定义的日期样式直接转换成字符串，也可以按自定义的日期格式进行转换。\n NSDateFormatter 对象也支持本地化功能，只需要提供一个有效的 NSLocale 对象，就可以按照给定的locale设置转换成合适的字符串内容。\n* NSDateComponentsFormatter 。它有一个重要目的：输入日期和时间，输出格式化好的可读字符串。它包含了许多方法来完成这个任务。\n\n***\n<!-- more -->\n![time](http://o7ttfnm00.bkt.clouddn.com/5.jpg)\n\n* [NSDate](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDate_Class/)\n* [NSDateFormatter](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDateFormatter_Class/index.html)\n* [NSDateComponentFormatter](https://developer.apple.com/library/watchos/documentation/Foundation/Reference/NSDateComponentsFormatter_class/index.html)\n* [NSCalendar](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/)\n***\n\n# NSDate\n```\n//获取当前时间\nlet date1 = NSDate()     //\"May 27, 2016, 2:36 PM\"\nlet str1 = String(date1) //\"2016-05-27 06:36:17 +0000\"\n\n//获取从1970年1月1日00:00到当前时间的秒数\nvar interval : NSTimeInterval = date1.timeIntervalSince1970 //1464330977.49057 \n\nlet date2 = NSDate()\n//计算时间差\ninterval = date2.timeIntervalSinceDate(date1) //0.2234339714050293\n//date1 距现在的时间差\ninterval = date1.timeIntervalSinceNow         //-0.2241280078887939\n\n//得到date2后一天的时间对象\nlet date3 = date2 .dateByAddingTimeInterval(24*3600)             // 实例方法\nlet date4 = NSDate.init(timeInterval: 24*3600, sinceDate: date2) // 类方法\nprint(\"date3 == \\(date3) ; date4 == \\(date4)\")                   \n//\"date3 == 2016-05-28 06:36:17 +0000 ; date4 == 2016-05-28 06:36:17 +0000\"\n\n//得到距现在多少秒后一个日期时间对象\nlet date5 = NSDate.init(timeIntervalSinceNow: 3*24*3600) //\"May 30, 2016, 2:36 PM\"\nprint(date5)                                             //\"2016-05-30 06:36:17 +0000\\n\"\n\n//未来\nlet date6 = NSDate.distantFuture() //\"Jan 1, 4001, 8:00 AM\"\n//亘古\nlet date7 = NSDate.distantPast()   //\"4001-01-01 00:00:00 +0000\\n\"\nprint(\"future == \\(date6); past == \\(date7)\")\n//\"future == 4001-01-01 00:00:00 +0000; past == 0000-12-30 00:00:00 +0000\"\n```\n***\n# NSDateFormatter\n\n## 初始化\n```\nlet dateFormatter = NSDateFormatter()\n```\n有两种方式可以设置格式:一种是通过一些预定义的日期格式化样式（dateStyle）；另外一种是通过某些说明符来手动设置日期格式。stringFromDate 方法的使用也很重要，它是真正执行转换的代码。当谈到日期、字符串转换时，就指的是这个方法，而其他步骤只是起到定制结果的辅助作用。如果你在项目里要用到日期转换，这个方法会非常方便。\n```\ndateFormatter.dateStyle = NSDateFormatterStyle.FullStyle   //完整样式（FullStyle）\nvar convertedDate = dateFormatter.stringFromDate(date1)    //\"Friday, May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.LongStyle   //长样式（Long Style）\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.MediumStyle //中等样式(Medium Style)\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.ShortStyle  //短样式（Short Style）\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"5/27/16\"\n```\n## 改变时区\n```\ndateFormatter.dateStyle = NSDateFormatterStyle.FullStyle\n// 希腊\ndateFormatter.locale = NSLocale(localeIdentifier: \"el_GR\")\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Παρασκευή, 27 Μαΐου 2016\"\n// 法国\ndateFormatter.locale = NSLocale(localeIdentifier: \"fr_FR\")\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"vendredi 27 mai 2016\"\n// 本地\ndateFormatter.locale = NSLocale.currentLocale()\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Friday, May 27, 2016\"\n```\n## 自定义的日期格式\n\n[设置自定义日期格式](http://unicode.org/reports/tr35/tr35-6.html#Date_Format_Patterns)在两种场景中很有用：          \n1.当预定义的日期样式不能满足我们的需求；2.当我们需要把一个复杂的日期字符串（比如Thu, 08 Oct 2015 09:22:33 GMT）转换成日期对象。要想设置合适的日期格式（对象），必须搭配使用一系列说明符。说明符也是简单的字符，但是对于date formatter来说有特定的含义。\n```\n EEEE：“星期”的全名（比如Monday）。如需缩写，指定1-3个字符（如E，EE，EEE代表Mon）。\n MMMM：“月份”的全名（比如October）。如需缩写，指定1-3个字符（如M，MM，MMM代表Oct）。\n dd：某月的第几天（例如，09或15）\n yyyy：四位字符串表示“年”（例如2015）\n HH：两位字符串表示“小时”（例如08或19）\n mm：两位字符串表示“分钟”（例如05或54）\n ss：两位字符串表示“秒”\n zzz：三位字符串表示“时区”（例如GMT）\n GGG：公元前BC或公元后AD\n ```\n \n```\ndateFormatter.dateFormat = \"EEEE, MMMM dd, yyyy\"\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Friday, May 27, 2016\"\n\ndateFormatter.dateFormat = \"HH:mm:ss\"\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"14:36:17\"\n\nvar dateAsString = \"27-05-2016 23:59\"\ndateFormatter.dateFormat = \"dd-MM-yyyy HH:mm\"\nvar newDate = dateFormatter.dateFromString(dateAsString)   //\"May 27, 2016, 11:59 PM\"\n\n// 包含时区信息的复杂字符串：\ndateAsString = \"Thu, 27 May 2016 09:22:33 GMT\"\ndateFormatter.dateFormat = \"EEE, dd MMM yyyy HH:mm:ss zzz\"\nnewDate = dateFormatter.dateFromString(dateAsString)       //\"May 27, 2016, 5:22 PM\"\n```\n***\n# NSDateComponents\n\n## NSDate到NSDateComponents\n\nNSCalendar 的 components(_:fromDate:)，这个方法接受两个参数：第二个是日期对象；第一个参数比较有意思，它接收若干个 NSCalendarUnit 类型值，NSCAlendarUnit 用来说明需要的日期部分。NSCalendarUnit 是一个结构体，你可以在 这个[文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/#//apple_ref/swift/struct/c:@E@NSCalendarUnit) 中看到所有属性。这里需要注意：若某个组件没有在第一个参数中指定，就无法访问它。如：在这个例子中，我们没有指定 NSCalendarUnit.TimeZone，这样就无法访问时区的组件，比如print(dateComponents.timezone)调用会造成一个运行时错误。如果你需要额外的日期组件，只能重新调用一次calendar.Components方法，把你需要的Calendar Unit添加进去。\n\n```\nlet calendar = NSCalendar.currentCalendar()\nlet dateComponents = calendar.components([NSCalendarUnit.Day, NSCalendarUnit.Month, NSCalendarUnit.Year, NSCalendarUnit.WeekOfYear, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second, NSCalendarUnit.Nanosecond], fromDate: date1)\n\nprint(\"day = \\(dateComponents.day)\", \"month = \\(dateComponents.month)\", \"year = \\(dateComponents.year)\", \"week of year = \\(dateComponents.weekOfYear)\", \"hour = \\(dateComponents.hour)\", \"minute = \\(dateComponents.minute)\", \"second = \\(dateComponents.second)\", \"nanosecond = \\(dateComponents.nanosecond)\" , separator: \", \", terminator: \"\")\n\n//\"day = 27, month = 5, year = 2016, week of year = 22, hour = 14, minute = 36, second = 17, nanosecond = 490570008\"\n\nlet year = dateComponents.year             //年\nlet mondth = dateComponents.month          //月\nlet day = dateComponents.day               //日\nlet weekOfYear = dateComponents.weekOfYear //第几周\nlet hour = dateComponents.hour             //时\nlet minute = dateComponents.minute         //分\nlet second = dateComponents.second         //秒\nlet nanosecond = dateComponents.nanosecond //毫微秒\n```\n## NSDateComponents到NSDate\n\n### 初始化\n\n这个过程中不需要使用calendar unit。只用初始化一个新的 NSDateComponents 对象，然后显式的设置你需要的组件的值，然后调用 NSCalendar 的 dateFromComponents 方法即可\n```\nlet components = NSDateComponents()\ncomponents.day = 5\ncomponents.month = 01\ncomponents.year = 2016\ncomponents.hour = 19\ncomponents.minute = 30\nnewDate = calendar.dateFromComponents(components)\n```\n### 改动时区对转换日期对象的影响\n```\nGMT = Greenwich Mean Time（格林尼治标准时间）\nCST = China Standard Time（中国标准时间）\nCET = Central European Time(欧洲中部时间）\n时区缩写的列表（http://www.timeanddate.com/time/zones/）\n```\n```\ncomponents.timeZone = NSTimeZone(abbreviation: \"GMT\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 3:30 AM\"\n\ncomponents.timeZone = NSTimeZone(abbreviation: \"CST\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 9:30 AM\"\n\ncomponents.timeZone = NSTimeZone(abbreviation: \"CET\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 2:30 AM\"\n```\n***\n# 比较日期和时间\nearlierDate:, 它用于判断一个日期是否早于另外一个日期。对应的还有一个是 laterDate:\n```\nearlierDate:\n如果 date1 早于 date2，该方法返回date1\n如过 date2 早于 date1，该方法返回date2\n如果 date1 和 date2 相同，返回date1\n\ndateFormatter.dateFormat = \"MMM dd, yyyy zzz\"\ndateAsString = \"May 27, 2016 GMT\"\nvar date8 = dateFormatter.dateFromString(dateAsString)! //\"May 27, 2016, 8:00 AM\"\n\nvar date10 = date1.earlierDate(date8)                   //\"May 27, 2016, 8:00 AM\"\ndate10 = date1.laterDate(date8)                         //\"May 27, 2016, 3:12 PM\"\n```\nNSDate 的 compare: 方法，它需要搭配使用 NSComparisonResult 枚举体。\n```\nif date1.compare(date2) == NSComparisonResult.OrderedDescending{\n    print(\"Date1 is later than date2\")\n}else if date1.compare(date2) == NSComparisonResult.OrderedAscending{\n    print(\"Date1 is Earlier than Date2\") //\"Date1 is Earlier than Date2\\n\"\n}else if date1.compare(date2) == NSComparisonResult.OrderedSame {\n    print(\"Same date\")\n}\n```\n时间间隔（time interval)，查找到每个日期（到现在）的时间间隔，进行比对。\n```\nif date1.timeIntervalSinceReferenceDate > date2.timeIntervalSinceReferenceDate {\n    print(\"Date1 is Later than Date2\")\n}else if date1.timeIntervalSinceReferenceDate <  date2.timeIntervalSinceReferenceDate {\n    print(\"Date1 is Earlier than Date2\") //\"Date1 is Earlier than Date2\\n\"\n}else {\n    print(\"Same dates\")\n}\n```\n在下面的方法里，会看到“2000-01-01”的日期，这是因为若 NSDate 对象没有指定日期，只指定时间的话，会自动添加默认的日期属性。\n```\ndateFormatter.dateFormat = \"HH:mm:ss zzz\"\ndateAsString = \"14:28:16 GMT\"\nlet date11 = dateFormatter.dateFromString(dateAsString)!\ndateAsString = \"19:53:12 GMT\"\nlet date12 = dateFormatter.dateFromString(dateAsString)!\n\nif date1.earlierDate(date2) == date1 {\n    if date1.isEqualToDate(date2) {\n        print(\"Same time\")\n    }else {\n        print(\"\\(date1) is earlier than \\(date2)\")\n        //2016-05-27 07:12:44 +0000 is earlier than 2016-05-27 07:12:44 +0000\n    }\n}else {\n    print(\"\\(date2) is earlier than \\(date1)\")\n}\n```\n***\n# 计算未来和过去的日期\n两种不同的方法：第一种使用 NSCalendar 类和 NSCalendarUnit 结构体；第二种使用 NSDateComponents 类。\n\n假定我们需要为这个日期往后推两个月又5天。\n```\nlet monthsToAdd = 2\nlet daysToAdd = 5\n\n```\n这里用到的方法是 NSCAlendar 类的 dateByAddingUnit:value:toDate:options: 方法。它的作用是添加某个日历单元值（如年月日时分秒等）到现有的日期对象上，然后返回新的日期对象。我们需要添加两个日历单元到当前日期，直接用这个方法是不可能的（它每次只能设置一个calendar unit）。关键是调用两次这个方法，设置不同的日历单元，就能得到最终结果。\n```\nvar calculatedDate = NSCalendar.currentCalendar().dateByAddingUnit(NSCalendarUnit.Month, value: monthsToAdd, toDate: date1, options: NSCalendarOptions.init(rawValue: 0))\ncalculatedDate = NSCalendar.currentCalendar().dateByAddingUnit(NSCalendarUnit.Day, value: daysToAdd, toDate: calculatedDate!, options: NSCalendarOptions.init(rawValue: 0))\n```\n当日历单元多的时候，你就需要多次调用这个方法。在日历单元比较多的时候，更好的方法是使用 NSDateComponents 类。初始化一个 NSDateComponents 对象，并设置月份和天的信息。然后我们调用 NSCalendar 的另一个方法dateByAddingComponents:toDate:options:，并最终获得我们需要的日期对象。\n```\nlet newDateComponents = NSDateComponents()\nnewDateComponents.month = monthsToAdd\nnewDateComponents.day = daysToAdd\n\ncalculatedDate = NSCalendar.currentCalendar().dateByAddingComponents(newDateComponents, toDate: date1, options: NSCalendarOptions.init(rawValue: 0))\n\n```\n// 注意：在以上调用 NSCalendar 方法的地方，最后一个参数options都没有被设置。如果你需要具体设置options的值，请参考完整的 [官方文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/)。\n\n***\n# 计算日期间隔\n通过date components来计算日期对象间隔。这个新方法叫 components:fromDate:toDate:options:,第一个参数是 NSCalendarUnit 值的数组。这里要注意，如果第一个日期如果晚于第二个日期，则结果会返回负值。\n```\nvar diffFateComponents = NSCalendar.currentCalendar().components([NSCalendarUnit.Year, NSCalendarUnit.Month, NSCalendarUnit.Day, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second], fromDate: date1, toDate: date14, options: NSCalendarOptions.init(rawValue: 0))\n\nprint(\"The difference between dates is: \\(diffFateComponents.year) years, \\(diffFateComponents.month) months, \\(diffFateComponents.day) days, \\(diffFateComponents.hour) hours, \\(diffFateComponents.minute) minutes, \\(diffFateComponents.second) seconds\")\n//\"The difference between dates is: 1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n\nlet diffYear = diffFateComponents.year\nlet diffMonth = diffFateComponents.month\nlet diffDay = diffFateComponents.day\nlet diffHour = diffFateComponents.hour\nlet diffMinute = diffFateComponents.minute\nlet diffSecond = diffFateComponents.second\n```\nNSDateComponentsFormatter 类，它提供了多种用于自动计算日期间隔的方法，并可以返回格式化字符串结果。unitsStyle 属性指定我们使用的 dateComponentsFormatter 以何种格式打印日期的间隔。这里我们使用 完整 样式。\n```\nlet dateComponentsFormatter = NSDateComponentsFormatter()\ndateComponentsFormatter.unitsStyle = NSDateComponentsFormatterUnitsStyle.Full\n\nlet interval2 = date14.timeIntervalSinceDate(date1)\ndateComponentsFormatter.stringFromTimeInterval(interval2)\n//\"1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n```\n最后，在第三种计算的方法中，我们将两个日期传递给 NSDateComponentsFormatter 对象的一个叫 stringFromDate:toDate: 的方法。但是这个方法需要有个前置的条件：NSDateComponentsFormatter 的 allowedUnits 属性必须被提前设置，这个属性接受数组类型的值，这里至少要设置一个日历单元的值。否则这个方法会返回nil值。所以，在这个方法的使用中，我们“告诉”它需要获取哪些日历单元，它会按照对应的日历单元返回结果：\n```\ndateComponentsFormatter.allowedUnits = [NSCalendarUnit.Year, NSCalendarUnit.Month, NSCalendarUnit.Day, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second]\nlet autoFormattedDifference = dateComponentsFormatter.stringFromDate(date1, toDate: date14)\n//\"1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n```\n","source":"_posts/Swift/时间魔法Swift篇.md","raw":"---\ntitle: 时间魔法 Swift篇\ndate: 2016-05-27\ntags: Swift\n---\n# 简介\n* NSDate 。在日期编程中，这个对象描述了日期和时间信息。可以把日期和时间看做是类中的普通属性，它不但用于日期，也用于时间处理。格式化，这个概念在直接处理 NSDate 对象时还用不到，只有在将日期对象转换为字符串对象时，才能用到格式化。\n* NSDateComponents 。这个类可以简单的看做是 NSDate 的“姐妹”类，因为它为开发者带来了许多关于日期的便捷操作。其中一项重要内容是：它可以将日期和时间分割成独立的属性，这样就可以直接访问每项属性，这在诸如日期计算之类的任务中非常有用。\n<!-- more -->\n 除了上面这些功能外， NSDateComponents 类在计算过去或未来的时间上也很有用。只需要简单的对某个子属性（年，月年等）执行加减操作，就可以算出未来或过去的一个时间。另外，NSDateComponents 类还适合查找两个日期之间的间隔。\n* NSCalendar 。这个类的功能并不在本文的讨论范围，但是，NSDate 和 NSDateComponents 之间的互相转换，却是由 NSCalendar 类来控制的，因为需要制定某个 NSCalendar 对象，才能完成转换。事实上，系统在进行转换时，需要知道使用的日历（历法）是哪个，然后才能获得正确的转换结果。要知道，世界上有许多不同的日历，其年月日的值是各不相同的。\n*  NSDateFormatter 。这个类会帮助我们将 NSDate 对象转换为字符串对象，也可以将字符串对象转换为 NSDate 对象。通过它，可以将 NSDate 对象按照预定义的日期样式直接转换成字符串，也可以按自定义的日期格式进行转换。\n NSDateFormatter 对象也支持本地化功能，只需要提供一个有效的 NSLocale 对象，就可以按照给定的locale设置转换成合适的字符串内容。\n* NSDateComponentsFormatter 。它有一个重要目的：输入日期和时间，输出格式化好的可读字符串。它包含了许多方法来完成这个任务。\n\n***\n<!-- more -->\n![time](http://o7ttfnm00.bkt.clouddn.com/5.jpg)\n\n* [NSDate](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDate_Class/)\n* [NSDateFormatter](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDateFormatter_Class/index.html)\n* [NSDateComponentFormatter](https://developer.apple.com/library/watchos/documentation/Foundation/Reference/NSDateComponentsFormatter_class/index.html)\n* [NSCalendar](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/)\n***\n\n# NSDate\n```\n//获取当前时间\nlet date1 = NSDate()     //\"May 27, 2016, 2:36 PM\"\nlet str1 = String(date1) //\"2016-05-27 06:36:17 +0000\"\n\n//获取从1970年1月1日00:00到当前时间的秒数\nvar interval : NSTimeInterval = date1.timeIntervalSince1970 //1464330977.49057 \n\nlet date2 = NSDate()\n//计算时间差\ninterval = date2.timeIntervalSinceDate(date1) //0.2234339714050293\n//date1 距现在的时间差\ninterval = date1.timeIntervalSinceNow         //-0.2241280078887939\n\n//得到date2后一天的时间对象\nlet date3 = date2 .dateByAddingTimeInterval(24*3600)             // 实例方法\nlet date4 = NSDate.init(timeInterval: 24*3600, sinceDate: date2) // 类方法\nprint(\"date3 == \\(date3) ; date4 == \\(date4)\")                   \n//\"date3 == 2016-05-28 06:36:17 +0000 ; date4 == 2016-05-28 06:36:17 +0000\"\n\n//得到距现在多少秒后一个日期时间对象\nlet date5 = NSDate.init(timeIntervalSinceNow: 3*24*3600) //\"May 30, 2016, 2:36 PM\"\nprint(date5)                                             //\"2016-05-30 06:36:17 +0000\\n\"\n\n//未来\nlet date6 = NSDate.distantFuture() //\"Jan 1, 4001, 8:00 AM\"\n//亘古\nlet date7 = NSDate.distantPast()   //\"4001-01-01 00:00:00 +0000\\n\"\nprint(\"future == \\(date6); past == \\(date7)\")\n//\"future == 4001-01-01 00:00:00 +0000; past == 0000-12-30 00:00:00 +0000\"\n```\n***\n# NSDateFormatter\n\n## 初始化\n```\nlet dateFormatter = NSDateFormatter()\n```\n有两种方式可以设置格式:一种是通过一些预定义的日期格式化样式（dateStyle）；另外一种是通过某些说明符来手动设置日期格式。stringFromDate 方法的使用也很重要，它是真正执行转换的代码。当谈到日期、字符串转换时，就指的是这个方法，而其他步骤只是起到定制结果的辅助作用。如果你在项目里要用到日期转换，这个方法会非常方便。\n```\ndateFormatter.dateStyle = NSDateFormatterStyle.FullStyle   //完整样式（FullStyle）\nvar convertedDate = dateFormatter.stringFromDate(date1)    //\"Friday, May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.LongStyle   //长样式（Long Style）\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.MediumStyle //中等样式(Medium Style)\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"May 27, 2016\"\n\ndateFormatter.dateStyle = NSDateFormatterStyle.ShortStyle  //短样式（Short Style）\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"5/27/16\"\n```\n## 改变时区\n```\ndateFormatter.dateStyle = NSDateFormatterStyle.FullStyle\n// 希腊\ndateFormatter.locale = NSLocale(localeIdentifier: \"el_GR\")\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Παρασκευή, 27 Μαΐου 2016\"\n// 法国\ndateFormatter.locale = NSLocale(localeIdentifier: \"fr_FR\")\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"vendredi 27 mai 2016\"\n// 本地\ndateFormatter.locale = NSLocale.currentLocale()\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Friday, May 27, 2016\"\n```\n## 自定义的日期格式\n\n[设置自定义日期格式](http://unicode.org/reports/tr35/tr35-6.html#Date_Format_Patterns)在两种场景中很有用：          \n1.当预定义的日期样式不能满足我们的需求；2.当我们需要把一个复杂的日期字符串（比如Thu, 08 Oct 2015 09:22:33 GMT）转换成日期对象。要想设置合适的日期格式（对象），必须搭配使用一系列说明符。说明符也是简单的字符，但是对于date formatter来说有特定的含义。\n```\n EEEE：“星期”的全名（比如Monday）。如需缩写，指定1-3个字符（如E，EE，EEE代表Mon）。\n MMMM：“月份”的全名（比如October）。如需缩写，指定1-3个字符（如M，MM，MMM代表Oct）。\n dd：某月的第几天（例如，09或15）\n yyyy：四位字符串表示“年”（例如2015）\n HH：两位字符串表示“小时”（例如08或19）\n mm：两位字符串表示“分钟”（例如05或54）\n ss：两位字符串表示“秒”\n zzz：三位字符串表示“时区”（例如GMT）\n GGG：公元前BC或公元后AD\n ```\n \n```\ndateFormatter.dateFormat = \"EEEE, MMMM dd, yyyy\"\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"Friday, May 27, 2016\"\n\ndateFormatter.dateFormat = \"HH:mm:ss\"\nconvertedDate = dateFormatter.stringFromDate(date1)        //\"14:36:17\"\n\nvar dateAsString = \"27-05-2016 23:59\"\ndateFormatter.dateFormat = \"dd-MM-yyyy HH:mm\"\nvar newDate = dateFormatter.dateFromString(dateAsString)   //\"May 27, 2016, 11:59 PM\"\n\n// 包含时区信息的复杂字符串：\ndateAsString = \"Thu, 27 May 2016 09:22:33 GMT\"\ndateFormatter.dateFormat = \"EEE, dd MMM yyyy HH:mm:ss zzz\"\nnewDate = dateFormatter.dateFromString(dateAsString)       //\"May 27, 2016, 5:22 PM\"\n```\n***\n# NSDateComponents\n\n## NSDate到NSDateComponents\n\nNSCalendar 的 components(_:fromDate:)，这个方法接受两个参数：第二个是日期对象；第一个参数比较有意思，它接收若干个 NSCalendarUnit 类型值，NSCAlendarUnit 用来说明需要的日期部分。NSCalendarUnit 是一个结构体，你可以在 这个[文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/#//apple_ref/swift/struct/c:@E@NSCalendarUnit) 中看到所有属性。这里需要注意：若某个组件没有在第一个参数中指定，就无法访问它。如：在这个例子中，我们没有指定 NSCalendarUnit.TimeZone，这样就无法访问时区的组件，比如print(dateComponents.timezone)调用会造成一个运行时错误。如果你需要额外的日期组件，只能重新调用一次calendar.Components方法，把你需要的Calendar Unit添加进去。\n\n```\nlet calendar = NSCalendar.currentCalendar()\nlet dateComponents = calendar.components([NSCalendarUnit.Day, NSCalendarUnit.Month, NSCalendarUnit.Year, NSCalendarUnit.WeekOfYear, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second, NSCalendarUnit.Nanosecond], fromDate: date1)\n\nprint(\"day = \\(dateComponents.day)\", \"month = \\(dateComponents.month)\", \"year = \\(dateComponents.year)\", \"week of year = \\(dateComponents.weekOfYear)\", \"hour = \\(dateComponents.hour)\", \"minute = \\(dateComponents.minute)\", \"second = \\(dateComponents.second)\", \"nanosecond = \\(dateComponents.nanosecond)\" , separator: \", \", terminator: \"\")\n\n//\"day = 27, month = 5, year = 2016, week of year = 22, hour = 14, minute = 36, second = 17, nanosecond = 490570008\"\n\nlet year = dateComponents.year             //年\nlet mondth = dateComponents.month          //月\nlet day = dateComponents.day               //日\nlet weekOfYear = dateComponents.weekOfYear //第几周\nlet hour = dateComponents.hour             //时\nlet minute = dateComponents.minute         //分\nlet second = dateComponents.second         //秒\nlet nanosecond = dateComponents.nanosecond //毫微秒\n```\n## NSDateComponents到NSDate\n\n### 初始化\n\n这个过程中不需要使用calendar unit。只用初始化一个新的 NSDateComponents 对象，然后显式的设置你需要的组件的值，然后调用 NSCalendar 的 dateFromComponents 方法即可\n```\nlet components = NSDateComponents()\ncomponents.day = 5\ncomponents.month = 01\ncomponents.year = 2016\ncomponents.hour = 19\ncomponents.minute = 30\nnewDate = calendar.dateFromComponents(components)\n```\n### 改动时区对转换日期对象的影响\n```\nGMT = Greenwich Mean Time（格林尼治标准时间）\nCST = China Standard Time（中国标准时间）\nCET = Central European Time(欧洲中部时间）\n时区缩写的列表（http://www.timeanddate.com/time/zones/）\n```\n```\ncomponents.timeZone = NSTimeZone(abbreviation: \"GMT\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 3:30 AM\"\n\ncomponents.timeZone = NSTimeZone(abbreviation: \"CST\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 9:30 AM\"\n\ncomponents.timeZone = NSTimeZone(abbreviation: \"CET\")\nnewDate = calendar.dateFromComponents(components)     //\"Jan 6, 2016, 2:30 AM\"\n```\n***\n# 比较日期和时间\nearlierDate:, 它用于判断一个日期是否早于另外一个日期。对应的还有一个是 laterDate:\n```\nearlierDate:\n如果 date1 早于 date2，该方法返回date1\n如过 date2 早于 date1，该方法返回date2\n如果 date1 和 date2 相同，返回date1\n\ndateFormatter.dateFormat = \"MMM dd, yyyy zzz\"\ndateAsString = \"May 27, 2016 GMT\"\nvar date8 = dateFormatter.dateFromString(dateAsString)! //\"May 27, 2016, 8:00 AM\"\n\nvar date10 = date1.earlierDate(date8)                   //\"May 27, 2016, 8:00 AM\"\ndate10 = date1.laterDate(date8)                         //\"May 27, 2016, 3:12 PM\"\n```\nNSDate 的 compare: 方法，它需要搭配使用 NSComparisonResult 枚举体。\n```\nif date1.compare(date2) == NSComparisonResult.OrderedDescending{\n    print(\"Date1 is later than date2\")\n}else if date1.compare(date2) == NSComparisonResult.OrderedAscending{\n    print(\"Date1 is Earlier than Date2\") //\"Date1 is Earlier than Date2\\n\"\n}else if date1.compare(date2) == NSComparisonResult.OrderedSame {\n    print(\"Same date\")\n}\n```\n时间间隔（time interval)，查找到每个日期（到现在）的时间间隔，进行比对。\n```\nif date1.timeIntervalSinceReferenceDate > date2.timeIntervalSinceReferenceDate {\n    print(\"Date1 is Later than Date2\")\n}else if date1.timeIntervalSinceReferenceDate <  date2.timeIntervalSinceReferenceDate {\n    print(\"Date1 is Earlier than Date2\") //\"Date1 is Earlier than Date2\\n\"\n}else {\n    print(\"Same dates\")\n}\n```\n在下面的方法里，会看到“2000-01-01”的日期，这是因为若 NSDate 对象没有指定日期，只指定时间的话，会自动添加默认的日期属性。\n```\ndateFormatter.dateFormat = \"HH:mm:ss zzz\"\ndateAsString = \"14:28:16 GMT\"\nlet date11 = dateFormatter.dateFromString(dateAsString)!\ndateAsString = \"19:53:12 GMT\"\nlet date12 = dateFormatter.dateFromString(dateAsString)!\n\nif date1.earlierDate(date2) == date1 {\n    if date1.isEqualToDate(date2) {\n        print(\"Same time\")\n    }else {\n        print(\"\\(date1) is earlier than \\(date2)\")\n        //2016-05-27 07:12:44 +0000 is earlier than 2016-05-27 07:12:44 +0000\n    }\n}else {\n    print(\"\\(date2) is earlier than \\(date1)\")\n}\n```\n***\n# 计算未来和过去的日期\n两种不同的方法：第一种使用 NSCalendar 类和 NSCalendarUnit 结构体；第二种使用 NSDateComponents 类。\n\n假定我们需要为这个日期往后推两个月又5天。\n```\nlet monthsToAdd = 2\nlet daysToAdd = 5\n\n```\n这里用到的方法是 NSCAlendar 类的 dateByAddingUnit:value:toDate:options: 方法。它的作用是添加某个日历单元值（如年月日时分秒等）到现有的日期对象上，然后返回新的日期对象。我们需要添加两个日历单元到当前日期，直接用这个方法是不可能的（它每次只能设置一个calendar unit）。关键是调用两次这个方法，设置不同的日历单元，就能得到最终结果。\n```\nvar calculatedDate = NSCalendar.currentCalendar().dateByAddingUnit(NSCalendarUnit.Month, value: monthsToAdd, toDate: date1, options: NSCalendarOptions.init(rawValue: 0))\ncalculatedDate = NSCalendar.currentCalendar().dateByAddingUnit(NSCalendarUnit.Day, value: daysToAdd, toDate: calculatedDate!, options: NSCalendarOptions.init(rawValue: 0))\n```\n当日历单元多的时候，你就需要多次调用这个方法。在日历单元比较多的时候，更好的方法是使用 NSDateComponents 类。初始化一个 NSDateComponents 对象，并设置月份和天的信息。然后我们调用 NSCalendar 的另一个方法dateByAddingComponents:toDate:options:，并最终获得我们需要的日期对象。\n```\nlet newDateComponents = NSDateComponents()\nnewDateComponents.month = monthsToAdd\nnewDateComponents.day = daysToAdd\n\ncalculatedDate = NSCalendar.currentCalendar().dateByAddingComponents(newDateComponents, toDate: date1, options: NSCalendarOptions.init(rawValue: 0))\n\n```\n// 注意：在以上调用 NSCalendar 方法的地方，最后一个参数options都没有被设置。如果你需要具体设置options的值，请参考完整的 [官方文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/)。\n\n***\n# 计算日期间隔\n通过date components来计算日期对象间隔。这个新方法叫 components:fromDate:toDate:options:,第一个参数是 NSCalendarUnit 值的数组。这里要注意，如果第一个日期如果晚于第二个日期，则结果会返回负值。\n```\nvar diffFateComponents = NSCalendar.currentCalendar().components([NSCalendarUnit.Year, NSCalendarUnit.Month, NSCalendarUnit.Day, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second], fromDate: date1, toDate: date14, options: NSCalendarOptions.init(rawValue: 0))\n\nprint(\"The difference between dates is: \\(diffFateComponents.year) years, \\(diffFateComponents.month) months, \\(diffFateComponents.day) days, \\(diffFateComponents.hour) hours, \\(diffFateComponents.minute) minutes, \\(diffFateComponents.second) seconds\")\n//\"The difference between dates is: 1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n\nlet diffYear = diffFateComponents.year\nlet diffMonth = diffFateComponents.month\nlet diffDay = diffFateComponents.day\nlet diffHour = diffFateComponents.hour\nlet diffMinute = diffFateComponents.minute\nlet diffSecond = diffFateComponents.second\n```\nNSDateComponentsFormatter 类，它提供了多种用于自动计算日期间隔的方法，并可以返回格式化字符串结果。unitsStyle 属性指定我们使用的 dateComponentsFormatter 以何种格式打印日期的间隔。这里我们使用 完整 样式。\n```\nlet dateComponentsFormatter = NSDateComponentsFormatter()\ndateComponentsFormatter.unitsStyle = NSDateComponentsFormatterUnitsStyle.Full\n\nlet interval2 = date14.timeIntervalSinceDate(date1)\ndateComponentsFormatter.stringFromTimeInterval(interval2)\n//\"1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n```\n最后，在第三种计算的方法中，我们将两个日期传递给 NSDateComponentsFormatter 对象的一个叫 stringFromDate:toDate: 的方法。但是这个方法需要有个前置的条件：NSDateComponentsFormatter 的 allowedUnits 属性必须被提前设置，这个属性接受数组类型的值，这里至少要设置一个日历单元的值。否则这个方法会返回nil值。所以，在这个方法的使用中，我们“告诉”它需要获取哪些日历单元，它会按照对应的日历单元返回结果：\n```\ndateComponentsFormatter.allowedUnits = [NSCalendarUnit.Year, NSCalendarUnit.Month, NSCalendarUnit.Day, NSCalendarUnit.Hour, NSCalendarUnit.Minute, NSCalendarUnit.Second]\nlet autoFormattedDifference = dateComponentsFormatter.stringFromDate(date1, toDate: date14)\n//\"1 years, 9 months, 5 days, 16 hours, 50 minutes, 42 seconds\"\n```\n","slug":"Swift/时间魔法Swift篇","published":1,"updated":"2023-08-22T09:52:14.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgu8001laq7kgbr4qmd0"},{"title":"流程控制","date":"2023-01-14T02:50:15.000Z","_content":"\n* [循环控制](#循环控制)\n* [switch](#switch)\n* [guard](#guard)\n* [模式和模式匹配](#模式和模式匹配)\n\n<!-- more -->\n\n## 循环控制\n\n### for-in 循环\n\n1、使用 for-in 循环来遍历序列，比如一个范围的数字：\n\n```swift\nfor i in 0...5 {\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n```\n\n2、遍历字符串中的字符：\n\n```swift\nfor c in \"Hello,World\" {\n    print(c)\n}\n```\n\n打印结果：\n\n```js\nh\ne\nl\nl\no\n,\nW\no\nr\nl\n```\n\n3、遍历数组中的元素：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names {\n    print(name)\n}\n```\n\n打印结果：\n\n```js\nzhangsan\nlisi\nwangwu\nzhaoliu\n```\n\n#### for-in 遍历字典\n\n1、字典在 for-in 遍历时，每一个元素都是一个元组 `(key, value)`。\n\n```swift\nlet numberLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor t in numberLegs {\n    print(\"\\(t.0) has \\(t.1) legs\")\n}\n```\n\n打印结果：\n\n```js\nspider has 8 legs\ncat has 4 legs\nant has 6 legs\n```\n\n2、可以在 for-in 循环体中，**使用显示命名常量来分解元组成员**：\n\n```swift\nlet numberLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor (animalName, legCount) in numberLegs {\n    print(\"\\(animalName) has \\(legCount) legs\")\n}\n```\n\n打印结果：\n\n```js\nant has 6 legs\ncat has 4 legs\nspider has 8 legs\n```\n\n3、在不需要遍历到的每一个值时，可以使用下划线 `_` 取代遍历名以忽略值：\n\n```swift\nlet base = 3\nlet power = 5\nvar answer = 1\nfor _ in 1...power {\n    answer *= base\n}\n\nprint(\"\\(base) to the power of \\(power) is \\(answer)\")\n// Prints \"3 to the power of 5 is 243\"\n```\n\n#### for-in 分段区间\n\n使用 `stride()` 函数来跳过不想要的标记。\n\n* `stride(from:to:by:)`：开区间\n\n```swift\nlet minuteInterval = 5\nfor tickMark in stride(from: 0, to: 50, by: minuteInterval) {\n    print(tickMark)\n}\n```\n\n打印结果：\n\n```js\n0\n5\n10\n15\n20\n25\n30\n35\n40\n45\n```\n\n* `stride(from:through:by:)`：闭区间\n\n```swift\nlet minuteInterval = 5\nfor tickMark in stride(from: 0, through: 50, by: minuteInterval) {\n    print(tickMark)\n}\n```\n\n打印结果：\n\n```js\n0\n5\n10\n15\n20\n25\n30\n35\n40\n45\n50\n```\n\n### while 循环\n\nSwift 中的 repeat-while 循环。\n\n```swift\nvar count = 0\nrepeat {\n    print(count)\n    count += 1\n} while count < 5\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\nOC 中的 do-while 循环：\n\n```swift\nint count = 0;\ndo {\n    NSLog(@\"%d\", count);\n    count += 1;\n} while (count < 5);\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\nOC 中的 while 循环\n\n```swift\nint count = 0;\nwhile (count < 5) {\n   NSLog(@\"%d\", count);\n   count += 1;\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\n## switch\n\nswitch 语句会将一个值与多个可能的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块。\n\nswitch 语句一定得是全面的，在给定类型里，每一个值都要被考虑到，并且匹配到一个对应的 switch case 里。如果无法提供一个 switch case 所有可能的值，则可以用关键字 default 标记，即默认匹配所有未明确的值。default 关键字必须在所有 case 的最后。\n\n```swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\":\n    print(\"The first letter of the alphabet\")\ncase \"z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n如果没有 default 关键字，则会报错：\n![01](流程控制/01.png)\n\n> Objective-C 中的 switch 语句如果不全面，仍然可以运行\n>\n```swift\nchar c = 'z';\nswitch (c) {\n    case 'a':\n        NSLog(@\"The first letter of the alphabet\");\n        break;\n    case 'z':\n        NSLog(@\"The last letter of the alphabet\");\n        break;\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n### 没有隐式贯穿\n\n相比 C 和 Objective-C 里的 switch 语句来说，Swift 里的 switch 语句不会默认从匹配 case 的末尾贯穿到下一个 case 里。相反，整个 switch 语句会在匹配到第一个 switch 的 case 执行完毕之后退出，不再需要显式的 break 语句。\n\n> C 和 Objective-C 里的 switch 的隐式贯穿：\n>\n```swift\nchar c = 'z';\nswitch (c) {\n    case 'a':\n        NSLog(@\"The first letter of the alphabet\");\n    case 'z':\n        NSLog(@\"The last letter of the alphabet\");\n    default:\n        NSLog(@\"Some other character\");\n}\n\n// The last letter of the alphabet\n// Some other character\n```\n\n因为 Swift 的 switch 语句没有隐式贯穿，所以每一个 case 的函数体必须包含至少一个可执行的语句。\n\n![02](流程控制/02.png)\n\n因为 Swift 的 switch 语句没有隐式贯穿，所以想要实现匹配多个值的情况，可以用逗号分隔，并且可以写成多行。\n\n```swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\", \"A\", \"B\",\n     \"C\", \"D\":\n    print(\"The first letter of the alphabet\")\ncase \"z\", \"Z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n### 区间匹配\n\nswitch 的 case 的值可以在一个区间中匹配。\n\n```swift\nlet approximateCount = 62\nlet countedThings = \"moons orbiting Saturn\"\nvar naturalCount: String\n\nswitch approximateCount {\ncase 0:\n    naturalCount = \"no\"\ncase 1..<5:\n    naturalCount = \"a few\"\ncase 5..<12:\n    naturalCount = \"several\"\ncase 12..<100:\n    naturalCount = \"dozens of\"\ncase 100..<1000:\n    naturalCount = \"hundreds of\"\ndefault:\n    naturalCount = \"many\"\n}\nprint(\"There are \\(naturalCount) \\(countedThings).\")\n\n// Prints \"There are dozens of moons orbiting Saturn.\"\n```\n\n### 元组匹配\n\n可以使用元组来在一个 switch 语句中测试多个值，使用下划线 `_` 来表明匹配所有可能的值。\n\n匹配在 (-2, 2) 组成的盒子内的点：\n\n![03](流程控制/03.png)\n\n```swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    print(\"(0, 0) is at the origin\")\ncase (_, 0):\n    print(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    print(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n\n// Prints \"(1, 1) is inside the box\"\n```\n\n### 值绑定\n\nswitch 的 case 可以将匹配到的值临时绑定为一个常量或者变量，来给 case 的函数体使用。\n\n```swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    print(\"ont the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    print(\"somewhere else at (\\(x), \\(y)\")\n}\n\n// Prints \"on the x-axis with an x value of 2\"\n```\n\n如果使用 `var` 关键字，临时的变量就会以合适的值来创建并初始化。这个变量的任何改变都只会在 case 的函数体内有效。\n\n```swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (var x, 0):\n    x += 2\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, var y):\n    print(\"on the y-axis with a y value of \\(y)\")\ncase var (x, y):\n    print(\"somewhere else at (\\(x), \\(y))\")\n}\n\nprint(anotherPoint)\n\n// on the x-axis with an x value of 4\n// (2, 0)\n```\n\n### where 分句\n\nswitch case 可以使用 `where` 分句来检查是否符合特定的约束。\n\n匹配在两条直线上的点：\n![04](流程控制/04.png)\n\n```swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    print(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    print(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    print(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n\n// Prints \"(1, -1) is on the line x == -y\"\n```\n\n### 复合匹配\n\n多种情形共享同一个函数体的多个情况可以在 case 后写多个模式来复合，在每个模式之间用逗号分隔。如果任何一个模式匹配了，那么这个情况都会被认为是匹配的。如果模式太长，可以把它们写成多行。\n\n```swift\nlet someCharacter: Character = \"e\"\nswitch someCharacter {\ncase \"a\", \"e\", \"i\", \"o\", \"u\":\n    print(\"\\(someCharacter) is a vowel\")\ncase \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n     \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n    print(\"\\(someCharacter) is a consonant\")\ndefault:\n    print(\"\\(someCharacter) is not a vowel or a consonant\")\n}\n\n// Prints \"e is a vowel\"\n```\n\n#### 复合匹配 - 值绑定\n\n复合匹配同样可以包含值绑定。所有复合匹配的模式都必须包含**相同的值绑定集合**，并且复合情况中的每一个绑定都得**有相同的类型格式**。这才能确保无论复合匹配的哪部分命中了，在函数体中的代码都能访问到绑定的值，并且值的类型也都相同。\n\n```swift\nlet stillAnotherPoint = (9, 0)\nswitch stillAnotherPoint {\ncase (let distance, 0), (0, let distance):\n    print(\"On an axis, \\(distance) from the origin\")\ndefault:\n    print(\"Not on an axis\")\n}\n\n// Prints \"On an axis, 9 from the origin\"\n```\n\n### 控制转移\n\n#### continue\n\n`continue` 语句表示让循环停止当前遍历，开始下一次遍历。并不是离开整个循环。\n\n```swift\nfor i in 0...5 {\n    if i == 3 {\n        continue\n    }\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n4\n5\n```\n\n#### break\n\nbreak 语句会立即结束整个控制流语句。在需要提前结束 switch 或者其它循环语句时，可以使用 break。\n\nbreak 会立即结束整个循环的执行，并且转移控制到循环结束花括号（`}`）后的第一行代码上。**结束整个循环**，表示当前遍历循环里的其它代码都不会被执行，并且余下的遍历循环也不会开始了。\n\n```swift\nfor i in 0...5 {\n    if i == 3 {\n        break\n    }\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n```\n\n在 `switch` 语句里使用 `break` 时，`switch` 语句会立即结束执行，并且转移控制到 `switch` 语句结束花括号（`}`）之后的第一行代码上。\n\n```swift\nlet string = \"break\"\nswitch string {\ncase \"break\":\n    print(\"Before break\")\n    break\n    print(\"After break\")\ndefault:\n    print(\"Nothing\")\n}\n\n// Prints \"Before break\"\n```\n\n#### fallthrough\n\nSwift 的 `switch` 语句不支持隐私贯穿，可以通过关键字 `fallthrough` 显式实现贯穿行为。\n\n```swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprint(description)\n\n// Prints \"The number 5 is a prime number, and also an integer.\"\n```\n\n#### 语句标签\n\n可以使用语句标签给循环语句或者条件语句做标记。在一个条件语句中，可以使用语句标签配合 `break` 语句来结束被标记的语句。在循环语句中，你可以使用语句标签来配合 `break` 或者 `continue` 语句来结束或者继续执行**被标记的语句**。\n\n```swift\nvar number = 10\nwhileLoop : while number > 0 {\n    switch number {\n    case 9:\n        print(\"9\")\n    case 10:\n        var sum = 0\n        for index in 0...10 {\n            sum += index\n            if index == 9 {\n                print(sum)\n                break whileLoop\n            }\n        }\n    default:\n        break\n    }\n    number = -1\n}\n\n// Prints 45\n```\n\n## guard\n\n`guard` 语句，类似于 `if` 语句，基于布尔值表达式来执行语句。使用 `guard` 语句来要求一个条件必须是真才能执行 `guard` 之后的语句。与 `if` 语句不同，`guard` 语句总是有一个 `else` 分句——`else` 分句里的代码会在条件不为真的时候执行：\n\n![05](流程控制/05.png)\n\n在编写条件语句的时候，左边的代码间距应该是一个“黄金”或者“快乐”的大道。不要嵌套 `if` 语句，多个 `return` 语句可能是更好的，这样可以避免圈复杂度（Cyclomatic Complexity），并且让代码更加容易阅读。因为重要部分没有嵌套在分支上，可以很清楚的找到相关代码。\n\n推荐写法：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) {\n        return;\n    }\n\n    //Do something important\n}\n```\n\n不推荐写法：\n\n```swift\n- (void)someMethod {\n    if ([someOther boolValue]) {\n        //Do something important\n    }\n}\n```\n\n或者：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) \n        return;\n\n    //Do something important\n}\n```\n\n或者：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) return;\n\n    //Do something important\n}\n```\n\n相关文档：\n<https://github.com/objc-zen/objc-zen-book>\n<https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html>\n\n### 应用1——验证 ip 地址的格式是否正确\n\n例1、使用 `if` 语句实现\n\n```swift\nfunc isIPAddress(ipAddr: String) -> (Int, String) {\n    let compoments = ipAddr.split(separator: \".\")\n    if compoments.count == 4 {\n        if let first = Int(compoments[0]), first >= 0 && first < 256 {\n            if let second = Int(compoments[1]), second >= 0 && second < 256 {\n                if let third = Int(compoments[2]), third >= 0 && third < 256 {\n                    if let fourth = Int(compoments[3]), fourth >= 0 && fourth < 256 {\n                        return (0, \"\")\n                    } else {\n                        return (4, \"第四个数不对\")\n                    }\n                } else {\n                    return (3, \"第三个数不对\")\n                }\n            } else {\n                return (2, \"第二个数不对\")\n            }\n        } else {\n            return (1, \"第一个数不对\")\n        }\n    }\n    return (100, \"ip只能有四部分\")\n}\n\nprint(isIPAddress(ipAddr: \"192.122.111.-1\"))\n\n// Prints \"(4, \"第四个数不对\")\"\n```\n\n例2、使用 guard 语句（注意左侧的黄金大道）实现\n\n```swift\nfunc isIPAddress(ipAddr: String) -> (Int, String) {\n    let compoments = ipAddr.split(separator: \".\")\n    \n    guard compoments.count == 4 else {\n        return (100, \"ip只能有四部分\")\n    }\n    \n    guard let first = Int(compoments[0]), first >= 0 && first < 256 else {\n        return (1, \"第一个数不对\")\n    }\n    \n    guard let second = Int(compoments[1]), second >= 0 && second < 256 else {\n        return (2, \"第二个数不对\")\n    }\n    \n    guard let third = Int(compoments[2]), third >= 0 && third < 256 else {\n        return (3, \"第三个数不对\")\n    }\n    \n    guard let fourth = Int(compoments[3]), fourth >= 0 && fourth < 256 else {\n        return (4, \"第四个数不对\")\n    }\n    \n    return (0, \"\")\n}\n\nprint(isIPAddress(ipAddr: \"192.118.222.300\"))\n\n// Prints \"(4, \"第四个数不对\")\"\n```\n\n### 应用2——检查 API 可用性\n\nSwift 拥有内置的 API 可用性的检查功能，能够确保使用不可用的 API。\n\n可以在 if 或者 guard 语句中使用一个可用性条件来有条件地执行代码。\n\n```swift\nif #available(iOS 10, macOS 10.12, *) {\n    // 在iOS上使用iOS 10 API，在macOS上使用macOS 10.12 API\n} else {\n    // 回到早期的iOS和macOS API\n}\n```\n\n## 模式和模式匹配\n\n模式：代表单个值或者复合值的**结构**。例如，`x` 的结构代表单个值的模式；元组 `(x, y)` 的结构是由逗号分隔的，包含两个元素的列表（元组模式）。\n\n模式匹配：**模式代表一种值的结构，而不是特定的某个值**，可以利用模式来匹配各种各样的值。例如，`(x, y)` 可以匹配元组 `(1, 2)`，以及任何两个元素的元组。\n\n除了利用模式匹配一个值以外，也可以从复合值中提取出部分或全部值，然后分别把各个部分的值和一个常量或者变量对应起来。\n\n### 模式分类\n\nSwift 中的模式分为两类：一种能成功匹配任何类型的值，另一种在运行时匹配某个特定值时可能会失败。\n\n* 第一类模式：用于解构简单变量、常量和可选绑定中的值。此类模式包括**通配符模式**、**标识符模式**，以及包含前两种模式的**值绑定模式**和**元组模式**。可以为这类模式指定一个类型标注，从而限制它们只能匹配某种特定类型的值。\n\n* 第二类模式：用于全模式匹配，这种情况下匹配的值在运行时可能不存在。此类模式包括**枚举用例模式**、**可选模式**、**表达式模式**和**类型转换模式**。在 `switch` 语句的 `case` 标签中，`do` 语句的 `catch` 子句中，或者在 `if`、`while`、`guard` 和 `for-in` 语句的 `cas`e 条件句中使用这类模式。\n\n#### 通配符模式（Wildcard Pattern）\n\n通配符模式：由一个下划线 `_` 构成，用于匹配并忽略任何值。如在便利时，忽略被匹配的值时可以使用该模式。\n\n```swift\nfor _ in 1...3 {\n    // TODO\n}\n```\n\n#### 标识符模式（Identifier Pattern）\n\n标识符模式：匹配任何值，并将匹配的值和一个变量或常量绑定起来。如定义一个常量：\n\n```swift\nlet someValue = 42\n```\n\n#### 值绑定模式（Value-Binding Pattern）\n\n值绑定模式：把匹配到的值绑定给一个变量或常量。如把匹配到的值绑定给常量时，用关键字 `let`，绑定给变量时，用关键字 `var`。\n\n```swift\nlet point = (3, 2)\nswitch point {\n// 将 point 中的元素绑定到 x 和 y\ncase let (x, y):\n    print(\"The point is at (\\(x), \\(y)).\")\n}\n```\n\n#### 元组模式（Tuple Pattern）\n\n元组模式：是有逗号分隔的，具有零个或多个模式的列表，并由一对圆括号括起来（如：`(x, y)`）。元组模式匹配相应元组类型的值。\n\n可以使用类型标注限制一个元组模式能匹配哪种元组类型。例如，在常量声明 `let(x, y): (Int, Int) = (1, 2)` 中的元组模式 `(x, y): (Int, Int)` 只能匹配两个元素都是 `Int` 类型的元组。\n\n当元组模式被用于 `for-in` 语句或者常量和变量声明时，它仅可以包含**通配符模式**、**标识符模式**、**可选模式**或者**其他包含这些模式的元组模式**。\n\n例如，在 `for-in` 语句中，使用通配符模式匹配 `y == 0` 的元组。\n\n```swift\nlet points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]\nfor (x, y) in points where y == 0 {\n    print(\"\\(x) and \\(y)\")\n}\n```\n\n打印结果：\n\n```js\n0 and 0\n1 and 0\n2 and 0\n```\n\n没有正确使用元组模式则会报错，如 `(x, 0)` 不是正确的元组模式：\n\n![06](流程控制/06.png)\n\n模式都是字母，而不是一个确切的数字，0 是数字，可以用 `y` 代替 0。\n\n#### 枚举用例模式（Enumeration Case Pattern）\n\n枚举用例模式：匹配现有的某个枚举类型的某个用例。枚举用例模式出现在 `switch` 语句中的 `case` 标签中，以及 `if`、`while`、`guard` 和 `for-in` 语句的 `case` 条件中。\n\n#### 可选项目模式（Optional Pattern）\n\n可选项模式匹配 `Optional<Wrapped>` 枚举在 `some(Wrapped)` 中包装的值。\n\n```swift\nlet someOptional: Int? = 42\nif case .some(let x) = someOptional {\n    print(x)\n}\n// Prints \"42\"\n```\n\n或者\n\n```swift\nif case let x? = someOptional {\n    print(x)\n}\n// Prints \"42\"\n```\n\n可选项模式为 `for-in` 语句提供了一种迭代数组的简便方式，只为数组中非 `nil` 的元素执行循环体。\n\n```swift\nlet arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]\nfor case let number? in arrayOfOptionalInts {\n    print(\"Found a \\(number)\")\n}\n```\n\n打印结果：\n\n```js\nFound a 2\nFound a 3\nFound a 5\n```\n\n#### 类型转换模式（Type-Casting Pattern）\n\n有两种类型转换模式，is 模式和 as 模式。is 模式只出现在 switch 语句中的 case 标签中。\n\n* `is` 模式：当一个值的类型在运行时和 `is` 模式右边的指定类型一致，或者是其子类的情况下，才会匹配这个值。`is` 模式和 `is` 运算符有相似表现，它们都进行类型转换，但是 `is` 模式没有返回类型。\n\n* `as` 模式：当一个值的类型在运行时和 `as` 模式右边的指定类型一致，或者是其子类的情况下，才会匹配这个值。如果匹配成功，被匹配的值的类型被转换成 `as` 模式右边指定的类型。\n\n```swift\nprotocol Animal {\n    var name: String { get }\n}\n\nstruct Dog: Animal {\n    var name: String {\n        return \"dog\"\n    }\n    var runSpeed: Int\n}\n\nstruct Bird: Animal {\n    var name: String {\n        return \"bird\"\n    }\n    var flightHeight: Int\n}\n\nstruct Fish: Animal {\n    var name: String {\n        return \"fish\"\n    }\n    var depth: Int\n}\n\nlet animals:[Any] = [Dog(runSpeed: 55), Bird(flightHeight: 2000), Fish(depth: 100)]\n\nfor animal in animals {\n    switch animal {\n    case let dog as Dog:\n        print(\"\\(dog.name) can run \\(dog.runSpeed)\")\n    case let fish as Fish:\n        print(\"\\(fish.name) can dive depth \\(fish.depth)\")\n    case is Bird:\n        print(\"bird can fly\")\n    default:\n        print(\"unknow animal!\")\n    }\n}\n\n// dog can run 55\n// bird can fly\n// fish can dive depth 100\n```\n\n#### 表达式模式（Expression Pattern）\n\n表达式模式代表表达式的值。表达式模式只出现在 switch 语句中的 case 标签中。\n\n表达式模式代表的表达式，会使用 Swift 标准库中的 `~=` 运算符，与输入表达式的值进行比较。如果 `~=` 运算符返回 true，则匹配成功。\n\n默认情况下，`~=` 运算符使用 `==` 运算符来比较两个相同类型的值。它也可以将一个整型数值与一个 Range 实例中的一段整数区间做匹配。\n\n```swift\nlet point = (1, 2)\nswitch point {\ncase (0, 0):\n    print(\"(0, 0) is at the origin.\")\ncase (-2...2, -2...2):\n    print(\"(\\(point.0), \\(point.1)) is near the origin.\")\ndefault:\n    print(\"The point is at (\\(point.0), \\(point.1)).\")\n}\n\n// Prints \"(1, 2) is near the origin.\"\n```\n\n可以重载 `~=` 运算符来提供自定义的表达式匹配行为：\n\n```swift\nfunc ~= (pattern: String, value: Int) -> Bool {\n    return pattern == \"\\(value)\"\n}\n\nlet point = (1, 2)\nswitch point {\ncase (\"0\", \"0\"):\n    print(\"(0, 0) is at the origin.\")\ndefault:\n    print(\"The point is at (\\(point.0), \\(point.1)).\")\n}\n\n// Prints \"The point is at (1, 2).\"\n```\n\n自定义类型默认也是无法进行表达式模式匹配的，也需要重载 `~=` 运算符。\n\n```swift\nstruct Employee {\n    var salary: Float\n}\nlet e = Employee(salary: 9999)\nfunc ~=(lhs: Range<Float>, rhs: Employee) -> Bool {\n    return lhs.contains(rhs.salary)\n}\nswitch e {\ncase 0.0..<1000:\n    print(\"艰难生活\")\ncase 1000..<5000:\n    print(\"小康生活\")\ncase 5000..<10000:\n    print(\"活的和滋润\")\ndefault:\n    break\n}\n\n// Prints \"活的和滋润\"\n```\n","source":"_posts/Swift/流程控制.md","raw":"---\ntitle: 流程控制\ndate: 2023-01-14 10:50:15\ntags: Swift\n---\n\n* [循环控制](#循环控制)\n* [switch](#switch)\n* [guard](#guard)\n* [模式和模式匹配](#模式和模式匹配)\n\n<!-- more -->\n\n## 循环控制\n\n### for-in 循环\n\n1、使用 for-in 循环来遍历序列，比如一个范围的数字：\n\n```swift\nfor i in 0...5 {\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n```\n\n2、遍历字符串中的字符：\n\n```swift\nfor c in \"Hello,World\" {\n    print(c)\n}\n```\n\n打印结果：\n\n```js\nh\ne\nl\nl\no\n,\nW\no\nr\nl\n```\n\n3、遍历数组中的元素：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names {\n    print(name)\n}\n```\n\n打印结果：\n\n```js\nzhangsan\nlisi\nwangwu\nzhaoliu\n```\n\n#### for-in 遍历字典\n\n1、字典在 for-in 遍历时，每一个元素都是一个元组 `(key, value)`。\n\n```swift\nlet numberLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor t in numberLegs {\n    print(\"\\(t.0) has \\(t.1) legs\")\n}\n```\n\n打印结果：\n\n```js\nspider has 8 legs\ncat has 4 legs\nant has 6 legs\n```\n\n2、可以在 for-in 循环体中，**使用显示命名常量来分解元组成员**：\n\n```swift\nlet numberLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor (animalName, legCount) in numberLegs {\n    print(\"\\(animalName) has \\(legCount) legs\")\n}\n```\n\n打印结果：\n\n```js\nant has 6 legs\ncat has 4 legs\nspider has 8 legs\n```\n\n3、在不需要遍历到的每一个值时，可以使用下划线 `_` 取代遍历名以忽略值：\n\n```swift\nlet base = 3\nlet power = 5\nvar answer = 1\nfor _ in 1...power {\n    answer *= base\n}\n\nprint(\"\\(base) to the power of \\(power) is \\(answer)\")\n// Prints \"3 to the power of 5 is 243\"\n```\n\n#### for-in 分段区间\n\n使用 `stride()` 函数来跳过不想要的标记。\n\n* `stride(from:to:by:)`：开区间\n\n```swift\nlet minuteInterval = 5\nfor tickMark in stride(from: 0, to: 50, by: minuteInterval) {\n    print(tickMark)\n}\n```\n\n打印结果：\n\n```js\n0\n5\n10\n15\n20\n25\n30\n35\n40\n45\n```\n\n* `stride(from:through:by:)`：闭区间\n\n```swift\nlet minuteInterval = 5\nfor tickMark in stride(from: 0, through: 50, by: minuteInterval) {\n    print(tickMark)\n}\n```\n\n打印结果：\n\n```js\n0\n5\n10\n15\n20\n25\n30\n35\n40\n45\n50\n```\n\n### while 循环\n\nSwift 中的 repeat-while 循环。\n\n```swift\nvar count = 0\nrepeat {\n    print(count)\n    count += 1\n} while count < 5\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\nOC 中的 do-while 循环：\n\n```swift\nint count = 0;\ndo {\n    NSLog(@\"%d\", count);\n    count += 1;\n} while (count < 5);\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\nOC 中的 while 循环\n\n```swift\nint count = 0;\nwhile (count < 5) {\n   NSLog(@\"%d\", count);\n   count += 1;\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n```\n\n## switch\n\nswitch 语句会将一个值与多个可能的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块。\n\nswitch 语句一定得是全面的，在给定类型里，每一个值都要被考虑到，并且匹配到一个对应的 switch case 里。如果无法提供一个 switch case 所有可能的值，则可以用关键字 default 标记，即默认匹配所有未明确的值。default 关键字必须在所有 case 的最后。\n\n```swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\":\n    print(\"The first letter of the alphabet\")\ncase \"z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n如果没有 default 关键字，则会报错：\n![01](流程控制/01.png)\n\n> Objective-C 中的 switch 语句如果不全面，仍然可以运行\n>\n```swift\nchar c = 'z';\nswitch (c) {\n    case 'a':\n        NSLog(@\"The first letter of the alphabet\");\n        break;\n    case 'z':\n        NSLog(@\"The last letter of the alphabet\");\n        break;\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n### 没有隐式贯穿\n\n相比 C 和 Objective-C 里的 switch 语句来说，Swift 里的 switch 语句不会默认从匹配 case 的末尾贯穿到下一个 case 里。相反，整个 switch 语句会在匹配到第一个 switch 的 case 执行完毕之后退出，不再需要显式的 break 语句。\n\n> C 和 Objective-C 里的 switch 的隐式贯穿：\n>\n```swift\nchar c = 'z';\nswitch (c) {\n    case 'a':\n        NSLog(@\"The first letter of the alphabet\");\n    case 'z':\n        NSLog(@\"The last letter of the alphabet\");\n    default:\n        NSLog(@\"Some other character\");\n}\n\n// The last letter of the alphabet\n// Some other character\n```\n\n因为 Swift 的 switch 语句没有隐式贯穿，所以每一个 case 的函数体必须包含至少一个可执行的语句。\n\n![02](流程控制/02.png)\n\n因为 Swift 的 switch 语句没有隐式贯穿，所以想要实现匹配多个值的情况，可以用逗号分隔，并且可以写成多行。\n\n```swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\", \"A\", \"B\",\n     \"C\", \"D\":\n    print(\"The first letter of the alphabet\")\ncase \"z\", \"Z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n\n// Prints \"The last letter of the alphabet\"\n```\n\n### 区间匹配\n\nswitch 的 case 的值可以在一个区间中匹配。\n\n```swift\nlet approximateCount = 62\nlet countedThings = \"moons orbiting Saturn\"\nvar naturalCount: String\n\nswitch approximateCount {\ncase 0:\n    naturalCount = \"no\"\ncase 1..<5:\n    naturalCount = \"a few\"\ncase 5..<12:\n    naturalCount = \"several\"\ncase 12..<100:\n    naturalCount = \"dozens of\"\ncase 100..<1000:\n    naturalCount = \"hundreds of\"\ndefault:\n    naturalCount = \"many\"\n}\nprint(\"There are \\(naturalCount) \\(countedThings).\")\n\n// Prints \"There are dozens of moons orbiting Saturn.\"\n```\n\n### 元组匹配\n\n可以使用元组来在一个 switch 语句中测试多个值，使用下划线 `_` 来表明匹配所有可能的值。\n\n匹配在 (-2, 2) 组成的盒子内的点：\n\n![03](流程控制/03.png)\n\n```swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    print(\"(0, 0) is at the origin\")\ncase (_, 0):\n    print(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    print(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n\n// Prints \"(1, 1) is inside the box\"\n```\n\n### 值绑定\n\nswitch 的 case 可以将匹配到的值临时绑定为一个常量或者变量，来给 case 的函数体使用。\n\n```swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    print(\"ont the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    print(\"somewhere else at (\\(x), \\(y)\")\n}\n\n// Prints \"on the x-axis with an x value of 2\"\n```\n\n如果使用 `var` 关键字，临时的变量就会以合适的值来创建并初始化。这个变量的任何改变都只会在 case 的函数体内有效。\n\n```swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (var x, 0):\n    x += 2\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, var y):\n    print(\"on the y-axis with a y value of \\(y)\")\ncase var (x, y):\n    print(\"somewhere else at (\\(x), \\(y))\")\n}\n\nprint(anotherPoint)\n\n// on the x-axis with an x value of 4\n// (2, 0)\n```\n\n### where 分句\n\nswitch case 可以使用 `where` 分句来检查是否符合特定的约束。\n\n匹配在两条直线上的点：\n![04](流程控制/04.png)\n\n```swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    print(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    print(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    print(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n\n// Prints \"(1, -1) is on the line x == -y\"\n```\n\n### 复合匹配\n\n多种情形共享同一个函数体的多个情况可以在 case 后写多个模式来复合，在每个模式之间用逗号分隔。如果任何一个模式匹配了，那么这个情况都会被认为是匹配的。如果模式太长，可以把它们写成多行。\n\n```swift\nlet someCharacter: Character = \"e\"\nswitch someCharacter {\ncase \"a\", \"e\", \"i\", \"o\", \"u\":\n    print(\"\\(someCharacter) is a vowel\")\ncase \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n     \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n    print(\"\\(someCharacter) is a consonant\")\ndefault:\n    print(\"\\(someCharacter) is not a vowel or a consonant\")\n}\n\n// Prints \"e is a vowel\"\n```\n\n#### 复合匹配 - 值绑定\n\n复合匹配同样可以包含值绑定。所有复合匹配的模式都必须包含**相同的值绑定集合**，并且复合情况中的每一个绑定都得**有相同的类型格式**。这才能确保无论复合匹配的哪部分命中了，在函数体中的代码都能访问到绑定的值，并且值的类型也都相同。\n\n```swift\nlet stillAnotherPoint = (9, 0)\nswitch stillAnotherPoint {\ncase (let distance, 0), (0, let distance):\n    print(\"On an axis, \\(distance) from the origin\")\ndefault:\n    print(\"Not on an axis\")\n}\n\n// Prints \"On an axis, 9 from the origin\"\n```\n\n### 控制转移\n\n#### continue\n\n`continue` 语句表示让循环停止当前遍历，开始下一次遍历。并不是离开整个循环。\n\n```swift\nfor i in 0...5 {\n    if i == 3 {\n        continue\n    }\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n4\n5\n```\n\n#### break\n\nbreak 语句会立即结束整个控制流语句。在需要提前结束 switch 或者其它循环语句时，可以使用 break。\n\nbreak 会立即结束整个循环的执行，并且转移控制到循环结束花括号（`}`）后的第一行代码上。**结束整个循环**，表示当前遍历循环里的其它代码都不会被执行，并且余下的遍历循环也不会开始了。\n\n```swift\nfor i in 0...5 {\n    if i == 3 {\n        break\n    }\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n```\n\n在 `switch` 语句里使用 `break` 时，`switch` 语句会立即结束执行，并且转移控制到 `switch` 语句结束花括号（`}`）之后的第一行代码上。\n\n```swift\nlet string = \"break\"\nswitch string {\ncase \"break\":\n    print(\"Before break\")\n    break\n    print(\"After break\")\ndefault:\n    print(\"Nothing\")\n}\n\n// Prints \"Before break\"\n```\n\n#### fallthrough\n\nSwift 的 `switch` 语句不支持隐私贯穿，可以通过关键字 `fallthrough` 显式实现贯穿行为。\n\n```swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprint(description)\n\n// Prints \"The number 5 is a prime number, and also an integer.\"\n```\n\n#### 语句标签\n\n可以使用语句标签给循环语句或者条件语句做标记。在一个条件语句中，可以使用语句标签配合 `break` 语句来结束被标记的语句。在循环语句中，你可以使用语句标签来配合 `break` 或者 `continue` 语句来结束或者继续执行**被标记的语句**。\n\n```swift\nvar number = 10\nwhileLoop : while number > 0 {\n    switch number {\n    case 9:\n        print(\"9\")\n    case 10:\n        var sum = 0\n        for index in 0...10 {\n            sum += index\n            if index == 9 {\n                print(sum)\n                break whileLoop\n            }\n        }\n    default:\n        break\n    }\n    number = -1\n}\n\n// Prints 45\n```\n\n## guard\n\n`guard` 语句，类似于 `if` 语句，基于布尔值表达式来执行语句。使用 `guard` 语句来要求一个条件必须是真才能执行 `guard` 之后的语句。与 `if` 语句不同，`guard` 语句总是有一个 `else` 分句——`else` 分句里的代码会在条件不为真的时候执行：\n\n![05](流程控制/05.png)\n\n在编写条件语句的时候，左边的代码间距应该是一个“黄金”或者“快乐”的大道。不要嵌套 `if` 语句，多个 `return` 语句可能是更好的，这样可以避免圈复杂度（Cyclomatic Complexity），并且让代码更加容易阅读。因为重要部分没有嵌套在分支上，可以很清楚的找到相关代码。\n\n推荐写法：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) {\n        return;\n    }\n\n    //Do something important\n}\n```\n\n不推荐写法：\n\n```swift\n- (void)someMethod {\n    if ([someOther boolValue]) {\n        //Do something important\n    }\n}\n```\n\n或者：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) \n        return;\n\n    //Do something important\n}\n```\n\n或者：\n\n```swift\n- (void)someMethod {\n    if (![someOther boolValue]) return;\n\n    //Do something important\n}\n```\n\n相关文档：\n<https://github.com/objc-zen/objc-zen-book>\n<https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html>\n\n### 应用1——验证 ip 地址的格式是否正确\n\n例1、使用 `if` 语句实现\n\n```swift\nfunc isIPAddress(ipAddr: String) -> (Int, String) {\n    let compoments = ipAddr.split(separator: \".\")\n    if compoments.count == 4 {\n        if let first = Int(compoments[0]), first >= 0 && first < 256 {\n            if let second = Int(compoments[1]), second >= 0 && second < 256 {\n                if let third = Int(compoments[2]), third >= 0 && third < 256 {\n                    if let fourth = Int(compoments[3]), fourth >= 0 && fourth < 256 {\n                        return (0, \"\")\n                    } else {\n                        return (4, \"第四个数不对\")\n                    }\n                } else {\n                    return (3, \"第三个数不对\")\n                }\n            } else {\n                return (2, \"第二个数不对\")\n            }\n        } else {\n            return (1, \"第一个数不对\")\n        }\n    }\n    return (100, \"ip只能有四部分\")\n}\n\nprint(isIPAddress(ipAddr: \"192.122.111.-1\"))\n\n// Prints \"(4, \"第四个数不对\")\"\n```\n\n例2、使用 guard 语句（注意左侧的黄金大道）实现\n\n```swift\nfunc isIPAddress(ipAddr: String) -> (Int, String) {\n    let compoments = ipAddr.split(separator: \".\")\n    \n    guard compoments.count == 4 else {\n        return (100, \"ip只能有四部分\")\n    }\n    \n    guard let first = Int(compoments[0]), first >= 0 && first < 256 else {\n        return (1, \"第一个数不对\")\n    }\n    \n    guard let second = Int(compoments[1]), second >= 0 && second < 256 else {\n        return (2, \"第二个数不对\")\n    }\n    \n    guard let third = Int(compoments[2]), third >= 0 && third < 256 else {\n        return (3, \"第三个数不对\")\n    }\n    \n    guard let fourth = Int(compoments[3]), fourth >= 0 && fourth < 256 else {\n        return (4, \"第四个数不对\")\n    }\n    \n    return (0, \"\")\n}\n\nprint(isIPAddress(ipAddr: \"192.118.222.300\"))\n\n// Prints \"(4, \"第四个数不对\")\"\n```\n\n### 应用2——检查 API 可用性\n\nSwift 拥有内置的 API 可用性的检查功能，能够确保使用不可用的 API。\n\n可以在 if 或者 guard 语句中使用一个可用性条件来有条件地执行代码。\n\n```swift\nif #available(iOS 10, macOS 10.12, *) {\n    // 在iOS上使用iOS 10 API，在macOS上使用macOS 10.12 API\n} else {\n    // 回到早期的iOS和macOS API\n}\n```\n\n## 模式和模式匹配\n\n模式：代表单个值或者复合值的**结构**。例如，`x` 的结构代表单个值的模式；元组 `(x, y)` 的结构是由逗号分隔的，包含两个元素的列表（元组模式）。\n\n模式匹配：**模式代表一种值的结构，而不是特定的某个值**，可以利用模式来匹配各种各样的值。例如，`(x, y)` 可以匹配元组 `(1, 2)`，以及任何两个元素的元组。\n\n除了利用模式匹配一个值以外，也可以从复合值中提取出部分或全部值，然后分别把各个部分的值和一个常量或者变量对应起来。\n\n### 模式分类\n\nSwift 中的模式分为两类：一种能成功匹配任何类型的值，另一种在运行时匹配某个特定值时可能会失败。\n\n* 第一类模式：用于解构简单变量、常量和可选绑定中的值。此类模式包括**通配符模式**、**标识符模式**，以及包含前两种模式的**值绑定模式**和**元组模式**。可以为这类模式指定一个类型标注，从而限制它们只能匹配某种特定类型的值。\n\n* 第二类模式：用于全模式匹配，这种情况下匹配的值在运行时可能不存在。此类模式包括**枚举用例模式**、**可选模式**、**表达式模式**和**类型转换模式**。在 `switch` 语句的 `case` 标签中，`do` 语句的 `catch` 子句中，或者在 `if`、`while`、`guard` 和 `for-in` 语句的 `cas`e 条件句中使用这类模式。\n\n#### 通配符模式（Wildcard Pattern）\n\n通配符模式：由一个下划线 `_` 构成，用于匹配并忽略任何值。如在便利时，忽略被匹配的值时可以使用该模式。\n\n```swift\nfor _ in 1...3 {\n    // TODO\n}\n```\n\n#### 标识符模式（Identifier Pattern）\n\n标识符模式：匹配任何值，并将匹配的值和一个变量或常量绑定起来。如定义一个常量：\n\n```swift\nlet someValue = 42\n```\n\n#### 值绑定模式（Value-Binding Pattern）\n\n值绑定模式：把匹配到的值绑定给一个变量或常量。如把匹配到的值绑定给常量时，用关键字 `let`，绑定给变量时，用关键字 `var`。\n\n```swift\nlet point = (3, 2)\nswitch point {\n// 将 point 中的元素绑定到 x 和 y\ncase let (x, y):\n    print(\"The point is at (\\(x), \\(y)).\")\n}\n```\n\n#### 元组模式（Tuple Pattern）\n\n元组模式：是有逗号分隔的，具有零个或多个模式的列表，并由一对圆括号括起来（如：`(x, y)`）。元组模式匹配相应元组类型的值。\n\n可以使用类型标注限制一个元组模式能匹配哪种元组类型。例如，在常量声明 `let(x, y): (Int, Int) = (1, 2)` 中的元组模式 `(x, y): (Int, Int)` 只能匹配两个元素都是 `Int` 类型的元组。\n\n当元组模式被用于 `for-in` 语句或者常量和变量声明时，它仅可以包含**通配符模式**、**标识符模式**、**可选模式**或者**其他包含这些模式的元组模式**。\n\n例如，在 `for-in` 语句中，使用通配符模式匹配 `y == 0` 的元组。\n\n```swift\nlet points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]\nfor (x, y) in points where y == 0 {\n    print(\"\\(x) and \\(y)\")\n}\n```\n\n打印结果：\n\n```js\n0 and 0\n1 and 0\n2 and 0\n```\n\n没有正确使用元组模式则会报错，如 `(x, 0)` 不是正确的元组模式：\n\n![06](流程控制/06.png)\n\n模式都是字母，而不是一个确切的数字，0 是数字，可以用 `y` 代替 0。\n\n#### 枚举用例模式（Enumeration Case Pattern）\n\n枚举用例模式：匹配现有的某个枚举类型的某个用例。枚举用例模式出现在 `switch` 语句中的 `case` 标签中，以及 `if`、`while`、`guard` 和 `for-in` 语句的 `case` 条件中。\n\n#### 可选项目模式（Optional Pattern）\n\n可选项模式匹配 `Optional<Wrapped>` 枚举在 `some(Wrapped)` 中包装的值。\n\n```swift\nlet someOptional: Int? = 42\nif case .some(let x) = someOptional {\n    print(x)\n}\n// Prints \"42\"\n```\n\n或者\n\n```swift\nif case let x? = someOptional {\n    print(x)\n}\n// Prints \"42\"\n```\n\n可选项模式为 `for-in` 语句提供了一种迭代数组的简便方式，只为数组中非 `nil` 的元素执行循环体。\n\n```swift\nlet arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]\nfor case let number? in arrayOfOptionalInts {\n    print(\"Found a \\(number)\")\n}\n```\n\n打印结果：\n\n```js\nFound a 2\nFound a 3\nFound a 5\n```\n\n#### 类型转换模式（Type-Casting Pattern）\n\n有两种类型转换模式，is 模式和 as 模式。is 模式只出现在 switch 语句中的 case 标签中。\n\n* `is` 模式：当一个值的类型在运行时和 `is` 模式右边的指定类型一致，或者是其子类的情况下，才会匹配这个值。`is` 模式和 `is` 运算符有相似表现，它们都进行类型转换，但是 `is` 模式没有返回类型。\n\n* `as` 模式：当一个值的类型在运行时和 `as` 模式右边的指定类型一致，或者是其子类的情况下，才会匹配这个值。如果匹配成功，被匹配的值的类型被转换成 `as` 模式右边指定的类型。\n\n```swift\nprotocol Animal {\n    var name: String { get }\n}\n\nstruct Dog: Animal {\n    var name: String {\n        return \"dog\"\n    }\n    var runSpeed: Int\n}\n\nstruct Bird: Animal {\n    var name: String {\n        return \"bird\"\n    }\n    var flightHeight: Int\n}\n\nstruct Fish: Animal {\n    var name: String {\n        return \"fish\"\n    }\n    var depth: Int\n}\n\nlet animals:[Any] = [Dog(runSpeed: 55), Bird(flightHeight: 2000), Fish(depth: 100)]\n\nfor animal in animals {\n    switch animal {\n    case let dog as Dog:\n        print(\"\\(dog.name) can run \\(dog.runSpeed)\")\n    case let fish as Fish:\n        print(\"\\(fish.name) can dive depth \\(fish.depth)\")\n    case is Bird:\n        print(\"bird can fly\")\n    default:\n        print(\"unknow animal!\")\n    }\n}\n\n// dog can run 55\n// bird can fly\n// fish can dive depth 100\n```\n\n#### 表达式模式（Expression Pattern）\n\n表达式模式代表表达式的值。表达式模式只出现在 switch 语句中的 case 标签中。\n\n表达式模式代表的表达式，会使用 Swift 标准库中的 `~=` 运算符，与输入表达式的值进行比较。如果 `~=` 运算符返回 true，则匹配成功。\n\n默认情况下，`~=` 运算符使用 `==` 运算符来比较两个相同类型的值。它也可以将一个整型数值与一个 Range 实例中的一段整数区间做匹配。\n\n```swift\nlet point = (1, 2)\nswitch point {\ncase (0, 0):\n    print(\"(0, 0) is at the origin.\")\ncase (-2...2, -2...2):\n    print(\"(\\(point.0), \\(point.1)) is near the origin.\")\ndefault:\n    print(\"The point is at (\\(point.0), \\(point.1)).\")\n}\n\n// Prints \"(1, 2) is near the origin.\"\n```\n\n可以重载 `~=` 运算符来提供自定义的表达式匹配行为：\n\n```swift\nfunc ~= (pattern: String, value: Int) -> Bool {\n    return pattern == \"\\(value)\"\n}\n\nlet point = (1, 2)\nswitch point {\ncase (\"0\", \"0\"):\n    print(\"(0, 0) is at the origin.\")\ndefault:\n    print(\"The point is at (\\(point.0), \\(point.1)).\")\n}\n\n// Prints \"The point is at (1, 2).\"\n```\n\n自定义类型默认也是无法进行表达式模式匹配的，也需要重载 `~=` 运算符。\n\n```swift\nstruct Employee {\n    var salary: Float\n}\nlet e = Employee(salary: 9999)\nfunc ~=(lhs: Range<Float>, rhs: Employee) -> Bool {\n    return lhs.contains(rhs.salary)\n}\nswitch e {\ncase 0.0..<1000:\n    print(\"艰难生活\")\ncase 1000..<5000:\n    print(\"小康生活\")\ncase 5000..<10000:\n    print(\"活的和滋润\")\ndefault:\n    break\n}\n\n// Prints \"活的和滋润\"\n```\n","slug":"Swift/流程控制","published":1,"updated":"2023-08-22T09:52:14.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgue001oaq7kbhds1fjw"},{"title":"运算符","date":"2022-10-14T02:19:27.000Z","_content":"\n* [溢出运算符](#溢出运算符)\n* [合并空值运算符](#合并空值运算符)\n* [区间运算符](#区间运算符)\n* [位运算符](#位运算符)\n* [位运算符经典算法](#位运算符经典算法)\n* [运算符的优先升级和结核性](#运算符的优先升级和结核性)\n* [自定义运算符](#自定义运算符)\n\n<!-- more -->\n\n## 赋值和算术运算符\n\n### 基本概念\n\n* 一元运算符，对一个目标进行操作。一元前缀运算符：`!b`，一元后缀运算符：`b!`。\n\n* 二元运算符，对两个目标进行操作。如`a + b`，同时因为它们出现在两个目标之间，所以是中缀运算符。\n\n* 三元运算符，对三个目标进行操作。Swift 语言仅有一个三元运算符，即三元条件运算符 `a ? b : c`。\n\nSwift 支持 C 中大多数的标准运算符，同时也增加了一些能力，用来排除常见代码错误：\n\n1. 赋值符号（`=`）不会返回值，以防止它和等于符号（`==`）产生误用。\n2. 算数符号（`+`，`-`，`*`，`/`，`%`等）可以检测并阻止值溢出，如存储类型放入大于允许范围的数字。\n\n### 赋值运算符\n\n* `=`：赋值运算符，将一个值赋值给另外一个值。如果赋值符号右侧是拥有多个值的元组，则元组的元素将会一次性拆分成常量和变量。\n\n#### 赋值运算符不会返回值\n\n在 OC 中，赋值运算符在赋值成功后会返回 `true`：\n\n![01](运算符/01.png)\n\n而 Swift 的赋值符号自身不会返回值：\n\n![02](运算符/02.png)\n\n### 算术运算符\n\n#### 标准运算符\n\n`+`、`-`、`*`、`/` 是标准算术运算符。\n  \n加法运算符也支持 String 的拼接：\n\n```swift\nlet str = str1 + str2\n```\n\n* Swift 算术运算符默认不允许值溢出\n\n#### 余数运算符\n\n```swift\nlet c = a % b\n```\n\n余数：指整数除法中被除数**未被除尽部分**，且余数的取值范围为0到除数之间（不包括除数）的整数。\n![03](运算符/03.png)\n\n除数为负数时，也是用同样的方法进行计算：\n\n```swift\nlet c = -4 % 3\nprint(c)\n// Prints -1\n```\n\n被除数为负数时，负号会被忽略：\n\n```swift\nlet c = 4 % -3\nprint(c)\n// Prints 1\n```\n\n#### 一元\n\n* 一元减号运算符（`-`）：直接放置在操作的值前边。数字值的正负号可以用前缀 `-` 来切换。\n* 一元加号运算符（`+`）：直接返回操作的值，不会对其进行任何的修改。\n\n## 溢出运算符\n\n向一个整数赋值超过它容量的值时，Swift 会报错，而不是生成一个无效的数。\n\n* `&+` 溢出加法\n* `&-` 溢出减法\n* `&*` 溢出乘法\n\n### 值溢出\n\n无符号整型数值和有符号整型数值都可以向上溢出或向下溢出。\n\n当发生上溢时，它们会从数值所能容纳的**最大数变成最小数**。\n\n当发生下溢时，它们会从数值所能容纳的**最小数变成最大数**。\n\n无符号整型数值，向上溢出：\n![04](运算符/04.png)\n\n无符号整型数值，向下溢出：\n![05](运算符/05.png)\n\n有符号整型数值，向下溢出：\n![06](运算符/06.png)\n\nSwift 算术运算符默认不允许值溢出：\n![07](运算符/07.png)\n\n可以使用**溢出加法`&+`**：\n![08](运算符/08.png)\n\n## 合并空值运算符\n\n如果 a 有值则返回 a，不会再判断 b；如果 a 没有值（`nil`），则返回默认值 b：\n\n```swift\nlet c = a ?? b\n```\n\n其中，a 必须是一个可选类型，b  必须与 a 的储存类型相同。\n\n合并空值运算符就是三元运算符，是三元运算符作用到 Optional 上的缩写版：\n\n```swift\n// 合并空值运算符\nlet c = a ?? b\n\n// 三元运算符\nlet c = a != nil ? a! : b\n```\n\n### 应用效果对比\n\n1、使用强制解包，有崩溃风险，如果 num1 或 num2 为 nil 会崩：\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    return num1! + num2!\n}\n```\n\n2、使用 if 判断，代码量比较多：\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    if num1 != nil && num2 != nil {\n        return num1! + num2!\n    } else {\n        return 0\n    }\n}\n```\n\n3、使用合并控制运算符 `??`\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    return (num1 ?? 0) + (num2 ?? 0)\n}\n```\n\n## 区间运算符\n\n### 闭区间运算符\n\n`a...b`：闭区间运算符，定义了从 a 到 b 的一组范围，**包含 a 和 b**。a 的值不能大于 b。\n\n```swift\nfor index in 1...5 {\n    print(index)\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n### 半开区间运算符\n\n`a..<b`：半开区间运算符，定义了从 a 到 b 的一组范围，**包含 a 不包含 b**。a 不能大于 b，如果 a 与 b 相等，则返回空。\n\n```swift\nfor index in 1..<5 {\n    print(index)\n}\n// 1\n// 2\n// 3\n// 4\n```\n\n### 单侧区间\n\n单侧区间是闭区间的另外一种形式，让区间**朝一个方向尽可能的远**。\n\n* `a...`：区间左边大于等于 a。\n* `...b`：区间右边小于等于 b。\n\n半开区间运算符也有单侧形式：\n\n* `..<b`：区间右边小于b。\n\n举例1：从索引2到数组最后一个元素\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[2...] {\n    print(name)\n}\n// wangwu\n// zhaoliu\n```\n\n举例2：从数组第一个元素开始到索引2：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[...2] {\n    print(name)\n}\n// zhangsan\n// lisi\n// wangwu\n```\n\n举例3：从数组第一个元素开始到索引2前一个元素：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[..<2] {\n    print(name)\n}\n// zhangsan\n// lisi\n```\n\n举例4：单侧区间不仅用于下标，还可以在上下文中使用\n\n```swift\nlet range = ...5\nprint(range.contains(7))\nprint(range.contains(4))\nprint(range.contains(-1))\n// false\n// true\n// true\n```\n\n### 字符串索引区间\n\n区间运算符在字符串中的应用：删除指定范围的字符\n\n```swift\nvar welcome = \"hello,world\"\nlet range = welcome.index(welcome.endIndex, offsetBy: -6) ..< welcome.endIndex\nwelcome.removeSubrange(range)\nprint(welcome)\n// Prints \"hello\"\n```\n\n### 倒序索引\n\n```swift\nvar welcome = \"hello,world\"\nlet reversedWelcome = String(welcome.reversed())\nprint(reversedWelcome)\n// Prints \"dlrow,olleh\"\n```\n\n### Comparable 区间\n\n区间运算符作用在 Comparable 类型上，返回闭区间和半闭区间。\n\n```swift\nlet welcome = \"Hello\"\nlet interval = \"a\"...\"z\"\nfor c in welcome {\n    if !interval.contains(String(c)) {\n        print(\"\\(c)不是小写字母\")\n    }\n}\n// Prints \"H不是小写字母\"\n```\n\n## 位运算符\n\n### 位取反运算符\n\n* `~` 位取反运算符，是对所有位的数字进行取反操作。\n\n![09](运算符/09.png)\n\n### 位与运算符\n\n* `&` 位与运算符，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位都是 1** 时返回 1。\n\n![10](运算符/10.png)\n\n### 位或运算符\n\n* `|` 位或运算符，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位任意一个为 1** 时返回 1。\n\n![11](运算符/11.png)\n\n### 位异或运算符\n\n* `^` 为异或运算符，或者叫“互斥或”，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位不相同** 时返回 1。\n\n![12](运算符/12.png)\n\n### 位左移和右移运算符\n\n* `<<` 位左移运算符，可以把所有位数的数字向左移动一个确定的位数。\n* `>>` 位右移运算符，可以把所有位数的数字向右移动一个确定的位数。\n\n**位左移和位右移具有将整数乘以或除以二的效果。**将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。\n\n### 无符号整数的移位操作\n\n实现过程：\n\n1. 已经存在的比特位按指定的位数进行左移和右移；\n2. 任何移动超出整型存储边界的位都会被丢弃；\n3. 用 0 来填充向左或向右移动后产生的空白位。\n\n![13](运算符/13.png)\n\n### 有符号整数的移位操作\n\n符号位：有符号整数用第一位表示正数还是负数。符号位为 0 表示正数，1 表示负数。\n\n数值位：除第一位外其余的位，存储了实际的值。\n\n有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。\n\n![14](运算符/14.png)\n\n但是负数的存储方式略有不同，它存储的是 2 的 n 次方减去它的绝对值，这里的 n 为数值位的位数。\n\n![15](运算符/15.png)\n\n-4 的存储位 128 - 4 = 124。\n\n### 补码表示的优点\n\n对于算式 `-4 + -1`，先将两个数的全部八个比特位相加（包括符号位），再将计算结果中超出的部分丢弃。\n\n![16](运算符/16.png)\n\n-4 的存储位 `2^8 - 4`，-1 的存储位 `2^8 - 1`，-5 的存储位 `2^8 - 5`。\n`-4 + -1 = 2^8 - 4 + 2^8 - 1`，将计算结果中超出的部分丢弃（去掉一个2^8）。\n即 `-4 + -1 = 2^8 - 4 - 1 = 2^8 - 5`，等于 -5。\n\n使用二进制补码可以使负数的位左移和右移操作，得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右移一位就将自身的数值除以 2。\n\n要达到此目的，对有符号整数的右移有一个额外的规则：当对正整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是 0。\n\n![17](运算符/17.png)\n\n### 位运算符经典算法\n\n#### 两个数字交换\n\n```swift\nvar a = 10\nvar b = 8\na = a ^ b\nb = a ^ b\na = a ^ b\nprint(a)\nprint(b)\n// 8\n// 10\n```\n\n#### 求无符号整数二进制中1的个数\n\n* 给定一个无符号整型（UInt）变量，求其二进制表示中 “1” 的个数，要求算法的执行效率尽可能的高。\n\n> 思路：看一个八位整数 10 100 001，先判断最后一位是否为 1，而“与”操作可以达到目的。可以把这个八位的数字与 00 000 001 进行“与”操作。如果结果为1，则表示当前八位数的最后一位为1，否则为0。怎么判断第二位呢？向右移位，在延续前面的判断即可。\n\n```swift\nfunc countOfOnes(num: UInt) -> UInt {\n    var count: UInt = 0\n    var temp = num\n    while temp != 0 {\n        count += temp & 1\n        temp = temp >> 1\n    }\n    return count\n}\nprint(countOfOnes(num: 4))\nprint(countOfOnes(num: 5))\n// Prints 1\n// Prints 2\n```\n\n思考：如果整数的二进制中有较多的 0，那么我们每一次右移一位做判断会很浪费，怎么改进呢？有没有办法让算法的复杂度只与“1”的个数有关？\n\n> 思路：为了简化这个问题，先考虑只有高位有“1”的情况。例如：11 000 000，如何跳过前面低位的 6 个 0，而直接判断第七位的 1？我们可以设计 11 000 000 和 10 111 111（也就是 11 000 000 - 1）做“与”操作，**消去最低位的 1**。如果得到的结果为 0，说明已经找到（消去）里面最后一个 1。如果不为 0，那么说明消去了最低位的 1，但是二进制中还有其它的 1，计数器加一继续上面的操作。\n>\n> 计数器 count = 0\n>\n> 步骤一：整数不为0，说明二进制里肯定有 1，count = 1\n>\n> 11 000 000 & 10 111 111 = 10 000 000（消去第七位的 1）。\n>\n> 步骤二：结果不为0，说明二进制里还有 1，count = 2\n>\n> 10 000 000 & 01 111 111 = 0（消去第八位的 1）。\n>\n> 步骤三：结果为0，终止，返回 count 为 2。\n\n```swift\nfunc countOfOnes(num: UInt) -> UInt {\n    var count: UInt = 0\n    var temp = num\n    while temp != 0 {\n        count += 1\n        temp = temp & (temp - 1)\n    }\n    return count\n}\n\nprint(countOfOnes(num: 4))\nprint(countOfOnes(num: 5))\n// Prints 1\n// Prints 2\n```\n\n#### 如何判断一个整数为2的整数次幂\n\n* 给定一个无符号整型（UInt）变量，判断是否为 2 的整数次幂。\n\n> 思路：**一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，其它所有位都是 0**。根据前面的分析，把这个整数减去 1 后再和它自己做“与”运算，这个整数中唯一的 1 就变成 0 了，也就是得到的结尾为 0。\n\n```swift\nfunc isPowerOfTwo(num: UInt) -> Bool {\n    return (num & (num - 1)) == 0;\n}\n\nprint(isPowerOfTwo(num: 4))\nprint(isPowerOfTwo(num: 5))\n// Prints true\n// Prints false\n```\n\n#### 缺失的数字\n\n* 很多成对出现的正整数保存在磁盘文件中，注意成对的数字不一定是相邻的，如 2，3，4，3，4，2......，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？\n\n> 思路：考虑“异或”操作的定义，当两个操作数的对应位不同时，该数的对应位就为 1。也就是说如果是 **相等的两个数“异或”，得到的结果为 0，而 0 与任何数字“异或”，得到的是那个数字本身**。所以可以将所的数字做“异或”操作，因为只有一个数字消失，那么其它两两出现的数字“异或”后为 0，0与仅有的一个数字做“异或”，就得到了消失的数字是哪个。\n\n```swift\nfunc findLostNum(nums: [UInt]) -> UInt {\n    var lostNum: UInt = 0\n    for num in nums {\n        lostNum = lostNum ^ num\n    }\n    return lostNum\n}\n\nprint(findLostNum(nums: [1, 2, 1, 3, 2, 3, 4]))\n// Prints 4\n```\n\n#### 缺失的数字2\n\n* 很多成对出现的正整数保存在磁盘文件中，注意成对的数字不一定是相邻的，如 2，3，4，3，4，2......，如果有两个数字意外丢失了（丢失的不是相等的数字），该如何找到丢失的两个数字？\n\n> 思路：设题目中这两个只出现 1 次的数字分别为 A 和 B，如果能将 A，B 分开到两个数组中，那显然符合“异或”解法的关键点了。因此这个题目的关键点就是将 A，B 分开到二个数组中。由于 A，B 肯定是不相等的，因此在二进制上必定有一位是不同的。根据这一位是 0 还是 1 可以将 A 和 B 分开到 A组 和 B组。而这个数组中其它数字要么属于 A 组，要么就属于 B 组。再对 A组 和 B组 分别执行“异或”解法就可以得到 A，B 了。而要判断 A，B 在哪一位上不相同，只要根据 “A异或B” 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B 在这一位上是不相同的。\n\n```swift\nfunc findTwoLostNums(nums: [UInt]) -> (UInt, UInt) {\n    var lostNum1: UInt = 0\n    var lostNum2: UInt = 0\n    var temp: UInt = 0\n    //计算两个数的异或结果\n    for num in nums {\n        temp = temp ^ num\n    }\n    //找到第一个不为1的位\n    var flag: UInt = 1;\n    while ((flag & temp) == 0) {\n        flag = flag << 1\n    }\n    //找两个丢失的数字\n    for num in nums {\n        if (num & flag == 0) {\n            lostNum1 = lostNum1 ^ num\n        } else {\n            lostNum2 = lostNum2 ^ num\n        }\n    }\n    return (lostNum1, lostNum2)\n}\n\nprint(findTwoLostNums(nums: [1,2,1,3,2,4]))\n// Prints (4, 3)\n```\n\n#### 缺失的数字3\n\n* 数组中，只有一个数出现一次，剩下的都出现三次，找出出现一次的数字。\n\n> 思路：考虑到三次异或后还是数字本身，所以不能像例2那样使用异或。根据**位运算**的思想，出现三次的数字每个比特位也出现了三次，如果将出现的次数相加的话，每一个比特位都可以被3整除。只出现一次的数字的每一个比特位出现的次数都是1，不能被3整除。\n\n```swift\nfunc findLostNum(nums: [UInt]) -> UInt {\n    // 长度为32的数组\n    var bitSum = [UInt](repeating: 0, count: 32)\n    // 遍历二进制表示的32个比特位\n    for i in 0..<32 {\n        var sum: UInt = 0\n        // 遍历数组，判断每个数的二进制表示，在第 i 位是否为1\n        for num in nums {\n            sum += (num >> i & 1)\n        }\n        // 保存所有数在第 i 位的总和\n        bitSum[i] = sum\n    }\n    var res: UInt = 0\n    for i in 0..<32 {\n        // 不能被3整除的比特位，表示只出现一次的那个数字在这个二进制位上为1\n        if (bitSum[i]%3 != 0) {\n            // 将res的第i位置为1\n            res += 1<<i\n        }\n    }\n    return res\n}\n\nprint(findLostNum(nums: [1,2,3,4,1,2,3,1,2,3]))\n// Prints 4\n```\n\n## 运算符的优先升级和结核性\n\n运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。\n\n结合性定义了具有相同优先级的运算符是如何结合（或关联）的——与左边结合为一组，还是与右边结合为一组。\n\n```swift\nlet c = 2 + 3 % 4 * 5\nprint(c)\n// Prints 17\n```\n\n`2 + 3 % 4 * 5` 等价于 `2 + ((3 % 4) * 5)`。\n\n### 运算符优先级 - 显示括号\n\nSwift 语言中逻辑运算符 `&&` 和 `||` 是做相关的，意味着多个逻辑运算符组合的表达式会首先计算最左边的子表达式。\n\n```swift\nlet lockA = true, lockB = false, lockC = false, lockD = false\n\nif (lockA && lockB || lockC || lockD) {\n    print(\"Welcome!\")\n} else {\n    print(\"ACCESS DENIED\")\n}\n// Prints \"ACCESS DENIED\"\n```\n\n等价于\n\n```swift\nif ((lockA && lockB) || lockC || lockD) {\n    print(\"Welcome!\")\n} else {\n    print(\"ACCESS DENIED\")\n}\n// Prints \"ACCESS DENIED\"\n```\n\n## 运算符重载\n\n类和结构体可以为现有的运算符提供自定义的实现，称为运算符重载。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedCector = vector + anotherVector\nprint(combinedCector)\n// prints Vector2D(x: 5.0, y: 5.0)\n```\n\n### 一元运算符重载\n\n类与结构体也能提供标准一元运算符的实现。要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static prefix func - (vector: Vector2D) -> Vector2D {\n        return Vector2D(x: -vector.x, y: -vector.y)\n    }\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\nlet alsoPositive = -negative\n\nprint(negative)\nprint(alsoPositive)\n// prints Vector2D(x: -3.0, y: -4.0)\n// prints Vector2D(x: 3.0, y: 4.0)\n```\n\n### 组合赋值运算符重载\n\n组合赋值运算符将赋值运算符（`=`）与其它运算符进行结合。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nextension Vector2D {\n    // 把 left 设置成 inout 类型\n    static func += (left: inout Vector2D, right: Vector2D) {\n        left = left + right\n    }\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n\nprint(original)\n// Prints Vector2D(x: 4.0, y: 6.0)\n```\n\n因为 `left` 的值会在运算符函数内直接被修改，所以需要把 `left` 设置成 `inout` 类型。\n\n### 等价运算符重载\n\n自定义类和结构体不接收等价运算符的默认实现，也就是所谓的“等于”运算符（`==`）和“不等于”运算符（`!=`）。要使用等价运算符，需要提供一个“等于”运算符（类似中缀运算符`+`），并且遵循标准库 Equaltable 协议。\n\n```swift\nstruct Vector3D: Equatable {\n    var x = 0.0, y = 0.0, z = 0.0\n}\n\nlet vector01 = Vector3D(x: 2.0, y: 3.0, z: 4.0)\nlet vector02 = Vector3D(x: 2.0, y: 3.0, z: 4.0)\nif vector01 == vector02 {\n    print(\"vector01 == vector02\")\n}\n// Prints \"vector01 == vector02\"\n```\n\nswift 为一下自定义类型提供等价运算符合成实现：\n\n* 只拥有遵循 Equaltable 协议存储属性的结构体\n* 只拥有遵循 Equaltable 协议关联类型的枚举\n* 没有关联类型的枚举\n\n## 自定义运算符\n\n除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。自定义的运算符如果想在全局作用域内，可以使用 `operator` 关键字进行声明，同时还要指定 `prefix`、`infix` 或者 `postfix` 限定符。\n\n```swift\n// 全局作用域\nprefix operator +++\n\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nextension Vector2D {\n    static func += (left: inout Vector2D, right: Vector2D) {\n        left = left + right\n    }\n}\n\n// 自定义前缀翻倍运算符\nextension Vector2D {\n    static prefix func +++ (vector: inout Vector2D) -> Vector2D {\n        vector += vector\n        return vector\n    }\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)\nlet afterDoubling = +++toBeDoubled\n\nprint(afterDoubling)\n// Prints Vector2D(x: 2.0, y: 8.0)\n```\n\n### 自定义中缀运算符的优先级和结合性\n\n自定义的中缀（`infix`）运算符也可以指定优先级和结合性，每一个自定义的中缀运算符都属于一个优先级组，优先级组制定了自定义中缀运算符和其他中缀运算符的关系。\n\n* `AdditionPrecedence` 加法运算优先级组\n* `MultiplicationPrecedence` 乘法运算优先级组\n\n```swift\n// 自定义优先级组\nprecedencegroup MyPrecedence {\n    // 设置优先级组的计算方向为从左侧开始\n    associativity: left\n    // 设置优先级小于加法运算优先级组\n    lowerThan: AdditionPrecedence\n}\n```\n\n自定义中缀运算符 `+-`\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\n// 自定义运算符 +- 属于加法运算符组\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\n// 自定义运算符 *^ 属于乘法运算符组\ninfix operator *^: MultiplicationPrecedence\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 7.0, y: -51.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n\n自定义运算符 `+-` 属于加法运算符组，自定义运算符 \\*^ 属于乘法运算符组。因为乘法运算的优先级大于加法运算，所以运算符组 `+-` 的优先级小于运算符组 `\\*^` ，即 `\\*^` 先于 `+-` 运算：\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\n// 自定义运算符 +- 属于加法运算符组\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\ninfix operator\n// 自定义运算符 *^ 属于乘法运算符组\nprecedencegroup MyPrecedence {\n    // 设置优先级组的计算方向为从左侧开始\n    associativity: left\n    // 设置优先级小于加法运算优先级组\n    lowerThan: AdditionPrecedence\n}\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 7.0, y: -51.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n\n自定义运算符组 `MyPrecedence`，设置优先级低于加法运算组。即 `*^` 和 `+-` 的执行顺序按从左至右的顺序：\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\n//infix operator *^: MultiplicationPrecedence\ninfix operator *^: MyPrecedence\nprecedencegroup MyPrecedence {\n    associativity: left\n    lowerThan: AdditionPrecedence\n}\n\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 8.0, y: 29.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n","source":"_posts/Swift/运算符.md","raw":"---\ntitle: 运算符\ndate: 2022-10-14 10:19:27\ntags: Swift\n---\n\n* [溢出运算符](#溢出运算符)\n* [合并空值运算符](#合并空值运算符)\n* [区间运算符](#区间运算符)\n* [位运算符](#位运算符)\n* [位运算符经典算法](#位运算符经典算法)\n* [运算符的优先升级和结核性](#运算符的优先升级和结核性)\n* [自定义运算符](#自定义运算符)\n\n<!-- more -->\n\n## 赋值和算术运算符\n\n### 基本概念\n\n* 一元运算符，对一个目标进行操作。一元前缀运算符：`!b`，一元后缀运算符：`b!`。\n\n* 二元运算符，对两个目标进行操作。如`a + b`，同时因为它们出现在两个目标之间，所以是中缀运算符。\n\n* 三元运算符，对三个目标进行操作。Swift 语言仅有一个三元运算符，即三元条件运算符 `a ? b : c`。\n\nSwift 支持 C 中大多数的标准运算符，同时也增加了一些能力，用来排除常见代码错误：\n\n1. 赋值符号（`=`）不会返回值，以防止它和等于符号（`==`）产生误用。\n2. 算数符号（`+`，`-`，`*`，`/`，`%`等）可以检测并阻止值溢出，如存储类型放入大于允许范围的数字。\n\n### 赋值运算符\n\n* `=`：赋值运算符，将一个值赋值给另外一个值。如果赋值符号右侧是拥有多个值的元组，则元组的元素将会一次性拆分成常量和变量。\n\n#### 赋值运算符不会返回值\n\n在 OC 中，赋值运算符在赋值成功后会返回 `true`：\n\n![01](运算符/01.png)\n\n而 Swift 的赋值符号自身不会返回值：\n\n![02](运算符/02.png)\n\n### 算术运算符\n\n#### 标准运算符\n\n`+`、`-`、`*`、`/` 是标准算术运算符。\n  \n加法运算符也支持 String 的拼接：\n\n```swift\nlet str = str1 + str2\n```\n\n* Swift 算术运算符默认不允许值溢出\n\n#### 余数运算符\n\n```swift\nlet c = a % b\n```\n\n余数：指整数除法中被除数**未被除尽部分**，且余数的取值范围为0到除数之间（不包括除数）的整数。\n![03](运算符/03.png)\n\n除数为负数时，也是用同样的方法进行计算：\n\n```swift\nlet c = -4 % 3\nprint(c)\n// Prints -1\n```\n\n被除数为负数时，负号会被忽略：\n\n```swift\nlet c = 4 % -3\nprint(c)\n// Prints 1\n```\n\n#### 一元\n\n* 一元减号运算符（`-`）：直接放置在操作的值前边。数字值的正负号可以用前缀 `-` 来切换。\n* 一元加号运算符（`+`）：直接返回操作的值，不会对其进行任何的修改。\n\n## 溢出运算符\n\n向一个整数赋值超过它容量的值时，Swift 会报错，而不是生成一个无效的数。\n\n* `&+` 溢出加法\n* `&-` 溢出减法\n* `&*` 溢出乘法\n\n### 值溢出\n\n无符号整型数值和有符号整型数值都可以向上溢出或向下溢出。\n\n当发生上溢时，它们会从数值所能容纳的**最大数变成最小数**。\n\n当发生下溢时，它们会从数值所能容纳的**最小数变成最大数**。\n\n无符号整型数值，向上溢出：\n![04](运算符/04.png)\n\n无符号整型数值，向下溢出：\n![05](运算符/05.png)\n\n有符号整型数值，向下溢出：\n![06](运算符/06.png)\n\nSwift 算术运算符默认不允许值溢出：\n![07](运算符/07.png)\n\n可以使用**溢出加法`&+`**：\n![08](运算符/08.png)\n\n## 合并空值运算符\n\n如果 a 有值则返回 a，不会再判断 b；如果 a 没有值（`nil`），则返回默认值 b：\n\n```swift\nlet c = a ?? b\n```\n\n其中，a 必须是一个可选类型，b  必须与 a 的储存类型相同。\n\n合并空值运算符就是三元运算符，是三元运算符作用到 Optional 上的缩写版：\n\n```swift\n// 合并空值运算符\nlet c = a ?? b\n\n// 三元运算符\nlet c = a != nil ? a! : b\n```\n\n### 应用效果对比\n\n1、使用强制解包，有崩溃风险，如果 num1 或 num2 为 nil 会崩：\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    return num1! + num2!\n}\n```\n\n2、使用 if 判断，代码量比较多：\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    if num1 != nil && num2 != nil {\n        return num1! + num2!\n    } else {\n        return 0\n    }\n}\n```\n\n3、使用合并控制运算符 `??`\n\n```swift\nfunc addTowNumber(num1: Int?, num2: Int?) -> Int {\n    return (num1 ?? 0) + (num2 ?? 0)\n}\n```\n\n## 区间运算符\n\n### 闭区间运算符\n\n`a...b`：闭区间运算符，定义了从 a 到 b 的一组范围，**包含 a 和 b**。a 的值不能大于 b。\n\n```swift\nfor index in 1...5 {\n    print(index)\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n### 半开区间运算符\n\n`a..<b`：半开区间运算符，定义了从 a 到 b 的一组范围，**包含 a 不包含 b**。a 不能大于 b，如果 a 与 b 相等，则返回空。\n\n```swift\nfor index in 1..<5 {\n    print(index)\n}\n// 1\n// 2\n// 3\n// 4\n```\n\n### 单侧区间\n\n单侧区间是闭区间的另外一种形式，让区间**朝一个方向尽可能的远**。\n\n* `a...`：区间左边大于等于 a。\n* `...b`：区间右边小于等于 b。\n\n半开区间运算符也有单侧形式：\n\n* `..<b`：区间右边小于b。\n\n举例1：从索引2到数组最后一个元素\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[2...] {\n    print(name)\n}\n// wangwu\n// zhaoliu\n```\n\n举例2：从数组第一个元素开始到索引2：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[...2] {\n    print(name)\n}\n// zhangsan\n// lisi\n// wangwu\n```\n\n举例3：从数组第一个元素开始到索引2前一个元素：\n\n```swift\nlet names = [\"zhangsan\", \"lisi\", \"wangwu\", \"zhaoliu\"]\nfor name in names[..<2] {\n    print(name)\n}\n// zhangsan\n// lisi\n```\n\n举例4：单侧区间不仅用于下标，还可以在上下文中使用\n\n```swift\nlet range = ...5\nprint(range.contains(7))\nprint(range.contains(4))\nprint(range.contains(-1))\n// false\n// true\n// true\n```\n\n### 字符串索引区间\n\n区间运算符在字符串中的应用：删除指定范围的字符\n\n```swift\nvar welcome = \"hello,world\"\nlet range = welcome.index(welcome.endIndex, offsetBy: -6) ..< welcome.endIndex\nwelcome.removeSubrange(range)\nprint(welcome)\n// Prints \"hello\"\n```\n\n### 倒序索引\n\n```swift\nvar welcome = \"hello,world\"\nlet reversedWelcome = String(welcome.reversed())\nprint(reversedWelcome)\n// Prints \"dlrow,olleh\"\n```\n\n### Comparable 区间\n\n区间运算符作用在 Comparable 类型上，返回闭区间和半闭区间。\n\n```swift\nlet welcome = \"Hello\"\nlet interval = \"a\"...\"z\"\nfor c in welcome {\n    if !interval.contains(String(c)) {\n        print(\"\\(c)不是小写字母\")\n    }\n}\n// Prints \"H不是小写字母\"\n```\n\n## 位运算符\n\n### 位取反运算符\n\n* `~` 位取反运算符，是对所有位的数字进行取反操作。\n\n![09](运算符/09.png)\n\n### 位与运算符\n\n* `&` 位与运算符，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位都是 1** 时返回 1。\n\n![10](运算符/10.png)\n\n### 位或运算符\n\n* `|` 位或运算符，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位任意一个为 1** 时返回 1。\n\n![11](运算符/11.png)\n\n### 位异或运算符\n\n* `^` 为异或运算符，或者叫“互斥或”，可以对两个数的比特位进行比较，返回一个新的数，当**两个比特位不相同** 时返回 1。\n\n![12](运算符/12.png)\n\n### 位左移和右移运算符\n\n* `<<` 位左移运算符，可以把所有位数的数字向左移动一个确定的位数。\n* `>>` 位右移运算符，可以把所有位数的数字向右移动一个确定的位数。\n\n**位左移和位右移具有将整数乘以或除以二的效果。**将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。\n\n### 无符号整数的移位操作\n\n实现过程：\n\n1. 已经存在的比特位按指定的位数进行左移和右移；\n2. 任何移动超出整型存储边界的位都会被丢弃；\n3. 用 0 来填充向左或向右移动后产生的空白位。\n\n![13](运算符/13.png)\n\n### 有符号整数的移位操作\n\n符号位：有符号整数用第一位表示正数还是负数。符号位为 0 表示正数，1 表示负数。\n\n数值位：除第一位外其余的位，存储了实际的值。\n\n有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。\n\n![14](运算符/14.png)\n\n但是负数的存储方式略有不同，它存储的是 2 的 n 次方减去它的绝对值，这里的 n 为数值位的位数。\n\n![15](运算符/15.png)\n\n-4 的存储位 128 - 4 = 124。\n\n### 补码表示的优点\n\n对于算式 `-4 + -1`，先将两个数的全部八个比特位相加（包括符号位），再将计算结果中超出的部分丢弃。\n\n![16](运算符/16.png)\n\n-4 的存储位 `2^8 - 4`，-1 的存储位 `2^8 - 1`，-5 的存储位 `2^8 - 5`。\n`-4 + -1 = 2^8 - 4 + 2^8 - 1`，将计算结果中超出的部分丢弃（去掉一个2^8）。\n即 `-4 + -1 = 2^8 - 4 - 1 = 2^8 - 5`，等于 -5。\n\n使用二进制补码可以使负数的位左移和右移操作，得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右移一位就将自身的数值除以 2。\n\n要达到此目的，对有符号整数的右移有一个额外的规则：当对正整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是 0。\n\n![17](运算符/17.png)\n\n### 位运算符经典算法\n\n#### 两个数字交换\n\n```swift\nvar a = 10\nvar b = 8\na = a ^ b\nb = a ^ b\na = a ^ b\nprint(a)\nprint(b)\n// 8\n// 10\n```\n\n#### 求无符号整数二进制中1的个数\n\n* 给定一个无符号整型（UInt）变量，求其二进制表示中 “1” 的个数，要求算法的执行效率尽可能的高。\n\n> 思路：看一个八位整数 10 100 001，先判断最后一位是否为 1，而“与”操作可以达到目的。可以把这个八位的数字与 00 000 001 进行“与”操作。如果结果为1，则表示当前八位数的最后一位为1，否则为0。怎么判断第二位呢？向右移位，在延续前面的判断即可。\n\n```swift\nfunc countOfOnes(num: UInt) -> UInt {\n    var count: UInt = 0\n    var temp = num\n    while temp != 0 {\n        count += temp & 1\n        temp = temp >> 1\n    }\n    return count\n}\nprint(countOfOnes(num: 4))\nprint(countOfOnes(num: 5))\n// Prints 1\n// Prints 2\n```\n\n思考：如果整数的二进制中有较多的 0，那么我们每一次右移一位做判断会很浪费，怎么改进呢？有没有办法让算法的复杂度只与“1”的个数有关？\n\n> 思路：为了简化这个问题，先考虑只有高位有“1”的情况。例如：11 000 000，如何跳过前面低位的 6 个 0，而直接判断第七位的 1？我们可以设计 11 000 000 和 10 111 111（也就是 11 000 000 - 1）做“与”操作，**消去最低位的 1**。如果得到的结果为 0，说明已经找到（消去）里面最后一个 1。如果不为 0，那么说明消去了最低位的 1，但是二进制中还有其它的 1，计数器加一继续上面的操作。\n>\n> 计数器 count = 0\n>\n> 步骤一：整数不为0，说明二进制里肯定有 1，count = 1\n>\n> 11 000 000 & 10 111 111 = 10 000 000（消去第七位的 1）。\n>\n> 步骤二：结果不为0，说明二进制里还有 1，count = 2\n>\n> 10 000 000 & 01 111 111 = 0（消去第八位的 1）。\n>\n> 步骤三：结果为0，终止，返回 count 为 2。\n\n```swift\nfunc countOfOnes(num: UInt) -> UInt {\n    var count: UInt = 0\n    var temp = num\n    while temp != 0 {\n        count += 1\n        temp = temp & (temp - 1)\n    }\n    return count\n}\n\nprint(countOfOnes(num: 4))\nprint(countOfOnes(num: 5))\n// Prints 1\n// Prints 2\n```\n\n#### 如何判断一个整数为2的整数次幂\n\n* 给定一个无符号整型（UInt）变量，判断是否为 2 的整数次幂。\n\n> 思路：**一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，其它所有位都是 0**。根据前面的分析，把这个整数减去 1 后再和它自己做“与”运算，这个整数中唯一的 1 就变成 0 了，也就是得到的结尾为 0。\n\n```swift\nfunc isPowerOfTwo(num: UInt) -> Bool {\n    return (num & (num - 1)) == 0;\n}\n\nprint(isPowerOfTwo(num: 4))\nprint(isPowerOfTwo(num: 5))\n// Prints true\n// Prints false\n```\n\n#### 缺失的数字\n\n* 很多成对出现的正整数保存在磁盘文件中，注意成对的数字不一定是相邻的，如 2，3，4，3，4，2......，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？\n\n> 思路：考虑“异或”操作的定义，当两个操作数的对应位不同时，该数的对应位就为 1。也就是说如果是 **相等的两个数“异或”，得到的结果为 0，而 0 与任何数字“异或”，得到的是那个数字本身**。所以可以将所的数字做“异或”操作，因为只有一个数字消失，那么其它两两出现的数字“异或”后为 0，0与仅有的一个数字做“异或”，就得到了消失的数字是哪个。\n\n```swift\nfunc findLostNum(nums: [UInt]) -> UInt {\n    var lostNum: UInt = 0\n    for num in nums {\n        lostNum = lostNum ^ num\n    }\n    return lostNum\n}\n\nprint(findLostNum(nums: [1, 2, 1, 3, 2, 3, 4]))\n// Prints 4\n```\n\n#### 缺失的数字2\n\n* 很多成对出现的正整数保存在磁盘文件中，注意成对的数字不一定是相邻的，如 2，3，4，3，4，2......，如果有两个数字意外丢失了（丢失的不是相等的数字），该如何找到丢失的两个数字？\n\n> 思路：设题目中这两个只出现 1 次的数字分别为 A 和 B，如果能将 A，B 分开到两个数组中，那显然符合“异或”解法的关键点了。因此这个题目的关键点就是将 A，B 分开到二个数组中。由于 A，B 肯定是不相等的，因此在二进制上必定有一位是不同的。根据这一位是 0 还是 1 可以将 A 和 B 分开到 A组 和 B组。而这个数组中其它数字要么属于 A 组，要么就属于 B 组。再对 A组 和 B组 分别执行“异或”解法就可以得到 A，B 了。而要判断 A，B 在哪一位上不相同，只要根据 “A异或B” 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B 在这一位上是不相同的。\n\n```swift\nfunc findTwoLostNums(nums: [UInt]) -> (UInt, UInt) {\n    var lostNum1: UInt = 0\n    var lostNum2: UInt = 0\n    var temp: UInt = 0\n    //计算两个数的异或结果\n    for num in nums {\n        temp = temp ^ num\n    }\n    //找到第一个不为1的位\n    var flag: UInt = 1;\n    while ((flag & temp) == 0) {\n        flag = flag << 1\n    }\n    //找两个丢失的数字\n    for num in nums {\n        if (num & flag == 0) {\n            lostNum1 = lostNum1 ^ num\n        } else {\n            lostNum2 = lostNum2 ^ num\n        }\n    }\n    return (lostNum1, lostNum2)\n}\n\nprint(findTwoLostNums(nums: [1,2,1,3,2,4]))\n// Prints (4, 3)\n```\n\n#### 缺失的数字3\n\n* 数组中，只有一个数出现一次，剩下的都出现三次，找出出现一次的数字。\n\n> 思路：考虑到三次异或后还是数字本身，所以不能像例2那样使用异或。根据**位运算**的思想，出现三次的数字每个比特位也出现了三次，如果将出现的次数相加的话，每一个比特位都可以被3整除。只出现一次的数字的每一个比特位出现的次数都是1，不能被3整除。\n\n```swift\nfunc findLostNum(nums: [UInt]) -> UInt {\n    // 长度为32的数组\n    var bitSum = [UInt](repeating: 0, count: 32)\n    // 遍历二进制表示的32个比特位\n    for i in 0..<32 {\n        var sum: UInt = 0\n        // 遍历数组，判断每个数的二进制表示，在第 i 位是否为1\n        for num in nums {\n            sum += (num >> i & 1)\n        }\n        // 保存所有数在第 i 位的总和\n        bitSum[i] = sum\n    }\n    var res: UInt = 0\n    for i in 0..<32 {\n        // 不能被3整除的比特位，表示只出现一次的那个数字在这个二进制位上为1\n        if (bitSum[i]%3 != 0) {\n            // 将res的第i位置为1\n            res += 1<<i\n        }\n    }\n    return res\n}\n\nprint(findLostNum(nums: [1,2,3,4,1,2,3,1,2,3]))\n// Prints 4\n```\n\n## 运算符的优先升级和结核性\n\n运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。\n\n结合性定义了具有相同优先级的运算符是如何结合（或关联）的——与左边结合为一组，还是与右边结合为一组。\n\n```swift\nlet c = 2 + 3 % 4 * 5\nprint(c)\n// Prints 17\n```\n\n`2 + 3 % 4 * 5` 等价于 `2 + ((3 % 4) * 5)`。\n\n### 运算符优先级 - 显示括号\n\nSwift 语言中逻辑运算符 `&&` 和 `||` 是做相关的，意味着多个逻辑运算符组合的表达式会首先计算最左边的子表达式。\n\n```swift\nlet lockA = true, lockB = false, lockC = false, lockD = false\n\nif (lockA && lockB || lockC || lockD) {\n    print(\"Welcome!\")\n} else {\n    print(\"ACCESS DENIED\")\n}\n// Prints \"ACCESS DENIED\"\n```\n\n等价于\n\n```swift\nif ((lockA && lockB) || lockC || lockD) {\n    print(\"Welcome!\")\n} else {\n    print(\"ACCESS DENIED\")\n}\n// Prints \"ACCESS DENIED\"\n```\n\n## 运算符重载\n\n类和结构体可以为现有的运算符提供自定义的实现，称为运算符重载。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedCector = vector + anotherVector\nprint(combinedCector)\n// prints Vector2D(x: 5.0, y: 5.0)\n```\n\n### 一元运算符重载\n\n类与结构体也能提供标准一元运算符的实现。要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static prefix func - (vector: Vector2D) -> Vector2D {\n        return Vector2D(x: -vector.x, y: -vector.y)\n    }\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\nlet alsoPositive = -negative\n\nprint(negative)\nprint(alsoPositive)\n// prints Vector2D(x: -3.0, y: -4.0)\n// prints Vector2D(x: 3.0, y: 4.0)\n```\n\n### 组合赋值运算符重载\n\n组合赋值运算符将赋值运算符（`=`）与其它运算符进行结合。\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nextension Vector2D {\n    // 把 left 设置成 inout 类型\n    static func += (left: inout Vector2D, right: Vector2D) {\n        left = left + right\n    }\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n\nprint(original)\n// Prints Vector2D(x: 4.0, y: 6.0)\n```\n\n因为 `left` 的值会在运算符函数内直接被修改，所以需要把 `left` 设置成 `inout` 类型。\n\n### 等价运算符重载\n\n自定义类和结构体不接收等价运算符的默认实现，也就是所谓的“等于”运算符（`==`）和“不等于”运算符（`!=`）。要使用等价运算符，需要提供一个“等于”运算符（类似中缀运算符`+`），并且遵循标准库 Equaltable 协议。\n\n```swift\nstruct Vector3D: Equatable {\n    var x = 0.0, y = 0.0, z = 0.0\n}\n\nlet vector01 = Vector3D(x: 2.0, y: 3.0, z: 4.0)\nlet vector02 = Vector3D(x: 2.0, y: 3.0, z: 4.0)\nif vector01 == vector02 {\n    print(\"vector01 == vector02\")\n}\n// Prints \"vector01 == vector02\"\n```\n\nswift 为一下自定义类型提供等价运算符合成实现：\n\n* 只拥有遵循 Equaltable 协议存储属性的结构体\n* 只拥有遵循 Equaltable 协议关联类型的枚举\n* 没有关联类型的枚举\n\n## 自定义运算符\n\n除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。自定义的运算符如果想在全局作用域内，可以使用 `operator` 关键字进行声明，同时还要指定 `prefix`、`infix` 或者 `postfix` 限定符。\n\n```swift\n// 全局作用域\nprefix operator +++\n\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\nextension Vector2D {\n    static func + (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y + right.y)\n    }\n}\n\nextension Vector2D {\n    static func += (left: inout Vector2D, right: Vector2D) {\n        left = left + right\n    }\n}\n\n// 自定义前缀翻倍运算符\nextension Vector2D {\n    static prefix func +++ (vector: inout Vector2D) -> Vector2D {\n        vector += vector\n        return vector\n    }\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)\nlet afterDoubling = +++toBeDoubled\n\nprint(afterDoubling)\n// Prints Vector2D(x: 2.0, y: 8.0)\n```\n\n### 自定义中缀运算符的优先级和结合性\n\n自定义的中缀（`infix`）运算符也可以指定优先级和结合性，每一个自定义的中缀运算符都属于一个优先级组，优先级组制定了自定义中缀运算符和其他中缀运算符的关系。\n\n* `AdditionPrecedence` 加法运算优先级组\n* `MultiplicationPrecedence` 乘法运算优先级组\n\n```swift\n// 自定义优先级组\nprecedencegroup MyPrecedence {\n    // 设置优先级组的计算方向为从左侧开始\n    associativity: left\n    // 设置优先级小于加法运算优先级组\n    lowerThan: AdditionPrecedence\n}\n```\n\n自定义中缀运算符 `+-`\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\n// 自定义运算符 +- 属于加法运算符组\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\n// 自定义运算符 *^ 属于乘法运算符组\ninfix operator *^: MultiplicationPrecedence\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 7.0, y: -51.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n\n自定义运算符 `+-` 属于加法运算符组，自定义运算符 \\*^ 属于乘法运算符组。因为乘法运算的优先级大于加法运算，所以运算符组 `+-` 的优先级小于运算符组 `\\*^` ，即 `\\*^` 先于 `+-` 运算：\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\n// 自定义运算符 +- 属于加法运算符组\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\ninfix operator\n// 自定义运算符 *^ 属于乘法运算符组\nprecedencegroup MyPrecedence {\n    // 设置优先级组的计算方向为从左侧开始\n    associativity: left\n    // 设置优先级小于加法运算优先级组\n    lowerThan: AdditionPrecedence\n}\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 7.0, y: -51.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n\n自定义运算符组 `MyPrecedence`，设置优先级低于加法运算组。即 `*^` 和 `+-` 的执行顺序按从左至右的顺序：\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n\ninfix operator +-: AdditionPrecedence\nextension Vector2D {\n    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x + right.x, y: left.y - right.y)\n    }\n}\n\n//infix operator *^: MultiplicationPrecedence\ninfix operator *^: MyPrecedence\nprecedencegroup MyPrecedence {\n    associativity: left\n    lowerThan: AdditionPrecedence\n}\n\nextension Vector2D {\n    static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {\n        return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y + right.y)\n    }\n}\n\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 7.0)\nlet plusMinusVector = firstVector +- secondVector\nlet thirdVector = Vector2D(x: 2.0, y: 2.0)\nlet resFirstVector = firstVector +- secondVector *^ thirdVector\nlet resSecondVector = (firstVector +- secondVector) *^ thirdVector\nprint(resFirstVector)\nprint(resSecondVector)\n// Prints Vector2D(x: 8.0, y: 29.0)\n// Prints Vector2D(x: 8.0, y: 29.0)\n```\n","slug":"Swift/运算符","published":1,"updated":"2023-08-22T09:52:14.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgul001qaq7kixhdysbr"},{"title":"iOS横竖屏","date":"2022-10-19T09:03:48.000Z","_content":"\n* UIDeviceOrientation\n\n* UIInterfaceOrientation\n\n* UIInterfaceOrientationMask\n\n* `- (BOOL)shouldAutorotate;`\n\n* `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n\n* `- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;`\n\n<!-- more -->\n\n## 基础概念\n\n* `UIDeviceOrientation`：设备朝向\n\n* `UIInterfaceOrientation`：页面内容朝向\n\n* `UIInterfaceOrientationMask`：页面支持的朝向\n\n### UIDeviceOrientation\n\n`UIDeviceOrientation` 表示设备朝向，可以通过该方法获取：\n\n```swift\n[[UIDevice currentDevice] orientation];\n```\n\n`UIDeviceOrientation` 的取值有：\n\n```swift\ntypedef NS_ENUM(NSInteger, UIDeviceOrientation) {\n    UIDeviceOrientationUnknown,             // 未知，启动时会出现\n    UIDeviceOrientationPortrait,            // Device oriented vertically, home button on the bottom\n    UIDeviceOrientationPortraitUpsideDown,  // Device oriented vertically, home button on the top\n    UIDeviceOrientationLandscapeLeft,       // Device oriented horizontally, home button on the right\n    UIDeviceOrientationLandscapeRight,      // Device oriented horizontally, home button on the left\n    UIDeviceOrientationFaceUp,              // Device oriented flat, face up\n    UIDeviceOrientationFaceDown             // Device oriented flat, face down\n} API_UNAVAILABLE(tvos);\n```\n\n### UIInterfaceOrientation\n\n`UIInterfaceOrientation` 表示页面内容朝向。\n\n⚠️注意：`UIInterfaceOrientation` 与 `UIDeviceOrientation` 的关系。不同枚举中的两个值可能相等：\n\n```swift\nUIInterfaceOrientationLandscapeLeft == UIDeviceOrientationLandscapeRight\n```\n\n这是因为向左旋转设备需要向右旋转内容。\n\n`UIInterfaceOrientation` 的取值有：\n\n```swift\n// Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa).\n// This is because rotating the device to the left requires rotating the content to the right.\ntypedef NS_ENUM(NSInteger, UIInterfaceOrientation) {\n    UIInterfaceOrientationUnknown            = UIDeviceOrientationUnknown,\n    UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,\n    UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,\n    UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,\n    UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft\n} API_UNAVAILABLE(tvos);\n```\n\n可以通过下面👇这个方法获取当前状态栏朝向：\n\n```swift\n[[UIApplication shareApplication] statusBarOrientation];\n```\n\n### UIInterfaceOrientationMask\n\n`UIInterfaceOrientationMask` 表示页面支持的朝向。\n\n`UIInterfaceOrientationMask` 的取值有：\n\n```swift\ntypedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {\n    UIInterfaceOrientationMaskPortrait = (1 << UIInterfaceOrientationPortrait),\n    UIInterfaceOrientationMaskLandscapeLeft = (1 << UIInterfaceOrientationLandscapeLeft),\n    UIInterfaceOrientationMaskLandscapeRight = (1 << UIInterfaceOrientationLandscapeRight),\n    UIInterfaceOrientationMaskPortraitUpsideDown = (1 << UIInterfaceOrientationPortraitUpsideDown),\n    UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),\n    UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),\n    UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),\n} API_UNAVAILABLE(tvos);\n```\n\n比如 `UIInterfaceOrientationMaskLandscape` 是由 `MaskLandscapeLeft` 和 `MaskLandscapeRight` 组成，是由页面内容朝向的二进制偏移组成，这样可以方便设备支持两个横屏方向。\n\n## 横竖屏之UIViewController相关方法\n\n* `- (BOOL)shouldAutorotate;`\n\n* `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n\n* `- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;`\n\n### shouldAutorotate\n\n```swift\n- (BOOL)shouldAutorotate;\n```\n\n用来返回页面是否支持自动旋转，或者说是否跟随屏幕方向进行旋转。\n\n* 默认值是 `YES`，表示当前页面允许跟随设备旋转而自动旋转。\n\n* iOS 16 相关改动：\n![Orientation01](iOS横竖屏/Orientation01.png)\n  `[UIViewController should Autorotate]` 已被弃用，不再受支持。`[UIViewController attmptRotationToDeviceOrientation]` 已被弃用，并替换为 `[UIViewController setNeedsUpdateOfSupportedInterfaceOrienttions]`。  \n\n  解决方法：依赖于 `shouldAutorotate` 的应用程序应使用支持的视图控制器 `InterfaceOrientations` 反映其首选项。**如果支持的方向更改**，请使用 `-[UIViewController setNeedsUpdateOfSupportedInterface]`\n\n### supportedInterfaceOrientations\n\n```swift\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations;\n```\n\n用来返回当前页面支持的页面朝向，可以返回四个朝向的任意组合。这个方法返回的前提是 `shouldAutorotate = YES`。\n\n### preferredInterfaceOrientationForPresentation\n\n```swift\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;\n```\n\n当页面被 **present** 出来的时候，返回该页面支持的朝向。可以返回四个朝向的任意组合。如果没有返回，则 **present** 时和原来页面的方向保持一致。\n\n## 横竖屏之APPDelegate相关方法\n\n* 方法一\n\n在 XCode 的工程设置的 `General` 里，设置 iPhone 和 iPad 的页面朝向支持。\n\n![Orientation02](iOS横竖屏/Orientation02.png)\n\n这种修改配置的方式其实就是修改 info.plist 文件，所以可以直接修改 info.plist 文件👇。\n\n* 方法二\n\n![Orientation01](iOS横竖屏/Orientation03.png)\n\n* 方法三  \n\n这个方法实现在 APPDelegate 里，**根据需要返回当前 window 是否支持横屏**，优先级最高：\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n该方法等效于 XCode 工程设置里的页面朝向支持，但是更灵活。\n\n📢注意：以下内容都是基于设置了 `UIInterfaceOrientationMaskAll` 的情况下实现的，如果有其它情况会单独作补充。\n\n## 自动旋转\n\n关闭方向锁定，让屏幕随重力感应旋转。\n\n* 自动旋转  \n  指的是旋转设备时，系统会触发界面的旋转。页面设置 `shouldAutorotate = true`，当设备旋转方向后，会通过 `-supportedInterfaceOrientations` 方法，获取页面支持的方向，并更改页面朝向。\n\n* 手动旋转  \n  也可以说成主动旋转，通过调用修改设备方向的 api 来修改设备当前的朝向。如 UIViewController 的 `+attemptRotationToDeviceOrientation`，UIDievice 的 `-setOrientation:` 方法。  \n  `+attemptRotationToDeviceOrientation` 是将界面朝向对齐设备朝向，是标准 api。  \n  `-setOrientation:` 是调整设备朝向，是私有 api。\n\n* iOS 16 相关改动：\n![Orientation01](iOS横竖屏/Orientation01.png)\n `[UIViewController should Autorotate]` 已被弃用，不再受支持。`[UIViewController attmptRotationToDeviceOrientation]` 已被弃用，并替换为 `[UIViewController setNeedsUpdateOfSupportedInterfaceOrienttions]`。  \n\n  解决方法：依赖于 `shouldAutorotate` 的应用程序应使用支持的视图控制器 `InterfaceOrientations` 反映其首选项。**如果支持的方向更改**，请使用 `-[UIViewController setNeedsUpdateOfSupportedInterface]`\n\n### App 自动旋转触发流程\n\n当手机的重力感应打开的时候，旋转手机，系统会触发 UIDeviceOrientationDidChangeNotification 事件，同时读取 plist 文件中的支持朝向。\n\n如果在 AppDelegate 中重写了下面这个方法👇，那么会以重写这个方法的返回值为准。\n\n```swift\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window\n```\n\n然后会判断当前的 ViewController 是否为 AppDelegate 的 rootvc 或者 modal 的 vc，如果是则会读取该页面的以下三个属性：\n\n```swift\n// 是否支持自动旋转\n- (BOOL)shouldAutorotate;\n\n// 初始展示方向，只有modal模式下才会调用\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;\n\n// 该页面支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations;\n```\n\n系统会根据 `-preferredInterfaceOrientationForPresentation` 方法返回的结果展示初始视图。  \n\n📢注意：在 `- (BOOL)shouldAutorotate;` 返回 `YES` 时，系统会调用该页面的 `supportedInterfaceOrientations` 方法获取页面朝向。该页面的 `supportedInterfaceOrientations` 返回值，必须是 plist 文件中 `supportedInterfaceOrientations` 包含的值。否则会 crash。\n\n### App 自动旋转实现\n\n#### 场景一\n\n此处需要横屏的 ViewController 是 AppDelegate 的 rootVC，或者是 modal 下的 vc。\n\n1. 先配置app支持的旋转方向，可以在 XCode 工程设置、info.plist 文件和 AppDelegate 三中方法中的任意一种。\n2. 指定横屏页面重写相关方法；\n  \n```swift\n// ViewController.m 文件\n\n// 是否支持自动旋转\n- (BOOL)shouldAutorotate{\n    return YES;\n}\n\n// 初始的显示方向\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return UIInterfaceOrientationLandscapeRight;\n}\n\n// 支持的旋转方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return UIInterfaceOrientationMaskAll; // 此处的返回值应该和infoplist文件中的值有交集，否则进入页面立马就会crash\n}\n```\n\n#### 场景二\n\n此处需要横屏的 ViewController 是被 push 过来的（非rootvc和modal下的vc）。\n\n1. 先配置app支持的旋转方向，可以在 XCode 工程设置、info.plist 文件和 AppDelegate 三中方法中的任意一种。\n2. 指定横屏页面重写相关方法；\n\n```swift\n// ViewController\n\n- (BOOL)shouldAutorotate{\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return UIInterfaceOrientationMaskAll; // 此处的返回值应该和infoplist文件中的值有交集，否则进入页面立马就会crash\n}\n```\n\n```swift\n// UITabBarController\n\n- (BOOL)shouldAutorotate {\n    return [self.selectedViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// UINavigationController\n\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n```\n\n📢注意：通过 present 方式进入的页面会调用 `preferredInterfaceOrientationForPresentation` 方法，确定初始显示方向。通过 push 的方式进入的页面，不会再加载页面时调用 `preferredInterfaceOrientationForPresentation` 方法。无法实现通过 push 方式，直接进入一个横屏页面，只有触发旋转才会横屏展示，想要实现一进入页面就展示横屏，只能以 present（modal） 的形式进入。\n\n#### 场景三\n\n除了重写系统方法外，还可以通过 transform 的方式实现自动旋转。\n\n1. 监听 UIDeviceOrientationDidChangeNotification 在监听回调中获取设备方向；\n2. 根据设备方向对 view 做相应的 transform 操作；\n\n## 强制横屏\n\n强制横屏的实现方案：\n\n1. 重写系统旋转方法；\n2. 视图适配：通过 transform 修改 layer，从而在视图上实现横屏，但是此时屏幕宽度、状态栏、安全距离等都保留竖屏状态，这种方式仅仅适用于横屏弹窗等部分场景。\n\n### 竖屏页面 present 横屏页面\n\n1. 设置 `secondViewController` 的 `modalPresentationStyle` 为 `UIModalPresentationFullScreen`；\n2. 在 `secondViewController.m` 文件，实现 `preferredInterfaceOrientationForPresentation` 方法，返回 `UIInterfaceOrientationLandscapeRight`;\n\n```swift\n// firstViewController.m 文件\n\n- (void)present {\n    UIViewController *secondViewController = [[VerticallyViewController alloc] init];\n    secondViewController.modalPresentationStyle = UIModalPresentationFullScreen;\n    [self presentViewController:secondViewController animated:YES completion:nil];\n}\n```\n\n```swift\n// secondViewController.m 文件\n\n- (BOOL)shouldAutorotate{\n    return NO;//关闭自动旋转\n}\n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return UIInterfaceOrientationLandscapeRight;//初始化朝右边显示\n}\n```\n\n补充：上面的代码有可能不生效，生效的前提是设置了 App 支持横屏方向，上面已经提到过，可以在 Xcode 里设置，也可以用代码设置👇\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n如果这个方法返回的是 `[self.window.rootViewController supportedInterfaceOrientations]`，则上面的“竖屏 present 横屏”方案不生效。\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return [self.window.rootViewController supportedInterfaceOrientations];\n}\n```\n\n解决方案：在通用工具的单例里添加“是否支持横屏”的属性，在需要 present 横屏前设置为 true，不 dismiss 前设置为 false，并在 AppDelegate.m 文件的方法里返回对应方向👇。\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    // present 前 true，dismiss 前 false\n    if ([CommonShared share].isSupportLandscapeRight) {\n        return UIInterfaceOrientationLandscapeRight\n    }\n    return [self.window.rootViewController supportedInterfaceOrientations];\n}\n```\n\n🤔思考：  \n\n1. 如何实现横屏转竖屏？\n2. 如何实现自定义旋转效果？\n3. 横屏返回竖屏需要怎么处理？\n\n📢注意：  \n\n1. 强制某一方向横屏只能在 modal 模式下实现，push 模式下不行。\n2. 通过 runtime 调用 setOrientation 的形式是不可行的，该方法仅支持 iOS6 以下的系统：\n\n```swift\n//以下仅仅使用ios6以下的设备！\n\nif ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n    SEL selector = NSSelectorFromString(@\"setOrientation:\");\n    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n    [invocation setSelector:selector];\n    [invocation setTarget:[UIDevice currentDevice]];\n    int val = UIInterfaceOrientationLandscapeRight;\n    [invocation setArgument:&val atIndex:2];\n    [invocation invoke];\n}\n```\n\n### 竖屏页面 push 横屏页面\n\n#### 方法一\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if ([self.navigationVC.topViewController isKindOfClass:secondViewController.class]) {\n        return UIInterfaceOrientationMaskLandscapeRight;\n    }\n    else {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n}\n```\n\n```swift\n// secondViewController.m 文件\n- (void)viewDidLoad {\n    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:@selector(setOrientation:)]];\n    invocation.selector = NSSelectorFromString(@\"setOrientation:\");\n    invocation.target = [UIDevice currentDevice];\n    int initOrientation = UIDeviceOrientationLandscapeRight;\n    [invocation setArgument:&initOrientation atIndex:2];\n    [invocation invoke];\n}\n```\n\n🤔思考：\n\n1. 这里为什么没有用到 `UIViewController` 的三个方法？\n2. 在 viewDidLoad 方法内部调用的旋转方法是什么意思？\n\n#### 方法二\n\n1. `UINavigationController` 内部实现相关方法，包括 `- (BOOL)shouldAutorotate;` 和 `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n2. `secondViewController` 内部实现相关方法，包括 `- (BOOL)shouldAutorotate;` 和 `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n3. `secondViewController` 主动旋转设备方向。\n\n```swift\n// UITabbarViewController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return [self.selectedViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// UINavigationController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// secondViewController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskLandscape; //⚠️此处的返回值应该和infoplist文件中的值有交集，否则旋转手机就会触发调用该方法，然后crash\n}\n\n- (void)viewDidLoad {\n    if ([[UIDevice currentDevice] orientation] == UIDeviceOrientationLandscapeRight) {\n        [self swichToNewOrientation:UIDeviceOrientationLandscapeRight];\n    } else {\n        [self swichToNewOrientation:UIDeviceOrientationLandscapeLeft];\n    }\n}\n\n/// 调整设备方向\n- (void)swichToNewOrientation:(UIDeviceOrientation)orientation {\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationUnknown) forKey:@\"orientation\"];\n    [[UIDevice currentDevice] setValue:@(orientation) forKey:@\"orientation\"];\n}\n```\n\n### view 的 transform\n\n该方法是将 view 进行一个90度的旋转，不改变系统的显示方向。\n\n```swift\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    //改变当前视图bounds的宽高\n    self.view.bounds = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.height, [UIScreen mainScreen].bounds.size.width);\n    //对当前视图做90度旋转\n    [UIView animateWithDuration:0.2 animations:^{\n        self.view.transform = CGAffineTransformMakeRotation(M_PI_2);\n    }];\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n\n    //隐藏状态栏\n    [[UIApplication sharedApplication] setStatusBarHidden:YES];\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n\n    //恢复状态栏\n    [[UIApplication sharedApplication] setStatusBarHidden:NO];\n}\n```\n\n📢注意：在全面屏手机中，可以通过 `self.view.safeAreaInsets` 获取到安全区域。竖屏状态下获取安全区域是 `(40, 0, 34, 0)`，横屏状态下获取安全区域是 `(0, 44, 0, 34)`。因为通过 transform 方式旋转 view，系统方向还是竖屏状态，所以获取到的安全区域不对。\n\n自定义根据指定方向获取安全区域的方法：\n\n```swift\n/**\n 获取屏幕的安全区域\n @param orientation 显示方向（是显示方向，非设备方向）\n */\n+ (CGRect)getSafeAreaWithOrientation:(UIInterfaceOrientation)orientation {\n    CGRect safeRect = kScreen_Bounds;\n    UIEdgeInsets insets = UIEdgeInsetsZero;\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000\n    //xcode baseSDK为11.0或者以上\n    if (@available(iOS 11.0, *)) {\n        insets = [UIApplication sharedApplication].keyWindow.safeAreaInsets;\n    }\n#endif\n    if (orientation == UIInterfaceOrientationLandscapeLeft) {\n        safeRect = CGRectMake(safeRect.origin.x, safeRect.origin.y, safeRect.size.height, safeRect.size.width);\n        insets = UIEdgeInsetsMake(insets.left, insets.bottom, insets.right, insets.top);\n    } else if (orientation == UIInterfaceOrientationLandscapeRight){\n        safeRect = CGRectMake(safeRect.origin.x, safeRect.origin.y, safeRect.size.height, safeRect.size.width);\n        insets = UIEdgeInsetsMake(insets.right, insets.top, insets.left, insets.bottom);\n    } else if (orientation == UIInterfaceOrientationPortraitUpsideDown){\n        insets = UIEdgeInsetsMake(insets.bottom, insets.right, insets.top, insets.left);\n    }\n    safeRect = UIEdgeInsetsInsetRect(safeRect, insets);\n    return safeRect;\n}\n```\n\n### AFPlayer\n\n关于 transform 的使用，[ZFPlayer](https://github.com/renzifeng/ZFPlayer) 中有相关应用。\n\nAFPlayer 支持小屏竖屏、大屏横屏状态，分别针对iOS15和iOS16做了对应的横屏方案。不支持小屏横屏状态。\n\niOS15\n\n小屏 -> 大屏\n\n1. 自定义 `ZFLandscapeWindow`，设置更控制器 `ZFLandscapeViewController_iOS15`，控制器中自定义一个 `playerSuperview`（`UIView`）；\n2. 全屏时，修改设备方向为横向；\n3. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `playerSuperview` 上，设置 playerSuperview、播放器 的大小为横屏大小；\n\n大屏 -> 小屏\n\n1. 修改设备方向为竖向；\n2. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `containerView` 上，`containerView` 是开发者创建播放器时的容器view，设置播放器的大小。\n\niOS 16\n\n小屏 -> 大屏\n\n1. 自定义 `ZFLandscapeWindow`，设置更控制器 `ZFLandscapeViewController`；\n2. 全屏时，修改设备方向为横向；\n3. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `ZFLandscapeWindow.view` 上\n4. 旋转播放器为横向，设置播放器坐标为对应 Window 上的frame\n5. 调用`setNeedsUpdateOfSupportedInterfaceOrientations`重新设置内容方向，将播放器添加到 `ZFLandscapeViewController.view` 上，设置播放器大小为横屏大小\n\n大屏 -> 小屏\n\n1. 修改设备方向为竖向；\n2. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `ZFLandscapeWindow.view` 上\n3. 旋转播放器为横向，设置播放器坐标为对应 Window 上的frame\n4. 将播放器添加到 `containerView` 上，`containerView` 是开发者创建播放器时的容器view，设置播放器的大小。\n\n## 横竖屏切换机制分析\n\n1. 工程配置文件没有设置支持横屏，为什么可以 push 出横屏页面？\n2. 工程配置、`APPDelegate` 和 `UIViewController`，在横竖屏切换过程的关系是什么？\n3. 自动旋转和手动旋转有什么区别？\n\n### 系统如何知道 APP 对页面朝向的支持\n\n* APP 启动前\n  在 APP 启动前进程还未加载，代码无法运行，系统无法通过 `AppDelegate` 或者 `UIViewController` 这种代码的方式获取横竖屏的配置。所以，在这种情况下，工程配置中的 plist 文件中的横竖屏配置，可以帮助系统识别应该以什么样的朝向启动 APP。  \n  在 plist 文件中增加横屏的支持，优点是开屏能够支持横屏，这样界面展示更加顺滑。缺点是开屏支持了横屏，导致启动的时候是横屏，但是 `[UIScreen mainScreen]` 是横屏的大小，很多业务代码在通过 `[UIScreen mainScreen]` 方法去获取屏幕的宽高时，会取到错误的值。\n\n* APP 运行时  \n  当 APP 进程加载完成，此时系统可以通过运行时询问的方式，来动态获取不同时机的界面朝向。  \n  此时 APPDelegate 控制的事 UIWindow 层面的朝向，UIViewController 控制的是 ViewController 层级的朝向。需要注意的是，当我们返回 UIViewController 的朝向时，还要考虑父容器的朝向。通常一个 App 的界面层级是 UIWindow → RootViewController（父） → ViewController（子）。只在 UIWindow 返回界面朝向也是允许的，如上面的**竖屏页面 push 横屏页面**👆。\n\n### 朝向冲突\n\n在每次界面切换的时候，系统都会回调新的界面朝向，最终结果取 UIWindow 朝向、RootViewController 朝向、ViewController 朝向**三者的与**值。\n\n如果 UIWindow 返回竖屏，RootViewController 和 ViewController 返回横屏，横屏不会生效。同样的，如果 UIWindow 返回横屏，RootViewController 和 ViewController 返回竖屏，竖屏不会生效。\n\n朝向优先级：**UIWindow 朝向 > RootViewController 朝向 > ViewController 朝向**。\n\n在界面切换的过程中，如果没有返回朝向值或朝向值未确定，系统更倾向于保持当前朝向不变。\n\n## 横竖屏切换通知\n\nNSNotification通知\n\n```swift\n[[NSNotificationCenter defaultCenter] addObserverForName:UIDeviceOrientationDidChangeNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) {\n    NSLog(@\"NSNotification:%@, orientation:%d\", note.userInfo, [(UIDevice *)note.object orientation]);\n}];\n```\n\nUIViewController回调\n\n```swift\n- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator API_AVAILABLE(ios(8.0));\n```\n\n参考博文：  \n[iOS横屏的深入研究](https://www.jianshu.com/p/7108620fee35)\n[iOS横竖屏切换](https://www.jianshu.com/p/9eb26580950e)\n","source":"_posts/iOS/iOS横竖屏.md","raw":"---\ntitle: iOS横竖屏\ndate: 2022-10-19 17:03:48\ntags: OC\n---\n\n* UIDeviceOrientation\n\n* UIInterfaceOrientation\n\n* UIInterfaceOrientationMask\n\n* `- (BOOL)shouldAutorotate;`\n\n* `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n\n* `- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;`\n\n<!-- more -->\n\n## 基础概念\n\n* `UIDeviceOrientation`：设备朝向\n\n* `UIInterfaceOrientation`：页面内容朝向\n\n* `UIInterfaceOrientationMask`：页面支持的朝向\n\n### UIDeviceOrientation\n\n`UIDeviceOrientation` 表示设备朝向，可以通过该方法获取：\n\n```swift\n[[UIDevice currentDevice] orientation];\n```\n\n`UIDeviceOrientation` 的取值有：\n\n```swift\ntypedef NS_ENUM(NSInteger, UIDeviceOrientation) {\n    UIDeviceOrientationUnknown,             // 未知，启动时会出现\n    UIDeviceOrientationPortrait,            // Device oriented vertically, home button on the bottom\n    UIDeviceOrientationPortraitUpsideDown,  // Device oriented vertically, home button on the top\n    UIDeviceOrientationLandscapeLeft,       // Device oriented horizontally, home button on the right\n    UIDeviceOrientationLandscapeRight,      // Device oriented horizontally, home button on the left\n    UIDeviceOrientationFaceUp,              // Device oriented flat, face up\n    UIDeviceOrientationFaceDown             // Device oriented flat, face down\n} API_UNAVAILABLE(tvos);\n```\n\n### UIInterfaceOrientation\n\n`UIInterfaceOrientation` 表示页面内容朝向。\n\n⚠️注意：`UIInterfaceOrientation` 与 `UIDeviceOrientation` 的关系。不同枚举中的两个值可能相等：\n\n```swift\nUIInterfaceOrientationLandscapeLeft == UIDeviceOrientationLandscapeRight\n```\n\n这是因为向左旋转设备需要向右旋转内容。\n\n`UIInterfaceOrientation` 的取值有：\n\n```swift\n// Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa).\n// This is because rotating the device to the left requires rotating the content to the right.\ntypedef NS_ENUM(NSInteger, UIInterfaceOrientation) {\n    UIInterfaceOrientationUnknown            = UIDeviceOrientationUnknown,\n    UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,\n    UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,\n    UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,\n    UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft\n} API_UNAVAILABLE(tvos);\n```\n\n可以通过下面👇这个方法获取当前状态栏朝向：\n\n```swift\n[[UIApplication shareApplication] statusBarOrientation];\n```\n\n### UIInterfaceOrientationMask\n\n`UIInterfaceOrientationMask` 表示页面支持的朝向。\n\n`UIInterfaceOrientationMask` 的取值有：\n\n```swift\ntypedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {\n    UIInterfaceOrientationMaskPortrait = (1 << UIInterfaceOrientationPortrait),\n    UIInterfaceOrientationMaskLandscapeLeft = (1 << UIInterfaceOrientationLandscapeLeft),\n    UIInterfaceOrientationMaskLandscapeRight = (1 << UIInterfaceOrientationLandscapeRight),\n    UIInterfaceOrientationMaskPortraitUpsideDown = (1 << UIInterfaceOrientationPortraitUpsideDown),\n    UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),\n    UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),\n    UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),\n} API_UNAVAILABLE(tvos);\n```\n\n比如 `UIInterfaceOrientationMaskLandscape` 是由 `MaskLandscapeLeft` 和 `MaskLandscapeRight` 组成，是由页面内容朝向的二进制偏移组成，这样可以方便设备支持两个横屏方向。\n\n## 横竖屏之UIViewController相关方法\n\n* `- (BOOL)shouldAutorotate;`\n\n* `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n\n* `- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;`\n\n### shouldAutorotate\n\n```swift\n- (BOOL)shouldAutorotate;\n```\n\n用来返回页面是否支持自动旋转，或者说是否跟随屏幕方向进行旋转。\n\n* 默认值是 `YES`，表示当前页面允许跟随设备旋转而自动旋转。\n\n* iOS 16 相关改动：\n![Orientation01](iOS横竖屏/Orientation01.png)\n  `[UIViewController should Autorotate]` 已被弃用，不再受支持。`[UIViewController attmptRotationToDeviceOrientation]` 已被弃用，并替换为 `[UIViewController setNeedsUpdateOfSupportedInterfaceOrienttions]`。  \n\n  解决方法：依赖于 `shouldAutorotate` 的应用程序应使用支持的视图控制器 `InterfaceOrientations` 反映其首选项。**如果支持的方向更改**，请使用 `-[UIViewController setNeedsUpdateOfSupportedInterface]`\n\n### supportedInterfaceOrientations\n\n```swift\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations;\n```\n\n用来返回当前页面支持的页面朝向，可以返回四个朝向的任意组合。这个方法返回的前提是 `shouldAutorotate = YES`。\n\n### preferredInterfaceOrientationForPresentation\n\n```swift\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;\n```\n\n当页面被 **present** 出来的时候，返回该页面支持的朝向。可以返回四个朝向的任意组合。如果没有返回，则 **present** 时和原来页面的方向保持一致。\n\n## 横竖屏之APPDelegate相关方法\n\n* 方法一\n\n在 XCode 的工程设置的 `General` 里，设置 iPhone 和 iPad 的页面朝向支持。\n\n![Orientation02](iOS横竖屏/Orientation02.png)\n\n这种修改配置的方式其实就是修改 info.plist 文件，所以可以直接修改 info.plist 文件👇。\n\n* 方法二\n\n![Orientation01](iOS横竖屏/Orientation03.png)\n\n* 方法三  \n\n这个方法实现在 APPDelegate 里，**根据需要返回当前 window 是否支持横屏**，优先级最高：\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n该方法等效于 XCode 工程设置里的页面朝向支持，但是更灵活。\n\n📢注意：以下内容都是基于设置了 `UIInterfaceOrientationMaskAll` 的情况下实现的，如果有其它情况会单独作补充。\n\n## 自动旋转\n\n关闭方向锁定，让屏幕随重力感应旋转。\n\n* 自动旋转  \n  指的是旋转设备时，系统会触发界面的旋转。页面设置 `shouldAutorotate = true`，当设备旋转方向后，会通过 `-supportedInterfaceOrientations` 方法，获取页面支持的方向，并更改页面朝向。\n\n* 手动旋转  \n  也可以说成主动旋转，通过调用修改设备方向的 api 来修改设备当前的朝向。如 UIViewController 的 `+attemptRotationToDeviceOrientation`，UIDievice 的 `-setOrientation:` 方法。  \n  `+attemptRotationToDeviceOrientation` 是将界面朝向对齐设备朝向，是标准 api。  \n  `-setOrientation:` 是调整设备朝向，是私有 api。\n\n* iOS 16 相关改动：\n![Orientation01](iOS横竖屏/Orientation01.png)\n `[UIViewController should Autorotate]` 已被弃用，不再受支持。`[UIViewController attmptRotationToDeviceOrientation]` 已被弃用，并替换为 `[UIViewController setNeedsUpdateOfSupportedInterfaceOrienttions]`。  \n\n  解决方法：依赖于 `shouldAutorotate` 的应用程序应使用支持的视图控制器 `InterfaceOrientations` 反映其首选项。**如果支持的方向更改**，请使用 `-[UIViewController setNeedsUpdateOfSupportedInterface]`\n\n### App 自动旋转触发流程\n\n当手机的重力感应打开的时候，旋转手机，系统会触发 UIDeviceOrientationDidChangeNotification 事件，同时读取 plist 文件中的支持朝向。\n\n如果在 AppDelegate 中重写了下面这个方法👇，那么会以重写这个方法的返回值为准。\n\n```swift\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window\n```\n\n然后会判断当前的 ViewController 是否为 AppDelegate 的 rootvc 或者 modal 的 vc，如果是则会读取该页面的以下三个属性：\n\n```swift\n// 是否支持自动旋转\n- (BOOL)shouldAutorotate;\n\n// 初始展示方向，只有modal模式下才会调用\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;\n\n// 该页面支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations;\n```\n\n系统会根据 `-preferredInterfaceOrientationForPresentation` 方法返回的结果展示初始视图。  \n\n📢注意：在 `- (BOOL)shouldAutorotate;` 返回 `YES` 时，系统会调用该页面的 `supportedInterfaceOrientations` 方法获取页面朝向。该页面的 `supportedInterfaceOrientations` 返回值，必须是 plist 文件中 `supportedInterfaceOrientations` 包含的值。否则会 crash。\n\n### App 自动旋转实现\n\n#### 场景一\n\n此处需要横屏的 ViewController 是 AppDelegate 的 rootVC，或者是 modal 下的 vc。\n\n1. 先配置app支持的旋转方向，可以在 XCode 工程设置、info.plist 文件和 AppDelegate 三中方法中的任意一种。\n2. 指定横屏页面重写相关方法；\n  \n```swift\n// ViewController.m 文件\n\n// 是否支持自动旋转\n- (BOOL)shouldAutorotate{\n    return YES;\n}\n\n// 初始的显示方向\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return UIInterfaceOrientationLandscapeRight;\n}\n\n// 支持的旋转方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return UIInterfaceOrientationMaskAll; // 此处的返回值应该和infoplist文件中的值有交集，否则进入页面立马就会crash\n}\n```\n\n#### 场景二\n\n此处需要横屏的 ViewController 是被 push 过来的（非rootvc和modal下的vc）。\n\n1. 先配置app支持的旋转方向，可以在 XCode 工程设置、info.plist 文件和 AppDelegate 三中方法中的任意一种。\n2. 指定横屏页面重写相关方法；\n\n```swift\n// ViewController\n\n- (BOOL)shouldAutorotate{\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations{\n    return UIInterfaceOrientationMaskAll; // 此处的返回值应该和infoplist文件中的值有交集，否则进入页面立马就会crash\n}\n```\n\n```swift\n// UITabBarController\n\n- (BOOL)shouldAutorotate {\n    return [self.selectedViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// UINavigationController\n\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n```\n\n📢注意：通过 present 方式进入的页面会调用 `preferredInterfaceOrientationForPresentation` 方法，确定初始显示方向。通过 push 的方式进入的页面，不会再加载页面时调用 `preferredInterfaceOrientationForPresentation` 方法。无法实现通过 push 方式，直接进入一个横屏页面，只有触发旋转才会横屏展示，想要实现一进入页面就展示横屏，只能以 present（modal） 的形式进入。\n\n#### 场景三\n\n除了重写系统方法外，还可以通过 transform 的方式实现自动旋转。\n\n1. 监听 UIDeviceOrientationDidChangeNotification 在监听回调中获取设备方向；\n2. 根据设备方向对 view 做相应的 transform 操作；\n\n## 强制横屏\n\n强制横屏的实现方案：\n\n1. 重写系统旋转方法；\n2. 视图适配：通过 transform 修改 layer，从而在视图上实现横屏，但是此时屏幕宽度、状态栏、安全距离等都保留竖屏状态，这种方式仅仅适用于横屏弹窗等部分场景。\n\n### 竖屏页面 present 横屏页面\n\n1. 设置 `secondViewController` 的 `modalPresentationStyle` 为 `UIModalPresentationFullScreen`；\n2. 在 `secondViewController.m` 文件，实现 `preferredInterfaceOrientationForPresentation` 方法，返回 `UIInterfaceOrientationLandscapeRight`;\n\n```swift\n// firstViewController.m 文件\n\n- (void)present {\n    UIViewController *secondViewController = [[VerticallyViewController alloc] init];\n    secondViewController.modalPresentationStyle = UIModalPresentationFullScreen;\n    [self presentViewController:secondViewController animated:YES completion:nil];\n}\n```\n\n```swift\n// secondViewController.m 文件\n\n- (BOOL)shouldAutorotate{\n    return NO;//关闭自动旋转\n}\n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{\n    return UIInterfaceOrientationLandscapeRight;//初始化朝右边显示\n}\n```\n\n补充：上面的代码有可能不生效，生效的前提是设置了 App 支持横屏方向，上面已经提到过，可以在 Xcode 里设置，也可以用代码设置👇\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n如果这个方法返回的是 `[self.window.rootViewController supportedInterfaceOrientations]`，则上面的“竖屏 present 横屏”方案不生效。\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    return [self.window.rootViewController supportedInterfaceOrientations];\n}\n```\n\n解决方案：在通用工具的单例里添加“是否支持横屏”的属性，在需要 present 横屏前设置为 true，不 dismiss 前设置为 false，并在 AppDelegate.m 文件的方法里返回对应方向👇。\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    // present 前 true，dismiss 前 false\n    if ([CommonShared share].isSupportLandscapeRight) {\n        return UIInterfaceOrientationLandscapeRight\n    }\n    return [self.window.rootViewController supportedInterfaceOrientations];\n}\n```\n\n🤔思考：  \n\n1. 如何实现横屏转竖屏？\n2. 如何实现自定义旋转效果？\n3. 横屏返回竖屏需要怎么处理？\n\n📢注意：  \n\n1. 强制某一方向横屏只能在 modal 模式下实现，push 模式下不行。\n2. 通过 runtime 调用 setOrientation 的形式是不可行的，该方法仅支持 iOS6 以下的系统：\n\n```swift\n//以下仅仅使用ios6以下的设备！\n\nif ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {\n    SEL selector = NSSelectorFromString(@\"setOrientation:\");\n    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];\n    [invocation setSelector:selector];\n    [invocation setTarget:[UIDevice currentDevice]];\n    int val = UIInterfaceOrientationLandscapeRight;\n    [invocation setArgument:&val atIndex:2];\n    [invocation invoke];\n}\n```\n\n### 竖屏页面 push 横屏页面\n\n#### 方法一\n\n```swift\n// AppDelegate.m 文件\n\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if ([self.navigationVC.topViewController isKindOfClass:secondViewController.class]) {\n        return UIInterfaceOrientationMaskLandscapeRight;\n    }\n    else {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n}\n```\n\n```swift\n// secondViewController.m 文件\n- (void)viewDidLoad {\n    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:@selector(setOrientation:)]];\n    invocation.selector = NSSelectorFromString(@\"setOrientation:\");\n    invocation.target = [UIDevice currentDevice];\n    int initOrientation = UIDeviceOrientationLandscapeRight;\n    [invocation setArgument:&initOrientation atIndex:2];\n    [invocation invoke];\n}\n```\n\n🤔思考：\n\n1. 这里为什么没有用到 `UIViewController` 的三个方法？\n2. 在 viewDidLoad 方法内部调用的旋转方法是什么意思？\n\n#### 方法二\n\n1. `UINavigationController` 内部实现相关方法，包括 `- (BOOL)shouldAutorotate;` 和 `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n2. `secondViewController` 内部实现相关方法，包括 `- (BOOL)shouldAutorotate;` 和 `- (UIInterfaceOrientationMask)supportedInterfaceOrientations;`\n3. `secondViewController` 主动旋转设备方向。\n\n```swift\n// UITabbarViewController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return [self.selectedViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.selectedViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// UINavigationController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return [self.topViewController shouldAutorotate];\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return [self.topViewController supportedInterfaceOrientations];\n}\n```\n\n```swift\n// secondViewController.m 文件\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskLandscape; //⚠️此处的返回值应该和infoplist文件中的值有交集，否则旋转手机就会触发调用该方法，然后crash\n}\n\n- (void)viewDidLoad {\n    if ([[UIDevice currentDevice] orientation] == UIDeviceOrientationLandscapeRight) {\n        [self swichToNewOrientation:UIDeviceOrientationLandscapeRight];\n    } else {\n        [self swichToNewOrientation:UIDeviceOrientationLandscapeLeft];\n    }\n}\n\n/// 调整设备方向\n- (void)swichToNewOrientation:(UIDeviceOrientation)orientation {\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationUnknown) forKey:@\"orientation\"];\n    [[UIDevice currentDevice] setValue:@(orientation) forKey:@\"orientation\"];\n}\n```\n\n### view 的 transform\n\n该方法是将 view 进行一个90度的旋转，不改变系统的显示方向。\n\n```swift\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    //改变当前视图bounds的宽高\n    self.view.bounds = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.height, [UIScreen mainScreen].bounds.size.width);\n    //对当前视图做90度旋转\n    [UIView animateWithDuration:0.2 animations:^{\n        self.view.transform = CGAffineTransformMakeRotation(M_PI_2);\n    }];\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n\n    //隐藏状态栏\n    [[UIApplication sharedApplication] setStatusBarHidden:YES];\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n\n    //恢复状态栏\n    [[UIApplication sharedApplication] setStatusBarHidden:NO];\n}\n```\n\n📢注意：在全面屏手机中，可以通过 `self.view.safeAreaInsets` 获取到安全区域。竖屏状态下获取安全区域是 `(40, 0, 34, 0)`，横屏状态下获取安全区域是 `(0, 44, 0, 34)`。因为通过 transform 方式旋转 view，系统方向还是竖屏状态，所以获取到的安全区域不对。\n\n自定义根据指定方向获取安全区域的方法：\n\n```swift\n/**\n 获取屏幕的安全区域\n @param orientation 显示方向（是显示方向，非设备方向）\n */\n+ (CGRect)getSafeAreaWithOrientation:(UIInterfaceOrientation)orientation {\n    CGRect safeRect = kScreen_Bounds;\n    UIEdgeInsets insets = UIEdgeInsetsZero;\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000\n    //xcode baseSDK为11.0或者以上\n    if (@available(iOS 11.0, *)) {\n        insets = [UIApplication sharedApplication].keyWindow.safeAreaInsets;\n    }\n#endif\n    if (orientation == UIInterfaceOrientationLandscapeLeft) {\n        safeRect = CGRectMake(safeRect.origin.x, safeRect.origin.y, safeRect.size.height, safeRect.size.width);\n        insets = UIEdgeInsetsMake(insets.left, insets.bottom, insets.right, insets.top);\n    } else if (orientation == UIInterfaceOrientationLandscapeRight){\n        safeRect = CGRectMake(safeRect.origin.x, safeRect.origin.y, safeRect.size.height, safeRect.size.width);\n        insets = UIEdgeInsetsMake(insets.right, insets.top, insets.left, insets.bottom);\n    } else if (orientation == UIInterfaceOrientationPortraitUpsideDown){\n        insets = UIEdgeInsetsMake(insets.bottom, insets.right, insets.top, insets.left);\n    }\n    safeRect = UIEdgeInsetsInsetRect(safeRect, insets);\n    return safeRect;\n}\n```\n\n### AFPlayer\n\n关于 transform 的使用，[ZFPlayer](https://github.com/renzifeng/ZFPlayer) 中有相关应用。\n\nAFPlayer 支持小屏竖屏、大屏横屏状态，分别针对iOS15和iOS16做了对应的横屏方案。不支持小屏横屏状态。\n\niOS15\n\n小屏 -> 大屏\n\n1. 自定义 `ZFLandscapeWindow`，设置更控制器 `ZFLandscapeViewController_iOS15`，控制器中自定义一个 `playerSuperview`（`UIView`）；\n2. 全屏时，修改设备方向为横向；\n3. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `playerSuperview` 上，设置 playerSuperview、播放器 的大小为横屏大小；\n\n大屏 -> 小屏\n\n1. 修改设备方向为竖向；\n2. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `containerView` 上，`containerView` 是开发者创建播放器时的容器view，设置播放器的大小。\n\niOS 16\n\n小屏 -> 大屏\n\n1. 自定义 `ZFLandscapeWindow`，设置更控制器 `ZFLandscapeViewController`；\n2. 全屏时，修改设备方向为横向；\n3. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `ZFLandscapeWindow.view` 上\n4. 旋转播放器为横向，设置播放器坐标为对应 Window 上的frame\n5. 调用`setNeedsUpdateOfSupportedInterfaceOrientations`重新设置内容方向，将播放器添加到 `ZFLandscapeViewController.view` 上，设置播放器大小为横屏大小\n\n大屏 -> 小屏\n\n1. 修改设备方向为竖向；\n2. 设备方向改变时，触发`viewWillTransitionToSize:withTransitionCoordinator:`方法，将播放器添加到 `ZFLandscapeWindow.view` 上\n3. 旋转播放器为横向，设置播放器坐标为对应 Window 上的frame\n4. 将播放器添加到 `containerView` 上，`containerView` 是开发者创建播放器时的容器view，设置播放器的大小。\n\n## 横竖屏切换机制分析\n\n1. 工程配置文件没有设置支持横屏，为什么可以 push 出横屏页面？\n2. 工程配置、`APPDelegate` 和 `UIViewController`，在横竖屏切换过程的关系是什么？\n3. 自动旋转和手动旋转有什么区别？\n\n### 系统如何知道 APP 对页面朝向的支持\n\n* APP 启动前\n  在 APP 启动前进程还未加载，代码无法运行，系统无法通过 `AppDelegate` 或者 `UIViewController` 这种代码的方式获取横竖屏的配置。所以，在这种情况下，工程配置中的 plist 文件中的横竖屏配置，可以帮助系统识别应该以什么样的朝向启动 APP。  \n  在 plist 文件中增加横屏的支持，优点是开屏能够支持横屏，这样界面展示更加顺滑。缺点是开屏支持了横屏，导致启动的时候是横屏，但是 `[UIScreen mainScreen]` 是横屏的大小，很多业务代码在通过 `[UIScreen mainScreen]` 方法去获取屏幕的宽高时，会取到错误的值。\n\n* APP 运行时  \n  当 APP 进程加载完成，此时系统可以通过运行时询问的方式，来动态获取不同时机的界面朝向。  \n  此时 APPDelegate 控制的事 UIWindow 层面的朝向，UIViewController 控制的是 ViewController 层级的朝向。需要注意的是，当我们返回 UIViewController 的朝向时，还要考虑父容器的朝向。通常一个 App 的界面层级是 UIWindow → RootViewController（父） → ViewController（子）。只在 UIWindow 返回界面朝向也是允许的，如上面的**竖屏页面 push 横屏页面**👆。\n\n### 朝向冲突\n\n在每次界面切换的时候，系统都会回调新的界面朝向，最终结果取 UIWindow 朝向、RootViewController 朝向、ViewController 朝向**三者的与**值。\n\n如果 UIWindow 返回竖屏，RootViewController 和 ViewController 返回横屏，横屏不会生效。同样的，如果 UIWindow 返回横屏，RootViewController 和 ViewController 返回竖屏，竖屏不会生效。\n\n朝向优先级：**UIWindow 朝向 > RootViewController 朝向 > ViewController 朝向**。\n\n在界面切换的过程中，如果没有返回朝向值或朝向值未确定，系统更倾向于保持当前朝向不变。\n\n## 横竖屏切换通知\n\nNSNotification通知\n\n```swift\n[[NSNotificationCenter defaultCenter] addObserverForName:UIDeviceOrientationDidChangeNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) {\n    NSLog(@\"NSNotification:%@, orientation:%d\", note.userInfo, [(UIDevice *)note.object orientation]);\n}];\n```\n\nUIViewController回调\n\n```swift\n- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator API_AVAILABLE(ios(8.0));\n```\n\n参考博文：  \n[iOS横屏的深入研究](https://www.jianshu.com/p/7108620fee35)\n[iOS横竖屏切换](https://www.jianshu.com/p/9eb26580950e)\n","slug":"iOS/iOS横竖屏","published":1,"updated":"2024-02-02T11:04:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgum001saq7knkqledw2"},{"title":"集合类","date":"2023-01-15T09:11:07.000Z","_content":"\n* [数组](#数组)\n* [Set](#set)\n* [字典](#字典)\n\n<!-- more -->\n\n## 数组\n\n### 创建数组\n\n#### 数组字面量\n\n1、字面量创建：\n\n```swift\nlet array = [1, 2, 3, 4]\n```\n\n>数组字面量写法：一系列的值，用逗号分隔，用方括号括起来。\n\n2、字面量创建空数组：\n\n```swift\nvar array:[Int] = []\nvar array:[String] = []\n```\n\n>⚠️注意：**创建空数组必须携带类型信息**，否则编译不通过。\n![01](集合类/01.png)\n\n3、如果内容已经提供了类型信息，则可以通过空数组字面量来创建一个空数组：\n\n```swift\n// 因为内容提供了类型信息 [Int]\nvar array = [1, 2, 3, 4]\nprint(array)\n// 所以可以通过空数组字面量来创建一个空数组\narray = []\nprint(array)\n```\n\n>提供类型信息的情况包括：\n>\n>1. 作为函数的实际参数；\n>2. 已经分类了的变量或常量；\n\n#### 初始化器\n\n使用初始化器有两种方式：\n\n1、`[类型]()`\n\n```swift\nvar array = [String]()\n```\n\n2、`Array<类型>()`\n\n```swift\nvar array = Array<String>()\n```\n\n#### 初始化器参数\n\n```swift\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints [\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\n```\n\n```swift\nlet fiveYs = Array(arrayLiteral: \"Y\", \"Y\", \"Y\", \"Y\", \"Y\")\nprint(fiveYs)\n// Prints [\"Y\", \"Y\", \"Y\", \"Y\", \"Y\"]\n```\n\n```swift\nlet numbers = [Int](0...7)\nprint(numbers)\n// Prints [0, 1, 2, 3, 4, 5, 6, 7]\n```\n\n```swift\nlet persons = [\"zhangsan\":27, \"lisi\":28, \"wangwu\":29]\nlet names = [String](persons.keys)\nprint(names)\n// Prints [\"zhangsan\", \"wangwu\", \"lisi\"]\n```\n\n### 数组遍历与索引\n\n#### For-In\n\n1、遍历\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n6\n7\n```\n\n2、使用 break 跳出循环。\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    if (num == 3) {\n        break\n    }\n    print(num)\n}\n```\n\n打印结果中只有`0、1、2`：\n\n```js\n0\n1\n2\n```\n\n3、使用 continue 跳过循环。\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    if (num == 3) {\n        continue\n    }\n    print(num)\n}\n```\n\n打印结果中没有3：\n\n```js\n0\n1\n2\n4\n5\n6\n7\n```\n\n#### forEach\n\n1、遍历。\n\n```swift\nlet numbers = [Int](0...7)\nnumbers.forEach { (num) in\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n6\n7\n```\n\n2、无法使用 break 或 continue 跳出或者跳过循环。\n\n![02](集合类/02.png)\n\n3、使用 return 只能退出当前一次循环的执行体，效果等同于 For-in 中使用 continue。\n\n```swift\nlet numbers = [Int](0...7)\nnumbers.forEach { (num) in\n    if num == 3 {\n        return\n    }\n    print(num)\n}\n```\n\n打印结果中没有3：\n\n```js\n0\n1\n2\n4\n5\n6\n7\n```\n\n#### enumerated\n\n可以实现同时得到索引和值。\n\n```swift\nlet numbers = [Int](2...7)\nfor (index, num) in numbers.enumerated() {\n    print(\"the index is: \\(index)\")\n}\n```\n\n打印结果：\n\n```js\nthe index is: 0\nthe index is: 1\nthe index is: 2\nthe index is: 3\nthe index is: 4\nthe index is: 5\n```\n\n想要同时得到索引和值，必须使用 `enumerated()`，否则会报错。\n\n![03](集合类/03.png)\n\n#### Iterator\n\n`Iterator`：迭代器。\n\n```swift\nlet numbers = [Int](2...7)\nvar numIterator = numbers.makeIterator()\nwhile let num = numIterator.next() {\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n2\n3\n4\n5\n6\n7\n```\n\n#### 索引\n\n`startIndex`：返回第一个元素的位置，对于数组来说，永远都是0。\n\n```swift\nlet numbers = [1]\nprint(numbers.startIndex)\n// Prints 0\n```\n\n`endIndex`：返回最后一个元素 **索引值+1** 的位置，对于数组来说，**等同于`count`**。\n\n```swift\nlet numbers = [1]\nprint(numbers.endIndex)\nprint(numbers.count)\n// 1\n// 1\n```\n\n对于空数组，`startIndex` 等于 `endIndex`。\n\n* `indices`：获取数组的索引区间。\n\n```swift\nlet numbers = [Int](2...7)\nfor i in numbers.indices {\n    print(numbers[i])\n}\n```\n\n打印结果：\n\n```js\n2\n3\n4\n5\n6\n7\n```\n\n### 数组的查找操作\n\n#### 判断是否包含指定元素\n\n`contains(_:)`：判断数组是否包含给定元素。\n\n```swift\nlet numbers = [Int](0...7)\nif numbers.contains(3) {\n    print(\"numbers contains 3\")\n}\n// Prints \"numbers contains 3\"\n```\n\n`contains(where:)`：判断数组是否包含符合给定条件的元素。\n\n```swift\nif numbers.contains(where: { $0 > 7 }) {\n    print(\"num > 7\")\n} else {\n    print(\"num < 7\")\n}\n// Prints \"num < 7\"\n```\n\n#### 判断所有元素符合某个条件\n\n`allSatisfy(_:)`：判断数组的每一个元素都符合给定的条件。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.allSatisfy({ $0 > 10 }))\nprint(array.allSatisfy({ $0 >= 4 }))\n```\n\n打印结果：\n\n```text\nfalse\ntrue\n```\n\n#### 查找元素\n\n`first`：返回数组第一个元素，如果数组为空，返回 nil。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.first)\n// Prints Optional(10)\n```\n\n`last`：返回数组最后一个元素，如果数组为空，返回 nil。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.last)\n// Prints Optional(4)\n```\n\n`first(where:)`：返回数组第一个符合给定条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.first(where: { $0 > 25 }))\n// Prints Optional(45)\n```\n\n`last(where)`：返回数组最后一个符合给定条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.last(where: { $0 > 25 }))\n// Prints Optional(30)\n```\n\n#### 查找索引\n\n`firstIndex(of:)`：返回给定元素在数组中出现的第一个位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.firstIndex(of: 30))\n// Prints Optional(3)\n```\n\n`lastIndex(of:)`：返回给定元素在数组中出现的最后一个位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.lastIndex(of: 20))\n// Prints Optional(1)\n```\n\n`firstIndex(where:)`：返回符合条件的第一个元素的位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.firstIndex(where: { $0 > 25 }))\n// Prints Optional(2)\n```\n\n`lastIndex(where:)`：返回符合条件的最后一个元素的位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.lastIndex(where: { $0 > 25 }))\n// Prints Optional(6)\n```\n\n#### 查找最大最小元素\n\n`min()`：返回数组中最小的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.min())\n// Prints Optional(4)\n```\n\n`max()`：返回数组中最大的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.max())\n// Prints Optional(101)\n```\n\n`min(by:)`：利用给定的方式比较元素并返回数组中最小的元素。\n\n```swift\nvar array = [(45, \"error1\"), (23, \"error2\"), (30, \"error3\")]\n// 系统方法\nprint(array.min(by: { a, b in\n    a.0 < b.0\n}))\n// Prints Optional((23, \"error2\"))\n\n// 尾随闭包方式\nprint(array.min { a, b in a.0 < b.0 })\n// Prints Optional((23, \"error2\"))\n```\n\n`max(by:)`：利用给定的方式比较元素并返回数组中最大的元素。\n\n```swift\nvar array = [(45, \"error1\"), (23, \"error2\"), (30, \"error3\")]\nprint(array.max { a, b in a.0 < b.0 })\n// Prints Optional((45, \"error1\"))\n```\n\n### 数组添加和删除\n\n#### 在末尾添加\n\n`append(_:)`：在末尾添加一个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.append(100)\nprint(numbers)\n// Prints [2, 3, 4, 5, 6, 7, 100]\n```\n\n`append(contentsOf:)`：在末尾添加多个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.append(contentsOf: 100...105)\nprint(numbers)\n// Prints [2, 3, 4, 5, 6, 7, 100, 101, 102, 103, 104, 105]\n```\n\n#### 在任意位置插入\n\n`insert(_:at:)`：在指定位置插入一个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.insert(-1, at: 0)\nprint(numbers)\n// Prints [-1, 2, 3, 4, 5, 6, 7]\n```\n\n`insert(contentOf:at:)`：在指定位置插入多个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.insert(contentsOf: -2...0, at: 0)\nprint(numbers)\n// Prints [-2, -1, 0, 2, 3, 4, 5, 6, 7]\n```\n\n#### 字符串也是集合\n\n字符串也是集合（Collection），Element（元素）是字符（Character）类型。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\"]\nchars.insert(contentsOf: \"hello\", at: 0)\nprint(chars)\n// Prints [\"h\", \"e\", \"l\", \"l\", \"o\", \"a\", \"b\", \"c\"]\n```\n\n#### 移除单个元素\n\n`remove(at:)`：移除并返回指定位置的一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.remove(at: 1)\nprint(removedChar)\nprint(chars)\n// b\n// [\"a\", \"c\", \"d\"]\n```\n\n`removeFirst()`：移除并返回数组的第一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.removeFirst()\nprint(removedChar)\nprint(chars)\n// a\n// [\"b\", \"c\", \"d\"]\n```\n\n`removeLast()`：移除并返回数组的最后一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.removeLast()\nprint(removedChar)\nprint(chars)\n// d\n// [\"a\", \"b\", \"c\"]\n```\n\n`popLast`：移除并返回数组的最后一个元素（`Optional`），如果数组为空返回`nil`。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.popLast()\nprint(removedChar)\nprint(chars)\n// Optional(\"d\")\n// [\"a\", \"b\", \"c\"]\n```\n\n```swift\nvar chars: [Character] = []\nlet removedChar = chars.popLast()\nprint(removedChar)\n// Prints nil\n```\n\n#### 移除多个元素\n\n`removeFirst(:)`：移除数组前面多个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nchars.removeFirst(2)\nprint(chars)\n// Prints [\"c\", \"d\"]\n```\n\n`removeLast(:)`：移除数组后面多个元素。\n\n```swift\nchars.removeLast(2)\nprint(chars)\n// Prints [\"a\", \"b\"]\n```\n\n`removeSubrange(_:)`：移除数组中给定范围的元素。\n\n```swift\nchars.removeSubrange(1...2)\nprint(chars)\n// Prints [\"a\", \"d\"]\n```\n\n`removeAll()`：移除数组所有元素，数组容量置为0。\n\n```swift\nchars.removeAll()\nprint(chars)\nprint(chars.capacity)\n// []\n// 0\n```\n\n`removeAll(keepingCapacity:)`：移除数组所有元素，保留数组容量。\n\n```swift\nchars.removeAll(keepingCapacity: true)\nprint(chars)\nprint(chars.capacity)\n// []\n// 4\n```\n\n### ArraySlice\n\nArraySlice 是数组或者其它 ArraySlice 的一段连续切片，**和原数组共享内存**。当要改变 ArraySlice 的时候，ArraySlice 会 copy 出来，形成单独内存。\n\nArraySlice 拥有和 Array 基本完全类似的方法。\n\n#### 通过 Drop 得到 ArraySlice\n\n`dropFirst(:)`：“移除”原数组前面指定个数的元素**得到一个 ArraySlice**。\n\n移除前面指定个数的元素，每次操作得到一个新的 ArraySlice：\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.dropFirst()                          // [2, 10, 1, 0, 100, 46, 99]\narray.dropFirst(3)                         // [1, 0, 100, 46, 99]\n```\n\n移除后面指定个数的元素，每次操作得到一个新的 ArraySlice：\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.dropLast()                           // [5, 2, 10, 1, 0, 100, 46]\narray.dropLast(3)                          // [5, 2, 10, 1, 0]\n```\n\n#### 通过 prefix 得到 ArraySlice\n\n`prefix()`：获取数组前面指定个数的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(4)                            // [5, 2, 10, 1]\n```\n\n`prefix(upTo:)`：获取数组到指定位置（不包含指定位置）前面的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(upTo: 4)                      // [5, 2, 10, 1]\n```\n\n`prefix(through:)`：获取数组到指定位置（包含指定位置）前面的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(through: 4)                   // [5, 2, 10, 1, 0]\n```\n\n`prefix(while:)`：获取数组前面符合条件的元素（到第一个不符合条件的元素截止）组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(while: { $0 < 10 })           // [5, 2]\narray.prefix { $0 < 10 }                   // [5, 2]\n```\n\n#### 通过 suffix 得到 ArraySlice\n\n`suffix()`：获取数组后面指定个数的元素组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]\narray.suffix(3)  // [100, 46, 99]\n```\n\n`suffix(from:)`：获取数组从指定位置到结尾（包含指定位置）的元素组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]\narray.suffix(from: 5)  // [100, 46, 99]\n```\n\n#### 通过 Range 得到 ArraySlice\n\n可以通过对数组下标指定 Range 获取 ArraySlice，可以使用闭区间、半开半闭区间、单侧区间截取数组获得 ArraySlice，也可以用`...`来获取整个数组组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray[...2]                                // [5, 2, 10]\narray[..<2]                                // [5, 2]\narray[3...5]                               // [1, 0, 100]\narray[3..<5]                               // [1, 0]\narray[6...]                                // [46, 99]\narray[...]                                 // [5, 2, 10, 1, 0, 100, 46, 99]\n```\n\n#### ArraySlice 转为 Array\n\nArraySlice 无法直接复制给一个 Array 的常量或变量，需要使用 `Array(slice)` 方法转成 Array 类型。\n\n```swift\nvar array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\nlet slice = array[3...5]                   // [1, 0, 100]\narray = Array(slice)                       // [1, 0, 100]\n```\n\n![04](集合类/04.png)\n\n#### ArraySlice 和原 Array 相互独立\n\n`ArraySlice` 和原 `Array` 是相互独立的，它们添加删除元素不会影响对方。\n\n```swift\nvar array = [10, 46, 99]      // [10, 46, 99]\nvar slice = array.dropLast()  // [10, 46]\n\narray.append(333)             // [10, 46, 99, 333]\nslice.append(555)             // [10, 46, 555]\n```\n\n### 重排操作\n\n#### 数组元素的随机化\n\n`shuffle()`：在原数组上将数组元素打乱，只能作用在数组**变量**上。\n\n```swift\nvar array = [Int](1...8)  // [1, 2, 3, 4, 5, 6, 7, 8]\narray.shuffle()           // [8, 2, 3, 5, 6, 1, 7, 4]\n```\n\n`shuffled()`：返回原数组的随机化**数组**，可以作用在数组**变量和常量**上。\n\n```swift\nlet array = [Int](1...8)       // [1, 2, 3, 4, 5, 6, 7, 8]\nvar array2 = array.shuffled()  // [4, 8, 1, 7, 3, 2, 6, 5]\n```\n\n#### 数组的逆序\n\n`reverse()`：在原数组上将数组逆序，只能作用在数组**变量**上。\n\n```swift\nvar array = [Int](1...8)  // [1, 2, 3, 4, 5, 6, 7, 8]\narray.reverse()           // [8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n`reversed()`：返回原数组的逆序“**集合表示**”，可以作用在数组变量和常量上，该方法**不会分配新内存空间**。\n\n```swift\nlet array1 = [Int](1...8)       // [1, 2, 3, 4, 5, 6, 7, 8]\nvar array2 = array1.reversed()  // ReversedCollection<Array<Int>>\nprint(array2)                   // ReversedCollection<Array<Int>>(_base: [1, 2, 3, 4, 5, 6, 7, 8])\n```\n\n#### 数组的分组\n\n`partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Int`：将数组以某个条件分组，数组前半部分都是不符合条件的元素，数组后半部分都是符合条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]         // [10, 20, 45, 30, 98, 101, 30, 4]\nlet index = array.partition { (element) -> Bool in   // 5\n    element > 30\n}\nlet partition1 = array[..<index]                     // [10, 20, 4, 30, 30]\nlet partition2 = array[index...]                     // [101, 98, 45]\n```\n\n#### 数组的排序\n\n`sort`：在原数组上将元素排序，只能作用于数组**变量**。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]  // [10, 20, 45, 30, 98, 101, 30, 4]\narray.sort()                                  // [4, 10, 20, 30, 30, 45, 98, 101] \n```\n\n`sorted()`：返回原数组的排序结果**数组**，可以作用在数组**变量和常量**上。\n\n```swift\nlet array = [10, 20, 45, 30, 98, 101, 30, 4]\nlet array2 = array.sorted()\n```\n\n#### 交换数组两个元素\n\n`swapAt(_ i: Int, _ j: Int)`：交换指定位置的两个元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]        // [10, 20, 45, 30, 98, 101, 30, 4]\narray.swapAt(array.startIndex, array.endIndex - 1)  // [4, 20, 45, 30, 98, 101, 30, 10]\n```\n\n### 拼接操作\n\n#### 字符串数组拼接\n\n`joined()`：拼接字符串数组里的所有元素为一个字符串。\n\n```swift\nvar array = [\"hello\", \"world\"]        // [\"hello\", \"world\"]\nprint(array.joined())                 // \"helloworld\\n\"\n```\n\n`joined(separator)`：以给定的分隔符拼接字符串数组里的所有元素为一个字符串。\n\n```swift\nvar array = [\"hello\", \"world\"]        // [\"hello\", \"world\"]\nprint(array.joined(separator: \", \"))  // \"hello, world\\n\"\n```\n\n#### 元素为 Sequence 数组的拼接\n\n`joined()`：拼接数组里的所有元素为一个更大的 Sequence。\n\n```swift\nlet ranges = [0..<3, 8..<10, 15..<17]  // [{lowerBound 0, upperBound 3}, {lowerBound 8, upperBound 10}, {lowerBound 15, upperBound 17}]\nfor range in ranges {\n    print(range)\n}\n\nprint(\"\")\nfor i in ranges.joined() {\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0..<3\n8..<10\n15..<17\n\n0\n1\n2\n8\n9\n15\n16\n```\n\n`joined(separator:)`：以给定的分隔符拼接数组里的所有元素为一个更大的Sequence。\n\n```swift\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))  // \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\\n\"\n```\n\n### 探秘数组\n\n阅读源码：\n\n1. 先看顶层设计，再看底层源码是怎么符合顶层设计的。\n2. 从关键的调用链开始，找到关键方法，再看关键方法底层又调用到了哪些方法。\n\n#### 数组的协议结构\n\n![05](集合类/05.png)\n\n#### 顶层设计\n\n##### Sequence\n\n一个序列（sequence）代表的是一系列具有相同类型的值，可以对这些值进行迭代。\n\n![06](集合类/06.png)\n\n##### IteratorProtocol\n\n迭代器：Sequence 通过创建一个迭代器来提供对元素的访问。迭代器每次产生一个序列的值，并且当遍历序列时对遍历状态进行管理。\n\n如：\n\n```swift\nprotocol IteratorProtocol {\n    associatedtype Element\n    mutating func next() -> Element?\n}\n```\n\n`next()` 返回序列的下一个元素。当序列被耗尽时，`next()` 应该返回 nil。\n\n##### 定义自己的 Sequence\n\n实现斐波那契数列：\n\n```swift\nstruct FibsIterator: IteratorProtocol {\n    let number: Int\n    var index: Int = 0\n    \n    init(_ number: Int) {\n        self.number = number\n    }\n    \n    var state = (0, 1)\n    mutating func next() -> Int? {\n        if index >= number {\n            return nil\n        }\n        index += 1\n        \n        let fibNumber = state.0\n        // 后一个数等于前两个数之和\n        state = (state.1, state.0 + state.1)\n        return fibNumber\n    }\n    typealias Element = Int\n}\n\nstruct FibsSequence: Sequence {\n    let number: Int\n    init(_ number: Int) {\n        self.number = number\n    }\n    typealias Iterator = FibsIterator\n    func makeIterator() -> FibsSequence.Iterator {\n        return FibsIterator(number)\n    }\n}\n\nlet fibs = FibsSequence(10)\n\nfor fib in fibs {\n    print(fib)\n}\n```\n\n打印结果：\n\n```swift\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n`IteratorProtocol` 是迭代器协议，继承协议同时实现协议要求的方法，就拥有了迭代器的能力。`Sequence` 是序列协议，继承协议同时实现协议要求的方法，就拥有了序列的能力。\n\n`mutating` 表示方法内部可以对全局变量进行修改。\n\n##### Collection\n\n一个集合（Collection）是满足下面条件的序列（Sequence）：\n\n1. 稳定的 Sequence， 能够被多次遍历且保持一致；\n2. 除了线性遍历以外，集合中的元素也可以通过下标索引的方式被获取到；\n3. 和 Sequence 不同，Collection 类型不能是无限的。\n\n![07](集合类/07.png)\n\n#### Array 源码\n\nArray 的本质是一个 Sequence。\n\nArray 的迭代器实现基于数组的下标操作，数组的小标操作基于 `buffer.getElement()` 方法，`buffer.getElement()` 方法基于 `UnsafeMutablePointer` 的小标操作。\n\n#### Array 的迭代器\n\n左侧是 Array 的迭代器的底层实现。`next()` 方法负责返回数组的下一个元素，超出数组容量则返回空。获取数组内部元素的方式是**下标访问**。\n\n右侧是 Array 的迭代器的创建。调用 `IndexingItetator` 传入的是 `self`，也就是说左面的 element 是右面传入的 Collection。\n\n![09](集合类/09.png)\n\n#### Array 的下标访问\n\n下图是下标访问的代码实现，核心方法是 `_getElement()` 方法。下标方法的调用链是 `subscrip(index:)`→`_getElement()`→`_buffer.getElement()`。\n\n![10](集合类/10.png)\n\n#### Array 的 buffer\n\n`_Buffer` 的实现区分 Objc 和 Swift 两个版本，Swift 版本是 `_ContiguousArrayBuffer`。\n\n![11](集合类/11.png)\n\n`storageAddr` 是通过 `UnsafeMutablePointer` 方法生成的一个地址，后续会对`_storageAddr`进行加法操作。\n\n##### _ContiguousArrayBuffer\n\n![12](集合类/12.png)\n\n`_ContiguousArrayBuffer` 中 `getElement()` 方法的实现：\n\n1. 首先判断了是否越界；\n2. 通过下表访问，返回 `firstElementAddress[i]` 中第 `i` 个元素。`firstElementAddress` 方法中是基于 c/c++ 的指针操作。\n\n##### _ContiguousArrayBuffer 的 getElement\n\n![13](集合类/13.png)\n\n##### UnsafeMutablePointer 的下标操作\n\n`UnsafeMutablePointer` 是 Array 的迭代器实现中真正的指针操作实现，基于 c/c++ 实现。\n\n![14](集合类/14.png)\n\n至此，数组迭代器的底层代码实现已经完成。数组的 `Iterator` 实际上是 `IndexingIterator`。因为 `IndexingIterator` 方法传入的参数是 self，所以 `next()` 方法实际是对 self（数组）的下标进行操作。而数组的下标操作又会转化成 ArrayBuffer 的下标操作。\n\n在阅读数组源码的过程中，主要包括两个步骤：\n\n1. 先看顶层设计，包括 Sequence、IteratorProtocol、Collection。\n2. 从关键的调用链开始，从 Iterator 的 `next()` 方法切入。 `subscrip(index:)`→`_getElement()`→`_buffer.getElement()`。\n\n#### 问题：endIndex vs count\n\n* endIdex 是 Self.index 类型。\n* count 是 Int 类型。\n\n![15](集合类/15.png)\n\n##### 探索-索引\n\n官方文档指出，所有实现 Collection 协议类，必须提供 startIndex 和 endIndex 两个属性，并且读取这两个属性的时间复杂度是 O(1) 的。因为在读取一个前向或双向的 Collection 的 count 属性时，需要遍历整个 Collection 的所有元素，所以其复杂度是 O(n) 的。\n\n即：\n\n对于一个随机存储的数组，获取 count 的时间复杂度是 O(1) 的。\n\n对于一个链表实现的数组，获取 count 的时间复杂度是 O(n) 的，startIndex 和 endIndex 属性获取是 O(1) 的。在遍历一个链表数组时，如果使用 startIndex 或 endIndex 遍历，会比使用 count 遍历更加便捷。\n\n![16](集合类/16.png)\n\n左侧是 String 的 endIndex 和 count 的实现。endIndex 返回的是 _guits.endIndex()，是 O(1) 复杂度的。count 返回的是从 startIndex 到 endIndex 的计算结果，复杂度是非 O(1) 的。\n\n右侧是 Array 的 endIndex 和 count 的实现。两者的实现是一样的。\n\n![17](集合类/17.png)\n\n##### 探索\n\n* 阅读 `removeFirst` 方法的源码，得出 `removeFirst` 的复杂度。\n\n* 阅读 `sort` 方法的源码，了解 Array 的排序方法。\n\n#### 实现栈和队列\n\n#### Stack\n\n栈（Stack）是一种 **后入先出（Last in First Out）** 的数据结构，仅限定在栈顶进行插入或者删除操作。栈结构的实现应用主要有数制转换、括号匹配、表达式求值等等。\n\n![18](集合类/18.png)\n\n```swift\nstruct Stack <T> {\n    private var elements = [T]()\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.last\n    }\n    \n    mutating func push(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func pop() -> T? {\n        return elements.popLast()\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(3)\nstack.push(8)\nprint(stack.pop() ?? 0)  // \"8\"\nprint(stack.count)       // \"2\"\n```\n\n#### Queue\n\n队列在生活中非常常见。排队等位吃饭、在火车站卖票、通过高速路口等，这些生活中的现象很好的描述了队列的特点：先进先出（FIFO，first in first out），排在最前面的先出来，后面来的只能排在最后面。\n\n![19](集合类/19.png)\n\n```swift\nstruct Queue<T> {\n    private var elements : [T] = []\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.first\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst();\n    }\n}\n\nvar queue = Queue<Int>()\nqueue.enqueue(1)\nqueue.enqueue(3)\nqueue.enqueue(8)\nprint(queue.dequeue() ?? 0)  // \"1\"\nprint(queue.count)           // \"2\"\n```\n\n#### 练习\n\n尝试改造 Stack 和 Queue 的代码让实现 Sequence 协议，支持 For-in 循环。\n\n```swift\nstruct QueueIterator<T>: IteratorProtocol {\n    let elements: [T]\n    var index: Int = 0\n    \n    init(_ elements: [T]) {\n        self.elements = elements\n    }\n    \n    mutating func next() -> T? {\n        if index >= elements.count {\n            return nil\n        }\n        let element: T = elements[index];\n        index += 1\n        return element\n    }\n    \n    typealias Element = T\n}\n\nstruct Queue<T> : Sequence {\n    private var elements : [T] = []\n        \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.first\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst();\n    }\n    \n    typealias Iterator = QueueIterator\n    func makeIterator() -> Queue.Iterator<T> {\n        return QueueIterator(elements)\n    }\n}\n\nvar queue = Queue<Int>()\nqueue.enqueue(1)\nqueue.enqueue(3)\nqueue.enqueue(8)\n\nfor element in queue {\n    print(element)\n}\n```\n\n打印结果：\n\n```js\n1\n3\n8\n```\n\n总结：实现 Sequence 协议，需要实现 Sequence 创建迭代器的方法 `makeIterator()`，迭代器则负责实现 `next()` 方法序列的下一个元素，从而实现对序列的遍历。\n\n## Set\n\nSet（集合）是指具有某种特定性质的具体的或抽象的对象汇总而成的集体。其中，构成 Set 的这些对象则称为该 Set 的元素。\n\n集合的三个特性\n\n1. 确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一。\n2. 互斥性：一个集合中，任何两个元素都认为是不相同的，即**每个元素只出现一次**。\n3. 无序性：一个集合中，每个元素的地位都是相同的，**元素之间是无序的**。\n\nSwift 的集合类型写做 `Set<Element>`，这里的 Element 是 Set 要储存的类型。不同于数组，集合没有等价的简写。\n\n### 创建 Set\n\n1、使用**初始化器**语法来创建一个确定类型的空 Set：\n\n```swift\nvar letters = Set<Character>()\nletters.insert(\"c\")\nprint(letters)\n```\n\n2、使用**数组字面量**创建 Set：\n\n```swift\nvar course: Set<String> = [\"Math\", \"English\", \"History\"]\ncourse.insert(\"History\")\nprint(course)\n```\n\n### Set 类型的哈希值\n\n为了能让类型储存在 Set 中，它必须是可哈希的——就是说类型必须提供计算它自身哈希值的方法。\n\n所有 Swift 的基础类型，比如 `String`，`Int`，`Double` 和 `Bool` 默认都是可哈希的，并且可以用于 Set 或者 DIctionary 的键。\n\n报错信息：Person 没有实现 Hashable 协议。\n\n![20](集合类/20.png)\n\n让 Person 实现 Hashable 协议：\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nvar PersonSet = Set<Person>()\nPersonSet.insert(Person(name: \"zhangsan\", age: 28))\n// Prints '[__lldb_expr_28.Person(name: \"zhangsan\", age: 28)]'\n```\n\n### 访问和修改 Set\n\n#### 遍历 Set\n\n可以使用 `For-In` 遍历 Set。\n\n```swift\nlet courses: Set = [\"Math\", \"English\", \"History\"]\nfor course in courses {\n    print(course)\n}\n```\n\n打印结果：\n\n```js\nHistory\nMath\nEnglish\n```\n\n因为 Set 是无序的，如果需要顺序遍历 Set，可以使用 `sorted()` 方法进行排序。\n\n```swift\nfor course in courses.sorted() {\n    print(course)\n}\n```\n\n打印结果：\n\n```js\nEnglish\nHistory\nMath\n```\n\n#### 访问 Set\n\n使用 `count` 获取 Set 里元素个数。\n\n```swift\nlet set: Set<Character> = [\"A\", \"B\", \"C\"]\nprint(set.count)\n//Prints '3'\n```\n\n使用 `isEmpty` 判断 Set 是否为空。\n\n```swift\nlet set: Set<Character> = [\"A\", \"B\", \"C\"]\nprint(set.isEmpty)\n// 'false'\n```\n\n#### 添加元素\n\n`insert(_:)`：添加一个元素到 Set。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nvar personSet = Set<Person>()\npersonSet.insert(Person(name: \"zhangsan\", age: 28))  // '[__lldb_expr_28.Person(name: \"zhangsan\", age: 28)]'\n```\n\n`update(with:)`：如果已经有相等的元素，替换为新元素。如果 Set 中没有，则插入。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28)]\npersonSet.update(with: Person(name: \"wangwu\", age: 18))    // '[__lldb_expr_44.Person(name: \"zhangsan\", age: 28), __lldb_expr_44.Person(name: \"wangwu\", age: 18)]'\npersonSet.update(with: Person(name: \"zhangsan\", age: 18))  // '[__lldb_expr_44.Person(name: \"zhangsan\", age: 18), __lldb_expr_44.Person(name: \"wangwu\", age: 18)]'\n```\n\n在使用 `update(with:)` 方法时，需要保证集合内的元素实现了 `Equatable` 协议，用来判断两个元素是否相等。\n\n#### 移除元素\n\n`filter(_:)`：返回一个新的 Set，新 Set 的元素是原始 Set 符合条件的元素。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\nprint(personSet.filter{ $0.age > 20 })  // '[__lldb_expr_59.Person(name: \"zhangsan\", age: 28)]'\nprint(personSet)                        // '[__lldb_expr_59.Person(name: \"wangwu\", age: 18), __lldb_expr_59.Person(name: \"zhangsan\", age: 28)]'\n```\n\n`remove(_:)`：从 Set 当中移除一个元素，如果元素是 Set 的成员就移除它，并且返回移除的值。如果集合没有这个成员就返回 nil。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.remove(Person(name: \"zhangsan\", age: 33))\nprint(personSet)\n// Prints '[__lldb_expr_67.Person(name: \"wangwu\", age: 18)]'\n```\n\n`removeAll()`：移除所有元素。\n\n```swift\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.removeAll()\nprint(personSet)\n// Prints '[]'\n```\n\n`removeFirst()`：移除 Set 的第一个元素，因为 Set 是无序的，所以第一个元素并不是放入的第一个元素。\n\n```swift\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.removeFirst()\nprint(personSet)\n// Prints '[__lldb_expr_71.Person(name: \"zhangsan\", age: 28)]'\n```\n\n### 基本 Set 操作\n\n![21](集合类/21.png)\n\n`intersection(_:)`：交集，由属于 A 且属于 B 的相同元素组成的集合，记作 A∩B（或 B∩A）。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.intersection(set2))\n// Prints '[\"B\"]'\n```\n\n`union(_:)`：并集，由属于 A 或者属于 B 的所有元素组成的集合，记作 A∪B（或 B∪A）。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.union(set2))\n// Prints '[\"F\", \"G\", \"C\", \"A\", \"E\", \"B\"]'\n```\n\n`symmetricDifference(_:)`：对称差集，集合 A 与集合 B 的对称差集定义为集合 A 与集合 B 中所有不属于 A∩B 的元素的集合。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.symmetricDifference(set2))\n// Prints '[\"G\", \"C\", \"A\", \"E\", \"F\"]'\n```\n\n`subtracting(_:)`：相对补集，由属于 A 而不属于 B 的元素组成的集合，称为 B 关于 A 的相对补集，记作 A-B 或 A\\B。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.subtracting(set2))\n// Prints '[\"C\", \"A\"]'\n```\n\n#### Set 判断方法\n\n`isSubset(of:)`：判断是否是另一个 Set 或者 Sequence 的子集。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isSubset(of: bigSet))\n// Prints 'true'\n```\n\n`isSuperset(of:)`：判断是否是另一个 Set 或者 Sequence 的超集。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(bigSet.isSuperset(of: smallSet))\n// Prints 'true'\n```\n\n`isStrictSubset(of:)` ：判断是否是另一个 Set 的**子集**，但是又不等于另一个 Set。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isStrictSubset(of: bigSet))\n// Prints 'true'\n```\n\n`isStrictSuperset(of:)`：判断是否是另一个 Set 的**超集**，但是又不等于另一个 Set。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(bigSet.isStrictSuperset(of: smallSet))\n// Prints 'true'\n```\n\n`isDisjoint(with:)`：判断两个 Set 是否不相交，如果不相交返回 `true`，如果相交返回 `false`。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isDisjoint(with: bigSet))\n// Prints 'false'\n```\n\n### Set-练习\n\n* 给定一个集合，返回这个集合所有的子集。\n\n#### 思路1-位\n\n解这道题的思想本质上就是元素选与不选的问题，于是就可以想到用二进制来代表选与不选的情况。“1”代表这个元素已经选择，而“0”代表这个元素没有选择。假如三个元素 A B C，那么 101 就代表 B 没有选择，所以 101 代表的子集为 AC。\n\n```swift\nfunc getSubsetsOfSet<T>(_ set1: Set<T>) -> Array<Set<T>> {\n    // 子集有 2^n 个\n    let count = 1 << set1.count\n    // 使用数组，方便使用下标\n    let elements = Array(set1)\n    var subsets = Array<Set<T>>()\n    // 遍历 2^n 个子集对应的下标\n    for i in 0..<count {\n        var subSet = Set<T>()\n        for j in 0..<set1.count {\n            // 当子集的下标对应的二进制位为1时，放入子集中\n            if ((i >> j) & 1) == 1 {\n                subSet.insert(elements[j])\n            }\n        }\n        subsets.append(subSet)\n    }\n    return subsets\n}\n\nlet set1: Set = [\"A\", \"B\", \"C\"]\nlet subSets = getSubsetsOfSet(set1)\nfor subset in subSets {\n    print(subset)\n}\n```\n\n打印结果：\n\n```js\n[]\n[\"A\"]\n[\"B\"]\n[\"A\", \"B\"]\n[\"C\"]\n[\"A\", \"C\"]\n[\"B\", \"C\"]\n[\"A\", \"B\", \"C\"]\n```\n\n打印结果解析：\n\n第0个子集，二进制 000，没有元素\n第1个子集，二进制 001，有一个元素 A\n第2个子集，二进制 010，有一个元素 B\n第3个子集，二进制 011，有两个元素 A B\n第4个子集，二进制 100，有一个元素 C\n第5个子集，二进制 101，有两个元素 A C\n第6个子集，二进制 110，有两个元素 A B\n第7个子集，二进制 111，有三个元素 A B C\n\n使用这种方式有一个注意项，因为二进制的最大长度是64，所有 count 不能超过64位。\n\n#### 思路2-递归\n\n```swift\nfunc getSubsetsOfSet<T>(_ originSet: Set<T>) -> Array<Set<T>> {\n    let elements = Array(originSet)\n    return getSubsetsOfSet2(elements, elements.count - 1)\n}\n\nfunc getSubsetsOfSet2<T>(_ elements: Array<T>, _ index: Int) -> Array<Set<T>> {\n    var subSets = Array<Set<T>>()\n    if index == 0 {\n        // 空集\n        subSets.append(Set<T>())\n        // 只有一个元素\n        var subSet = Set<T>()\n        subSet.insert(elements[index])\n        subSets.append(subSet)\n    } else {\n        subSets = getSubsetsOfSet2(elements, index - 1)\n        for subSet in subSets {\n            // 根据 subSet 生成新的 currentSubSet，向 currentSubSet 中加入新的元素\n            var currentSubSet = subSet\n            currentSubSet.insert(elements[index])\n            subSets.append(currentSubSet)\n        }\n    }\n    return subSets\n}\n\nlet originSet: Set = [\"A\", \"B\", \"C\"]\nlet subSets = getSubsetsOfSet(originSet)\nfor subSet in subSets {\n    print(subSet)\n}\n```\n\n打印结果：\n\n```js\n[]\n[\"A\"]\n[\"B\"]\n[\"A\", \"B\"]\n[\"C\"]\n[\"C\", \"A\"]\n[\"B\", \"C\"]\n[\"A\", \"B\", \"C\"]\n```\n\nindex == 0，一个元素，生成两个子集，`[] [\"A\"]`\nindex == 1，两个元素，生成四个子集，`[] [\"A\"]` `[\"B\"] [\"A\", \"B\"]`\nindex == 2，三个元素，生成八个子集，`[] [\"A\"]` `[\"B\"] [\"A\", \"B\"]` `[\"C\"] [\"A\", \"C\"] [\"B\", \"C\"] [\"A\", \"B\", \"C\"]`\n\n### Set 实现探秘\n\n1. 先看顶层设计，再看底层源码实现。\n2. 从关键方法开始，沿着调用链阅读。\n\n主要包括两个部分：\n\n1. 使用 HashTable 存放 bucket。\n2. 使用 elements 存放 元素。\n\n线性探测的开放寻址法：\n\n![22](集合类/22.png)\n\n左侧是 keys，右侧是 buckets。\n\nJohn Smith 通过计算找到 bucket，因为 bucket 没有被占用，所以可以直接进行存储。\nSam Doe 通过计算得找到 bucket，因为 bucket 被占用，寻找下一个 bucket01，因为 bucket01 没有被占用，所以可以使用 bucket01 进行存储。\n\n#### 从 Set 的 insert 说起\n\n![23](集合类/23.png)\n\n这是 `inser()` 的关键代码，用到的核心方法是 `find()` 和 `insertNew()`。\n\n#### _NativeSet 的 find 方法\n\n`find()`：查找桶（Bucket），找到后直接使用并返回。没有找到则调用 `insertNew()`。主要用到了 HasTable 的 `idealBucket()` 和 `bucket()` 方法。\n\n`_isOccupied()`：判断桶是否被占用。\n\n![24](集合类/24.png)\n\n#### HashTable\n\n`idealBucket()`：找到对应的 bucket。\n`bucket()`：找到当前 bucket 的后一个 bucket。\n\n![25](集合类/25.png)\n\n从 HashTable 的源码可以看到，`bucketMask = bucketCount &-1`，与上 `-1` 可以保证 `bucket.offset & bucketMask` 小于 bucketCount，`hashValue & bucketMask` 小于 bucketCount。\n\n![26](集合类/26.png)\n\n#### _NativeSet 的 insertNew\n\n_isDebugAssertConfiguration() 是 debug 代码，可以直接看 else 里的代码，是调用了 HashTable 的 `insertNew()` 方法。\n\n`insertNew()` 根据 hashValue 找到 bucket，再调用 `uncheckedInitialize()` 插入数据。\n\n![27](集合类/27.png)\n\n#### HashTable 的 insertNew\n\n根据 hashValue 找到可用的 bucket。\n\n![28](集合类/28.png)\n\n#### _NativeSet 的 uncheckedInitialize\n\n根据 `_elements` 首地址值加偏移量 `bucket.offset` 得到插入位置，插入数据。\n\n![29](集合类/29.png)\n\n## 字典\n\n字典：储存无序的互相关联的同一类型的键和同一类型的值的集合。\n\n字典类型的全写方式 `Dictionary<Key, Value>`，简写方式 `[Key: Value]`，建议使用简写方式。其中字典的 Key 必须是可哈希的。\n\n### 创建空字典\n\n1、初始器方式\n\n```swift\nvar dic = Dictionary<String, Int>()\n```\n\n2、简写方式\n\n```swift\nvar dic = [String: Int]()\n```\n\n3、字面量方式\n\n```swift\nvar dic3: Dictionary<String, Int> = [:]\n```\n\n### 字面量创建字典\n\n字典字面量：`[key1:value1, key2:value2, key3:value3]`\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n```\n\n#### count 和 isEmpty\n\n`count`：只读属性，找出 Dictionary 拥有多少元素。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.count)\n// Prints '3'\n```\n\n`isEmpty`：布尔量属性，检查字典是否为空。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.isEmpty)\n// Prints 'false'\n```\n\n### 遍历字典\n\n`For-In`循环\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor (key, value) in dic {\n    print(\"name \\(key), age \\(value)\")\n}\n```\n\n打印结果：\n\n```js\nname lishi, age 19\nname wangwu, age 20\nname zhangsan, age 18\n```\n\n可以通过字典的 keys 或 values 属性遍历字典的键或值的集合。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor key in dic.keys {\n    print(\"name \\(key)\")\n}\n\nfor key in dic.values {\n    print(\"name \\(key)\")\n}\n```\n\n打印结果：\n\n```js\nname zhangsan\nname wangwu\nname lishi\nname 18\nname 20\nname 19\n```\n\nSwift 的 Dictionary 类型是无序的，可以通过对 keys 或 values 调用 sort() 方法排序，来遍历有序的键或值。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor key in dic.keys.sorted() {\n    print(\"name \\(key), age \\(dic[key])\")\n}\n```\n\n打印结果：\n\n```swift\nname lishi, age Optional(19)\nname wangwu, age Optional(20)\nname zhangsan, age Optional(18)\n```\n\n### 操作字典\n\n#### 添加或更新元素\n\n1、使用下标添加或更新元素。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic[\"zhangsan\"] = 28  // '[\"lishi\": 19, \"zhangsan\": 28, \"wangwu\": 20]'\n```\n\n2、使用 `updateValue(_:forKey)` 方法添加或更新元素，返回一个字典值类型的可选项值。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic.updateValue(29, forKey: \"lishi\")  // '[\"wangwu\": 20, \"zhangsan\": 18, \"lishi\": 29]'\n```\n\n#### 字典-移除元素\n\n1、可以使用下标脚本语法给一个键赋值 `nil`，实现从字典中移除该键值对。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic[\"zhangsan\"] = nil  // '[\"lishi\": 19, \"wangwu\": 20]'\n```\n\n2、也可以使用 `removeValue(forKey:)` 从字典中移除键值对。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.removeValue(forKey: \"zhangsan\") ?? 0)  // '18'\nprint(dic)                                       // '[\"lishi\": 19, \"wangwu\": 20]'\nprint(dic.removeValue(forKey: \"zhangsan\"))       // 'nil'\n```\n\n在使用这个方法移除键值对时，如果键值对存在则返回其 `value`，如果不存在则返回 `nil`。\n\n#### 合并两个字典\n\n`merge(_:uniquingKeysWith:)`\n\n1、保留旧值\n\n```swift\nvar dictionary = [\"a\": 1, \"b\": 2]\ndictionary.merge([\"a\": 3, \"c\": 4]) { (current, _) in current }\nprint(dictionary)\n// Prints '[\"b\": 2, \"c\": 4, \"a\": 1]'\n```\n\n2、保留新值\n\n```swift\nvar dictionary = [\"a\": 1, \"b\": 2]\ndictionary.merge([\"a\": 5, \"d\": 6]) { (_, new) in new }\nprint(dictionary)\n// Prints '[\"a\": 5, \"b\": 2, \"d\": 6, \"c\": 4]'\n```\n\n#### firstIndex\n\n虽然字典是无序的，但是每个kv对（键值对）在扩容之前的位置是确定的。可以通过 `firstIndex` 获取某个kv对的位置。\n\n```swift\nlet imagePaths = [\"star\": \"/glyphs/stat.png\",\n                  \"protrait\": \"/images/content/portrait.jpg\",\n                  \"spacer\": \"/images/shared/spacer.gif\"]\nlet glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix(\"/glyphs\") })\n\nif let index = glyphIndex {\n    print(index)\n    print(\"The '\\(imagePaths[index].key)' image is a glyph.\")\n} else {\n    print(\"No glyphs found!\")\n}\n```\n\n打印结果：\n\n```js\nIndex(_variant: Swift.Dictionary<Swift.String, Swift.String>.Index._Variant.native(Swift._HashTable.Index(bucket: Swift._HashTable.Bucket(offset: 1), age: -1384877248)))\nThe 'star' image is a glyph.\n```\n\n如果需要保持顺序的kv对，可以是用 KeyValuePairs。\n\n```swift\nlet recordTimes: KeyValuePairs = [\"Florence Griffith-Joyner\": 10.49,\n                                  \"Evelyn Ashford\": 10.76,\n                                  \"Evelyn Ashford\": 10.79,\n                                  \"Marlies Gohr\": 10.81]\nprint(recordTimes.first)\n// Prints 'Optional((key: \"Florence Griffith-Joyner\", value: 10.49))'\n```\n\n### 字典实现探秘\n\n从关键方法开始，沿着调用链阅读。从 set 方法开始。\n\n#### 从下标操作说起\n\n字典的关键操作跟 set 方法类似，就是下标操作。\n\n`subscript(key:)`：字典的 set 方法，参数是 `Key`，返回值是可选 `Value?`。\n\n![30](集合类/30.png)\n\n`lookup()`：get 方法通过 lookup() 方法找到对应的 value。\n\n`setValue()`：写入新值。\n\n#### Dictionary._Variant 的 setValue\n\n`setValue(_ value: __owned Value, forKey key: Key)`：写入新值。需要两个参数，值、键。\n\n源码包括 OC 和 Swift 两个实现，最后两行是 Swift 实现部分。\n\n![31](集合类/31.png)\n\n调用链：`setValue()` → `asNative.setValue()`。\n\n`isUniquelyReferenced()`：判断当前 Dictionary 是否唯一。\n\n`asNative` 是 `_NativeDictionary`，主要负责实现 `setValue()` 方法👇。\n\n#### _NativeDictionary 的 setValue\n\n`setValue(_ value: __owned Value, forKey key: Key, isUnique: Bool)`：可以看到需要三个参数，值、键、是否唯一。\n\n![32](集合类/32.png)\n\n实现部分和 `insertNew()` 类似，采用的也是开放寻址法。\n\n如果找到了，则根据 `_values` 首地址值加上桶的偏移量 `bucket.offset` 计算出位置，存放 value。\n\n如果没找到，则调用 `_insert()` 方法👇。\n\n#### _NativeDictionary 的_insert\n\n`_insert(at bucket: Bucket, key: __owned Key, value: __owned Value)`：需要三个参数，桶、键、值。\n\n![33](集合类/33.png)\n\n`hashTable.insert(bucket)`：将桶插入到哈希表里。\n\n`uncheckedInitialize()`：保存键值。\n\n>两个关键操作：\n>\n>1. 保存桶到哈希表。\n>2. 保存键值。\n\n#### _NativeDictionary 的 uncheckedInitialize\n\n`uncheckedInitialize(at bucket: Bucket, toKey key: __owned Key, value: __owned Value)`：需要三个参数，桶、键、值。\n\n![34](集合类/34.png)\n\n`(_keys + bucket.offset).initialize(to: key)`：根据 _keys 的首地址加上桶的偏移量 bucket.offset 计算出位置，存放 key。\n\n`(_values + bucket.offset).initialize(to: value)`：根据 _values 的首地址加上桶的偏移量 bucket.offset 计算出位置，存放 key。\n\n>两个关键操作：\n>\n>1. 保存key。\n>2. 保存value。\n\n#### _NativeDictionary 的 findKey\n\n`find(_ key: Key, hashValue: Int) -> (bucket: Bucket, found: Bool)`：需要两个参数，键、键的哈希值。返回结果包括两个内容，桶、是否存在。\n\n![35](集合类/35.png)\n\n`idealBucket()`：根据哈希值查找桶。\n\n`_isOccupied()`：桶是否被占用。\n\n`bucket(wrappedAfter:)`：从当前 bucket 开始向后查找桶。\n\n>两个关键操作：\n>\n>1. 根据哈希值查找对应的桶。\n>2. 查找没有被占用的桶。\n","source":"_posts/Swift/集合类.md","raw":"---\ntitle: 集合类\ndate: 2023-01-15 17:11:07\ntags: Swift\n---\n\n* [数组](#数组)\n* [Set](#set)\n* [字典](#字典)\n\n<!-- more -->\n\n## 数组\n\n### 创建数组\n\n#### 数组字面量\n\n1、字面量创建：\n\n```swift\nlet array = [1, 2, 3, 4]\n```\n\n>数组字面量写法：一系列的值，用逗号分隔，用方括号括起来。\n\n2、字面量创建空数组：\n\n```swift\nvar array:[Int] = []\nvar array:[String] = []\n```\n\n>⚠️注意：**创建空数组必须携带类型信息**，否则编译不通过。\n![01](集合类/01.png)\n\n3、如果内容已经提供了类型信息，则可以通过空数组字面量来创建一个空数组：\n\n```swift\n// 因为内容提供了类型信息 [Int]\nvar array = [1, 2, 3, 4]\nprint(array)\n// 所以可以通过空数组字面量来创建一个空数组\narray = []\nprint(array)\n```\n\n>提供类型信息的情况包括：\n>\n>1. 作为函数的实际参数；\n>2. 已经分类了的变量或常量；\n\n#### 初始化器\n\n使用初始化器有两种方式：\n\n1、`[类型]()`\n\n```swift\nvar array = [String]()\n```\n\n2、`Array<类型>()`\n\n```swift\nvar array = Array<String>()\n```\n\n#### 初始化器参数\n\n```swift\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints [\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\n```\n\n```swift\nlet fiveYs = Array(arrayLiteral: \"Y\", \"Y\", \"Y\", \"Y\", \"Y\")\nprint(fiveYs)\n// Prints [\"Y\", \"Y\", \"Y\", \"Y\", \"Y\"]\n```\n\n```swift\nlet numbers = [Int](0...7)\nprint(numbers)\n// Prints [0, 1, 2, 3, 4, 5, 6, 7]\n```\n\n```swift\nlet persons = [\"zhangsan\":27, \"lisi\":28, \"wangwu\":29]\nlet names = [String](persons.keys)\nprint(names)\n// Prints [\"zhangsan\", \"wangwu\", \"lisi\"]\n```\n\n### 数组遍历与索引\n\n#### For-In\n\n1、遍历\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n6\n7\n```\n\n2、使用 break 跳出循环。\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    if (num == 3) {\n        break\n    }\n    print(num)\n}\n```\n\n打印结果中只有`0、1、2`：\n\n```js\n0\n1\n2\n```\n\n3、使用 continue 跳过循环。\n\n```swift\nlet numbers = [Int](0...7)\nfor num in numbers {\n    if (num == 3) {\n        continue\n    }\n    print(num)\n}\n```\n\n打印结果中没有3：\n\n```js\n0\n1\n2\n4\n5\n6\n7\n```\n\n#### forEach\n\n1、遍历。\n\n```swift\nlet numbers = [Int](0...7)\nnumbers.forEach { (num) in\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n0\n1\n2\n3\n4\n5\n6\n7\n```\n\n2、无法使用 break 或 continue 跳出或者跳过循环。\n\n![02](集合类/02.png)\n\n3、使用 return 只能退出当前一次循环的执行体，效果等同于 For-in 中使用 continue。\n\n```swift\nlet numbers = [Int](0...7)\nnumbers.forEach { (num) in\n    if num == 3 {\n        return\n    }\n    print(num)\n}\n```\n\n打印结果中没有3：\n\n```js\n0\n1\n2\n4\n5\n6\n7\n```\n\n#### enumerated\n\n可以实现同时得到索引和值。\n\n```swift\nlet numbers = [Int](2...7)\nfor (index, num) in numbers.enumerated() {\n    print(\"the index is: \\(index)\")\n}\n```\n\n打印结果：\n\n```js\nthe index is: 0\nthe index is: 1\nthe index is: 2\nthe index is: 3\nthe index is: 4\nthe index is: 5\n```\n\n想要同时得到索引和值，必须使用 `enumerated()`，否则会报错。\n\n![03](集合类/03.png)\n\n#### Iterator\n\n`Iterator`：迭代器。\n\n```swift\nlet numbers = [Int](2...7)\nvar numIterator = numbers.makeIterator()\nwhile let num = numIterator.next() {\n    print(num)\n}\n```\n\n打印结果：\n\n```js\n2\n3\n4\n5\n6\n7\n```\n\n#### 索引\n\n`startIndex`：返回第一个元素的位置，对于数组来说，永远都是0。\n\n```swift\nlet numbers = [1]\nprint(numbers.startIndex)\n// Prints 0\n```\n\n`endIndex`：返回最后一个元素 **索引值+1** 的位置，对于数组来说，**等同于`count`**。\n\n```swift\nlet numbers = [1]\nprint(numbers.endIndex)\nprint(numbers.count)\n// 1\n// 1\n```\n\n对于空数组，`startIndex` 等于 `endIndex`。\n\n* `indices`：获取数组的索引区间。\n\n```swift\nlet numbers = [Int](2...7)\nfor i in numbers.indices {\n    print(numbers[i])\n}\n```\n\n打印结果：\n\n```js\n2\n3\n4\n5\n6\n7\n```\n\n### 数组的查找操作\n\n#### 判断是否包含指定元素\n\n`contains(_:)`：判断数组是否包含给定元素。\n\n```swift\nlet numbers = [Int](0...7)\nif numbers.contains(3) {\n    print(\"numbers contains 3\")\n}\n// Prints \"numbers contains 3\"\n```\n\n`contains(where:)`：判断数组是否包含符合给定条件的元素。\n\n```swift\nif numbers.contains(where: { $0 > 7 }) {\n    print(\"num > 7\")\n} else {\n    print(\"num < 7\")\n}\n// Prints \"num < 7\"\n```\n\n#### 判断所有元素符合某个条件\n\n`allSatisfy(_:)`：判断数组的每一个元素都符合给定的条件。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.allSatisfy({ $0 > 10 }))\nprint(array.allSatisfy({ $0 >= 4 }))\n```\n\n打印结果：\n\n```text\nfalse\ntrue\n```\n\n#### 查找元素\n\n`first`：返回数组第一个元素，如果数组为空，返回 nil。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.first)\n// Prints Optional(10)\n```\n\n`last`：返回数组最后一个元素，如果数组为空，返回 nil。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.last)\n// Prints Optional(4)\n```\n\n`first(where:)`：返回数组第一个符合给定条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.first(where: { $0 > 25 }))\n// Prints Optional(45)\n```\n\n`last(where)`：返回数组最后一个符合给定条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.last(where: { $0 > 25 }))\n// Prints Optional(30)\n```\n\n#### 查找索引\n\n`firstIndex(of:)`：返回给定元素在数组中出现的第一个位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.firstIndex(of: 30))\n// Prints Optional(3)\n```\n\n`lastIndex(of:)`：返回给定元素在数组中出现的最后一个位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.lastIndex(of: 20))\n// Prints Optional(1)\n```\n\n`firstIndex(where:)`：返回符合条件的第一个元素的位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.firstIndex(where: { $0 > 25 }))\n// Prints Optional(2)\n```\n\n`lastIndex(where:)`：返回符合条件的最后一个元素的位置。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.lastIndex(where: { $0 > 25 }))\n// Prints Optional(6)\n```\n\n#### 查找最大最小元素\n\n`min()`：返回数组中最小的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.min())\n// Prints Optional(4)\n```\n\n`max()`：返回数组中最大的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]\nprint(array.max())\n// Prints Optional(101)\n```\n\n`min(by:)`：利用给定的方式比较元素并返回数组中最小的元素。\n\n```swift\nvar array = [(45, \"error1\"), (23, \"error2\"), (30, \"error3\")]\n// 系统方法\nprint(array.min(by: { a, b in\n    a.0 < b.0\n}))\n// Prints Optional((23, \"error2\"))\n\n// 尾随闭包方式\nprint(array.min { a, b in a.0 < b.0 })\n// Prints Optional((23, \"error2\"))\n```\n\n`max(by:)`：利用给定的方式比较元素并返回数组中最大的元素。\n\n```swift\nvar array = [(45, \"error1\"), (23, \"error2\"), (30, \"error3\")]\nprint(array.max { a, b in a.0 < b.0 })\n// Prints Optional((45, \"error1\"))\n```\n\n### 数组添加和删除\n\n#### 在末尾添加\n\n`append(_:)`：在末尾添加一个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.append(100)\nprint(numbers)\n// Prints [2, 3, 4, 5, 6, 7, 100]\n```\n\n`append(contentsOf:)`：在末尾添加多个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.append(contentsOf: 100...105)\nprint(numbers)\n// Prints [2, 3, 4, 5, 6, 7, 100, 101, 102, 103, 104, 105]\n```\n\n#### 在任意位置插入\n\n`insert(_:at:)`：在指定位置插入一个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.insert(-1, at: 0)\nprint(numbers)\n// Prints [-1, 2, 3, 4, 5, 6, 7]\n```\n\n`insert(contentOf:at:)`：在指定位置插入多个元素。\n\n```swift\nvar numbers = [Int](2...7)\nnumbers.insert(contentsOf: -2...0, at: 0)\nprint(numbers)\n// Prints [-2, -1, 0, 2, 3, 4, 5, 6, 7]\n```\n\n#### 字符串也是集合\n\n字符串也是集合（Collection），Element（元素）是字符（Character）类型。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\"]\nchars.insert(contentsOf: \"hello\", at: 0)\nprint(chars)\n// Prints [\"h\", \"e\", \"l\", \"l\", \"o\", \"a\", \"b\", \"c\"]\n```\n\n#### 移除单个元素\n\n`remove(at:)`：移除并返回指定位置的一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.remove(at: 1)\nprint(removedChar)\nprint(chars)\n// b\n// [\"a\", \"c\", \"d\"]\n```\n\n`removeFirst()`：移除并返回数组的第一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.removeFirst()\nprint(removedChar)\nprint(chars)\n// a\n// [\"b\", \"c\", \"d\"]\n```\n\n`removeLast()`：移除并返回数组的最后一个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.removeLast()\nprint(removedChar)\nprint(chars)\n// d\n// [\"a\", \"b\", \"c\"]\n```\n\n`popLast`：移除并返回数组的最后一个元素（`Optional`），如果数组为空返回`nil`。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nlet removedChar = chars.popLast()\nprint(removedChar)\nprint(chars)\n// Optional(\"d\")\n// [\"a\", \"b\", \"c\"]\n```\n\n```swift\nvar chars: [Character] = []\nlet removedChar = chars.popLast()\nprint(removedChar)\n// Prints nil\n```\n\n#### 移除多个元素\n\n`removeFirst(:)`：移除数组前面多个元素。\n\n```swift\nvar chars: [Character] = [\"a\", \"b\", \"c\", \"d\"]\nchars.removeFirst(2)\nprint(chars)\n// Prints [\"c\", \"d\"]\n```\n\n`removeLast(:)`：移除数组后面多个元素。\n\n```swift\nchars.removeLast(2)\nprint(chars)\n// Prints [\"a\", \"b\"]\n```\n\n`removeSubrange(_:)`：移除数组中给定范围的元素。\n\n```swift\nchars.removeSubrange(1...2)\nprint(chars)\n// Prints [\"a\", \"d\"]\n```\n\n`removeAll()`：移除数组所有元素，数组容量置为0。\n\n```swift\nchars.removeAll()\nprint(chars)\nprint(chars.capacity)\n// []\n// 0\n```\n\n`removeAll(keepingCapacity:)`：移除数组所有元素，保留数组容量。\n\n```swift\nchars.removeAll(keepingCapacity: true)\nprint(chars)\nprint(chars.capacity)\n// []\n// 4\n```\n\n### ArraySlice\n\nArraySlice 是数组或者其它 ArraySlice 的一段连续切片，**和原数组共享内存**。当要改变 ArraySlice 的时候，ArraySlice 会 copy 出来，形成单独内存。\n\nArraySlice 拥有和 Array 基本完全类似的方法。\n\n#### 通过 Drop 得到 ArraySlice\n\n`dropFirst(:)`：“移除”原数组前面指定个数的元素**得到一个 ArraySlice**。\n\n移除前面指定个数的元素，每次操作得到一个新的 ArraySlice：\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.dropFirst()                          // [2, 10, 1, 0, 100, 46, 99]\narray.dropFirst(3)                         // [1, 0, 100, 46, 99]\n```\n\n移除后面指定个数的元素，每次操作得到一个新的 ArraySlice：\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.dropLast()                           // [5, 2, 10, 1, 0, 100, 46]\narray.dropLast(3)                          // [5, 2, 10, 1, 0]\n```\n\n#### 通过 prefix 得到 ArraySlice\n\n`prefix()`：获取数组前面指定个数的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(4)                            // [5, 2, 10, 1]\n```\n\n`prefix(upTo:)`：获取数组到指定位置（不包含指定位置）前面的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(upTo: 4)                      // [5, 2, 10, 1]\n```\n\n`prefix(through:)`：获取数组到指定位置（包含指定位置）前面的元素组成 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(through: 4)                   // [5, 2, 10, 1, 0]\n```\n\n`prefix(while:)`：获取数组前面符合条件的元素（到第一个不符合条件的元素截止）组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray.prefix(while: { $0 < 10 })           // [5, 2]\narray.prefix { $0 < 10 }                   // [5, 2]\n```\n\n#### 通过 suffix 得到 ArraySlice\n\n`suffix()`：获取数组后面指定个数的元素组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]\narray.suffix(3)  // [100, 46, 99]\n```\n\n`suffix(from:)`：获取数组从指定位置到结尾（包含指定位置）的元素组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]\narray.suffix(from: 5)  // [100, 46, 99]\n```\n\n#### 通过 Range 得到 ArraySlice\n\n可以通过对数组下标指定 Range 获取 ArraySlice，可以使用闭区间、半开半闭区间、单侧区间截取数组获得 ArraySlice，也可以用`...`来获取整个数组组成的 ArraySlice。\n\n```swift\nlet array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\narray[...2]                                // [5, 2, 10]\narray[..<2]                                // [5, 2]\narray[3...5]                               // [1, 0, 100]\narray[3..<5]                               // [1, 0]\narray[6...]                                // [46, 99]\narray[...]                                 // [5, 2, 10, 1, 0, 100, 46, 99]\n```\n\n#### ArraySlice 转为 Array\n\nArraySlice 无法直接复制给一个 Array 的常量或变量，需要使用 `Array(slice)` 方法转成 Array 类型。\n\n```swift\nvar array = [5, 2, 10, 1, 0, 100, 46, 99]  // [5, 2, 10, 1, 0, 100, 46, 99]\nlet slice = array[3...5]                   // [1, 0, 100]\narray = Array(slice)                       // [1, 0, 100]\n```\n\n![04](集合类/04.png)\n\n#### ArraySlice 和原 Array 相互独立\n\n`ArraySlice` 和原 `Array` 是相互独立的，它们添加删除元素不会影响对方。\n\n```swift\nvar array = [10, 46, 99]      // [10, 46, 99]\nvar slice = array.dropLast()  // [10, 46]\n\narray.append(333)             // [10, 46, 99, 333]\nslice.append(555)             // [10, 46, 555]\n```\n\n### 重排操作\n\n#### 数组元素的随机化\n\n`shuffle()`：在原数组上将数组元素打乱，只能作用在数组**变量**上。\n\n```swift\nvar array = [Int](1...8)  // [1, 2, 3, 4, 5, 6, 7, 8]\narray.shuffle()           // [8, 2, 3, 5, 6, 1, 7, 4]\n```\n\n`shuffled()`：返回原数组的随机化**数组**，可以作用在数组**变量和常量**上。\n\n```swift\nlet array = [Int](1...8)       // [1, 2, 3, 4, 5, 6, 7, 8]\nvar array2 = array.shuffled()  // [4, 8, 1, 7, 3, 2, 6, 5]\n```\n\n#### 数组的逆序\n\n`reverse()`：在原数组上将数组逆序，只能作用在数组**变量**上。\n\n```swift\nvar array = [Int](1...8)  // [1, 2, 3, 4, 5, 6, 7, 8]\narray.reverse()           // [8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n`reversed()`：返回原数组的逆序“**集合表示**”，可以作用在数组变量和常量上，该方法**不会分配新内存空间**。\n\n```swift\nlet array1 = [Int](1...8)       // [1, 2, 3, 4, 5, 6, 7, 8]\nvar array2 = array1.reversed()  // ReversedCollection<Array<Int>>\nprint(array2)                   // ReversedCollection<Array<Int>>(_base: [1, 2, 3, 4, 5, 6, 7, 8])\n```\n\n#### 数组的分组\n\n`partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Int`：将数组以某个条件分组，数组前半部分都是不符合条件的元素，数组后半部分都是符合条件的元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]         // [10, 20, 45, 30, 98, 101, 30, 4]\nlet index = array.partition { (element) -> Bool in   // 5\n    element > 30\n}\nlet partition1 = array[..<index]                     // [10, 20, 4, 30, 30]\nlet partition2 = array[index...]                     // [101, 98, 45]\n```\n\n#### 数组的排序\n\n`sort`：在原数组上将元素排序，只能作用于数组**变量**。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]  // [10, 20, 45, 30, 98, 101, 30, 4]\narray.sort()                                  // [4, 10, 20, 30, 30, 45, 98, 101] \n```\n\n`sorted()`：返回原数组的排序结果**数组**，可以作用在数组**变量和常量**上。\n\n```swift\nlet array = [10, 20, 45, 30, 98, 101, 30, 4]\nlet array2 = array.sorted()\n```\n\n#### 交换数组两个元素\n\n`swapAt(_ i: Int, _ j: Int)`：交换指定位置的两个元素。\n\n```swift\nvar array = [10, 20, 45, 30, 98, 101, 30, 4]        // [10, 20, 45, 30, 98, 101, 30, 4]\narray.swapAt(array.startIndex, array.endIndex - 1)  // [4, 20, 45, 30, 98, 101, 30, 10]\n```\n\n### 拼接操作\n\n#### 字符串数组拼接\n\n`joined()`：拼接字符串数组里的所有元素为一个字符串。\n\n```swift\nvar array = [\"hello\", \"world\"]        // [\"hello\", \"world\"]\nprint(array.joined())                 // \"helloworld\\n\"\n```\n\n`joined(separator)`：以给定的分隔符拼接字符串数组里的所有元素为一个字符串。\n\n```swift\nvar array = [\"hello\", \"world\"]        // [\"hello\", \"world\"]\nprint(array.joined(separator: \", \"))  // \"hello, world\\n\"\n```\n\n#### 元素为 Sequence 数组的拼接\n\n`joined()`：拼接数组里的所有元素为一个更大的 Sequence。\n\n```swift\nlet ranges = [0..<3, 8..<10, 15..<17]  // [{lowerBound 0, upperBound 3}, {lowerBound 8, upperBound 10}, {lowerBound 15, upperBound 17}]\nfor range in ranges {\n    print(range)\n}\n\nprint(\"\")\nfor i in ranges.joined() {\n    print(i)\n}\n```\n\n打印结果：\n\n```js\n0..<3\n8..<10\n15..<17\n\n0\n1\n2\n8\n9\n15\n16\n```\n\n`joined(separator:)`：以给定的分隔符拼接数组里的所有元素为一个更大的Sequence。\n\n```swift\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))  // \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\\n\"\n```\n\n### 探秘数组\n\n阅读源码：\n\n1. 先看顶层设计，再看底层源码是怎么符合顶层设计的。\n2. 从关键的调用链开始，找到关键方法，再看关键方法底层又调用到了哪些方法。\n\n#### 数组的协议结构\n\n![05](集合类/05.png)\n\n#### 顶层设计\n\n##### Sequence\n\n一个序列（sequence）代表的是一系列具有相同类型的值，可以对这些值进行迭代。\n\n![06](集合类/06.png)\n\n##### IteratorProtocol\n\n迭代器：Sequence 通过创建一个迭代器来提供对元素的访问。迭代器每次产生一个序列的值，并且当遍历序列时对遍历状态进行管理。\n\n如：\n\n```swift\nprotocol IteratorProtocol {\n    associatedtype Element\n    mutating func next() -> Element?\n}\n```\n\n`next()` 返回序列的下一个元素。当序列被耗尽时，`next()` 应该返回 nil。\n\n##### 定义自己的 Sequence\n\n实现斐波那契数列：\n\n```swift\nstruct FibsIterator: IteratorProtocol {\n    let number: Int\n    var index: Int = 0\n    \n    init(_ number: Int) {\n        self.number = number\n    }\n    \n    var state = (0, 1)\n    mutating func next() -> Int? {\n        if index >= number {\n            return nil\n        }\n        index += 1\n        \n        let fibNumber = state.0\n        // 后一个数等于前两个数之和\n        state = (state.1, state.0 + state.1)\n        return fibNumber\n    }\n    typealias Element = Int\n}\n\nstruct FibsSequence: Sequence {\n    let number: Int\n    init(_ number: Int) {\n        self.number = number\n    }\n    typealias Iterator = FibsIterator\n    func makeIterator() -> FibsSequence.Iterator {\n        return FibsIterator(number)\n    }\n}\n\nlet fibs = FibsSequence(10)\n\nfor fib in fibs {\n    print(fib)\n}\n```\n\n打印结果：\n\n```swift\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n`IteratorProtocol` 是迭代器协议，继承协议同时实现协议要求的方法，就拥有了迭代器的能力。`Sequence` 是序列协议，继承协议同时实现协议要求的方法，就拥有了序列的能力。\n\n`mutating` 表示方法内部可以对全局变量进行修改。\n\n##### Collection\n\n一个集合（Collection）是满足下面条件的序列（Sequence）：\n\n1. 稳定的 Sequence， 能够被多次遍历且保持一致；\n2. 除了线性遍历以外，集合中的元素也可以通过下标索引的方式被获取到；\n3. 和 Sequence 不同，Collection 类型不能是无限的。\n\n![07](集合类/07.png)\n\n#### Array 源码\n\nArray 的本质是一个 Sequence。\n\nArray 的迭代器实现基于数组的下标操作，数组的小标操作基于 `buffer.getElement()` 方法，`buffer.getElement()` 方法基于 `UnsafeMutablePointer` 的小标操作。\n\n#### Array 的迭代器\n\n左侧是 Array 的迭代器的底层实现。`next()` 方法负责返回数组的下一个元素，超出数组容量则返回空。获取数组内部元素的方式是**下标访问**。\n\n右侧是 Array 的迭代器的创建。调用 `IndexingItetator` 传入的是 `self`，也就是说左面的 element 是右面传入的 Collection。\n\n![09](集合类/09.png)\n\n#### Array 的下标访问\n\n下图是下标访问的代码实现，核心方法是 `_getElement()` 方法。下标方法的调用链是 `subscrip(index:)`→`_getElement()`→`_buffer.getElement()`。\n\n![10](集合类/10.png)\n\n#### Array 的 buffer\n\n`_Buffer` 的实现区分 Objc 和 Swift 两个版本，Swift 版本是 `_ContiguousArrayBuffer`。\n\n![11](集合类/11.png)\n\n`storageAddr` 是通过 `UnsafeMutablePointer` 方法生成的一个地址，后续会对`_storageAddr`进行加法操作。\n\n##### _ContiguousArrayBuffer\n\n![12](集合类/12.png)\n\n`_ContiguousArrayBuffer` 中 `getElement()` 方法的实现：\n\n1. 首先判断了是否越界；\n2. 通过下表访问，返回 `firstElementAddress[i]` 中第 `i` 个元素。`firstElementAddress` 方法中是基于 c/c++ 的指针操作。\n\n##### _ContiguousArrayBuffer 的 getElement\n\n![13](集合类/13.png)\n\n##### UnsafeMutablePointer 的下标操作\n\n`UnsafeMutablePointer` 是 Array 的迭代器实现中真正的指针操作实现，基于 c/c++ 实现。\n\n![14](集合类/14.png)\n\n至此，数组迭代器的底层代码实现已经完成。数组的 `Iterator` 实际上是 `IndexingIterator`。因为 `IndexingIterator` 方法传入的参数是 self，所以 `next()` 方法实际是对 self（数组）的下标进行操作。而数组的下标操作又会转化成 ArrayBuffer 的下标操作。\n\n在阅读数组源码的过程中，主要包括两个步骤：\n\n1. 先看顶层设计，包括 Sequence、IteratorProtocol、Collection。\n2. 从关键的调用链开始，从 Iterator 的 `next()` 方法切入。 `subscrip(index:)`→`_getElement()`→`_buffer.getElement()`。\n\n#### 问题：endIndex vs count\n\n* endIdex 是 Self.index 类型。\n* count 是 Int 类型。\n\n![15](集合类/15.png)\n\n##### 探索-索引\n\n官方文档指出，所有实现 Collection 协议类，必须提供 startIndex 和 endIndex 两个属性，并且读取这两个属性的时间复杂度是 O(1) 的。因为在读取一个前向或双向的 Collection 的 count 属性时，需要遍历整个 Collection 的所有元素，所以其复杂度是 O(n) 的。\n\n即：\n\n对于一个随机存储的数组，获取 count 的时间复杂度是 O(1) 的。\n\n对于一个链表实现的数组，获取 count 的时间复杂度是 O(n) 的，startIndex 和 endIndex 属性获取是 O(1) 的。在遍历一个链表数组时，如果使用 startIndex 或 endIndex 遍历，会比使用 count 遍历更加便捷。\n\n![16](集合类/16.png)\n\n左侧是 String 的 endIndex 和 count 的实现。endIndex 返回的是 _guits.endIndex()，是 O(1) 复杂度的。count 返回的是从 startIndex 到 endIndex 的计算结果，复杂度是非 O(1) 的。\n\n右侧是 Array 的 endIndex 和 count 的实现。两者的实现是一样的。\n\n![17](集合类/17.png)\n\n##### 探索\n\n* 阅读 `removeFirst` 方法的源码，得出 `removeFirst` 的复杂度。\n\n* 阅读 `sort` 方法的源码，了解 Array 的排序方法。\n\n#### 实现栈和队列\n\n#### Stack\n\n栈（Stack）是一种 **后入先出（Last in First Out）** 的数据结构，仅限定在栈顶进行插入或者删除操作。栈结构的实现应用主要有数制转换、括号匹配、表达式求值等等。\n\n![18](集合类/18.png)\n\n```swift\nstruct Stack <T> {\n    private var elements = [T]()\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.last\n    }\n    \n    mutating func push(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func pop() -> T? {\n        return elements.popLast()\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(3)\nstack.push(8)\nprint(stack.pop() ?? 0)  // \"8\"\nprint(stack.count)       // \"2\"\n```\n\n#### Queue\n\n队列在生活中非常常见。排队等位吃饭、在火车站卖票、通过高速路口等，这些生活中的现象很好的描述了队列的特点：先进先出（FIFO，first in first out），排在最前面的先出来，后面来的只能排在最后面。\n\n![19](集合类/19.png)\n\n```swift\nstruct Queue<T> {\n    private var elements : [T] = []\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.first\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst();\n    }\n}\n\nvar queue = Queue<Int>()\nqueue.enqueue(1)\nqueue.enqueue(3)\nqueue.enqueue(8)\nprint(queue.dequeue() ?? 0)  // \"1\"\nprint(queue.count)           // \"2\"\n```\n\n#### 练习\n\n尝试改造 Stack 和 Queue 的代码让实现 Sequence 协议，支持 For-in 循环。\n\n```swift\nstruct QueueIterator<T>: IteratorProtocol {\n    let elements: [T]\n    var index: Int = 0\n    \n    init(_ elements: [T]) {\n        self.elements = elements\n    }\n    \n    mutating func next() -> T? {\n        if index >= elements.count {\n            return nil\n        }\n        let element: T = elements[index];\n        index += 1\n        return element\n    }\n    \n    typealias Element = T\n}\n\nstruct Queue<T> : Sequence {\n    private var elements : [T] = []\n        \n    var count: Int {\n        return elements.count\n    }\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var peek: T? {\n        return elements.first\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst();\n    }\n    \n    typealias Iterator = QueueIterator\n    func makeIterator() -> Queue.Iterator<T> {\n        return QueueIterator(elements)\n    }\n}\n\nvar queue = Queue<Int>()\nqueue.enqueue(1)\nqueue.enqueue(3)\nqueue.enqueue(8)\n\nfor element in queue {\n    print(element)\n}\n```\n\n打印结果：\n\n```js\n1\n3\n8\n```\n\n总结：实现 Sequence 协议，需要实现 Sequence 创建迭代器的方法 `makeIterator()`，迭代器则负责实现 `next()` 方法序列的下一个元素，从而实现对序列的遍历。\n\n## Set\n\nSet（集合）是指具有某种特定性质的具体的或抽象的对象汇总而成的集体。其中，构成 Set 的这些对象则称为该 Set 的元素。\n\n集合的三个特性\n\n1. 确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一。\n2. 互斥性：一个集合中，任何两个元素都认为是不相同的，即**每个元素只出现一次**。\n3. 无序性：一个集合中，每个元素的地位都是相同的，**元素之间是无序的**。\n\nSwift 的集合类型写做 `Set<Element>`，这里的 Element 是 Set 要储存的类型。不同于数组，集合没有等价的简写。\n\n### 创建 Set\n\n1、使用**初始化器**语法来创建一个确定类型的空 Set：\n\n```swift\nvar letters = Set<Character>()\nletters.insert(\"c\")\nprint(letters)\n```\n\n2、使用**数组字面量**创建 Set：\n\n```swift\nvar course: Set<String> = [\"Math\", \"English\", \"History\"]\ncourse.insert(\"History\")\nprint(course)\n```\n\n### Set 类型的哈希值\n\n为了能让类型储存在 Set 中，它必须是可哈希的——就是说类型必须提供计算它自身哈希值的方法。\n\n所有 Swift 的基础类型，比如 `String`，`Int`，`Double` 和 `Bool` 默认都是可哈希的，并且可以用于 Set 或者 DIctionary 的键。\n\n报错信息：Person 没有实现 Hashable 协议。\n\n![20](集合类/20.png)\n\n让 Person 实现 Hashable 协议：\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nvar PersonSet = Set<Person>()\nPersonSet.insert(Person(name: \"zhangsan\", age: 28))\n// Prints '[__lldb_expr_28.Person(name: \"zhangsan\", age: 28)]'\n```\n\n### 访问和修改 Set\n\n#### 遍历 Set\n\n可以使用 `For-In` 遍历 Set。\n\n```swift\nlet courses: Set = [\"Math\", \"English\", \"History\"]\nfor course in courses {\n    print(course)\n}\n```\n\n打印结果：\n\n```js\nHistory\nMath\nEnglish\n```\n\n因为 Set 是无序的，如果需要顺序遍历 Set，可以使用 `sorted()` 方法进行排序。\n\n```swift\nfor course in courses.sorted() {\n    print(course)\n}\n```\n\n打印结果：\n\n```js\nEnglish\nHistory\nMath\n```\n\n#### 访问 Set\n\n使用 `count` 获取 Set 里元素个数。\n\n```swift\nlet set: Set<Character> = [\"A\", \"B\", \"C\"]\nprint(set.count)\n//Prints '3'\n```\n\n使用 `isEmpty` 判断 Set 是否为空。\n\n```swift\nlet set: Set<Character> = [\"A\", \"B\", \"C\"]\nprint(set.isEmpty)\n// 'false'\n```\n\n#### 添加元素\n\n`insert(_:)`：添加一个元素到 Set。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nvar personSet = Set<Person>()\npersonSet.insert(Person(name: \"zhangsan\", age: 28))  // '[__lldb_expr_28.Person(name: \"zhangsan\", age: 28)]'\n```\n\n`update(with:)`：如果已经有相等的元素，替换为新元素。如果 Set 中没有，则插入。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28)]\npersonSet.update(with: Person(name: \"wangwu\", age: 18))    // '[__lldb_expr_44.Person(name: \"zhangsan\", age: 28), __lldb_expr_44.Person(name: \"wangwu\", age: 18)]'\npersonSet.update(with: Person(name: \"zhangsan\", age: 18))  // '[__lldb_expr_44.Person(name: \"zhangsan\", age: 18), __lldb_expr_44.Person(name: \"wangwu\", age: 18)]'\n```\n\n在使用 `update(with:)` 方法时，需要保证集合内的元素实现了 `Equatable` 协议，用来判断两个元素是否相等。\n\n#### 移除元素\n\n`filter(_:)`：返回一个新的 Set，新 Set 的元素是原始 Set 符合条件的元素。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\nprint(personSet.filter{ $0.age > 20 })  // '[__lldb_expr_59.Person(name: \"zhangsan\", age: 28)]'\nprint(personSet)                        // '[__lldb_expr_59.Person(name: \"wangwu\", age: 18), __lldb_expr_59.Person(name: \"zhangsan\", age: 28)]'\n```\n\n`remove(_:)`：从 Set 当中移除一个元素，如果元素是 Set 的成员就移除它，并且返回移除的值。如果集合没有这个成员就返回 nil。\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nextension Person: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(age)\n    }\n}\n\nextension Person: Equatable {\n    static func == (lhs: Person, rhs: Person) -> Bool {\n        return lhs.name == rhs.name\n    }\n}\n\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.remove(Person(name: \"zhangsan\", age: 33))\nprint(personSet)\n// Prints '[__lldb_expr_67.Person(name: \"wangwu\", age: 18)]'\n```\n\n`removeAll()`：移除所有元素。\n\n```swift\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.removeAll()\nprint(personSet)\n// Prints '[]'\n```\n\n`removeFirst()`：移除 Set 的第一个元素，因为 Set 是无序的，所以第一个元素并不是放入的第一个元素。\n\n```swift\nvar personSet : Set = [Person(name: \"zhangsan\", age: 28), Person(name: \"wangwu\", age: 18)]\npersonSet.removeFirst()\nprint(personSet)\n// Prints '[__lldb_expr_71.Person(name: \"zhangsan\", age: 28)]'\n```\n\n### 基本 Set 操作\n\n![21](集合类/21.png)\n\n`intersection(_:)`：交集，由属于 A 且属于 B 的相同元素组成的集合，记作 A∩B（或 B∩A）。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.intersection(set2))\n// Prints '[\"B\"]'\n```\n\n`union(_:)`：并集，由属于 A 或者属于 B 的所有元素组成的集合，记作 A∪B（或 B∪A）。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.union(set2))\n// Prints '[\"F\", \"G\", \"C\", \"A\", \"E\", \"B\"]'\n```\n\n`symmetricDifference(_:)`：对称差集，集合 A 与集合 B 的对称差集定义为集合 A 与集合 B 中所有不属于 A∩B 的元素的集合。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.symmetricDifference(set2))\n// Prints '[\"G\", \"C\", \"A\", \"E\", \"F\"]'\n```\n\n`subtracting(_:)`：相对补集，由属于 A 而不属于 B 的元素组成的集合，称为 B 关于 A 的相对补集，记作 A-B 或 A\\B。\n\n```swift\nlet set1: Set<Character> = [\"A\", \"B\", \"C\"]\nlet set2: Set<Character> = [\"B\", \"E\", \"F\", \"G\"]\nprint(set1.subtracting(set2))\n// Prints '[\"C\", \"A\"]'\n```\n\n#### Set 判断方法\n\n`isSubset(of:)`：判断是否是另一个 Set 或者 Sequence 的子集。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isSubset(of: bigSet))\n// Prints 'true'\n```\n\n`isSuperset(of:)`：判断是否是另一个 Set 或者 Sequence 的超集。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(bigSet.isSuperset(of: smallSet))\n// Prints 'true'\n```\n\n`isStrictSubset(of:)` ：判断是否是另一个 Set 的**子集**，但是又不等于另一个 Set。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isStrictSubset(of: bigSet))\n// Prints 'true'\n```\n\n`isStrictSuperset(of:)`：判断是否是另一个 Set 的**超集**，但是又不等于另一个 Set。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(bigSet.isStrictSuperset(of: smallSet))\n// Prints 'true'\n```\n\n`isDisjoint(with:)`：判断两个 Set 是否不相交，如果不相交返回 `true`，如果相交返回 `false`。\n\n```swift\nlet smallSet: Set = [1, 2, 3]\nlet bigSet: Set = [1, 2, 3, 4]\nprint(smallSet.isDisjoint(with: bigSet))\n// Prints 'false'\n```\n\n### Set-练习\n\n* 给定一个集合，返回这个集合所有的子集。\n\n#### 思路1-位\n\n解这道题的思想本质上就是元素选与不选的问题，于是就可以想到用二进制来代表选与不选的情况。“1”代表这个元素已经选择，而“0”代表这个元素没有选择。假如三个元素 A B C，那么 101 就代表 B 没有选择，所以 101 代表的子集为 AC。\n\n```swift\nfunc getSubsetsOfSet<T>(_ set1: Set<T>) -> Array<Set<T>> {\n    // 子集有 2^n 个\n    let count = 1 << set1.count\n    // 使用数组，方便使用下标\n    let elements = Array(set1)\n    var subsets = Array<Set<T>>()\n    // 遍历 2^n 个子集对应的下标\n    for i in 0..<count {\n        var subSet = Set<T>()\n        for j in 0..<set1.count {\n            // 当子集的下标对应的二进制位为1时，放入子集中\n            if ((i >> j) & 1) == 1 {\n                subSet.insert(elements[j])\n            }\n        }\n        subsets.append(subSet)\n    }\n    return subsets\n}\n\nlet set1: Set = [\"A\", \"B\", \"C\"]\nlet subSets = getSubsetsOfSet(set1)\nfor subset in subSets {\n    print(subset)\n}\n```\n\n打印结果：\n\n```js\n[]\n[\"A\"]\n[\"B\"]\n[\"A\", \"B\"]\n[\"C\"]\n[\"A\", \"C\"]\n[\"B\", \"C\"]\n[\"A\", \"B\", \"C\"]\n```\n\n打印结果解析：\n\n第0个子集，二进制 000，没有元素\n第1个子集，二进制 001，有一个元素 A\n第2个子集，二进制 010，有一个元素 B\n第3个子集，二进制 011，有两个元素 A B\n第4个子集，二进制 100，有一个元素 C\n第5个子集，二进制 101，有两个元素 A C\n第6个子集，二进制 110，有两个元素 A B\n第7个子集，二进制 111，有三个元素 A B C\n\n使用这种方式有一个注意项，因为二进制的最大长度是64，所有 count 不能超过64位。\n\n#### 思路2-递归\n\n```swift\nfunc getSubsetsOfSet<T>(_ originSet: Set<T>) -> Array<Set<T>> {\n    let elements = Array(originSet)\n    return getSubsetsOfSet2(elements, elements.count - 1)\n}\n\nfunc getSubsetsOfSet2<T>(_ elements: Array<T>, _ index: Int) -> Array<Set<T>> {\n    var subSets = Array<Set<T>>()\n    if index == 0 {\n        // 空集\n        subSets.append(Set<T>())\n        // 只有一个元素\n        var subSet = Set<T>()\n        subSet.insert(elements[index])\n        subSets.append(subSet)\n    } else {\n        subSets = getSubsetsOfSet2(elements, index - 1)\n        for subSet in subSets {\n            // 根据 subSet 生成新的 currentSubSet，向 currentSubSet 中加入新的元素\n            var currentSubSet = subSet\n            currentSubSet.insert(elements[index])\n            subSets.append(currentSubSet)\n        }\n    }\n    return subSets\n}\n\nlet originSet: Set = [\"A\", \"B\", \"C\"]\nlet subSets = getSubsetsOfSet(originSet)\nfor subSet in subSets {\n    print(subSet)\n}\n```\n\n打印结果：\n\n```js\n[]\n[\"A\"]\n[\"B\"]\n[\"A\", \"B\"]\n[\"C\"]\n[\"C\", \"A\"]\n[\"B\", \"C\"]\n[\"A\", \"B\", \"C\"]\n```\n\nindex == 0，一个元素，生成两个子集，`[] [\"A\"]`\nindex == 1，两个元素，生成四个子集，`[] [\"A\"]` `[\"B\"] [\"A\", \"B\"]`\nindex == 2，三个元素，生成八个子集，`[] [\"A\"]` `[\"B\"] [\"A\", \"B\"]` `[\"C\"] [\"A\", \"C\"] [\"B\", \"C\"] [\"A\", \"B\", \"C\"]`\n\n### Set 实现探秘\n\n1. 先看顶层设计，再看底层源码实现。\n2. 从关键方法开始，沿着调用链阅读。\n\n主要包括两个部分：\n\n1. 使用 HashTable 存放 bucket。\n2. 使用 elements 存放 元素。\n\n线性探测的开放寻址法：\n\n![22](集合类/22.png)\n\n左侧是 keys，右侧是 buckets。\n\nJohn Smith 通过计算找到 bucket，因为 bucket 没有被占用，所以可以直接进行存储。\nSam Doe 通过计算得找到 bucket，因为 bucket 被占用，寻找下一个 bucket01，因为 bucket01 没有被占用，所以可以使用 bucket01 进行存储。\n\n#### 从 Set 的 insert 说起\n\n![23](集合类/23.png)\n\n这是 `inser()` 的关键代码，用到的核心方法是 `find()` 和 `insertNew()`。\n\n#### _NativeSet 的 find 方法\n\n`find()`：查找桶（Bucket），找到后直接使用并返回。没有找到则调用 `insertNew()`。主要用到了 HasTable 的 `idealBucket()` 和 `bucket()` 方法。\n\n`_isOccupied()`：判断桶是否被占用。\n\n![24](集合类/24.png)\n\n#### HashTable\n\n`idealBucket()`：找到对应的 bucket。\n`bucket()`：找到当前 bucket 的后一个 bucket。\n\n![25](集合类/25.png)\n\n从 HashTable 的源码可以看到，`bucketMask = bucketCount &-1`，与上 `-1` 可以保证 `bucket.offset & bucketMask` 小于 bucketCount，`hashValue & bucketMask` 小于 bucketCount。\n\n![26](集合类/26.png)\n\n#### _NativeSet 的 insertNew\n\n_isDebugAssertConfiguration() 是 debug 代码，可以直接看 else 里的代码，是调用了 HashTable 的 `insertNew()` 方法。\n\n`insertNew()` 根据 hashValue 找到 bucket，再调用 `uncheckedInitialize()` 插入数据。\n\n![27](集合类/27.png)\n\n#### HashTable 的 insertNew\n\n根据 hashValue 找到可用的 bucket。\n\n![28](集合类/28.png)\n\n#### _NativeSet 的 uncheckedInitialize\n\n根据 `_elements` 首地址值加偏移量 `bucket.offset` 得到插入位置，插入数据。\n\n![29](集合类/29.png)\n\n## 字典\n\n字典：储存无序的互相关联的同一类型的键和同一类型的值的集合。\n\n字典类型的全写方式 `Dictionary<Key, Value>`，简写方式 `[Key: Value]`，建议使用简写方式。其中字典的 Key 必须是可哈希的。\n\n### 创建空字典\n\n1、初始器方式\n\n```swift\nvar dic = Dictionary<String, Int>()\n```\n\n2、简写方式\n\n```swift\nvar dic = [String: Int]()\n```\n\n3、字面量方式\n\n```swift\nvar dic3: Dictionary<String, Int> = [:]\n```\n\n### 字面量创建字典\n\n字典字面量：`[key1:value1, key2:value2, key3:value3]`\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n```\n\n#### count 和 isEmpty\n\n`count`：只读属性，找出 Dictionary 拥有多少元素。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.count)\n// Prints '3'\n```\n\n`isEmpty`：布尔量属性，检查字典是否为空。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.isEmpty)\n// Prints 'false'\n```\n\n### 遍历字典\n\n`For-In`循环\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor (key, value) in dic {\n    print(\"name \\(key), age \\(value)\")\n}\n```\n\n打印结果：\n\n```js\nname lishi, age 19\nname wangwu, age 20\nname zhangsan, age 18\n```\n\n可以通过字典的 keys 或 values 属性遍历字典的键或值的集合。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor key in dic.keys {\n    print(\"name \\(key)\")\n}\n\nfor key in dic.values {\n    print(\"name \\(key)\")\n}\n```\n\n打印结果：\n\n```js\nname zhangsan\nname wangwu\nname lishi\nname 18\nname 20\nname 19\n```\n\nSwift 的 Dictionary 类型是无序的，可以通过对 keys 或 values 调用 sort() 方法排序，来遍历有序的键或值。\n\n```swift\nlet dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\n\nfor key in dic.keys.sorted() {\n    print(\"name \\(key), age \\(dic[key])\")\n}\n```\n\n打印结果：\n\n```swift\nname lishi, age Optional(19)\nname wangwu, age Optional(20)\nname zhangsan, age Optional(18)\n```\n\n### 操作字典\n\n#### 添加或更新元素\n\n1、使用下标添加或更新元素。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic[\"zhangsan\"] = 28  // '[\"lishi\": 19, \"zhangsan\": 28, \"wangwu\": 20]'\n```\n\n2、使用 `updateValue(_:forKey)` 方法添加或更新元素，返回一个字典值类型的可选项值。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic.updateValue(29, forKey: \"lishi\")  // '[\"wangwu\": 20, \"zhangsan\": 18, \"lishi\": 29]'\n```\n\n#### 字典-移除元素\n\n1、可以使用下标脚本语法给一个键赋值 `nil`，实现从字典中移除该键值对。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\ndic[\"zhangsan\"] = nil  // '[\"lishi\": 19, \"wangwu\": 20]'\n```\n\n2、也可以使用 `removeValue(forKey:)` 从字典中移除键值对。\n\n```swift\nvar dic = [\"zhangsan\": 18, \"lishi\": 19, \"wangwu\": 20]\nprint(dic.removeValue(forKey: \"zhangsan\") ?? 0)  // '18'\nprint(dic)                                       // '[\"lishi\": 19, \"wangwu\": 20]'\nprint(dic.removeValue(forKey: \"zhangsan\"))       // 'nil'\n```\n\n在使用这个方法移除键值对时，如果键值对存在则返回其 `value`，如果不存在则返回 `nil`。\n\n#### 合并两个字典\n\n`merge(_:uniquingKeysWith:)`\n\n1、保留旧值\n\n```swift\nvar dictionary = [\"a\": 1, \"b\": 2]\ndictionary.merge([\"a\": 3, \"c\": 4]) { (current, _) in current }\nprint(dictionary)\n// Prints '[\"b\": 2, \"c\": 4, \"a\": 1]'\n```\n\n2、保留新值\n\n```swift\nvar dictionary = [\"a\": 1, \"b\": 2]\ndictionary.merge([\"a\": 5, \"d\": 6]) { (_, new) in new }\nprint(dictionary)\n// Prints '[\"a\": 5, \"b\": 2, \"d\": 6, \"c\": 4]'\n```\n\n#### firstIndex\n\n虽然字典是无序的，但是每个kv对（键值对）在扩容之前的位置是确定的。可以通过 `firstIndex` 获取某个kv对的位置。\n\n```swift\nlet imagePaths = [\"star\": \"/glyphs/stat.png\",\n                  \"protrait\": \"/images/content/portrait.jpg\",\n                  \"spacer\": \"/images/shared/spacer.gif\"]\nlet glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix(\"/glyphs\") })\n\nif let index = glyphIndex {\n    print(index)\n    print(\"The '\\(imagePaths[index].key)' image is a glyph.\")\n} else {\n    print(\"No glyphs found!\")\n}\n```\n\n打印结果：\n\n```js\nIndex(_variant: Swift.Dictionary<Swift.String, Swift.String>.Index._Variant.native(Swift._HashTable.Index(bucket: Swift._HashTable.Bucket(offset: 1), age: -1384877248)))\nThe 'star' image is a glyph.\n```\n\n如果需要保持顺序的kv对，可以是用 KeyValuePairs。\n\n```swift\nlet recordTimes: KeyValuePairs = [\"Florence Griffith-Joyner\": 10.49,\n                                  \"Evelyn Ashford\": 10.76,\n                                  \"Evelyn Ashford\": 10.79,\n                                  \"Marlies Gohr\": 10.81]\nprint(recordTimes.first)\n// Prints 'Optional((key: \"Florence Griffith-Joyner\", value: 10.49))'\n```\n\n### 字典实现探秘\n\n从关键方法开始，沿着调用链阅读。从 set 方法开始。\n\n#### 从下标操作说起\n\n字典的关键操作跟 set 方法类似，就是下标操作。\n\n`subscript(key:)`：字典的 set 方法，参数是 `Key`，返回值是可选 `Value?`。\n\n![30](集合类/30.png)\n\n`lookup()`：get 方法通过 lookup() 方法找到对应的 value。\n\n`setValue()`：写入新值。\n\n#### Dictionary._Variant 的 setValue\n\n`setValue(_ value: __owned Value, forKey key: Key)`：写入新值。需要两个参数，值、键。\n\n源码包括 OC 和 Swift 两个实现，最后两行是 Swift 实现部分。\n\n![31](集合类/31.png)\n\n调用链：`setValue()` → `asNative.setValue()`。\n\n`isUniquelyReferenced()`：判断当前 Dictionary 是否唯一。\n\n`asNative` 是 `_NativeDictionary`，主要负责实现 `setValue()` 方法👇。\n\n#### _NativeDictionary 的 setValue\n\n`setValue(_ value: __owned Value, forKey key: Key, isUnique: Bool)`：可以看到需要三个参数，值、键、是否唯一。\n\n![32](集合类/32.png)\n\n实现部分和 `insertNew()` 类似，采用的也是开放寻址法。\n\n如果找到了，则根据 `_values` 首地址值加上桶的偏移量 `bucket.offset` 计算出位置，存放 value。\n\n如果没找到，则调用 `_insert()` 方法👇。\n\n#### _NativeDictionary 的_insert\n\n`_insert(at bucket: Bucket, key: __owned Key, value: __owned Value)`：需要三个参数，桶、键、值。\n\n![33](集合类/33.png)\n\n`hashTable.insert(bucket)`：将桶插入到哈希表里。\n\n`uncheckedInitialize()`：保存键值。\n\n>两个关键操作：\n>\n>1. 保存桶到哈希表。\n>2. 保存键值。\n\n#### _NativeDictionary 的 uncheckedInitialize\n\n`uncheckedInitialize(at bucket: Bucket, toKey key: __owned Key, value: __owned Value)`：需要三个参数，桶、键、值。\n\n![34](集合类/34.png)\n\n`(_keys + bucket.offset).initialize(to: key)`：根据 _keys 的首地址加上桶的偏移量 bucket.offset 计算出位置，存放 key。\n\n`(_values + bucket.offset).initialize(to: value)`：根据 _values 的首地址加上桶的偏移量 bucket.offset 计算出位置，存放 key。\n\n>两个关键操作：\n>\n>1. 保存key。\n>2. 保存value。\n\n#### _NativeDictionary 的 findKey\n\n`find(_ key: Key, hashValue: Int) -> (bucket: Bucket, found: Bool)`：需要两个参数，键、键的哈希值。返回结果包括两个内容，桶、是否存在。\n\n![35](集合类/35.png)\n\n`idealBucket()`：根据哈希值查找桶。\n\n`_isOccupied()`：桶是否被占用。\n\n`bucket(wrappedAfter:)`：从当前 bucket 开始向后查找桶。\n\n>两个关键操作：\n>\n>1. 根据哈希值查找对应的桶。\n>2. 查找没有被占用的桶。\n","slug":"Swift/集合类","published":1,"updated":"2023-08-22T09:52:14.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgun001uaq7ktuhpuj4v"},{"title":"多线程 — GCD","date":"2016-06-13T16:00:00.000Z","_content":"# 简介\nGCD 全称为 Grand Central Dispatch，是 libdispatch 的市场名称，而 libdispatch 是 Apple 的一个库，其为并发代码在 iOS 和 macOS 的多核硬件上执行提供支持。确切地说 GCD 是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过 GCD 来管理线程，从而解决线程被创建的问题。\n\n<!-- more -->\n![gcd_oc](http://o7ttfnm00.bkt.clouddn.com/jiaotong.jpg)\n\n* [官方文档](https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/)\n* [WWDC](https://developer.apple.com/videos/play/wwdc2015/718/)\n***\n# 创建队列\n## dispatch_queue_create\n主队列：一个特殊的串行队列，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。\n\n```\ndispatch_queue_t queue = dispatch_get_main_queue(); //OC\nlet queue = dispatch_get_main_queue()               //Swift\n```\n\n手动创建队列：可以创建 串行队列, 也可以创建 并行队列。第一个参数是标识符，第二个参数用来表示创建的队列是串行的还是并行的。DISPATCH_QUEUE_SERIAL / NULL 串行队列；DISPATCH_QUEUE_CONCURRENT 并行队列。\n\n```\n//OC\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", NULL);\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n//Swift\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", nil);\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_SERIAL)\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_CONCURRENT)\n```\n\n***\n# 创建任务\n## dispatch\\_async / dispatch\\_sync\n同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行；\n异步派发(async)也不绝对会另开线程，例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n* dispatch_sync 同步任务：会阻塞当前线程；\n* dispatch_async 异步任务：不会阻塞当前线程\n\n```\n//OC\ndispatch_sync(<#queue#>, ^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n});\ndispatch_async(<#queue#>, ^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n});\n\n//Swift\ndispatch_sync(<#queue#>, { () -> Void in\n    println(NSThread.currentThread())\n})\ndispatch_async(<#queue#>, { () -> Void in\n    println(NSThread.currentThread())\n})\n```\n***\n## dispatch_after\ndispatch_after只是延时提交block，不是延时立刻执行。\n\n```\ndouble delayInSeconds = 2.0;\ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n    [self bar];\n});\n```\n\n## dispatch_set_target_queue\ndispatch_set_target_queue可以设置queue的优先级，也可以使多个serial queue在目标queue上一次只有一个执行。\n\n（如果将多个串行的queue使用dispatch\\_set\\_target\\_queue指定到了同一目标，那么多个串行queue在目标queue上就是同步执行的，不再是并行执行。\n例如，把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这就可以使用dispatch\\_set\\_target\\_queue了。）\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t firstQueue = dispatch_queue_create(\"com.starming.gcddemo.firstqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t secondQueue = dispatch_queue_create(\"com.starming.gcddemo.secondqueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_set_target_queue(firstQueue, serialQueue);\ndispatch_set_target_queue(secondQueue, serialQueue);\n\ndispatch_async(firstQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:3.f];\n});\ndispatch_async(secondQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:2.f];\n});\ndispatch_async(secondQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.f];\n});\n```\n\n打印结果1、2、3。\n***\n## dispatch_barrier_async / dispatch_barrier_sync\ndispatch_barrier_async 这个函数可以设置同步执行的block，它会等到在它加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。\n\ndispatch_barrier_sync 同上，除了它是同步返回函数。\n```\n//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。\ndispatch_queue_t dataQueue = dispatch_queue_create(\"com.starming.gcddemo.dataqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_async(dataQueue, ^{\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"read 1\");\n});\ndispatch_async(dataQueue, ^{\n    NSLog(@\"read 2\");\n});\n//等待前面的都完成，在执行barrier后面的\ndispatch_barrier_async(dataQueue, ^{\n    NSLog(@\"write 1\");\n    [NSThread sleepForTimeInterval:1];\n});\ndispatch_async(dataQueue, ^{\n    [NSThread sleepForTimeInterval:1.f];\n    NSLog(@\"read 3\");\n});\ndispatch_async(dataQueue, ^{\n    NSLog(@\"read 4\");\n});\n```\n\n打印结果：read 1、read 2、write 1、read 3、read 4。\n\n***\n\n## dispatch_apply\ndispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。\n\n需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回，所以这里会阻塞主线程，如需异步返回，使用dispatch_async包一下就不会阻塞了。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_apply(10, concurrentQueue, ^(size_t i) {\n    NSLog(@\"%zu\",i);\n});\ndispatch_async(dispatch_get_main_queue(), ^{\n    dispatch_apply(10, concurrentQueue, ^(size_t i) {\n        NSLog(@\"%zu\",i);\n    });\n});\nNSLog(@\"The end\");\n//打印结果：0、2、4、1、3、6、5、7、9、8、The end、0、4、1、3、5、2、8、6、7、9。\n```\n\n对比：\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\nif (explode) {\n    //有问题的情况，可能会死锁\n    for (int i = 0; i < 999 ; i++) {\n        dispatch_async(concurrentQueue, ^{\n            NSLog(@\"wrong %d\",i);\n            //do something hard\n        });\n    }\n} else {\n    //会优化很多，能够利用GCD管理\n    dispatch_apply(999, concurrentQueue, ^(size_t i){\n        NSLog(@\"correct %zu\",i);\n        //do something hard\n    });\n    NSLog(@\"----\");\n}\n```\n\n***\n\n# Dispatch Block\n## dispatch\\_block_create\n自己创建block并添加到queue中去执行。并且，在创建block时可以通过设置QoS，指定block对应的优先级，在dispatch\\_block\\_create\\_with\\_qos\\_class中指定QoS类别即可。\n\n```\n//normal way\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_block_t block = dispatch_block_create(0, ^{\n    NSLog(@\"run block\");\n});\ndispatch_async(concurrentQueue, block);\n\n//QOS way\ndispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{\n    NSLog(@\"run qos block\");\n});\ndispatch_async(concurrentQueue, qosBlock);\n```\n\n***\n\n## dispatch\\_block_wait\n可以根据dispatch block来设置等待时间，参数DISPATCH\\_TIME_FOREVER会一直等待block结束。\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t block = dispatch_block_create(0, ^{\n    NSLog(@\"star\");   \n    [NSThread sleepForTimeInterval:5.f];\n    NSLog(@\"end\");\n});\ndispatch_async(serialQueue, block);\n//设置DISPATCH_TIME_FOREVER后，会一直等到前面任务都完成\ndispatch_block_wait(block, DISPATCH_TIME_FOREVER);\nNSLog(@\"ok, now can go on\");//打印结果：star、end、ok, now can go on。\n```\n\n***\n\n## dispatch\\_block_notify\ndispatch\\_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block，函数的原型。\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.Kevin.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t firstBlock = dispatch_block_create(0, ^{\n    NSLog(@\"first block start\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"first block end\");\n});\ndispatch_async(serialQueue, firstBlock);\ndispatch_block_t secondBlock = dispatch_block_create(0, ^{\n    NSLog(@\"second block run\");\n});\n//first block执行完才在serial queue中执行second block\ndispatch_block_notify(firstBlock, serialQueue, secondBlock);\n\n//打印结果：first block start、first block end、second block run。\n```\n\n***\n## dispatch\\_block_cancel\niOS8后GCD支持对dispatch block的取消\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.Kevin.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t firstBlock = dispatch_block_create(0, ^{\n    NSLog(@\"first block start\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"first block end\");\n});\ndispatch_block_t secondBlock = dispatch_block_create(0, ^{\n    NSLog(@\"second block run\");\n});\ndispatch_async(serialQueue, firstBlock);\ndispatch_async(serialQueue, secondBlock);\n//取消secondBlock\ndispatch_block_cancel(secondBlock);\n//打印结果：first block start、first block end。\n```\n\n***\n\n# Dispatch_groups\n当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用 dispatch\\_group 来实现了，dispatch\\_group 能很方便的解决同步的问题。dispatch\\_group_create可以创建一个group对象，然后可以添加block到该组里面。\n\n***\n## dispatch\\_group_create\n创建dispatch\\_group_t\n\n```\ndispatch_group_t group = dispatch_group_create();\n```\n***\n## dispatch\\_group_async\n自己创建队列时，当然就用dispatch\\_group_async函数，简单有效。\n\n```\ndispatch_group_async(group, queue, ^{\n    //Do you work...\n});\n```\n\n***\n\n## dispatch\\_group_wait\ndispatch\\_group_wait会同步地等待group中所有的block执行完毕后才继续执行,类似于dispatch barrier\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.Kevin.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\n//在group中添加队列的block\ndispatch_group_async(group, concurrentQueue, ^{\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"1\");\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n});\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\nNSLog(@\"can continue\");//打印结果：2、1、can continue。\n```\n\n***\n\n## dispatch\\_group_notify\n功能与dispatch\\_group\\_wait类似，不过该过程是异步的，不会阻塞该线程，dispatch\\_group\\_notify有三个参数,第一个参数指定要观察的group，第二个参数指定block待执行的队列，第三个参数指定group中所有任务执行完毕之后要执行的block。\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.Kevin.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, concurrentQueue, ^{\n   [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"1\");\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n});\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    NSLog(@\"end\");\n});\n[NSThread sleepForTimeInterval:2.f];\nNSLog(@\"can continue\");//打印结果：2、can continue、1、end。\n```\n\n***\n## dispatch\\_group\\_enter / dispatch\\_group\\_leave\n\n```\nAFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];\n\n//Enter group\ndispatch_group_enter(group);\n[manager GET:@\"http://www.baidu.com\" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {\n    \n    //Leave group\n    dispatch_group_leave(group);\n}    failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n\n    //Leave group\n    dispatch_group_leave(group);\n}];\n```\n\n***\n\n## dispatch\\_semaphore_create\ndispatch semaphore用来做解决一些同步的问题，dispatch\\_semaphore\\_create会创建一个信号量，该函数需要传递一个信号值，dispatch\\_semaphore\\_signal会使信号值加1，如果信号值的大小等于1，dispatch\\_semaphore\\_wait会使信号值减1，并继续往下走，如果信号值为0，则等待。\n\n```\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    NSLog(@\"start\");\n    [NSThread sleepForTimeInterval:1.f];\n    NSLog(@\"semaphore +1\");\n    dispatch_semaphore_signal(semaphore); //+1 semaphore\n});\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\nNSLog(@\"continue\");//打印结果：start、semaphore +1、continue。\n```\n\n***\n# Dispatch Source\ndispatch源（dispatch source）和RunLoop源概念上有些类似的地方，而且使用起来更简单。要很好地理解dispatch源，其实把它看成一种特别的生产消费模式。dispatch源好比生产的数据，当有新数据时，会自动在dispatch指定的队列（即消费队列）上运行相应地block，生产和消费同步是dispatch源会自动管理的。\n\nDispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表：\n\n| Methods                              | explain     |\n| ------------------------------------ |:-----------:|\n| DISPATCH_SOURCE\\_TYPE\\_DATA\\_ADD        | 变量增加      | \n| DISPATCH_SOURCE\\_TYPE\\_DATA\\_OR         | 变量OR       | \n| DISPATCH_SOURCE\\_TYPE\\_MACH\\_SEND       | Mach端口发送  |\n| DISPATCH_SOURCE\\_TYPE\\_MACH\\_RECV       | MACH端口接收  |\n| DISPATCH_SOURCE\\_TYPE\\_MEMORYPRESSURE  | 内存压力  |\n| DISPATCH_SOURCE\\_TYPE\\_PROC            | 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号  |\n| DISPATCH_SOURCE\\_TYPE\\_READ            | IO操作，如对文件的操作、socket操作的读响应  |\n| DISPATCH_SOURCE\\_TYPE\\_SIGNAL          | 接收到UNIX信号时响应 |\n| DISPATCH_SOURCE\\_TYPE\\_TIMER           | 定时器  |\n| DISPATCH_SOURCE\\_TYPE\\_VNODE           | 文件状态监听，文件被删除、移动、重命名  |\n| DISPATCH_SOURCE\\_TYPE\\_WRITE           | IO操作，如对文件的操作、socket操作的写响应  |\n\n####方法：\n*  dispatch\\_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。\n*  dispatch_source\\_set\\_event\\_handler：设置事件处理handler\n*  dispatch\\_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。\n\n```\n//监视文件夹内文件变化\nNSURL *directoryURL; //指定需要监听的文件夹路径\nint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);\nif (fd < 0) {\n    char buffer[80];\n    strerror_r(errno, buffer, sizeof(buffer));\n    NSLog(@\"Unable to open \\\"%@\\\": %s (%d)\", [directoryURL path], buffer, errno);\n    return;\n}\n\n//创建dispatch源，这里使用加法来合并dispatch源数据，最后一个参数是指定dispatch队列\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,\n                                                  DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);\n\n//设置响应dispatch源事件的block，在dispatch源指定的队列上运行\ndispatch_source_set_event_handler(source, ^(){\n    \n    //可以通过dispatch_source_get_data(source)来得到dispatch源数据\n    unsigned long const data = dispatch_source_get_data(source);\n    if (data & DISPATCH_VNODE_WRITE) {\n        NSLog(@\"The directory changed.\");\n    }\n    if (data & DISPATCH_VNODE_DELETE) {\n        NSLog(@\"The directory has been deleted.\");\n    }\n});\ndispatch_source_set_cancel_handler(source, ^(){\n    close(fd);\n});\n//dispatch源创建后处于suspend状态，所以需要启动dispatch源\ndispatch_resume(source);\n//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听\n```\n\n***\n\n## dispatch\\_time_t\n\n```\ndispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0/*延迟执行时间*/ * NSEC_PER_SEC));\n\ndispatch_after(delayTime, dispatch_get_main_queue(), ^{\n    [weakSelf delayMethod];\n});\n```\n\n***\n\n## dispatch_source\\_set\\_timer\n\n```\ndispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway);\n```\n\n第一个参数:定时器对象；第二个参数:DISPATCH\\_TIME_NOW 表示从现在开始计时；第三个参数:间隔时间 GCD里面的时间最小单位为 纳秒；第四个参数:精准度(表示允许的误差,0表示绝对精准)。  \n\nNSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer。\n\n   \nNSEC\\_PER_SEC 1000000000ull  \nUSEC\\_PER_SEC 1000000ull  \nNSEC\\_PER_USEC 1000ull  \n\nNSEC：纳秒；USEC：微妙；SEC：秒；PER：每。\n\n```\n//第一个参数代表：dispatch source类型，最后一个是block会进入的queue，用来执行事件处理器和取消处理器，第二三个参数在会根据source类型设置。\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);\n\n//设置事件的处理handler\ndispatch_source_set_event_handler(source, ^(){\n    NSLog(@\"Time flies.\");\n});\n\n//5秒触发一次，误差100毫秒\ndispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);\n\n//开始处理定时器事件，dispatch_suspend暂停处理事件\ndispatch_resume(source);\n\n```\n\n***\n\n## dispatch_suspend和dispatch\\_resume\n*  dispatch_suspend 挂起队列\n*  dispatch_resume  恢复队列\n\ndispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"me.kevin.gcd\", DISPATCH_QUEUE_SERIAL);\n\n//提交第一个block，延时5秒打印。\ndispatch_async(queue, ^{\n    [NSThread sleepForTimeInterval:5];\n    NSLog(@\"After 5 seconds...\");\n});\n\n//提交第二个block，也是延时5秒打印\ndispatch_async(queue, ^{\n    [NSThread sleepForTimeInterval:5];\n    NSLog(@\"After 5 seconds again...\");\n});\n\n//延时一秒\nNSLog(@\"sleep 1 second...\");\n[NSThread sleepForTimeInterval:1];\n\n//挂起队列\nNSLog(@\"suspend...\");\ndispatch_suspend(queue);\n\n//延时10秒\nNSLog(@\"sleep 10 second...\");\n[NSThread sleepForTimeInterval:10];\n\n//恢复队列\nNSLog(@\"resume...\");\ndispatch_resume(queue);\n```\n\n可知，在dispatch_suspend挂起队列后，第一个block还是在运行，并且正常输出。\n结合文档，我们可以得知，dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。\n\n***\n\n# 死锁！\n## dispatch_sync导致的死锁\n在main线程使用“同步”方法提交Block，必定会死锁：\n\n```\ndispatch_sync(dispatch_get_main_queue(), ^{\n    NSLog(@\"I am block...\");\n});\n```\n\n嵌套调用可能就会造成死锁：\n\n```\n- (void)updateUI1 {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"Update ui 1\");\n\n        //死锁！\n        [self updateUI2];\n    });\n}\n- (void)updateUI2 {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"Update ui 2\");\n    });\n}\n```\n\n其它情况：\n\n```\n- (void)deadLockCase1 {\n    NSLog(@\"1\");\n    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n- (void)deadLockCase2 {\n    NSLog(@\"1\");\n    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行\n    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n- (void)deadLockCase3 {\n    dispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\n    NSLog(@\"1\");\n    dispatch_async(serialQueue, ^{\n        NSLog(@\"2\");\n        //串行队列里面同步一个串行队列就会死锁\n        dispatch_sync(serialQueue, ^{\n            NSLog(@\"3\");\n        });\n        NSLog(@\"4\");\n    });\n    NSLog(@\"5\");\n}\n```\n\n***\n\n## dispatch_apply导致的死锁:\n\n```\n//在串行队列里嵌套使用dispatch_apply\ndispatch_queue_t queue = dispatch_queue_create(\"me.tutuge.test.gcd\", DISPATCH_QUEUE_SERIAL);\n\ndispatch_apply(3, queue, ^(size_t i) {\n\tNSLog(@\"apply loop: %zu\", i);\n\n    //再来一个dispatch_apply！死锁！\n\tdispatch_apply(3, queue, ^(size_t j) {\n\t\tNSLog(@\"apply loop inside %zu\", j);\n\t});\n});\n```\n","source":"_posts/iOS/GCD.md","raw":"---\ntitle: 多线程 — GCD\ndate: 2016-06-14 \ntags: OC\n---\n# 简介\nGCD 全称为 Grand Central Dispatch，是 libdispatch 的市场名称，而 libdispatch 是 Apple 的一个库，其为并发代码在 iOS 和 macOS 的多核硬件上执行提供支持。确切地说 GCD 是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过 GCD 来管理线程，从而解决线程被创建的问题。\n\n<!-- more -->\n![gcd_oc](http://o7ttfnm00.bkt.clouddn.com/jiaotong.jpg)\n\n* [官方文档](https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/)\n* [WWDC](https://developer.apple.com/videos/play/wwdc2015/718/)\n***\n# 创建队列\n## dispatch_queue_create\n主队列：一个特殊的串行队列，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。\n\n```\ndispatch_queue_t queue = dispatch_get_main_queue(); //OC\nlet queue = dispatch_get_main_queue()               //Swift\n```\n\n手动创建队列：可以创建 串行队列, 也可以创建 并行队列。第一个参数是标识符，第二个参数用来表示创建的队列是串行的还是并行的。DISPATCH_QUEUE_SERIAL / NULL 串行队列；DISPATCH_QUEUE_CONCURRENT 并行队列。\n\n```\n//OC\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", NULL);\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n//Swift\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", nil);\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_SERIAL)\nlet queue = dispatch_queue_create(\"tk.bourne.testQueue\", DISPATCH_QUEUE_CONCURRENT)\n```\n\n***\n# 创建任务\n## dispatch\\_async / dispatch\\_sync\n同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行；\n异步派发(async)也不绝对会另开线程，例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n* dispatch_sync 同步任务：会阻塞当前线程；\n* dispatch_async 异步任务：不会阻塞当前线程\n\n```\n//OC\ndispatch_sync(<#queue#>, ^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n});\ndispatch_async(<#queue#>, ^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n});\n\n//Swift\ndispatch_sync(<#queue#>, { () -> Void in\n    println(NSThread.currentThread())\n})\ndispatch_async(<#queue#>, { () -> Void in\n    println(NSThread.currentThread())\n})\n```\n***\n## dispatch_after\ndispatch_after只是延时提交block，不是延时立刻执行。\n\n```\ndouble delayInSeconds = 2.0;\ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n    [self bar];\n});\n```\n\n## dispatch_set_target_queue\ndispatch_set_target_queue可以设置queue的优先级，也可以使多个serial queue在目标queue上一次只有一个执行。\n\n（如果将多个串行的queue使用dispatch\\_set\\_target\\_queue指定到了同一目标，那么多个串行queue在目标queue上就是同步执行的，不再是并行执行。\n例如，把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这就可以使用dispatch\\_set\\_target\\_queue了。）\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t firstQueue = dispatch_queue_create(\"com.starming.gcddemo.firstqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t secondQueue = dispatch_queue_create(\"com.starming.gcddemo.secondqueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_set_target_queue(firstQueue, serialQueue);\ndispatch_set_target_queue(secondQueue, serialQueue);\n\ndispatch_async(firstQueue, ^{\n    NSLog(@\"1\");\n    [NSThread sleepForTimeInterval:3.f];\n});\ndispatch_async(secondQueue, ^{\n    NSLog(@\"2\");\n    [NSThread sleepForTimeInterval:2.f];\n});\ndispatch_async(secondQueue, ^{\n    NSLog(@\"3\");\n    [NSThread sleepForTimeInterval:1.f];\n});\n```\n\n打印结果1、2、3。\n***\n## dispatch_barrier_async / dispatch_barrier_sync\ndispatch_barrier_async 这个函数可以设置同步执行的block，它会等到在它加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。\n\ndispatch_barrier_sync 同上，除了它是同步返回函数。\n```\n//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。\ndispatch_queue_t dataQueue = dispatch_queue_create(\"com.starming.gcddemo.dataqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_async(dataQueue, ^{\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"read 1\");\n});\ndispatch_async(dataQueue, ^{\n    NSLog(@\"read 2\");\n});\n//等待前面的都完成，在执行barrier后面的\ndispatch_barrier_async(dataQueue, ^{\n    NSLog(@\"write 1\");\n    [NSThread sleepForTimeInterval:1];\n});\ndispatch_async(dataQueue, ^{\n    [NSThread sleepForTimeInterval:1.f];\n    NSLog(@\"read 3\");\n});\ndispatch_async(dataQueue, ^{\n    NSLog(@\"read 4\");\n});\n```\n\n打印结果：read 1、read 2、write 1、read 3、read 4。\n\n***\n\n## dispatch_apply\ndispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。\n\n需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回，所以这里会阻塞主线程，如需异步返回，使用dispatch_async包一下就不会阻塞了。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_apply(10, concurrentQueue, ^(size_t i) {\n    NSLog(@\"%zu\",i);\n});\ndispatch_async(dispatch_get_main_queue(), ^{\n    dispatch_apply(10, concurrentQueue, ^(size_t i) {\n        NSLog(@\"%zu\",i);\n    });\n});\nNSLog(@\"The end\");\n//打印结果：0、2、4、1、3、6、5、7、9、8、The end、0、4、1、3、5、2、8、6、7、9。\n```\n\n对比：\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\nif (explode) {\n    //有问题的情况，可能会死锁\n    for (int i = 0; i < 999 ; i++) {\n        dispatch_async(concurrentQueue, ^{\n            NSLog(@\"wrong %d\",i);\n            //do something hard\n        });\n    }\n} else {\n    //会优化很多，能够利用GCD管理\n    dispatch_apply(999, concurrentQueue, ^(size_t i){\n        NSLog(@\"correct %zu\",i);\n        //do something hard\n    });\n    NSLog(@\"----\");\n}\n```\n\n***\n\n# Dispatch Block\n## dispatch\\_block_create\n自己创建block并添加到queue中去执行。并且，在创建block时可以通过设置QoS，指定block对应的优先级，在dispatch\\_block\\_create\\_with\\_qos\\_class中指定QoS类别即可。\n\n```\n//normal way\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_block_t block = dispatch_block_create(0, ^{\n    NSLog(@\"run block\");\n});\ndispatch_async(concurrentQueue, block);\n\n//QOS way\ndispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{\n    NSLog(@\"run qos block\");\n});\ndispatch_async(concurrentQueue, qosBlock);\n```\n\n***\n\n## dispatch\\_block_wait\n可以根据dispatch block来设置等待时间，参数DISPATCH\\_TIME_FOREVER会一直等待block结束。\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t block = dispatch_block_create(0, ^{\n    NSLog(@\"star\");   \n    [NSThread sleepForTimeInterval:5.f];\n    NSLog(@\"end\");\n});\ndispatch_async(serialQueue, block);\n//设置DISPATCH_TIME_FOREVER后，会一直等到前面任务都完成\ndispatch_block_wait(block, DISPATCH_TIME_FOREVER);\nNSLog(@\"ok, now can go on\");//打印结果：star、end、ok, now can go on。\n```\n\n***\n\n## dispatch\\_block_notify\ndispatch\\_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block，函数的原型。\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.Kevin.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t firstBlock = dispatch_block_create(0, ^{\n    NSLog(@\"first block start\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"first block end\");\n});\ndispatch_async(serialQueue, firstBlock);\ndispatch_block_t secondBlock = dispatch_block_create(0, ^{\n    NSLog(@\"second block run\");\n});\n//first block执行完才在serial queue中执行second block\ndispatch_block_notify(firstBlock, serialQueue, secondBlock);\n\n//打印结果：first block start、first block end、second block run。\n```\n\n***\n## dispatch\\_block_cancel\niOS8后GCD支持对dispatch block的取消\n\n```\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.Kevin.serialqueue\", DISPATCH_QUEUE_SERIAL);\ndispatch_block_t firstBlock = dispatch_block_create(0, ^{\n    NSLog(@\"first block start\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"first block end\");\n});\ndispatch_block_t secondBlock = dispatch_block_create(0, ^{\n    NSLog(@\"second block run\");\n});\ndispatch_async(serialQueue, firstBlock);\ndispatch_async(serialQueue, secondBlock);\n//取消secondBlock\ndispatch_block_cancel(secondBlock);\n//打印结果：first block start、first block end。\n```\n\n***\n\n# Dispatch_groups\n当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用 dispatch\\_group 来实现了，dispatch\\_group 能很方便的解决同步的问题。dispatch\\_group_create可以创建一个group对象，然后可以添加block到该组里面。\n\n***\n## dispatch\\_group_create\n创建dispatch\\_group_t\n\n```\ndispatch_group_t group = dispatch_group_create();\n```\n***\n## dispatch\\_group_async\n自己创建队列时，当然就用dispatch\\_group_async函数，简单有效。\n\n```\ndispatch_group_async(group, queue, ^{\n    //Do you work...\n});\n```\n\n***\n\n## dispatch\\_group_wait\ndispatch\\_group_wait会同步地等待group中所有的block执行完毕后才继续执行,类似于dispatch barrier\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.Kevin.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\n//在group中添加队列的block\ndispatch_group_async(group, concurrentQueue, ^{\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"1\");\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n});\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\nNSLog(@\"can continue\");//打印结果：2、1、can continue。\n```\n\n***\n\n## dispatch\\_group_notify\n功能与dispatch\\_group\\_wait类似，不过该过程是异步的，不会阻塞该线程，dispatch\\_group\\_notify有三个参数,第一个参数指定要观察的group，第二个参数指定block待执行的队列，第三个参数指定group中所有任务执行完毕之后要执行的block。\n\n```\ndispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.Kevin.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, concurrentQueue, ^{\n   [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"1\");\n});\ndispatch_group_async(group, concurrentQueue, ^{\n    NSLog(@\"2\");\n});\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    NSLog(@\"end\");\n});\n[NSThread sleepForTimeInterval:2.f];\nNSLog(@\"can continue\");//打印结果：2、can continue、1、end。\n```\n\n***\n## dispatch\\_group\\_enter / dispatch\\_group\\_leave\n\n```\nAFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];\n\n//Enter group\ndispatch_group_enter(group);\n[manager GET:@\"http://www.baidu.com\" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {\n    \n    //Leave group\n    dispatch_group_leave(group);\n}    failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n\n    //Leave group\n    dispatch_group_leave(group);\n}];\n```\n\n***\n\n## dispatch\\_semaphore_create\ndispatch semaphore用来做解决一些同步的问题，dispatch\\_semaphore\\_create会创建一个信号量，该函数需要传递一个信号值，dispatch\\_semaphore\\_signal会使信号值加1，如果信号值的大小等于1，dispatch\\_semaphore\\_wait会使信号值减1，并继续往下走，如果信号值为0，则等待。\n\n```\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    NSLog(@\"start\");\n    [NSThread sleepForTimeInterval:1.f];\n    NSLog(@\"semaphore +1\");\n    dispatch_semaphore_signal(semaphore); //+1 semaphore\n});\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\nNSLog(@\"continue\");//打印结果：start、semaphore +1、continue。\n```\n\n***\n# Dispatch Source\ndispatch源（dispatch source）和RunLoop源概念上有些类似的地方，而且使用起来更简单。要很好地理解dispatch源，其实把它看成一种特别的生产消费模式。dispatch源好比生产的数据，当有新数据时，会自动在dispatch指定的队列（即消费队列）上运行相应地block，生产和消费同步是dispatch源会自动管理的。\n\nDispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表：\n\n| Methods                              | explain     |\n| ------------------------------------ |:-----------:|\n| DISPATCH_SOURCE\\_TYPE\\_DATA\\_ADD        | 变量增加      | \n| DISPATCH_SOURCE\\_TYPE\\_DATA\\_OR         | 变量OR       | \n| DISPATCH_SOURCE\\_TYPE\\_MACH\\_SEND       | Mach端口发送  |\n| DISPATCH_SOURCE\\_TYPE\\_MACH\\_RECV       | MACH端口接收  |\n| DISPATCH_SOURCE\\_TYPE\\_MEMORYPRESSURE  | 内存压力  |\n| DISPATCH_SOURCE\\_TYPE\\_PROC            | 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号  |\n| DISPATCH_SOURCE\\_TYPE\\_READ            | IO操作，如对文件的操作、socket操作的读响应  |\n| DISPATCH_SOURCE\\_TYPE\\_SIGNAL          | 接收到UNIX信号时响应 |\n| DISPATCH_SOURCE\\_TYPE\\_TIMER           | 定时器  |\n| DISPATCH_SOURCE\\_TYPE\\_VNODE           | 文件状态监听，文件被删除、移动、重命名  |\n| DISPATCH_SOURCE\\_TYPE\\_WRITE           | IO操作，如对文件的操作、socket操作的写响应  |\n\n####方法：\n*  dispatch\\_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。\n*  dispatch_source\\_set\\_event\\_handler：设置事件处理handler\n*  dispatch\\_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。\n\n```\n//监视文件夹内文件变化\nNSURL *directoryURL; //指定需要监听的文件夹路径\nint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);\nif (fd < 0) {\n    char buffer[80];\n    strerror_r(errno, buffer, sizeof(buffer));\n    NSLog(@\"Unable to open \\\"%@\\\": %s (%d)\", [directoryURL path], buffer, errno);\n    return;\n}\n\n//创建dispatch源，这里使用加法来合并dispatch源数据，最后一个参数是指定dispatch队列\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,\n                                                  DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);\n\n//设置响应dispatch源事件的block，在dispatch源指定的队列上运行\ndispatch_source_set_event_handler(source, ^(){\n    \n    //可以通过dispatch_source_get_data(source)来得到dispatch源数据\n    unsigned long const data = dispatch_source_get_data(source);\n    if (data & DISPATCH_VNODE_WRITE) {\n        NSLog(@\"The directory changed.\");\n    }\n    if (data & DISPATCH_VNODE_DELETE) {\n        NSLog(@\"The directory has been deleted.\");\n    }\n});\ndispatch_source_set_cancel_handler(source, ^(){\n    close(fd);\n});\n//dispatch源创建后处于suspend状态，所以需要启动dispatch源\ndispatch_resume(source);\n//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听\n```\n\n***\n\n## dispatch\\_time_t\n\n```\ndispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0/*延迟执行时间*/ * NSEC_PER_SEC));\n\ndispatch_after(delayTime, dispatch_get_main_queue(), ^{\n    [weakSelf delayMethod];\n});\n```\n\n***\n\n## dispatch_source\\_set\\_timer\n\n```\ndispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway);\n```\n\n第一个参数:定时器对象；第二个参数:DISPATCH\\_TIME_NOW 表示从现在开始计时；第三个参数:间隔时间 GCD里面的时间最小单位为 纳秒；第四个参数:精准度(表示允许的误差,0表示绝对精准)。  \n\nNSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer。\n\n   \nNSEC\\_PER_SEC 1000000000ull  \nUSEC\\_PER_SEC 1000000ull  \nNSEC\\_PER_USEC 1000ull  \n\nNSEC：纳秒；USEC：微妙；SEC：秒；PER：每。\n\n```\n//第一个参数代表：dispatch source类型，最后一个是block会进入的queue，用来执行事件处理器和取消处理器，第二三个参数在会根据source类型设置。\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);\n\n//设置事件的处理handler\ndispatch_source_set_event_handler(source, ^(){\n    NSLog(@\"Time flies.\");\n});\n\n//5秒触发一次，误差100毫秒\ndispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);\n\n//开始处理定时器事件，dispatch_suspend暂停处理事件\ndispatch_resume(source);\n\n```\n\n***\n\n## dispatch_suspend和dispatch\\_resume\n*  dispatch_suspend 挂起队列\n*  dispatch_resume  恢复队列\n\ndispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"me.kevin.gcd\", DISPATCH_QUEUE_SERIAL);\n\n//提交第一个block，延时5秒打印。\ndispatch_async(queue, ^{\n    [NSThread sleepForTimeInterval:5];\n    NSLog(@\"After 5 seconds...\");\n});\n\n//提交第二个block，也是延时5秒打印\ndispatch_async(queue, ^{\n    [NSThread sleepForTimeInterval:5];\n    NSLog(@\"After 5 seconds again...\");\n});\n\n//延时一秒\nNSLog(@\"sleep 1 second...\");\n[NSThread sleepForTimeInterval:1];\n\n//挂起队列\nNSLog(@\"suspend...\");\ndispatch_suspend(queue);\n\n//延时10秒\nNSLog(@\"sleep 10 second...\");\n[NSThread sleepForTimeInterval:10];\n\n//恢复队列\nNSLog(@\"resume...\");\ndispatch_resume(queue);\n```\n\n可知，在dispatch_suspend挂起队列后，第一个block还是在运行，并且正常输出。\n结合文档，我们可以得知，dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。\n\n***\n\n# 死锁！\n## dispatch_sync导致的死锁\n在main线程使用“同步”方法提交Block，必定会死锁：\n\n```\ndispatch_sync(dispatch_get_main_queue(), ^{\n    NSLog(@\"I am block...\");\n});\n```\n\n嵌套调用可能就会造成死锁：\n\n```\n- (void)updateUI1 {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"Update ui 1\");\n\n        //死锁！\n        [self updateUI2];\n    });\n}\n- (void)updateUI2 {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"Update ui 2\");\n    });\n}\n```\n\n其它情况：\n\n```\n- (void)deadLockCase1 {\n    NSLog(@\"1\");\n    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n- (void)deadLockCase2 {\n    NSLog(@\"1\");\n    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行\n    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n- (void)deadLockCase3 {\n    dispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);\n    NSLog(@\"1\");\n    dispatch_async(serialQueue, ^{\n        NSLog(@\"2\");\n        //串行队列里面同步一个串行队列就会死锁\n        dispatch_sync(serialQueue, ^{\n            NSLog(@\"3\");\n        });\n        NSLog(@\"4\");\n    });\n    NSLog(@\"5\");\n}\n```\n\n***\n\n## dispatch_apply导致的死锁:\n\n```\n//在串行队列里嵌套使用dispatch_apply\ndispatch_queue_t queue = dispatch_queue_create(\"me.tutuge.test.gcd\", DISPATCH_QUEUE_SERIAL);\n\ndispatch_apply(3, queue, ^(size_t i) {\n\tNSLog(@\"apply loop: %zu\", i);\n\n    //再来一个dispatch_apply！死锁！\n\tdispatch_apply(3, queue, ^(size_t j) {\n\t\tNSLog(@\"apply loop inside %zu\", j);\n\t});\n});\n```\n","slug":"iOS/GCD","published":1,"updated":"2024-02-02T11:04:33.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguo001xaq7kgxotrvrx"},{"title":"时间魔法-NSDate回忆录","date":"2016-05-24T16:00:00.000Z","_content":"# 简介   \n总结了下Swift中关于时间的一些简单操作，顺便也把OC的有关NSDate的一些常用方法回顾了一遍，记录成这篇NSDate回忆录。\n\n* 日期时间的比较\n* NSDate 简单实用\n* NSDateFormatter 对日期时间对象做格式化操作的类\n* NSDateComponents 的简单使用\n***\n<!-- more -->\n![time_oc](http://o7ttfnm00.bkt.clouddn.com/1.jpg)\n\n# 日期时间的比较\n```\n// 当前时间\nNSDate *currentDate = [NSDate date];\n// 比当前时间晚一个小时的时间\nNSDate *laterDate = [[NSDate alloc] initWithTimeInterval:60*60 sinceDate:[NSDate date]];\n// 比当前时间早一个小时的时间\nNSDate *earlierDate = [[NSDate alloc] initWithTimeInterval:-60*60 sinceDate:[NSDate date]];\n// 比较哪个时间晚\nif ([currentDate laterDate:laterDate]) {\n    // current-2016-05-25 13:50:27 +0000比later-2016-05-25 14:50:27 +0000晚\n    NSLog(@\"current-%@比later-%@晚\",currentDate,laterDate);\n}\n// 比较哪个时间早\nif ([currentDate earlierDate:earlierDate]) {\n    // current-2016-05-25 13:50:27 +0000 比 earlier-2016-05-25 12:50:27 +0000 早\n    NSLog(@\"current-%@ 比 earlier-%@ 早\",currentDate,earlierDate);\n}\n\n*\n- (NSComparisonResult)compare:(NSDate *)other;\n该方法用于排序时调用:\n. 当实例保存的日期值与anotherDate相同时返回NSOrderedSame\n. 当实例保存的日期值晚于anotherDate时返回NSOrderedDescending\n. 当实例保存的日期值早于anotherDate时返回NSOrderedAscending\n*/\n\nif ([currentDate compare:earlierDate]==NSOrderedDescending) {\n    // 打印结果\n    NSLog(@\"current 晚\");\n}\nif ([currentDate compare:currentDate]==NSOrderedSame) {\n    // 打印结果\n    NSLog(@\"时间相等\");\n}\nif ([currentDate compare:laterDate]==NSOrderedAscending) {\n    // 打印结果\n    NSLog(@\"current 早\");\n}\n\n```\n***\n# NSDate 简单实用\n```\n//-获取当前日期时间的方法\n//实例方法\nNSDate *date1=[[NSDate alloc]init];\nNSLog(@\"date1:%@\",date1);  //2016-05-25 13:06:12 +0000\n//类方法\nNSDate *date2=[NSDate date];\nNSLog(@\"date2:%@\",date2);  //2016-05-25 13:06:12 +0000\n\n//获取从1970年1月1日00:00到date2的秒数\nNSTimeInterval interval= [date2 timeIntervalSince1970];\nNSLog(@\"%f\",interval);     //1464182226.511477\n\n//*********可以加一个延时操作\n//[NSThread sleepForTimeInterval:2.f];\nfor(int i=0;i<10000;i++){}\n//********* \n//计算两个时间差（秒数）\ninterval=[date2 timeIntervalSinceDate:date1];\nNSLog(@\"%f\",interval);     //0.001625\n\n//date1距现在的时间差\ninterval=[date1 timeIntervalSinceNow];\nNSLog(@\"%f\",interval);     //-0.001935\n\n//-得到date2的后一天(单位-秒)的时间对象\n//实例方法：\nNSDate *date3=[date2 dateByAddingTimeInterval:24*3600];\nNSLog(@\"date3:%@\",date3);  //2016-05-26 13:18:21 +0000\n//类方法：\nNSDate *date4=[NSDate dateWithTimeInterval:24*3600 sinceDate:date2];\nNSLog(@\"date4:%@\",date4);  //2016-05-26 13:18:21 +0000\n\n//得到距现在多少秒后的一个日期时间对象\nNSDate *date5=[NSDate dateWithTimeIntervalSinceNow:3*24*3600];\nNSLog(@\"date5:%@\",date5);  //2016-05-28 13:18:21 +0000\n\n//获取将来的一个日期时间对象\nNSDate *date6=[NSDate distantFuture];\nNSLog(@\"date6:%@\",date6);  //4001-01-01 00:00:00 +0000\n    \n//获取过去的一个日期时间对象\nNSDate *date7=[NSDate distantPast];\nNSLog(@\"date7:%@\",date7);  //0000-12-30 00:00:00 +0000\n```\n***\n# NSDateFormatter 对日期时间对象做格式化操作的类\n```\nNSDateFormatter *format=[[NSDateFormatter alloc]init];\n[format setDateStyle:NSDateFormatterMediumStyle]; //设置日期的样式\n[format setTimeStyle:NSDateFormatterMediumStyle]; //设置时间的样式\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSString *styledate= [format stringFromDate:date1];\nNSLog(@\"styledate:%@\",styledate);                 //May 25, 2016, 9:18:21 PM\n\n[format setDateFormat:@\"yyyy-MM-dd hh:mm:ss\"];    //自定义格式字符串\nNSString *sdate=[format stringFromDate:date1];    //将NSDate对象转换为字符串\nNSLog(@\"sdate:%@\",sdate);                         //2016-05-25 09:18:21\n\n//将字符串形式的日期时间转换为NSDate对象(保证字符串的形式与format中的形式一致)\nNSString *str=@\"2016-05-25 09:15:30\";\nNSDate *date8=[format dateFromString:str];\nNSLog(@\"date8:%@\",date8); //2015-07-09 16:10:30 +0000\n\n//时间格式化字符串\nNSDate *newdate=[NSDate date];\nNSDateFormatter *formatter = [[NSDateFormatter alloc]init];\n[formatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss MMM eee a\"];\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSString *strdate = [formatter stringFromDate:newdate];\nNSLog(@\"%@\",strdate); //2016-05-25 21:18:21 May Wed PM\n\n//时间字符串转换为时间类型\nNSDateFormatter * formatter2 = [[NSDateFormatter alloc]init];\nNSString * nstr =@\"2016年05月25日 9点14分18秒\";\n[formatter2 setDateFormat:@\"yyyy年MM月dd日  hh点mm分ss秒\"];\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSDate * date9 = [formatter2 dateFromString:nstr];\n\nps：NSDateFormatter 是时间的一些配置项：对应的时区、展示的格式等等。如果服务器没有返回时间戳，而是返回了默认 “Asia/Shanghai” 时区的字符串时间（XXXX年X月X日），这时候在转NSDate时就必须要设置清楚这个时间所属的时区，否则会被当做是零时区的时间。 \n\n```\n***\n# NSDateComponents 的简单使用\n\n```\n//获取系统时间的年月日时分秒部分\nNSCalendar *cal = [NSCalendar currentCalendar];\n//Mac 10.10以前的系统使用 NSYearCalendarUnit\nunsigned int unitFlags = NSCalendarUnitYear |NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond;\nNSDateComponents *d = [cal components:unitFlags fromDate:newdate];\nNSLog(@\"年=%ld\",[d year]);   //年=2016\nNSLog(@\"月=%ld\",[d month]);  //月=5\nNSLog(@\"日=%ld\",[d day]);    //日=25\nNSLog(@\"时=%ld\",[d hour]);   //时=21\nNSLog(@\"分=%ld\",[d minute]); //分=18\nNSLog(@\"秒=%ld\",[d second]); //秒=21\n   \n//将传入时间字符串转换成需要的时间格式\nNSString *dateStr=@\"2013-08-13 20:28:40\";\nNSDateFormatter *format1=[[NSDateFormatter alloc] init];\n[format1 setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\nNSDate *fromdate=[format1 dateFromString:dateStr];\n     \n//解决时分秒转换不准确问题--相差了8小时，是时区的问题\nNSTimeZone *fzone = [NSTimeZone systemTimeZone];\nNSInteger finterval = [fzone secondsFromGMTForDate:date9];\nNSDate *fDate = [date9  dateByAddingTimeInterval:finterval];\nNSLog(@\"%@\",fDate); //2014-05-01 10:23:18 +0000\n\n//将传入时间字符串转换成需要的时间格式\nNSString *dateStr=@\"2013-08-13 20:28:40\";\nNSDateFormatter *format1=[[NSDateFormatter alloc] init];\n[format1 setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\nNSDate *fromdate=[format1 dateFromString:dateStr];\n\n//解决时分秒转换不准确问题\nNSTimeZone *fromzone = [NSTimeZone systemTimeZone];\nNSInteger frominterval = [fromzone secondsFromGMTForDate: fromdate];\nNSDate *fromDate = [fromdate  dateByAddingTimeInterval: frominterval];\nNSLog(@\"fromdate=%@\",fromDate);\n    \nNSDate *currentDate = [NSDate date];\nNSString *timeSp = [NSString stringWithFormat:@\"%ld\", (long)[currentDate timeIntervalSince1970]];\nNSLog(@\"currentDate == %@\", timeSp); //1464182301\nNSTimeInterval time = [timeSp doubleValue];\nNSTimeInterval addTime = 60 * 60 * 24 * 7;\ntime = time + addTime;\n    \nNSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n[dateFormatter setDateFormat:@\"YYYY/MM/dd hh:mm:ss SS\"];\nNSString *dateString = [dateFormatter stringFromDate:currentDate];\nNSString *year = [dateString substringToIndex:4];\nNSString *month = [dateString substringWithRange:NSMakeRange(5, 2)];\nNSString *day = [dateString substringWithRange:NSMakeRange(8, 2)];\nNSLog(@\"%@-%@-%@\", year, month, day); //2016-05-25\n```\n\n","source":"_posts/iOS/时间魔法.md","raw":"---\ntitle: 时间魔法-NSDate回忆录\ndate: 2016-05-25 \ntags: OC\n---\n# 简介   \n总结了下Swift中关于时间的一些简单操作，顺便也把OC的有关NSDate的一些常用方法回顾了一遍，记录成这篇NSDate回忆录。\n\n* 日期时间的比较\n* NSDate 简单实用\n* NSDateFormatter 对日期时间对象做格式化操作的类\n* NSDateComponents 的简单使用\n***\n<!-- more -->\n![time_oc](http://o7ttfnm00.bkt.clouddn.com/1.jpg)\n\n# 日期时间的比较\n```\n// 当前时间\nNSDate *currentDate = [NSDate date];\n// 比当前时间晚一个小时的时间\nNSDate *laterDate = [[NSDate alloc] initWithTimeInterval:60*60 sinceDate:[NSDate date]];\n// 比当前时间早一个小时的时间\nNSDate *earlierDate = [[NSDate alloc] initWithTimeInterval:-60*60 sinceDate:[NSDate date]];\n// 比较哪个时间晚\nif ([currentDate laterDate:laterDate]) {\n    // current-2016-05-25 13:50:27 +0000比later-2016-05-25 14:50:27 +0000晚\n    NSLog(@\"current-%@比later-%@晚\",currentDate,laterDate);\n}\n// 比较哪个时间早\nif ([currentDate earlierDate:earlierDate]) {\n    // current-2016-05-25 13:50:27 +0000 比 earlier-2016-05-25 12:50:27 +0000 早\n    NSLog(@\"current-%@ 比 earlier-%@ 早\",currentDate,earlierDate);\n}\n\n*\n- (NSComparisonResult)compare:(NSDate *)other;\n该方法用于排序时调用:\n. 当实例保存的日期值与anotherDate相同时返回NSOrderedSame\n. 当实例保存的日期值晚于anotherDate时返回NSOrderedDescending\n. 当实例保存的日期值早于anotherDate时返回NSOrderedAscending\n*/\n\nif ([currentDate compare:earlierDate]==NSOrderedDescending) {\n    // 打印结果\n    NSLog(@\"current 晚\");\n}\nif ([currentDate compare:currentDate]==NSOrderedSame) {\n    // 打印结果\n    NSLog(@\"时间相等\");\n}\nif ([currentDate compare:laterDate]==NSOrderedAscending) {\n    // 打印结果\n    NSLog(@\"current 早\");\n}\n\n```\n***\n# NSDate 简单实用\n```\n//-获取当前日期时间的方法\n//实例方法\nNSDate *date1=[[NSDate alloc]init];\nNSLog(@\"date1:%@\",date1);  //2016-05-25 13:06:12 +0000\n//类方法\nNSDate *date2=[NSDate date];\nNSLog(@\"date2:%@\",date2);  //2016-05-25 13:06:12 +0000\n\n//获取从1970年1月1日00:00到date2的秒数\nNSTimeInterval interval= [date2 timeIntervalSince1970];\nNSLog(@\"%f\",interval);     //1464182226.511477\n\n//*********可以加一个延时操作\n//[NSThread sleepForTimeInterval:2.f];\nfor(int i=0;i<10000;i++){}\n//********* \n//计算两个时间差（秒数）\ninterval=[date2 timeIntervalSinceDate:date1];\nNSLog(@\"%f\",interval);     //0.001625\n\n//date1距现在的时间差\ninterval=[date1 timeIntervalSinceNow];\nNSLog(@\"%f\",interval);     //-0.001935\n\n//-得到date2的后一天(单位-秒)的时间对象\n//实例方法：\nNSDate *date3=[date2 dateByAddingTimeInterval:24*3600];\nNSLog(@\"date3:%@\",date3);  //2016-05-26 13:18:21 +0000\n//类方法：\nNSDate *date4=[NSDate dateWithTimeInterval:24*3600 sinceDate:date2];\nNSLog(@\"date4:%@\",date4);  //2016-05-26 13:18:21 +0000\n\n//得到距现在多少秒后的一个日期时间对象\nNSDate *date5=[NSDate dateWithTimeIntervalSinceNow:3*24*3600];\nNSLog(@\"date5:%@\",date5);  //2016-05-28 13:18:21 +0000\n\n//获取将来的一个日期时间对象\nNSDate *date6=[NSDate distantFuture];\nNSLog(@\"date6:%@\",date6);  //4001-01-01 00:00:00 +0000\n    \n//获取过去的一个日期时间对象\nNSDate *date7=[NSDate distantPast];\nNSLog(@\"date7:%@\",date7);  //0000-12-30 00:00:00 +0000\n```\n***\n# NSDateFormatter 对日期时间对象做格式化操作的类\n```\nNSDateFormatter *format=[[NSDateFormatter alloc]init];\n[format setDateStyle:NSDateFormatterMediumStyle]; //设置日期的样式\n[format setTimeStyle:NSDateFormatterMediumStyle]; //设置时间的样式\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSString *styledate= [format stringFromDate:date1];\nNSLog(@\"styledate:%@\",styledate);                 //May 25, 2016, 9:18:21 PM\n\n[format setDateFormat:@\"yyyy-MM-dd hh:mm:ss\"];    //自定义格式字符串\nNSString *sdate=[format stringFromDate:date1];    //将NSDate对象转换为字符串\nNSLog(@\"sdate:%@\",sdate);                         //2016-05-25 09:18:21\n\n//将字符串形式的日期时间转换为NSDate对象(保证字符串的形式与format中的形式一致)\nNSString *str=@\"2016-05-25 09:15:30\";\nNSDate *date8=[format dateFromString:str];\nNSLog(@\"date8:%@\",date8); //2015-07-09 16:10:30 +0000\n\n//时间格式化字符串\nNSDate *newdate=[NSDate date];\nNSDateFormatter *formatter = [[NSDateFormatter alloc]init];\n[formatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss MMM eee a\"];\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSString *strdate = [formatter stringFromDate:newdate];\nNSLog(@\"%@\",strdate); //2016-05-25 21:18:21 May Wed PM\n\n//时间字符串转换为时间类型\nNSDateFormatter * formatter2 = [[NSDateFormatter alloc]init];\nNSString * nstr =@\"2016年05月25日 9点14分18秒\";\n[formatter2 setDateFormat:@\"yyyy年MM月dd日  hh点mm分ss秒\"];\n[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"Asia/Shanghai\"]]; //设置时区\nNSDate * date9 = [formatter2 dateFromString:nstr];\n\nps：NSDateFormatter 是时间的一些配置项：对应的时区、展示的格式等等。如果服务器没有返回时间戳，而是返回了默认 “Asia/Shanghai” 时区的字符串时间（XXXX年X月X日），这时候在转NSDate时就必须要设置清楚这个时间所属的时区，否则会被当做是零时区的时间。 \n\n```\n***\n# NSDateComponents 的简单使用\n\n```\n//获取系统时间的年月日时分秒部分\nNSCalendar *cal = [NSCalendar currentCalendar];\n//Mac 10.10以前的系统使用 NSYearCalendarUnit\nunsigned int unitFlags = NSCalendarUnitYear |NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond;\nNSDateComponents *d = [cal components:unitFlags fromDate:newdate];\nNSLog(@\"年=%ld\",[d year]);   //年=2016\nNSLog(@\"月=%ld\",[d month]);  //月=5\nNSLog(@\"日=%ld\",[d day]);    //日=25\nNSLog(@\"时=%ld\",[d hour]);   //时=21\nNSLog(@\"分=%ld\",[d minute]); //分=18\nNSLog(@\"秒=%ld\",[d second]); //秒=21\n   \n//将传入时间字符串转换成需要的时间格式\nNSString *dateStr=@\"2013-08-13 20:28:40\";\nNSDateFormatter *format1=[[NSDateFormatter alloc] init];\n[format1 setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\nNSDate *fromdate=[format1 dateFromString:dateStr];\n     \n//解决时分秒转换不准确问题--相差了8小时，是时区的问题\nNSTimeZone *fzone = [NSTimeZone systemTimeZone];\nNSInteger finterval = [fzone secondsFromGMTForDate:date9];\nNSDate *fDate = [date9  dateByAddingTimeInterval:finterval];\nNSLog(@\"%@\",fDate); //2014-05-01 10:23:18 +0000\n\n//将传入时间字符串转换成需要的时间格式\nNSString *dateStr=@\"2013-08-13 20:28:40\";\nNSDateFormatter *format1=[[NSDateFormatter alloc] init];\n[format1 setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\nNSDate *fromdate=[format1 dateFromString:dateStr];\n\n//解决时分秒转换不准确问题\nNSTimeZone *fromzone = [NSTimeZone systemTimeZone];\nNSInteger frominterval = [fromzone secondsFromGMTForDate: fromdate];\nNSDate *fromDate = [fromdate  dateByAddingTimeInterval: frominterval];\nNSLog(@\"fromdate=%@\",fromDate);\n    \nNSDate *currentDate = [NSDate date];\nNSString *timeSp = [NSString stringWithFormat:@\"%ld\", (long)[currentDate timeIntervalSince1970]];\nNSLog(@\"currentDate == %@\", timeSp); //1464182301\nNSTimeInterval time = [timeSp doubleValue];\nNSTimeInterval addTime = 60 * 60 * 24 * 7;\ntime = time + addTime;\n    \nNSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n[dateFormatter setDateFormat:@\"YYYY/MM/dd hh:mm:ss SS\"];\nNSString *dateString = [dateFormatter stringFromDate:currentDate];\nNSString *year = [dateString substringToIndex:4];\nNSString *month = [dateString substringWithRange:NSMakeRange(5, 2)];\nNSString *day = [dateString substringWithRange:NSMakeRange(8, 2)];\nNSLog(@\"%@-%@-%@\", year, month, day); //2016-05-25\n```\n\n","slug":"iOS/时间魔法","published":1,"updated":"2024-02-02T11:04:33.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgup001zaq7kh61c2ive"},{"title":"iOS横竖屏","date":"2022-10-19T09:03:48.000Z","_content":"\n## UIBezierPath\n\n`UIBezierPath` 是在 UIKit 中定义的类，可以用来创建基于矢量的**路径**，可以用来创建矩形、椭圆、曲线等等。`UIBezierPath`` 本质是对 Core Graphics 框架中的 CGPathRef 的封装。\n\n### API\n\n```js\nER_AUDIT_BEGIN(nullability, sendability)\n\nUIKIT_EXTERN API_AVAILABLE(ios(3.2)) @interface UIBezierPath : NSObject<NSCopying, NSSecureCoding>\n\n/// 创建 UIBezierPath 对象\n+ (instancetype)bezierPath;\n\n/// 创建矩形\n/// - Parameters:\n///   - rect: 大小\n+ (instancetype)bezierPathWithRect:(CGRect)rect;\n\n/// 创建圆形\n/// - Parameters:\n///   - rect: 大小\n+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;\n\n/// 创建圆角矩形\n/// - Parameters:\n///   - rect: 大小\n///   - cornerRadius: 圆角\n+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;\n\n/// 创建指定角为圆角的矩形\n/// - Parameters:\n///   - rect: 大小\n///   - corners: 指定角\n///   - cornerRadius: 圆角\n+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;\n\n/// 创建圆弧\n/// - Parameters:\n///   - center: 圆点\n///   - radius: 半径\n///   - startAngle: 开始位置\n///   - endAngle: 结束为止\n///   - clockwise: 是否顺时针方向\n+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;\n\n/// 根据已有路径创建新路径\n/// - Parameters:\n///   - CGPath: 已有路径\n+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;\n\n- (instancetype)init NS_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;\n\n/// 返回一个不可变的CGPathRef，该值仅在UIBezierPath进一步发生突变之前有效。\n/// 设置路径将创建所提供CGPathRef的不可变副本，因此将忽略所提供CGMutablePathRef上的任何进一步突变。\n@property(nonatomic) CGPathRef CGPath;\n- (CGPathRef)CGPath NS_RETURNS_INNER_POINTER CF_RETURNS_NOT_RETAINED;\n\n// 路径建设\n\n/// 移动到某一点\n/// - Parameters:\n///   - point: 指定点坐标\n- (void)moveToPoint:(CGPoint)point;\n\n/// 绘制一条直线\n/// - Parameters:\n///   - point: 指定点坐标\n- (void)addLineToPoint:(CGPoint)point;\n\n/// 创建三次贝塞尔曲线\n/// - Parameters:\n///   - endPoint: 终点\n///   - controlPoint1: 控制点1\n///   - controlPoint2: 控制点2\n- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;\n\n/// 创建两次贝塞尔曲线\n/// - Parameters:\n///   - endPoint: 终点\n///   - controlPoint: 控制点\n- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;\n\n/// 创建圆弧\n/// - Parameters:\n///   - center: 圆心\n///   - radius: 半径\n///   - startAngle: 开始位置\n///   - endAngle: 结束为止\n///   - clockwise: 是否顺时针方向\n- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise API_AVAILABLE(ios(4.0));\n\n/// 闭合路径，即在终点和起点绘制一根线\n- (void)closePath;\n\n/// 清空路径\n- (void)removeAllPoints;\n\n// 附加路径\n\n/// 追加路径\n/// - Parameters:\n///   - bezierPath: 路径\n- (void)appendPath:(UIBezierPath *)bezierPath;\n\n// 修改路径\n\n/// 翻转路径，即起点变终点，终点变起点\n- (UIBezierPath *)bezierPathByReversingPath API_AVAILABLE(ios(6.0));\n\n// 转换路径\n\n/// 路径进行仿射变换\n/// - Parameters:\n///   - transform: 仿射变换\n- (void)applyTransform:(CGAffineTransform)transform;\n\n// 路径信息\n\n/// 路径上是否有有效元素（只读）\n@property(readonly,getter=isEmpty) BOOL empty;\n\n/// 获取 Path 的 x坐标、y坐标、宽度，高度为0（不同于UIView的bounds）\n@property(nonatomic,readonly) CGRect bounds;\n\n/// 当前path的位置，可以理解为path的终点\n@property(nonatomic,readonly) CGPoint currentPoint;\n\n/// 是否包含某点\n/// - Parameters:\n///   - point: 指定点\n- (BOOL)containsPoint:(CGPoint)point;\n\n// 绘画属性\n\n/// path宽度\n@property(nonatomic) CGFloat lineWidth;\n\n/// path端点样式（butt：无端点；round：圆形端点；square：方形端点，跟 butt 一样，但是比 butt 长）\n@property(nonatomic) CGLineCap lineCapStyle;\n\n/// path拐角样式（miter：尖角；round：圆角；bevel：缺角）\n@property(nonatomic) CGLineJoin lineJoinStyle;\n\n/// 最大斜接长度，角度越小，斜接长度越大（在miter类型情况下，为了避免斜接长度过长，使用lineLimit属性限制，超过限制会以 bevel 类型来显示）\n@property(nonatomic) CGFloat miterLimit; \n\n/// 弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能\n@property(nonatomic) CGFloat flatness;\n\n/// 奇偶数圈规则是否用于绘制路径\n@property(nonatomic) BOOL usesEvenOddFillRule;\n\n/// 绘制虚线\n/// - Parameters:\n///   - pattern: 如何交替绘制，C类型现行数据（如：CGFloat dash[] = {0.0, dotSpacing+dotDiameter};）\n///   - count: 数组长度\n///   - phase: 偏移量\n- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;\n- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;\n\n// 当前图形上下文（CGContextRef）上的路径操作\n\n/// 填充\n- (void)fill;\n\n/// 描边，路径的绘制需要描边才能显示出来\n- (void)stroke;\n\n/*\n补充：\n\n设置描边颜色，需要在设置后调用描边发方法\n[[UIColor redColor] setStroke];\n\n设置填充颜色，需要在设置后调用填充方法\n[[UIColor redColor] setFill]; \n*/\n\n// 这些方法不会影响当前图形上下文（CGContextRef）的混合模式或alpha\n\n/// 设置填充的混合模式\n/// - Parameters:\n///   - blendMode: 混合模式\n///   - alpha: 透明度、\n- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;\n\n/// 设置描边的混合模式\n/// - Parameters:\n///   - blendMode: 混合模式\n///   - alpha: 透明度\n- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;\n\n/// 修改当前图形上下文（CGContextRef）的绘图区域可见\n- (void)addClip;\n\n@end\n\nNS_HEADER_AUDIT_END(nullability, sendability)\n```\n\n### 直线\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段；\n4. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 直线\n    UIBezierPath *path = [UIBezierPath bezierPath];\n    path.lineWidth = 10;\n    [path moveToPoint:CGPointMake(50, 50)];\n    [path addLineToPoint:CGPointMake(300, 50)];\n    // path.lineCapStyle = kCGLineCapButt; // 默认无线帽\n    [path stroke];\n    \n    // 圆形线帽\n    UIBezierPath *lineCapPath_round = [UIBezierPath bezierPath];\n    lineCapPath_round.lineWidth = 10;\n    [lineCapPath_round moveToPoint:CGPointMake(50, 100)];\n    [lineCapPath_round addLineToPoint:CGPointMake(300, 100)];\n    lineCapPath_round.lineCapStyle = kCGLineCapRound; // 圆角\n    [lineCapPath_round stroke];\n    \n    // 直角线帽\n    UIBezierPath *lineCapPath_square = [UIBezierPath bezierPath];\n    lineCapPath_square.lineWidth = 10;\n    [lineCapPath_square moveToPoint:CGPointMake(50, 150)];\n    [lineCapPath_square addLineToPoint:CGPointMake(300, 150)];\n    lineCapPath_square.lineCapStyle = kCGLineCapSquare; // 直角\n    [lineCapPath_square stroke];\n}\n```\n\n![01](../iOS/UIBezierPath/01.png)\n\n### 虚线\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段；\n4. `setLineDash:count:`：设置线段样式，交替绘制数组中的长度；\n5. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 虚线\n    UIBezierPath *lineDashPath = [UIBezierPath bezierPath];\n    lineDashPath.lineWidth = 10;\n    [lineDashPath moveToPoint:CGPointMake(50, 200)];\n    [lineDashPath addLineToPoint:CGPointMake(300, 200)];\n    CGFloat pattern[] = {10, 20};\n    [lineDashPath setLineDash:pattern count:2 phase:0];\n    [lineDashPath stroke];\n}\n```\n\n相较于实线，创建虚线多了一个设置项 `setLineDash:count:`，它是**交替**绘制的线段长度的数组。\n\n如果数组长度是偶数，如 `{10, 20}`，则 10 是虚线长度，20 是虚线间隙长度。\n\n![03](../iOS/UIBezierPath/03.png)\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 虚线\n    UIBezierPath *lineDashPath = [UIBezierPath bezierPath];\n    lineDashPath.lineWidth = 10;\n    [lineDashPath moveToPoint:CGPointMake(50, 200)];\n    [lineDashPath addLineToPoint:CGPointMake(300, 200)];\n    CGFloat pattern[] = {10, 20, 40};\n    [lineDashPath setLineDash:pattern count:3 phase:0];\n    [lineDashPath stroke];\n}\n```\n\n如果数组长度是奇数，如 `{10, 20, 40}`，则 10 即是虚线长度也是间隙长度，如下图：\n\n![02](../iOS/UIBezierPath/02.png)\n\n`setLineDash:count:` 中的 count 表示线段个数，dash 是线段长度数组。如果 dash 等于 {10, 20}，count 等于3，则第三个线段长度默认为0，交替方式为：\n\n![04](../iOS/UIBezierPath/04.png)\n\n### 三角行\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段（多次调用创建多个子路径）；\n4. `closePath`：闭合路径，即在终点和起点绘制一根线；\n5. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath = [UIBezierPath bezierPath];\n    lineJoinPath.lineWidth = 10;\n    [lineJoinPath moveToPoint:CGPointMake(50, 50)];\n    [lineJoinPath addLineToPoint:CGPointMake(300, 100)];\n    [lineJoinPath addLineToPoint:CGPointMake(50, 150)];\n    // lineJoinPath.lineJoinStyle = kCGLineJoinMiter; // 默认尖角\n    [lineJoinPath closePath];\n    [lineJoinPath stroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath_round = [UIBezierPath bezierPath];\n    lineJoinPath_round.lineWidth = 10;\n    [lineJoinPath_round moveToPoint:CGPointMake(50, 200)];\n    [lineJoinPath_round addLineToPoint:CGPointMake(300, 250)];\n    [lineJoinPath_round addLineToPoint:CGPointMake(50, 300)];\n    lineJoinPath_round.lineJoinStyle = kCGLineJoinRound; // 圆角\n    [lineJoinPath_round closePath];\n    [lineJoinPath_round stroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath_bevel = [UIBezierPath bezierPath];\n    lineJoinPath_bevel.lineWidth = 10;\n    [lineJoinPath_bevel moveToPoint:CGPointMake(50, 350)];\n    [lineJoinPath_bevel addLineToPoint:CGPointMake(300, 400)];\n    [lineJoinPath_bevel addLineToPoint:CGPointMake(50, 450)];\n    lineJoinPath_bevel.lineJoinStyle = kCGLineJoinBevel; // 缺角\n    [lineJoinPath_bevel closePath];\n    [lineJoinPath_bevel stroke];\n}\n```\n\n![05](../iOS/UIBezierPath/05.png)\n\n`lineJoinStyle` 是设置斜接长度\n\n`kCGLineJoinMiter`：\n\n![11](../iOS/UIBezierPath/11.png)\n\n`kCGLineJoinBevel`：\n\n![12](../iOS/UIBezierPath/12.png)\n\n### 图形\n\n```js\n- (void)drawRect:(CGRect)rect {\n\n    // 设置描边色\n    [[UIColor redColor] setStroke];\n    \n    // 矩形\n    UIBezierPath *rectPath = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 100, 50)];\n    [rectPath stroke];\n    \n    // 圆\n    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 150, 100, 100)];\n    [ovalPath stroke];\n    \n    // 圆角矩形\n    UIBezierPath *roundPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 300, 100, 100) cornerRadius:20];\n    [roundPath stroke];\n    \n    // 指定角圆角矩形\n    UIBezierPath *roundPath2 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 450, 100, 100) byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    [roundPath2 stroke];\n    \n    // 圆弧\n    UIBezierPath *arcPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 650) radius:50 startAngle:0 endAngle:M_PI clockwise:YES];\n    [arcPath stroke];\n    \n    // 设置描边色\n    [[UIColor blueColor] setStroke];\n    \n    // 圆弧\n    UIBezierPath *arcPath2 = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 650) radius:50 startAngle:0 endAngle:-M_PI*0.5 clockwise:NO];\n    [arcPath2 stroke];\n    \n    // 设置填充色\n    [[UIColor blueColor] setFill];\n    \n    // 矩形\n    UIBezierPath *rectPath_fill = [UIBezierPath bezierPathWithRect:CGRectMake(200, 50, 100, 50)];\n    [rectPath_fill fill];\n    \n    // 圆\n    UIBezierPath *ovalPath_fill = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(200, 150, 100, 100)];\n    [ovalPath_fill fill];\n    \n    // 圆角矩形\n    UIBezierPath *roundPath_fill = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 300, 100, 100) cornerRadius:20];\n    [roundPath_fill fill];\n    \n    // 指定角圆角矩形\n    UIBezierPath *roundPath2_fill = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 450, 100, 100) byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    [roundPath2_fill fill];\n    \n    // 圆弧\n    UIBezierPath *arcPath_fill = [UIBezierPath bezierPathWithArcCenter:CGPointMake(250, 650) radius:50 startAngle:0 endAngle:M_PI clockwise:YES];\n    [arcPath_fill fill];\n    \n    // 设置填充色\n    [[UIColor redColor] setFill];\n    \n    // 圆弧\n    UIBezierPath *arcPath2_fill = [UIBezierPath bezierPathWithArcCenter:CGPointMake(250, 650) radius:50 startAngle:0 endAngle:-M_PI*0.5 clockwise:NO];\n    [arcPath2_fill fill];\n}\n```\n\n![06](../iOS/UIBezierPath/06.png)\n\n绘制圆形的角度关系\n\n![10](../iOS/UIBezierPath/10.png)\n\n### 曲线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边色\n    [[UIColor redColor] setStroke];\n    \n    // 一个控制点的曲线\n    UIBezierPath *quadCurvePath = [UIBezierPath bezierPath];\n    quadCurvePath.lineWidth = 5;\n    [quadCurvePath moveToPoint:CGPointMake(50, 100)];\n    [quadCurvePath addQuadCurveToPoint:CGPointMake(300, 100) controlPoint:CGPointMake(200, 150)];\n    [quadCurvePath stroke];\n    \n    // 两个控制点的曲线\n    UIBezierPath *curvePath = [UIBezierPath bezierPath];\n    curvePath.lineWidth = 5;\n    [curvePath moveToPoint:CGPointMake(50, 200)];\n    [curvePath addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(100, 150) controlPoint2:CGPointMake(250, 250)];\n    [curvePath stroke];\n}\n```\n\n![07](../iOS/UIBezierPath/07.png)\n\n二次曲线：包括两个起点，一个控制点。\n\n![09](../iOS/UIBezierPath/09.png)\n\n三次曲线：包括两个起点，两个控制点。\n\n![08](../iOS/UIBezierPath/08.png)\n\n## Core Graphics\n\nCore Graphics Framework 是一套基于 C 的 API 框架，使用了 Quartz 作为绘图引擎。它提供了低级别、轻量级、高保真度的 2D 渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩，以及PDF文档的创建、显示和分析。\n\niOS 支持两套图形API族：\n\n1. Core Graphics/QuartZ 2D（QuartZ 2D 是苹果公司开发的API，是 Core Graphics Framework 的一部分）；\n2. OpenGL ES（跨平台图形API，OpenGL 的简化版本）；\n\n`UIBezierPath` 是基于 Core Graphics 对 `CGPathRef` 数据类型的封装。\n\n### 直线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n    \n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    // 线帽，butt（默认值，无线帽）\n    CGContextSetLineCap(context, kCGLineCapButt);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 50);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 线帽，round（圆形）\n    CGContextSetLineCap(context, kCGLineCapRound);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 线帽，square（方形）\n    CGContextSetLineCap(context, kCGLineCapSquare);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 150);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 150);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![01](../iOS/UIBezierPath/01.png)\n\n### 虚线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 线段长度数组\n    CGFloat lengths[] = {10, 20};\n    \n    \n    // 宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 50);\n    // 设置虚线样式\n    CGContextSetLineDash(context, 0, lengths, 2);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 设置虚线样式（phase = 20，虚线向左移动20）\n    CGContextSetLineDash(context, 20, lengths, 2);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![13](../iOS/UIBezierPath/13.png)\n\n### 三角形\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n\n    // 后期当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    // 设置斜接角样式，miter（默认，尖角）\n    CGContextSetLineJoin(context, kCGLineJoinMiter);\n    // 线宽\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 150);\n    // 闭环\n    CGContextClosePath(context);\n    // 描边\n    CGContextStrokePath(context);\n    \n    // 设置斜接角仰视，round（圆形）\n    CGContextSetLineJoin(context, kCGLineJoinRound);\n    // 先款\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 200);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 250);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 300);\n    // 闭环\n    CGContextClosePath(context);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    // 设置斜接角样式，bevel（方形）\n    CGContextSetLineJoin(context, kCGLineJoinBevel);\n    // 起点\n    CGContextMoveToPoint(context, 50, 350);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 400);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 450);\n    // 闭环\n    CGContextClosePath(context);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![05](../iOS/UIBezierPath/05.png)\n\n### 更多图形\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    \n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    CGContextMoveToPoint(context, 50, 50);\n    CGContextAddLineToPoint(context, 150, 75);\n    CGContextAddLineToPoint(context, 50, 100);\n    \n    // 矩形\n    CGContextAddRect(context, CGRectMake(50, 150, 100, 100));\n    \n    // 圆\n    CGContextAddEllipseInRect(context, CGRectMake(50, 300, 100, 100));\n    \n    // 椭圆\n    CGContextAddEllipseInRect(context, CGRectMake(50, 450, 100, 50));\n    \n    // 描边（绘制上面的path，下面的path单独绘制）\n    CGContextStrokePath(context);\n    \n    // 圆弧（(x, y)中心点，radius半径，startAngle起点，endAngle终点，clockwise顺时针0、逆时针1）\n    CGContextAddArc(context, 100, 600, 50, 0, M_PI, 0);\n    \n    // 描边（绘制上面的path，下面的path单独绘制）\n    CGContextStrokePath(context);\n    \n    // 改变颜色\n    [[UIColor blueColor] setStroke];\n    // 圆弧\n    CGContextAddArc(context, 100, 600, 50, M_PI, M_PI * 1.5, 0);\n    // 描边\n    CGContextStrokePath(context);\n}\n```\n\n![14](../iOS/UIBezierPath/14.png)\n\n填充样式：\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    [[UIColor blueColor] setFill];\n\n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 三角\n    CGPoint points[] = {CGPointMake(200, 50), CGPointMake(300, 75), CGPointMake(200, 100)};\n    CGContextAddLines(context, points, 3);\n    CGContextClosePath(context);\n    \n    // 矩形\n    CGContextAddRect(context, CGRectMake(200, 150, 100, 100));\n    \n    // 圆\n    CGContextAddEllipseInRect(context, CGRectMake(200, 300, 100, 100));\n    \n    // 椭圆\n    CGContextAddEllipseInRect(context, CGRectMake(200, 450, 100, 50));\n    // CGContextFillEllipseInRect(context, CGRectMake(150, 450, 100, 50));\n    \n    CGContextFillPath(context);\n    \n    // 圆弧\n    CGContextAddArc(context, 250, 600, 50, 0, -M_PI, 1);\n    CGContextFillPath(context);\n    \n    CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);\n    CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);\n    CGContextAddArc(context, 250, 600, 50, -M_PI, -M_PI*1.5, 1);\n    \n    CGContextFillPath(context);\n}\n```\n\n![15](../iOS/UIBezierPath/15.png)\n\n### 贝塞尔曲线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    \n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 弧线（(x1, y1)起点，(x2, y2)终点，半径）\n    CGContextAddArcToPoint(context, 250, 50, 200, 150, 20);\n    \n    CGContextMoveToPoint(context, 50, 200);\n    // 二次贝塞尔曲线（(cpx, cpy)控制点，(x, y)终点）\n    CGContextAddQuadCurveToPoint(context, 200, 100, 250, 200);\n    \n    CGContextMoveToPoint(context, 50, 300);\n    // 三次贝塞尔曲线（(cp1x, cp1y)控制点，(cp2x, cp2y)控制点，(x, y)终点）\n    CGContextAddCurveToPoint(context, 100, 200, 200, 400, 250, 300);\n    \n    CGContextStrokePath(context);\n}\n```\n\n![16](../iOS/UIBezierPath/16.png)\n\n### 高级API\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    [[UIColor blueColor] setFill];\n    \n    CGPoint points[] = {CGPointMake(50, 50), CGPointMake(250, 50), CGPointMake(100, 80), CGPointMake(250, 80)};\n    \n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 绘制直线线，p0-p1，p2-p3\n    CGContextStrokeLineSegments(context, points, 4);\n    \n    // 矩形\n    CGContextStrokeRect(context, CGRectMake(50, 150, 100, 100));\n    \n    // 矩形，指定线宽\n    CGContextStrokeRectWithWidth(context, CGRectMake(50, 300, 100, 100), 1);\n    // 填充矩形\n    CGContextFillRect(context, CGRectMake(200, 300, 100, 100));\n    \n    // 同时创建多个填充矩形\n    CGRect rects[] = {CGRectMake(50, 450, 100, 100), CGRectMake(200, 450, 100, 100)};\n    CGContextFillRects(context, rects, 2);\n    \n    // 椭圆\n    CGContextStrokeEllipseInRect(context, CGRectMake(50, 600, 100, 60));\n    // 填充椭圆\n    CGContextFillEllipseInRect(context, CGRectMake(200, 600, 100, 60));\n}\n```\n\n![17](../iOS/UIBezierPath/17.png)\n\n### push\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置填充色：红色\n    [[UIColor redColor] setFill];\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 50, 100, 100));\n    // 把context压入栈中，并把context设置为当前绘图上下文\n    UIGraphicsPushContext(UIGraphicsGetCurrentContext());\n    // 设置填充色：蓝色\n    [[UIColor blueColor] setFill];\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 200, 100, 100));\n    // 将栈顶的上下文弹出，恢复先前的上下文，但是绘图状态不变\n    UIGraphicsPopContext();\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 350, 100, 100));\n}\n```\n\n![18](../iOS/UIBezierPath/18.png)\n\n### SaveGState\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置填充色：红色\n    [[UIColor redColor] setFill]; // red\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 50, 100, 100));\n    // 保存状态\n    CGContextSaveGState(UIGraphicsGetCurrentContext()); // red\n    // 设置填充色：蓝色\n    [[UIColor blueColor] setFill]; // blue\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 200, 100, 100));\n    // 恢复状态\n    CGContextRestoreGState(UIGraphicsGetCurrentContext()); // red\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 350, 100, 100)); // red\n}\n```\n\n![19](../iOS/UIBezierPath/19.png)\n\n## drawRect\n\n上面演示的 UIBezierPath 和 Core Graphics，都是在 `drawRect:` 方法里实现的，所以这里有一个问题：为什么要在 `drawRect:` 方法内实现绘图操作？\n\n### 思考：为什么要在 `drawRect:` 方法内实现绘图操作\n\n因为 Core Graphics API 所有的操作都在上下文中进行，所以在绘图前需要获取该上下文并传入执行渲染的函数内。上下文就是**内存中的一块画布**，屏幕上的所有图片有自己所属的画布（上下文），同时任何绘图操作都要在画布（上下文）上实现。\n\n有两种获取上下文的常用方法：\n\n一、重载 UIView 的 `- (void)drawRect:(CGRect)rect` 方法，利用 Cocoa 自动生成的上下文\n\n1. 子类化 `UIView` 并实现 `drawRect:` 方法，一旦 `drawRect:` 方法被调用，Cocoa 就会创建一个图形上下文；\n\n2. 调用 `UIGraphicsGetCurrentContext()` 函数，获取到当前的图形上下文；\n\n3. 进行绘图操作，所有操作都会显示在当前上下文对应的 UIView 上；\n\n4. 重绘：`setNeedDisplay`。\n\n二、创建一个图片类型的上下文\n\n1. 调用 `UIGraphicsBeginImageContext()` 或 `UIGraphicsBeginImageContextWithOptions()` 函数可以获得处理图片的图形上下文；\n\n2. 调用 `UIGraphicsGetImageFromCurrentImageContext()` 函数可以从画布（上下文）中获取一个 UIImag 对象；\n\n3. 调用 `UIGraphicsEndImageContext()` 函数关闭图形上下文。\n\n### UIGraphicsBeginImageContext\n\n在 `drawRect:` 方法**外**完成绘图操作：\n\n```js\n- (void)withoutDrawRect {\n    \n    CGRect rect = CGRectMake(50, 50, 100, 100);\n    // 获取图形上下文，用来处理图片\n    UIGraphicsBeginImageContext(rect.size);\n    // 获取当前上下文\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 设置填充色\n    CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);\n    // 设置填充坐标、大小（在rect内的坐标）\n    CGContextFillRect(context, CGRectMake(0, 0, 100, 100));\n    // 设置边框颜色\n    CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);\n    // 设置边框宽度\n    CGContextSetLineWidth(context, 5);\n    // 设置边框坐标、大小（在rect内的坐标）\n    CGContextStrokeRect(context, CGRectMake(0, 0, 100, 100));\n    // 当前上下文中获取 UIImage 对象\n    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭图形上下文\n    UIGraphicsEndImageContext();\n    \n    // 展示\n    UIImageView *imageView = [[UIImageView alloc] initWithImage:theImage];\n    imageView.frame = rect;\n    [self addSubview:imageView];\n}\n```\n\n![20](../iOS/UIBezierPath/20.png)\n\n这里使用 `UIGraphicsBeginImageContext()` 方法，完成了在 `drawRect:` 方法外绘图的操作。\n\n## Core Animation\n\n### CALayer\n\n一、重载 CALayer 的 `- (void)drawInContext:(CGContextRef)ctx` 方法，利用 Cocoa 自动生成的上下文\n\n1. 子类化 `CALayer` 并实现 `- (void)drawInContext:(CGContextRef)ctx` 方法，一旦 `- (void)drawInContext:(CGContextRef)ctx` 方法被调用，Cocoa 就会创建一个图形上下文；\n\n2. 调用 `UIGraphicsGetCurrentContext()` 函数，获取到当前的图形上下文；\n\n3. 进行绘图操作，所有操作都会显示在当前上下文对应的 UIView 上；\n\n4. 重绘：`setNeedDisplay`。\n\n因为 `- (void)drawInContext:(CGContextRef)ctx` 方法内部会调用 CALayerDelegate 协议中的 `-drawLayer:inContext:` 方法，所以也可以实现`-drawLayer:inContext:` 方法获取到当前上下文。\n\n```js\n/* If defined, called by the default implementation of -drawInContext: */\n\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;\n```\n\n### CAShapeLayer\n\n`CAShapeLayer` 是一个通过矢量图形而不是 bitmap（位图）来绘制的图层子类。可以设置颜色和线宽，用 `CGPath` 定义图形，让 `CAShapeLayer` 自动渲染出来。先比用 Core Graphics 直接向原始的 CALayer 的内容中绘制路径，使用 CAShapeLayer 有四点优势：\n\n1. 渲染快速。\n2. 高效使用内存。\n3. 不会被图层边界剪裁掉。\n4. 不会出现像素化。\n\n`CAShapeLayer` 可以绘制所有能够通过 CGPath 来表示的形状。这个形状不一定要闭合，图层路径也不一定要不间断，可以在一个图层上绘制好几个不同的形状。\n\n`CAShapeLayer` 有图形属性，如 `lineWidth`（线宽，用点表示单位），`lineCap`（线条结尾的样子），和 `lineJoin`（线条之间的结合点的样子）等等。\n\n在图层层面，只有一次机会设置这些属性，如果想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。 \n\n### CAShapeLayer & Core Graphics\n\n术语**绘图**通常在 Core Animation 的上下文中指代软件绘图，即不由 GPU 协助的绘图。在 iOS 中，软件绘图通常是由 Core Graphics 框架完成。但是，在一些必要的情况下，Core Graphics 要比 Core Animation 和 OpenGL 慢很多。\n\n软件绘图不仅效率低，而且还会消耗较大的内存。一旦实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（对前者的包装），图层就会创建一个绘制上下文，这个上下文需要的内存大小如下，宽高的单位是**像素**：\n\n```js\n上下文大小 = 图层宽 * 图层高 * 4字节\n```\n\n对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 `2048 * 1526 * 4 字节 = 12MB`。图层每次重绘的时候都需要**重新抹掉内存然后重新分配**。\n\n软件绘图的代价昂贵，除非绝对必要，应该避免重绘视图。\n\n而提高绘制性能的秘诀就是避免绘制，如使用 CAShapeLayer 代替 Core Graphics。\n\n### 显示的大致流程\n\n1. **布局** - 准备视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等）的阶段；\n2. **显示** - 绘制图层的寄宿图的阶段。绘制有可能涉及到 UIView 的 -drawRect: 和 CALayer 的 -drawLayer:inContext: 方法的调用路径；\n3. **准备** - Core Animation 准备发送数据到渲染服务的阶段；\n4. **光栅化** - 对所有的图层属性计算中间值，设置 OpenGL 几何形状（纹理化的三角形）来执行渲染；\n5. **渲染** - 在屏幕上渲染可见的三角形。\n\n### UIView - CALayer - Core Graphics\n\n![24](../iOS/UIBezierPath/24.png)\n\n* 继承关系：`UIView —> UIResponder —> NSObject`，`CALayer —> NSObject`。\n\n* 响应时间：因为 UIView 继承自 UIResponder，所以 UIView 可以响应时间。因为 CALayer 继承自 NSObject，所以 CALayer 不能响应事件。\n\n* 框架：UIView 在 UIKit 框架中定义，用来构建界面、响应事件。CALayer 在 QuartzCore 框架中定义，绘制 2D 图像。\n\n* 寄宿图：即图层中包含的图。UIView 内部联图了一个 CALayer 图层，即 backing layer。CALayer 内部包含一个 content 属性指向一块缓冲区，即 backing store，里面存放位图（bitmap）。iOS 中奖缓存区的图片称为寄宿图。寄宿图有两种设置方式：1、想 content 设置 CGImage 图片，这需要以来 Core Image 提供图片；2、实现 UIView 的 drawRect: 方法自定义绘图，这需要依赖 Core Graphics 绘制图形，再由 CALayer 生成图片。\n\n* UIView 的显示原理：CALayer 会创建一个图形上下文（CGContextRef），然后调用 CALayerDelegate 协议（这里是 UIView 实现）的 `-drawLayer:inContext:` 方法，传入创建好的图形上下文（CGContextRef）对象，在 `-drawLayer:inContext:` 方法内部再调用 UIView 的 `-drawRect:` 方法。\n\n## 应用\n\n### 虚线圆形\n\n问题：因为在设置虚线的线段长度和间隙长度时会不等于周长，所以就会出现虚线的尾部和头部的结合部分不匀称。\n\n解决方案：通过计算得到实际的间隙长度，代替期望的间隙长度。\n\n1. 半径 * M_PI * 2.0 = 周长；\n2. 周长 / (线段长度 + 期望间隙长度) = 线段数量；\n3. (周长 / 线段数量) - 线段长度 = 实际间隙长度；\n\n```js\n// 虚线圆\n- (void)setDashedLineCirclePath:(CGRect)frame fill:(UIColor *)fillColor stroke:(UIColor *)strokeColor {\n    // 虚线直径\n    CGFloat dotDiameter = self.xAxisDashDotDiameter;\n    // 期望的虚线间隙\n    CGFloat expDotSpacing = self.xAxisDashExpDotSpacing;\n    // 圆的大小\n    CGSize s = frame.size;\n    // 圆圈的半径，计算方式为，宽度或高度的一半（以较小者为准）减去点半径。\n    CGFloat radius = (s.width < s.height) ? s.width*0.5-dotDiameter*0.5 : s.height*0.5-dotDiameter*0.5;\n    // 周长\n    CGFloat circum = M_PI*radius*2.0;\n    // 虚线数量\n    NSUInteger numberOfDots = round(circum/(dotDiameter+expDotSpacing));\n    // 计算出的点间距，由周长除以点的数量减去点的直径得出。\n    CGFloat dotSpacing = (circum/numberOfDots)-dotDiameter;\n    // 圆形路径-以层的中心为中心，从弧的顶部开始。\n    UIBezierPath* path = [UIBezierPath bezierPathWithArcCenter:(CGPoint){frame.origin.x + s.width*0.5, frame.origin.y + s.height*0.5} radius:radius startAngle:-M_PI*0.5 endAngle:M_PI*1.5 clockwise:YES];\n    // 每个点的直径\n    path.lineWidth = dotDiameter;\n    // 点的形状\n    path.lineCapStyle = kCGLineCapSquare;\n    // 填充线段的长度（根据线宽计算的半径），点直径加上未填充线段的点间距\n    CGFloat dash[] = {0.0, dotSpacing+dotDiameter};\n    [path setLineDash:dash count:2 phase:0];\n    // 填充色\n    if (fillColor) {\n        [fillColor set];\n        [path fill];\n    }\n    // 线框色\n    if (strokeColor) {\n        [strokeColor setStroke];\n        [path stroke];\n    }\n}\n```\n\n![21](../iOS/UIBezierPath/21.png)\n\n### 渐变多边形\n\n```js\n- (void)setYAxisLayer:(NSArray *)series {\n    CGFloat max_r = self.bounds.size.width * 0.5;\n    CGFloat r = max_r;\n    CGFloat x = 0;\n    CGFloat y = 0;\n    CGFloat angle = 360.0 / series.count;\n    \n    CGFloat top  = max_r * 2.0;\n    CGFloat bottom = 0;\n    \n    NSMutableArray *dotPointArray = [NSMutableArray arrayWithCapacity:series.count];\n    UIBezierPath *path = [UIBezierPath bezierPath];\n    for (int i = 0; i < series.count; i++) {\n        NSNumber *num = series[i];\n        CGFloat radian = kDegreesToRadian(angle * i);\n        r = (num.floatValue / self.maxValue) * max_r;\n        r = MIN(r, max_r);\n        x = max_r + sinf(radian) * r;\n        y = max_r - cosf(radian) * r;\n        CGPoint p = CGPointMake(x, y);\n        if (i == 0) {\n            [path moveToPoint:p];\n        } else {\n            [path addLineToPoint:p];\n        }\n        [dotPointArray addObject:[NSValue valueWithCGPoint:p]];\n        \n        top  = top < y ? top : y;\n        bottom = bottom > y ? bottom : y;\n    }\n    path.lineWidth = 1.0;\n    [path closePath];\n    [path stroke];\n    \n    CAShapeLayer *layer = [[CAShapeLayer alloc] init];\n    layer.strokeColor = vkColorFromHex(self.yAxisHex).CGColor;\n    layer.fillColor = vkColorFromHex(self.yAxisHex).CGColor;\n    layer.path = path.CGPath;\n    \n    CGFloat color01 = top / (max_r * 2.0);\n    CGFloat color02 = bottom / (max_r * 2.0);\n    // gLayer 的坐标从 layer 的 (0, 0) 点开始\n    CAGradientLayer *gLayer = [CAGradientLayer layer];\n    gLayer.frame = self.bounds;\n    gLayer.locations = @[@(color01), @(color02)];\n    gLayer.colors = @[(__bridge id)vkColorFromHex(self.yAxisHex).CGColor,\n                      (__bridge id)[UIColor colorWithHex:self.yAxisHex alpha:0.24].CGColor];\n    gLayer.startPoint = CGPointMake(0.5, 0);\n    gLayer.endPoint = CGPointMake(0.5, 1);\n    gLayer.mask = layer;\n    [self.layer addSublayer:gLayer];\n    \n    CAShapeLayer *lineLayer = [[CAShapeLayer alloc] init];\n    lineLayer.strokeColor = vkColorFromHex(self.yAxisHex).CGColor;\n    lineLayer.fillColor = [UIColor clearColor].CGColor;\n    lineLayer.path = path.CGPath;\n    lineLayer.lineWidth = 1.0;\n    // 角过尖锐的话，会超出UI范围\n    lineLayer.lineCap = @\"bevel\"; //线条拐角\n    lineLayer.lineJoin = @\"bevel\"; //终点处理\n    [self.layer addSublayer:lineLayer];\n    \n    for (NSValue *value in dotPointArray) {\n        CGPoint textPoint = value.CGPointValue;\n        [self setDotLayer:textPoint];\n    }\n}\n```\n\n![22](../iOS/UIBezierPath/22.png)\n\n### 提示框\n\n```swift\noverride func draw(_ rect: CGRect) {\n    // 圆角\n    let r = 8.0\n    // 箭头高度\n    let offset = 10.0\n    // 箭头位置\n    let positionNum = rect.size.width / 2.0\n    // 移动量（坐标点）\n    let changeNum = r + offset\n    // 划线 长 宽\n    let w = rect.size.width\n    let h = rect.size.height\n    \n    // 获取文本\n    let context = UIGraphicsGetCurrentContext()!\n    // 边框宽度\n    context.setLineWidth(1.5);\n    // 边框颜色\n    context.setStrokeColor(UIColor(hex6: 0x272733).cgColor)\n    // 填充颜色\n    context.setFillColor(UIColor.clear.cgColor)\n    \n    // 开始坐标【左上角】（r, offset）\n    context.move(to: CGPoint(x: r, y: offset))\n    \n    // 向右划线 (r, offset) + (positionNum - 10, h - offset)\n    context.addLine(to: CGPoint(x: positionNum - 10, y: offset))\n    // 向右上划线 (positionNum - 10, offset) + (positionNum, 0)\n    context.addLine(to: CGPoint(x: positionNum, y: 0))\n    // 向右下划线 (positionNum, 0) + (positionNum + 10, offset)\n    context.addLine(to: CGPoint(x: positionNum + 10, y: offset))\n    \n    // 【右上角】设置弧线，三个点组成的直角：(r, offset) + (w, offset) + (w, r + offset)\n    context.addArc(tangent1End: CGPoint(x: w, y: offset), tangent2End: CGPoint(x: w, y: changeNum), radius: r)\n    // 【右下角】设置弧线，三个点组成的直角：(w, r + offset) + (w, h) + (w - r, h)\n    context.addArc(tangent1End: CGPoint(x: w, y: h), tangent2End: CGPoint(x: w - r, y: h), radius: r)\n    // 【左下角】设置弧线，三个点组成的直角：(w - r, h) + (0, h) + (0, h - r)\n    context.addArc(tangent1End: CGPoint(x: 0, y: h), tangent2End: CGPoint(x: 0, y: h - r), radius: r)\n    // 【左上角】设置弧线，三个点组成的直角：(0, h - r) + (0, offset) + (r, offset)\n    context.addArc(tangent1End: CGPoint(x: 0, y: offset), tangent2End: CGPoint(x: r, y: offset), radius: r)\n    \n    // 根据坐标绘制路径\n    context.drawPath(using: .fillStroke)\n    \n    super.draw(rect)\n  }\n```\n\n![23](../iOS/UIBezierPath/23.png)\n\n相关文档：\n\n1. [iOS绘图教程](https://www.cnblogs.com/xdream86/archive/2012/12/12/2814552.html)\n2. [iOS-Core-Animation-Advanced-Techniques](https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques)\n","source":"_posts/iOS/UIBezierPath.md","raw":"---\ntitle: iOS横竖屏\ndate: 2022-10-19 17:03:48\ntags: OC\n---\n\n## UIBezierPath\n\n`UIBezierPath` 是在 UIKit 中定义的类，可以用来创建基于矢量的**路径**，可以用来创建矩形、椭圆、曲线等等。`UIBezierPath`` 本质是对 Core Graphics 框架中的 CGPathRef 的封装。\n\n### API\n\n```js\nER_AUDIT_BEGIN(nullability, sendability)\n\nUIKIT_EXTERN API_AVAILABLE(ios(3.2)) @interface UIBezierPath : NSObject<NSCopying, NSSecureCoding>\n\n/// 创建 UIBezierPath 对象\n+ (instancetype)bezierPath;\n\n/// 创建矩形\n/// - Parameters:\n///   - rect: 大小\n+ (instancetype)bezierPathWithRect:(CGRect)rect;\n\n/// 创建圆形\n/// - Parameters:\n///   - rect: 大小\n+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;\n\n/// 创建圆角矩形\n/// - Parameters:\n///   - rect: 大小\n///   - cornerRadius: 圆角\n+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;\n\n/// 创建指定角为圆角的矩形\n/// - Parameters:\n///   - rect: 大小\n///   - corners: 指定角\n///   - cornerRadius: 圆角\n+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;\n\n/// 创建圆弧\n/// - Parameters:\n///   - center: 圆点\n///   - radius: 半径\n///   - startAngle: 开始位置\n///   - endAngle: 结束为止\n///   - clockwise: 是否顺时针方向\n+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;\n\n/// 根据已有路径创建新路径\n/// - Parameters:\n///   - CGPath: 已有路径\n+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;\n\n- (instancetype)init NS_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;\n\n/// 返回一个不可变的CGPathRef，该值仅在UIBezierPath进一步发生突变之前有效。\n/// 设置路径将创建所提供CGPathRef的不可变副本，因此将忽略所提供CGMutablePathRef上的任何进一步突变。\n@property(nonatomic) CGPathRef CGPath;\n- (CGPathRef)CGPath NS_RETURNS_INNER_POINTER CF_RETURNS_NOT_RETAINED;\n\n// 路径建设\n\n/// 移动到某一点\n/// - Parameters:\n///   - point: 指定点坐标\n- (void)moveToPoint:(CGPoint)point;\n\n/// 绘制一条直线\n/// - Parameters:\n///   - point: 指定点坐标\n- (void)addLineToPoint:(CGPoint)point;\n\n/// 创建三次贝塞尔曲线\n/// - Parameters:\n///   - endPoint: 终点\n///   - controlPoint1: 控制点1\n///   - controlPoint2: 控制点2\n- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;\n\n/// 创建两次贝塞尔曲线\n/// - Parameters:\n///   - endPoint: 终点\n///   - controlPoint: 控制点\n- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;\n\n/// 创建圆弧\n/// - Parameters:\n///   - center: 圆心\n///   - radius: 半径\n///   - startAngle: 开始位置\n///   - endAngle: 结束为止\n///   - clockwise: 是否顺时针方向\n- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise API_AVAILABLE(ios(4.0));\n\n/// 闭合路径，即在终点和起点绘制一根线\n- (void)closePath;\n\n/// 清空路径\n- (void)removeAllPoints;\n\n// 附加路径\n\n/// 追加路径\n/// - Parameters:\n///   - bezierPath: 路径\n- (void)appendPath:(UIBezierPath *)bezierPath;\n\n// 修改路径\n\n/// 翻转路径，即起点变终点，终点变起点\n- (UIBezierPath *)bezierPathByReversingPath API_AVAILABLE(ios(6.0));\n\n// 转换路径\n\n/// 路径进行仿射变换\n/// - Parameters:\n///   - transform: 仿射变换\n- (void)applyTransform:(CGAffineTransform)transform;\n\n// 路径信息\n\n/// 路径上是否有有效元素（只读）\n@property(readonly,getter=isEmpty) BOOL empty;\n\n/// 获取 Path 的 x坐标、y坐标、宽度，高度为0（不同于UIView的bounds）\n@property(nonatomic,readonly) CGRect bounds;\n\n/// 当前path的位置，可以理解为path的终点\n@property(nonatomic,readonly) CGPoint currentPoint;\n\n/// 是否包含某点\n/// - Parameters:\n///   - point: 指定点\n- (BOOL)containsPoint:(CGPoint)point;\n\n// 绘画属性\n\n/// path宽度\n@property(nonatomic) CGFloat lineWidth;\n\n/// path端点样式（butt：无端点；round：圆形端点；square：方形端点，跟 butt 一样，但是比 butt 长）\n@property(nonatomic) CGLineCap lineCapStyle;\n\n/// path拐角样式（miter：尖角；round：圆角；bevel：缺角）\n@property(nonatomic) CGLineJoin lineJoinStyle;\n\n/// 最大斜接长度，角度越小，斜接长度越大（在miter类型情况下，为了避免斜接长度过长，使用lineLimit属性限制，超过限制会以 bevel 类型来显示）\n@property(nonatomic) CGFloat miterLimit; \n\n/// 弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能\n@property(nonatomic) CGFloat flatness;\n\n/// 奇偶数圈规则是否用于绘制路径\n@property(nonatomic) BOOL usesEvenOddFillRule;\n\n/// 绘制虚线\n/// - Parameters:\n///   - pattern: 如何交替绘制，C类型现行数据（如：CGFloat dash[] = {0.0, dotSpacing+dotDiameter};）\n///   - count: 数组长度\n///   - phase: 偏移量\n- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;\n- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;\n\n// 当前图形上下文（CGContextRef）上的路径操作\n\n/// 填充\n- (void)fill;\n\n/// 描边，路径的绘制需要描边才能显示出来\n- (void)stroke;\n\n/*\n补充：\n\n设置描边颜色，需要在设置后调用描边发方法\n[[UIColor redColor] setStroke];\n\n设置填充颜色，需要在设置后调用填充方法\n[[UIColor redColor] setFill]; \n*/\n\n// 这些方法不会影响当前图形上下文（CGContextRef）的混合模式或alpha\n\n/// 设置填充的混合模式\n/// - Parameters:\n///   - blendMode: 混合模式\n///   - alpha: 透明度、\n- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;\n\n/// 设置描边的混合模式\n/// - Parameters:\n///   - blendMode: 混合模式\n///   - alpha: 透明度\n- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;\n\n/// 修改当前图形上下文（CGContextRef）的绘图区域可见\n- (void)addClip;\n\n@end\n\nNS_HEADER_AUDIT_END(nullability, sendability)\n```\n\n### 直线\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段；\n4. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 直线\n    UIBezierPath *path = [UIBezierPath bezierPath];\n    path.lineWidth = 10;\n    [path moveToPoint:CGPointMake(50, 50)];\n    [path addLineToPoint:CGPointMake(300, 50)];\n    // path.lineCapStyle = kCGLineCapButt; // 默认无线帽\n    [path stroke];\n    \n    // 圆形线帽\n    UIBezierPath *lineCapPath_round = [UIBezierPath bezierPath];\n    lineCapPath_round.lineWidth = 10;\n    [lineCapPath_round moveToPoint:CGPointMake(50, 100)];\n    [lineCapPath_round addLineToPoint:CGPointMake(300, 100)];\n    lineCapPath_round.lineCapStyle = kCGLineCapRound; // 圆角\n    [lineCapPath_round stroke];\n    \n    // 直角线帽\n    UIBezierPath *lineCapPath_square = [UIBezierPath bezierPath];\n    lineCapPath_square.lineWidth = 10;\n    [lineCapPath_square moveToPoint:CGPointMake(50, 150)];\n    [lineCapPath_square addLineToPoint:CGPointMake(300, 150)];\n    lineCapPath_square.lineCapStyle = kCGLineCapSquare; // 直角\n    [lineCapPath_square stroke];\n}\n```\n\n![01](../iOS/UIBezierPath/01.png)\n\n### 虚线\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段；\n4. `setLineDash:count:`：设置线段样式，交替绘制数组中的长度；\n5. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 虚线\n    UIBezierPath *lineDashPath = [UIBezierPath bezierPath];\n    lineDashPath.lineWidth = 10;\n    [lineDashPath moveToPoint:CGPointMake(50, 200)];\n    [lineDashPath addLineToPoint:CGPointMake(300, 200)];\n    CGFloat pattern[] = {10, 20};\n    [lineDashPath setLineDash:pattern count:2 phase:0];\n    [lineDashPath stroke];\n}\n```\n\n相较于实线，创建虚线多了一个设置项 `setLineDash:count:`，它是**交替**绘制的线段长度的数组。\n\n如果数组长度是偶数，如 `{10, 20}`，则 10 是虚线长度，20 是虚线间隙长度。\n\n![03](../iOS/UIBezierPath/03.png)\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 虚线\n    UIBezierPath *lineDashPath = [UIBezierPath bezierPath];\n    lineDashPath.lineWidth = 10;\n    [lineDashPath moveToPoint:CGPointMake(50, 200)];\n    [lineDashPath addLineToPoint:CGPointMake(300, 200)];\n    CGFloat pattern[] = {10, 20, 40};\n    [lineDashPath setLineDash:pattern count:3 phase:0];\n    [lineDashPath stroke];\n}\n```\n\n如果数组长度是奇数，如 `{10, 20, 40}`，则 10 即是虚线长度也是间隙长度，如下图：\n\n![02](../iOS/UIBezierPath/02.png)\n\n`setLineDash:count:` 中的 count 表示线段个数，dash 是线段长度数组。如果 dash 等于 {10, 20}，count 等于3，则第三个线段长度默认为0，交替方式为：\n\n![04](../iOS/UIBezierPath/04.png)\n\n### 三角行\n\n1. `bezierPath`：创建一个 UIBezierPath 对象；\n2. `moveToPoint:`：设置起点；\n3. `addLineToPoint:`：创建线段（多次调用创建多个子路径）；\n4. `closePath`：闭合路径，即在终点和起点绘制一根线；\n5. `stroke`：绘制线段；\n\n```js\n- (void)drawRect:(CGRect)rect {\n    \n    [[UIColor redColor] setStroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath = [UIBezierPath bezierPath];\n    lineJoinPath.lineWidth = 10;\n    [lineJoinPath moveToPoint:CGPointMake(50, 50)];\n    [lineJoinPath addLineToPoint:CGPointMake(300, 100)];\n    [lineJoinPath addLineToPoint:CGPointMake(50, 150)];\n    // lineJoinPath.lineJoinStyle = kCGLineJoinMiter; // 默认尖角\n    [lineJoinPath closePath];\n    [lineJoinPath stroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath_round = [UIBezierPath bezierPath];\n    lineJoinPath_round.lineWidth = 10;\n    [lineJoinPath_round moveToPoint:CGPointMake(50, 200)];\n    [lineJoinPath_round addLineToPoint:CGPointMake(300, 250)];\n    [lineJoinPath_round addLineToPoint:CGPointMake(50, 300)];\n    lineJoinPath_round.lineJoinStyle = kCGLineJoinRound; // 圆角\n    [lineJoinPath_round closePath];\n    [lineJoinPath_round stroke];\n    \n    // 三角形\n    UIBezierPath *lineJoinPath_bevel = [UIBezierPath bezierPath];\n    lineJoinPath_bevel.lineWidth = 10;\n    [lineJoinPath_bevel moveToPoint:CGPointMake(50, 350)];\n    [lineJoinPath_bevel addLineToPoint:CGPointMake(300, 400)];\n    [lineJoinPath_bevel addLineToPoint:CGPointMake(50, 450)];\n    lineJoinPath_bevel.lineJoinStyle = kCGLineJoinBevel; // 缺角\n    [lineJoinPath_bevel closePath];\n    [lineJoinPath_bevel stroke];\n}\n```\n\n![05](../iOS/UIBezierPath/05.png)\n\n`lineJoinStyle` 是设置斜接长度\n\n`kCGLineJoinMiter`：\n\n![11](../iOS/UIBezierPath/11.png)\n\n`kCGLineJoinBevel`：\n\n![12](../iOS/UIBezierPath/12.png)\n\n### 图形\n\n```js\n- (void)drawRect:(CGRect)rect {\n\n    // 设置描边色\n    [[UIColor redColor] setStroke];\n    \n    // 矩形\n    UIBezierPath *rectPath = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 100, 50)];\n    [rectPath stroke];\n    \n    // 圆\n    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 150, 100, 100)];\n    [ovalPath stroke];\n    \n    // 圆角矩形\n    UIBezierPath *roundPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 300, 100, 100) cornerRadius:20];\n    [roundPath stroke];\n    \n    // 指定角圆角矩形\n    UIBezierPath *roundPath2 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 450, 100, 100) byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    [roundPath2 stroke];\n    \n    // 圆弧\n    UIBezierPath *arcPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 650) radius:50 startAngle:0 endAngle:M_PI clockwise:YES];\n    [arcPath stroke];\n    \n    // 设置描边色\n    [[UIColor blueColor] setStroke];\n    \n    // 圆弧\n    UIBezierPath *arcPath2 = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 650) radius:50 startAngle:0 endAngle:-M_PI*0.5 clockwise:NO];\n    [arcPath2 stroke];\n    \n    // 设置填充色\n    [[UIColor blueColor] setFill];\n    \n    // 矩形\n    UIBezierPath *rectPath_fill = [UIBezierPath bezierPathWithRect:CGRectMake(200, 50, 100, 50)];\n    [rectPath_fill fill];\n    \n    // 圆\n    UIBezierPath *ovalPath_fill = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(200, 150, 100, 100)];\n    [ovalPath_fill fill];\n    \n    // 圆角矩形\n    UIBezierPath *roundPath_fill = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 300, 100, 100) cornerRadius:20];\n    [roundPath_fill fill];\n    \n    // 指定角圆角矩形\n    UIBezierPath *roundPath2_fill = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 450, 100, 100) byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    [roundPath2_fill fill];\n    \n    // 圆弧\n    UIBezierPath *arcPath_fill = [UIBezierPath bezierPathWithArcCenter:CGPointMake(250, 650) radius:50 startAngle:0 endAngle:M_PI clockwise:YES];\n    [arcPath_fill fill];\n    \n    // 设置填充色\n    [[UIColor redColor] setFill];\n    \n    // 圆弧\n    UIBezierPath *arcPath2_fill = [UIBezierPath bezierPathWithArcCenter:CGPointMake(250, 650) radius:50 startAngle:0 endAngle:-M_PI*0.5 clockwise:NO];\n    [arcPath2_fill fill];\n}\n```\n\n![06](../iOS/UIBezierPath/06.png)\n\n绘制圆形的角度关系\n\n![10](../iOS/UIBezierPath/10.png)\n\n### 曲线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边色\n    [[UIColor redColor] setStroke];\n    \n    // 一个控制点的曲线\n    UIBezierPath *quadCurvePath = [UIBezierPath bezierPath];\n    quadCurvePath.lineWidth = 5;\n    [quadCurvePath moveToPoint:CGPointMake(50, 100)];\n    [quadCurvePath addQuadCurveToPoint:CGPointMake(300, 100) controlPoint:CGPointMake(200, 150)];\n    [quadCurvePath stroke];\n    \n    // 两个控制点的曲线\n    UIBezierPath *curvePath = [UIBezierPath bezierPath];\n    curvePath.lineWidth = 5;\n    [curvePath moveToPoint:CGPointMake(50, 200)];\n    [curvePath addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(100, 150) controlPoint2:CGPointMake(250, 250)];\n    [curvePath stroke];\n}\n```\n\n![07](../iOS/UIBezierPath/07.png)\n\n二次曲线：包括两个起点，一个控制点。\n\n![09](../iOS/UIBezierPath/09.png)\n\n三次曲线：包括两个起点，两个控制点。\n\n![08](../iOS/UIBezierPath/08.png)\n\n## Core Graphics\n\nCore Graphics Framework 是一套基于 C 的 API 框架，使用了 Quartz 作为绘图引擎。它提供了低级别、轻量级、高保真度的 2D 渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩，以及PDF文档的创建、显示和分析。\n\niOS 支持两套图形API族：\n\n1. Core Graphics/QuartZ 2D（QuartZ 2D 是苹果公司开发的API，是 Core Graphics Framework 的一部分）；\n2. OpenGL ES（跨平台图形API，OpenGL 的简化版本）；\n\n`UIBezierPath` 是基于 Core Graphics 对 `CGPathRef` 数据类型的封装。\n\n### 直线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n    \n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    // 线帽，butt（默认值，无线帽）\n    CGContextSetLineCap(context, kCGLineCapButt);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 50);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 线帽，round（圆形）\n    CGContextSetLineCap(context, kCGLineCapRound);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 线帽，square（方形）\n    CGContextSetLineCap(context, kCGLineCapSquare);\n    // 线条宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 150);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 150);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![01](../iOS/UIBezierPath/01.png)\n\n### 虚线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 线段长度数组\n    CGFloat lengths[] = {10, 20};\n    \n    \n    // 宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 50);\n    // 设置虚线样式\n    CGContextSetLineDash(context, 0, lengths, 2);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    \n    // 宽度\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 设置虚线样式（phase = 20，虚线向左移动20）\n    CGContextSetLineDash(context, 20, lengths, 2);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![13](../iOS/UIBezierPath/13.png)\n\n### 三角形\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置描边颜色\n    [[UIColor redColor] setStroke];\n\n    // 后期当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    // 设置斜接角样式，miter（默认，尖角）\n    CGContextSetLineJoin(context, kCGLineJoinMiter);\n    // 线宽\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 100);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 150);\n    // 闭环\n    CGContextClosePath(context);\n    // 描边\n    CGContextStrokePath(context);\n    \n    // 设置斜接角仰视，round（圆形）\n    CGContextSetLineJoin(context, kCGLineJoinRound);\n    // 先款\n    CGContextSetLineWidth(context, 10);\n    // 起点\n    CGContextMoveToPoint(context, 50, 200);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 250);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 300);\n    // 闭环\n    CGContextClosePath(context);\n    // 绘制\n    CGContextStrokePath(context);\n    \n    // 设置斜接角样式，bevel（方形）\n    CGContextSetLineJoin(context, kCGLineJoinBevel);\n    // 起点\n    CGContextMoveToPoint(context, 50, 350);\n    // 创建线段\n    CGContextAddLineToPoint(context, 300, 400);\n    // 创建线段\n    CGContextAddLineToPoint(context, 50, 450);\n    // 闭环\n    CGContextClosePath(context);\n    // 绘制\n    CGContextStrokePath(context);\n}\n```\n\n![05](../iOS/UIBezierPath/05.png)\n\n### 更多图形\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    \n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    CGContextMoveToPoint(context, 50, 50);\n    CGContextAddLineToPoint(context, 150, 75);\n    CGContextAddLineToPoint(context, 50, 100);\n    \n    // 矩形\n    CGContextAddRect(context, CGRectMake(50, 150, 100, 100));\n    \n    // 圆\n    CGContextAddEllipseInRect(context, CGRectMake(50, 300, 100, 100));\n    \n    // 椭圆\n    CGContextAddEllipseInRect(context, CGRectMake(50, 450, 100, 50));\n    \n    // 描边（绘制上面的path，下面的path单独绘制）\n    CGContextStrokePath(context);\n    \n    // 圆弧（(x, y)中心点，radius半径，startAngle起点，endAngle终点，clockwise顺时针0、逆时针1）\n    CGContextAddArc(context, 100, 600, 50, 0, M_PI, 0);\n    \n    // 描边（绘制上面的path，下面的path单独绘制）\n    CGContextStrokePath(context);\n    \n    // 改变颜色\n    [[UIColor blueColor] setStroke];\n    // 圆弧\n    CGContextAddArc(context, 100, 600, 50, M_PI, M_PI * 1.5, 0);\n    // 描边\n    CGContextStrokePath(context);\n}\n```\n\n![14](../iOS/UIBezierPath/14.png)\n\n填充样式：\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    [[UIColor blueColor] setFill];\n\n    // 获取当前上下文（CGContextRef）\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 三角\n    CGPoint points[] = {CGPointMake(200, 50), CGPointMake(300, 75), CGPointMake(200, 100)};\n    CGContextAddLines(context, points, 3);\n    CGContextClosePath(context);\n    \n    // 矩形\n    CGContextAddRect(context, CGRectMake(200, 150, 100, 100));\n    \n    // 圆\n    CGContextAddEllipseInRect(context, CGRectMake(200, 300, 100, 100));\n    \n    // 椭圆\n    CGContextAddEllipseInRect(context, CGRectMake(200, 450, 100, 50));\n    // CGContextFillEllipseInRect(context, CGRectMake(150, 450, 100, 50));\n    \n    CGContextFillPath(context);\n    \n    // 圆弧\n    CGContextAddArc(context, 250, 600, 50, 0, -M_PI, 1);\n    CGContextFillPath(context);\n    \n    CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);\n    CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);\n    CGContextAddArc(context, 250, 600, 50, -M_PI, -M_PI*1.5, 1);\n    \n    CGContextFillPath(context);\n}\n```\n\n![15](../iOS/UIBezierPath/15.png)\n\n### 贝塞尔曲线\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    \n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 起点\n    CGContextMoveToPoint(context, 50, 50);\n    // 弧线（(x1, y1)起点，(x2, y2)终点，半径）\n    CGContextAddArcToPoint(context, 250, 50, 200, 150, 20);\n    \n    CGContextMoveToPoint(context, 50, 200);\n    // 二次贝塞尔曲线（(cpx, cpy)控制点，(x, y)终点）\n    CGContextAddQuadCurveToPoint(context, 200, 100, 250, 200);\n    \n    CGContextMoveToPoint(context, 50, 300);\n    // 三次贝塞尔曲线（(cp1x, cp1y)控制点，(cp2x, cp2y)控制点，(x, y)终点）\n    CGContextAddCurveToPoint(context, 100, 200, 200, 400, 250, 300);\n    \n    CGContextStrokePath(context);\n}\n```\n\n![16](../iOS/UIBezierPath/16.png)\n\n### 高级API\n\n```js\n- (void)drawRect:(CGRect)rect {\n    [[UIColor redColor] setStroke];\n    [[UIColor blueColor] setFill];\n    \n    CGPoint points[] = {CGPointMake(50, 50), CGPointMake(250, 50), CGPointMake(100, 80), CGPointMake(250, 80)};\n    \n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetLineWidth(context, 10);\n    \n    // 绘制直线线，p0-p1，p2-p3\n    CGContextStrokeLineSegments(context, points, 4);\n    \n    // 矩形\n    CGContextStrokeRect(context, CGRectMake(50, 150, 100, 100));\n    \n    // 矩形，指定线宽\n    CGContextStrokeRectWithWidth(context, CGRectMake(50, 300, 100, 100), 1);\n    // 填充矩形\n    CGContextFillRect(context, CGRectMake(200, 300, 100, 100));\n    \n    // 同时创建多个填充矩形\n    CGRect rects[] = {CGRectMake(50, 450, 100, 100), CGRectMake(200, 450, 100, 100)};\n    CGContextFillRects(context, rects, 2);\n    \n    // 椭圆\n    CGContextStrokeEllipseInRect(context, CGRectMake(50, 600, 100, 60));\n    // 填充椭圆\n    CGContextFillEllipseInRect(context, CGRectMake(200, 600, 100, 60));\n}\n```\n\n![17](../iOS/UIBezierPath/17.png)\n\n### push\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置填充色：红色\n    [[UIColor redColor] setFill];\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 50, 100, 100));\n    // 把context压入栈中，并把context设置为当前绘图上下文\n    UIGraphicsPushContext(UIGraphicsGetCurrentContext());\n    // 设置填充色：蓝色\n    [[UIColor blueColor] setFill];\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 200, 100, 100));\n    // 将栈顶的上下文弹出，恢复先前的上下文，但是绘图状态不变\n    UIGraphicsPopContext();\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 350, 100, 100));\n}\n```\n\n![18](../iOS/UIBezierPath/18.png)\n\n### SaveGState\n\n```js\n- (void)drawRect:(CGRect)rect {\n    // 设置填充色：红色\n    [[UIColor redColor] setFill]; // red\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 50, 100, 100));\n    // 保存状态\n    CGContextSaveGState(UIGraphicsGetCurrentContext()); // red\n    // 设置填充色：蓝色\n    [[UIColor blueColor] setFill]; // blue\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 200, 100, 100));\n    // 恢复状态\n    CGContextRestoreGState(UIGraphicsGetCurrentContext()); // red\n    // 设置填充范围\n    UIRectFill(CGRectMake(50, 350, 100, 100)); // red\n}\n```\n\n![19](../iOS/UIBezierPath/19.png)\n\n## drawRect\n\n上面演示的 UIBezierPath 和 Core Graphics，都是在 `drawRect:` 方法里实现的，所以这里有一个问题：为什么要在 `drawRect:` 方法内实现绘图操作？\n\n### 思考：为什么要在 `drawRect:` 方法内实现绘图操作\n\n因为 Core Graphics API 所有的操作都在上下文中进行，所以在绘图前需要获取该上下文并传入执行渲染的函数内。上下文就是**内存中的一块画布**，屏幕上的所有图片有自己所属的画布（上下文），同时任何绘图操作都要在画布（上下文）上实现。\n\n有两种获取上下文的常用方法：\n\n一、重载 UIView 的 `- (void)drawRect:(CGRect)rect` 方法，利用 Cocoa 自动生成的上下文\n\n1. 子类化 `UIView` 并实现 `drawRect:` 方法，一旦 `drawRect:` 方法被调用，Cocoa 就会创建一个图形上下文；\n\n2. 调用 `UIGraphicsGetCurrentContext()` 函数，获取到当前的图形上下文；\n\n3. 进行绘图操作，所有操作都会显示在当前上下文对应的 UIView 上；\n\n4. 重绘：`setNeedDisplay`。\n\n二、创建一个图片类型的上下文\n\n1. 调用 `UIGraphicsBeginImageContext()` 或 `UIGraphicsBeginImageContextWithOptions()` 函数可以获得处理图片的图形上下文；\n\n2. 调用 `UIGraphicsGetImageFromCurrentImageContext()` 函数可以从画布（上下文）中获取一个 UIImag 对象；\n\n3. 调用 `UIGraphicsEndImageContext()` 函数关闭图形上下文。\n\n### UIGraphicsBeginImageContext\n\n在 `drawRect:` 方法**外**完成绘图操作：\n\n```js\n- (void)withoutDrawRect {\n    \n    CGRect rect = CGRectMake(50, 50, 100, 100);\n    // 获取图形上下文，用来处理图片\n    UIGraphicsBeginImageContext(rect.size);\n    // 获取当前上下文\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 设置填充色\n    CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);\n    // 设置填充坐标、大小（在rect内的坐标）\n    CGContextFillRect(context, CGRectMake(0, 0, 100, 100));\n    // 设置边框颜色\n    CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);\n    // 设置边框宽度\n    CGContextSetLineWidth(context, 5);\n    // 设置边框坐标、大小（在rect内的坐标）\n    CGContextStrokeRect(context, CGRectMake(0, 0, 100, 100));\n    // 当前上下文中获取 UIImage 对象\n    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();\n    // 关闭图形上下文\n    UIGraphicsEndImageContext();\n    \n    // 展示\n    UIImageView *imageView = [[UIImageView alloc] initWithImage:theImage];\n    imageView.frame = rect;\n    [self addSubview:imageView];\n}\n```\n\n![20](../iOS/UIBezierPath/20.png)\n\n这里使用 `UIGraphicsBeginImageContext()` 方法，完成了在 `drawRect:` 方法外绘图的操作。\n\n## Core Animation\n\n### CALayer\n\n一、重载 CALayer 的 `- (void)drawInContext:(CGContextRef)ctx` 方法，利用 Cocoa 自动生成的上下文\n\n1. 子类化 `CALayer` 并实现 `- (void)drawInContext:(CGContextRef)ctx` 方法，一旦 `- (void)drawInContext:(CGContextRef)ctx` 方法被调用，Cocoa 就会创建一个图形上下文；\n\n2. 调用 `UIGraphicsGetCurrentContext()` 函数，获取到当前的图形上下文；\n\n3. 进行绘图操作，所有操作都会显示在当前上下文对应的 UIView 上；\n\n4. 重绘：`setNeedDisplay`。\n\n因为 `- (void)drawInContext:(CGContextRef)ctx` 方法内部会调用 CALayerDelegate 协议中的 `-drawLayer:inContext:` 方法，所以也可以实现`-drawLayer:inContext:` 方法获取到当前上下文。\n\n```js\n/* If defined, called by the default implementation of -drawInContext: */\n\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;\n```\n\n### CAShapeLayer\n\n`CAShapeLayer` 是一个通过矢量图形而不是 bitmap（位图）来绘制的图层子类。可以设置颜色和线宽，用 `CGPath` 定义图形，让 `CAShapeLayer` 自动渲染出来。先比用 Core Graphics 直接向原始的 CALayer 的内容中绘制路径，使用 CAShapeLayer 有四点优势：\n\n1. 渲染快速。\n2. 高效使用内存。\n3. 不会被图层边界剪裁掉。\n4. 不会出现像素化。\n\n`CAShapeLayer` 可以绘制所有能够通过 CGPath 来表示的形状。这个形状不一定要闭合，图层路径也不一定要不间断，可以在一个图层上绘制好几个不同的形状。\n\n`CAShapeLayer` 有图形属性，如 `lineWidth`（线宽，用点表示单位），`lineCap`（线条结尾的样子），和 `lineJoin`（线条之间的结合点的样子）等等。\n\n在图层层面，只有一次机会设置这些属性，如果想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。 \n\n### CAShapeLayer & Core Graphics\n\n术语**绘图**通常在 Core Animation 的上下文中指代软件绘图，即不由 GPU 协助的绘图。在 iOS 中，软件绘图通常是由 Core Graphics 框架完成。但是，在一些必要的情况下，Core Graphics 要比 Core Animation 和 OpenGL 慢很多。\n\n软件绘图不仅效率低，而且还会消耗较大的内存。一旦实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（对前者的包装），图层就会创建一个绘制上下文，这个上下文需要的内存大小如下，宽高的单位是**像素**：\n\n```js\n上下文大小 = 图层宽 * 图层高 * 4字节\n```\n\n对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 `2048 * 1526 * 4 字节 = 12MB`。图层每次重绘的时候都需要**重新抹掉内存然后重新分配**。\n\n软件绘图的代价昂贵，除非绝对必要，应该避免重绘视图。\n\n而提高绘制性能的秘诀就是避免绘制，如使用 CAShapeLayer 代替 Core Graphics。\n\n### 显示的大致流程\n\n1. **布局** - 准备视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等）的阶段；\n2. **显示** - 绘制图层的寄宿图的阶段。绘制有可能涉及到 UIView 的 -drawRect: 和 CALayer 的 -drawLayer:inContext: 方法的调用路径；\n3. **准备** - Core Animation 准备发送数据到渲染服务的阶段；\n4. **光栅化** - 对所有的图层属性计算中间值，设置 OpenGL 几何形状（纹理化的三角形）来执行渲染；\n5. **渲染** - 在屏幕上渲染可见的三角形。\n\n### UIView - CALayer - Core Graphics\n\n![24](../iOS/UIBezierPath/24.png)\n\n* 继承关系：`UIView —> UIResponder —> NSObject`，`CALayer —> NSObject`。\n\n* 响应时间：因为 UIView 继承自 UIResponder，所以 UIView 可以响应时间。因为 CALayer 继承自 NSObject，所以 CALayer 不能响应事件。\n\n* 框架：UIView 在 UIKit 框架中定义，用来构建界面、响应事件。CALayer 在 QuartzCore 框架中定义，绘制 2D 图像。\n\n* 寄宿图：即图层中包含的图。UIView 内部联图了一个 CALayer 图层，即 backing layer。CALayer 内部包含一个 content 属性指向一块缓冲区，即 backing store，里面存放位图（bitmap）。iOS 中奖缓存区的图片称为寄宿图。寄宿图有两种设置方式：1、想 content 设置 CGImage 图片，这需要以来 Core Image 提供图片；2、实现 UIView 的 drawRect: 方法自定义绘图，这需要依赖 Core Graphics 绘制图形，再由 CALayer 生成图片。\n\n* UIView 的显示原理：CALayer 会创建一个图形上下文（CGContextRef），然后调用 CALayerDelegate 协议（这里是 UIView 实现）的 `-drawLayer:inContext:` 方法，传入创建好的图形上下文（CGContextRef）对象，在 `-drawLayer:inContext:` 方法内部再调用 UIView 的 `-drawRect:` 方法。\n\n## 应用\n\n### 虚线圆形\n\n问题：因为在设置虚线的线段长度和间隙长度时会不等于周长，所以就会出现虚线的尾部和头部的结合部分不匀称。\n\n解决方案：通过计算得到实际的间隙长度，代替期望的间隙长度。\n\n1. 半径 * M_PI * 2.0 = 周长；\n2. 周长 / (线段长度 + 期望间隙长度) = 线段数量；\n3. (周长 / 线段数量) - 线段长度 = 实际间隙长度；\n\n```js\n// 虚线圆\n- (void)setDashedLineCirclePath:(CGRect)frame fill:(UIColor *)fillColor stroke:(UIColor *)strokeColor {\n    // 虚线直径\n    CGFloat dotDiameter = self.xAxisDashDotDiameter;\n    // 期望的虚线间隙\n    CGFloat expDotSpacing = self.xAxisDashExpDotSpacing;\n    // 圆的大小\n    CGSize s = frame.size;\n    // 圆圈的半径，计算方式为，宽度或高度的一半（以较小者为准）减去点半径。\n    CGFloat radius = (s.width < s.height) ? s.width*0.5-dotDiameter*0.5 : s.height*0.5-dotDiameter*0.5;\n    // 周长\n    CGFloat circum = M_PI*radius*2.0;\n    // 虚线数量\n    NSUInteger numberOfDots = round(circum/(dotDiameter+expDotSpacing));\n    // 计算出的点间距，由周长除以点的数量减去点的直径得出。\n    CGFloat dotSpacing = (circum/numberOfDots)-dotDiameter;\n    // 圆形路径-以层的中心为中心，从弧的顶部开始。\n    UIBezierPath* path = [UIBezierPath bezierPathWithArcCenter:(CGPoint){frame.origin.x + s.width*0.5, frame.origin.y + s.height*0.5} radius:radius startAngle:-M_PI*0.5 endAngle:M_PI*1.5 clockwise:YES];\n    // 每个点的直径\n    path.lineWidth = dotDiameter;\n    // 点的形状\n    path.lineCapStyle = kCGLineCapSquare;\n    // 填充线段的长度（根据线宽计算的半径），点直径加上未填充线段的点间距\n    CGFloat dash[] = {0.0, dotSpacing+dotDiameter};\n    [path setLineDash:dash count:2 phase:0];\n    // 填充色\n    if (fillColor) {\n        [fillColor set];\n        [path fill];\n    }\n    // 线框色\n    if (strokeColor) {\n        [strokeColor setStroke];\n        [path stroke];\n    }\n}\n```\n\n![21](../iOS/UIBezierPath/21.png)\n\n### 渐变多边形\n\n```js\n- (void)setYAxisLayer:(NSArray *)series {\n    CGFloat max_r = self.bounds.size.width * 0.5;\n    CGFloat r = max_r;\n    CGFloat x = 0;\n    CGFloat y = 0;\n    CGFloat angle = 360.0 / series.count;\n    \n    CGFloat top  = max_r * 2.0;\n    CGFloat bottom = 0;\n    \n    NSMutableArray *dotPointArray = [NSMutableArray arrayWithCapacity:series.count];\n    UIBezierPath *path = [UIBezierPath bezierPath];\n    for (int i = 0; i < series.count; i++) {\n        NSNumber *num = series[i];\n        CGFloat radian = kDegreesToRadian(angle * i);\n        r = (num.floatValue / self.maxValue) * max_r;\n        r = MIN(r, max_r);\n        x = max_r + sinf(radian) * r;\n        y = max_r - cosf(radian) * r;\n        CGPoint p = CGPointMake(x, y);\n        if (i == 0) {\n            [path moveToPoint:p];\n        } else {\n            [path addLineToPoint:p];\n        }\n        [dotPointArray addObject:[NSValue valueWithCGPoint:p]];\n        \n        top  = top < y ? top : y;\n        bottom = bottom > y ? bottom : y;\n    }\n    path.lineWidth = 1.0;\n    [path closePath];\n    [path stroke];\n    \n    CAShapeLayer *layer = [[CAShapeLayer alloc] init];\n    layer.strokeColor = vkColorFromHex(self.yAxisHex).CGColor;\n    layer.fillColor = vkColorFromHex(self.yAxisHex).CGColor;\n    layer.path = path.CGPath;\n    \n    CGFloat color01 = top / (max_r * 2.0);\n    CGFloat color02 = bottom / (max_r * 2.0);\n    // gLayer 的坐标从 layer 的 (0, 0) 点开始\n    CAGradientLayer *gLayer = [CAGradientLayer layer];\n    gLayer.frame = self.bounds;\n    gLayer.locations = @[@(color01), @(color02)];\n    gLayer.colors = @[(__bridge id)vkColorFromHex(self.yAxisHex).CGColor,\n                      (__bridge id)[UIColor colorWithHex:self.yAxisHex alpha:0.24].CGColor];\n    gLayer.startPoint = CGPointMake(0.5, 0);\n    gLayer.endPoint = CGPointMake(0.5, 1);\n    gLayer.mask = layer;\n    [self.layer addSublayer:gLayer];\n    \n    CAShapeLayer *lineLayer = [[CAShapeLayer alloc] init];\n    lineLayer.strokeColor = vkColorFromHex(self.yAxisHex).CGColor;\n    lineLayer.fillColor = [UIColor clearColor].CGColor;\n    lineLayer.path = path.CGPath;\n    lineLayer.lineWidth = 1.0;\n    // 角过尖锐的话，会超出UI范围\n    lineLayer.lineCap = @\"bevel\"; //线条拐角\n    lineLayer.lineJoin = @\"bevel\"; //终点处理\n    [self.layer addSublayer:lineLayer];\n    \n    for (NSValue *value in dotPointArray) {\n        CGPoint textPoint = value.CGPointValue;\n        [self setDotLayer:textPoint];\n    }\n}\n```\n\n![22](../iOS/UIBezierPath/22.png)\n\n### 提示框\n\n```swift\noverride func draw(_ rect: CGRect) {\n    // 圆角\n    let r = 8.0\n    // 箭头高度\n    let offset = 10.0\n    // 箭头位置\n    let positionNum = rect.size.width / 2.0\n    // 移动量（坐标点）\n    let changeNum = r + offset\n    // 划线 长 宽\n    let w = rect.size.width\n    let h = rect.size.height\n    \n    // 获取文本\n    let context = UIGraphicsGetCurrentContext()!\n    // 边框宽度\n    context.setLineWidth(1.5);\n    // 边框颜色\n    context.setStrokeColor(UIColor(hex6: 0x272733).cgColor)\n    // 填充颜色\n    context.setFillColor(UIColor.clear.cgColor)\n    \n    // 开始坐标【左上角】（r, offset）\n    context.move(to: CGPoint(x: r, y: offset))\n    \n    // 向右划线 (r, offset) + (positionNum - 10, h - offset)\n    context.addLine(to: CGPoint(x: positionNum - 10, y: offset))\n    // 向右上划线 (positionNum - 10, offset) + (positionNum, 0)\n    context.addLine(to: CGPoint(x: positionNum, y: 0))\n    // 向右下划线 (positionNum, 0) + (positionNum + 10, offset)\n    context.addLine(to: CGPoint(x: positionNum + 10, y: offset))\n    \n    // 【右上角】设置弧线，三个点组成的直角：(r, offset) + (w, offset) + (w, r + offset)\n    context.addArc(tangent1End: CGPoint(x: w, y: offset), tangent2End: CGPoint(x: w, y: changeNum), radius: r)\n    // 【右下角】设置弧线，三个点组成的直角：(w, r + offset) + (w, h) + (w - r, h)\n    context.addArc(tangent1End: CGPoint(x: w, y: h), tangent2End: CGPoint(x: w - r, y: h), radius: r)\n    // 【左下角】设置弧线，三个点组成的直角：(w - r, h) + (0, h) + (0, h - r)\n    context.addArc(tangent1End: CGPoint(x: 0, y: h), tangent2End: CGPoint(x: 0, y: h - r), radius: r)\n    // 【左上角】设置弧线，三个点组成的直角：(0, h - r) + (0, offset) + (r, offset)\n    context.addArc(tangent1End: CGPoint(x: 0, y: offset), tangent2End: CGPoint(x: r, y: offset), radius: r)\n    \n    // 根据坐标绘制路径\n    context.drawPath(using: .fillStroke)\n    \n    super.draw(rect)\n  }\n```\n\n![23](../iOS/UIBezierPath/23.png)\n\n相关文档：\n\n1. [iOS绘图教程](https://www.cnblogs.com/xdream86/archive/2012/12/12/2814552.html)\n2. [iOS-Core-Animation-Advanced-Techniques](https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques)\n","slug":"iOS/UIBezierPath","published":1,"updated":"2024-02-02T11:04:33.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguq0021aq7k51bjzy0p"},{"title":"AVL树","date":"2021-01-15T10:25:13.000Z","_content":"\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n\n<!-- more -->\n\n# 平衡二叉搜索树（Balanced Binary Search Tree）\n## 二叉搜索树的复杂度分析\n依次添加节点 `7、4、9、2、5、8、11` 得到的二叉搜索树，添加、删除和搜索操作的复杂度跟二叉搜索树的高度有关，O(h) == O(logn)。\n![AVL树](AVL树/AVL树01.png)\n\n依次添加节点 `2、4、5、7、8、9、11` 得到的二叉搜索树，添加、删除和搜索操作的复杂度跟节点个数有关，O(h) == O(n)。二叉搜索树退化成了链表。\n![AVL树](AVL树/AVL树02.png)\n\n当 n 比较大时，两者的性能差异比较大。如 n == 1000000 时，二叉搜索树的最低高度是 20。\n\n## 平衡（Balance）\n平衡：当节点数固定时，左右子树的高度越接近，这课二叉树就越平衡（高度越低）\n![AVL树](AVL树/AVL树03.png)\n\n## 理想平衡\n最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的。\n![AVL树](AVL树/AVL树04.png)\n\n## 如何改进二叉搜索树？\n因为节点的添加、删除顺序是无法限制的，可以认为是随机的，所以改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。\n![AVL树](AVL树/AVL树05.png)\n\n如果按照图中的调整方式再继续调整其它节点的位置，就可以达到理想平衡。但是调整的次数太多，反而增加了时间复杂度。所以，比较合理的改进方案是：用尽量少的调整次数达到适合平衡即可，即平衡二叉搜索树。\n\n## 经典的平衡二叉搜索树\n平衡二叉搜索树简称：BBST。\n\n### AVL 树\nWindows NT 内核中广泛使用\n\n### 红黑树\n1. C++ STL（比如：map、set）；\n2. Java 的 TreeMap、TreeSet、HashMap、HashSet；\n3. Linux 的进度调整；\n4. Ngix 的 timer 管理；\n\nAVL 树、红黑树一般也称为自平衡的二叉搜索树。\n\n# AVL 树\n\n## 平衡因子\n平衡因子（Balance Factor）：某节点的左右子树的高度差。\n\nAVL树的特点：\n1. 每个节点的平衡因子只可能是 1、0、-1（绝对值 <= 1，如果超过 1，称之为“失衡”）；\n2. 每个节点的左右子树高度差不超过 1；\n3. 搜索、添加和删除的时间复杂度是 O(logn)；  \n![AVL树](AVL树/AVL树06.png)\n\n## 继承结构\n创建 AVLTree 继承自 BST。红黑树同理，创建 RBTree 继承自 BST。\n![AVL树](AVL树/AVL树07.png)\n\n# 添加导致的失衡\n下面这个子树原本是平衡的，添加节点`13`后出现失衡。最坏情况是导致节点`13`的所有祖先节点都失衡（`14`、`15`、`9`及其父节点）。节点`13`的父节点、非祖先节点都不可能失衡。\n![AVL树](AVL树/AVL树08.png)\n\n## LL-右旋转（单旋）\n`n`（node）、`p`（paren）和`g`（grandparent），`T0`（n的左子树）、`T1`（n的右子树）、`T2`（p的右子树）、`T3`（g的右子树）。\n\n1. `g.left = p.right`\n2. `p.right = g`\n3. 让`p`成为这棵子树的根节点\n4. 更新 `T2`、`p`、`g` 的 parent 属性\n5. 先后更新 `g`、`p` 的高度\n\n旋转后的子树又恢复了平衡，仍然是一棵二叉搜索树：T0 < g < T1 < p < T2 < n < T3。\n\n注意：一定要修改 `T2`、`p`、`g` 的 parent 属性；依次更新 `g`、`p` 的高度（因为旋转后，`g` 是 `p` 的右子树，所以先计算子树的高度，然后 +1 就是 `p` 的高度）。\n![AVL树](AVL树/AVL树09.png)\n\n## RR-左旋转（单旋）\n1. `g.right = p.left`\n2. `p.left = g`\n3. 让`p`成为这个子树的根节点\n4. 更新 `T1`、`p`、`g` 的 parent 属性\n5. 先后更新 `g`、`p` 的高度\n\n旋转后的子树又恢复了平衡，仍然是一棵二叉搜索树：T0 < g < T1 < p < T2 < n < T3。\n![AVL树](AVL树/AVL树10.png)\n\n## LR-RR左旋转，LL右旋转（双旋）\n![AVL树](AVL树/AVL树11.png)\n\n## RL-LL右旋转，RR左旋转（双旋）\n![AVL树](AVL树/AVL树12.png)\n\n## CODE\n```\npublic void add(E element) {\n    elementNotNullCheck(element);\n    //添加第一个节点\n    if (root == null) {\n        root = createNode(element, null);\n        size++;\n        // 新添加节点之后的处理\n        afterAdd(root);\n        return;\n    }\n    // 添加的不是第一个节点\n    // 找到父节点\n    Node<E> parent = root;\n    Node<E> node = root;\n    int cmp = 0;\n    while (node != null) {\n        cmp = compare(element, node.element);\n        parent = node;\n        if (cmp > 0) {\n            node = node.right;\n        } else if (cmp < 0) {\n            node = node.left;\n        } else {\n            node.element = element;\n            return;\n        }\n    }\n    Node<E> newNode = createNode(element, parent);\n    if (cmp > 0) {\n        parent.right = newNode;\n    } else {\n        parent.left = newNode;\n    }\n    \n    size++;\n    // 新添加节点之后的处理\n    afterAdd(newNode);\n}\n```\n\n### 添加处理（affterAdd）\n在节点的添加、删除操作之后，先办法让二叉搜索树恢复平衡（减小树的高度）。  \n在 BST 定义：\n```\nprotected void afterAdd(Node<E> node) { }\n```\n\n在 AVLTree 实现：\n```\n@Override\nprotected void afterAdd(Node<E> node) {\n    while ((node = node.parent) != null) {\n        if (isBalanced(node)) {\n            // 更新高度\n            updateHeight(node);\n        } else {\n            // 恢复平衡\n            rebalance(node);\n            // 整棵树恢复平衡\n            break;\n        }\n    }\n}\n\nprivate boolean isBalanced(Node<E> node) {\n    return Math.abs(((AVLNode<E>)node).balanceFactor()) <= 1;\n}\n\nprivate void updateHeight(Node<E> node) {\n    ((AVLNode<E>)node).updateHeight();\n}\n```\n\n### AVLNode\n1. 因为 Node 里用不到 height 属性，所以定义 AVLNode 继承自 Node，添加 height 属性；\n2. `isBalanced()` 是否平衡；\n3. `updateHeight()` 更新高度；\n4. `tallerChild()` 高度较高的子树，用于恢复平衡；\n```\nprivate static class AVLNode<E> extends Node<E> {\n    //叶子节点高度默认1\n    int height = 1;\n    \n    public AVLNode(E element, Node<E> parent) {\n        super(element, parent);\n    }\n    \n    public int balanceFactor() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        return leftHeight - rightHeight;\n    }\n    \n    public void updateHeight() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        height= 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    public Node<E> tallerChild() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        if (leftHeight > rightHeight) return left;\n        if (leftHeight < rightHeight) return right;\n        return isLeftChild() ? left : right;\n    }\n}\n```\n\n### 恢复平衡\n```\n// 恢复平衡\nprivate void rebalance(Node<E> grand) {\n    Node<E> parent = ((AVLNode<E>)grand).tallerChild();\n    Node<E> node = ((AVLNode<E>)parent).tallerChild();\n    if (parent.isLeftChild()) { //L\n        if (node.isLeftChild()) { //LL\n            roteRight(grand);\n        } else { //LR\n            roteLeft(parent);\n            roteRight(grand);\n        }\n    } else { //R\n        if (node.isLeftChild()) { //RL\n            roteRight(parent);\n            roteLeft(grand);\n        } else { //RR\n            roteLeft(grand);\n        }\n    }\n}\n\n//左旋转（RR）\nprivate void roteLeft(Node<E> grand) {\n    Node<E> parent = grand.right;\n    Node<E> child = parent.left;\n    grand.right = child;\n    parent.left = grand;\n    \n    //让parent成为子树的根节点\n    parent.parent = grand.parent;\n    if (grand.isLeftChild()) {\n        grand.parent.left = parent;\n    } else if (grand.isRightChild()) {\n        grand.parent.right = parent;\n    } else {\n        root = parent;\n    }\n    \n    //更新child的parent\n    if (child != null) {\n        child.parent = grand;\n    }\n    \n    //更新grand的parent\n    grand.parent = parent;\n    \n    //更新高度\n    updateHeight(grand);\n    updateHeight(parent);\n}\n\n//右旋转（LL）\nprivate void roteRight(Node<E> grand) {\n    Node<E> parent = grand.left;\n    Node<E> child = parent.right;\n    grand.left = child;\n    parent.right = grand;\n    \n    //让parent成为子树的根节点\n    parent.parent = grand.parent;\n    if (grand.isLeftChild()) {\n        grand.parent.left = parent;\n    } else if (grand.isRightChild()) {\n        grand.parent.right = parent;\n    } else {\n        root = parent;\n    }\n    \n    //更新child的parent\n    if (child != null) {\n        child.parent = parent;\n    }\n    \n    //更新grand的parent\n    grand.parent = parent;\n    \n    //更新高度\n    updateHeight(grand);\n    updateHeight(parent);\n}\n```\n\n### 统一所有旋转操作\n综上所述，失去平衡的情况有四种：LL、RR、LR 和 RL。这四种情况再恢复平衡后是一样的结构：\n1. `d` 是根节点；\n2. `b` 和 `f` 分别是 `d` 的左子树和右子树；\n3. `a` 和 `c` 分别是 `b` 的左子树和右子树，`e` 和 `g` 分别是 `f` 的左子树和右子树；\n\n（`a` 和 `g` 在操作前后是没有变化的，所以这里的 `a` 和 `g` 可以不做处理）\n![AVL树](AVL树/AVL树13.png)\n```\nprivate void rebalance(Node<E> grand) {\n    Node<E> parent = ((AVLNode<E>)grand).tallerChild();\n    Node<E> node = ((AVLNode<E>)parent).tallerChild();\n    if (parent.isLeftChild()) { //L\n        if (node.isLeftChild()) { //LL\n            rote(grand, node, node.right, parent, parent.right, grand);\n        } else { //LR\n            rote(grand, parent, node.left, node, node.right, grand);\n        }\n    } else { //R\n        if (node.isLeftChild()) { //RL\n            rote(grand, grand, node.left, node, node.right, parent);\n        } else { //RR\n            rote(grand, grand, parent.left, parent, node.left, node);\n        }\n    }\n}\n\nprivate void rote(\n        Node<E> r, \n        Node<E> b, Node<E> c,\n        Node<E> d,\n        Node<E> e, Node<E> f) {\n    // 让 d 成为子树的根节点\n    d.parent = r.parent;\n    if (r.isLeftChild()) {\n        r.parent.left = d;\n    } else if (r.isRightChild()) {\n        r.parent.right = d;\n    } else {\n        root = d;\n    }\n    \n    // b-c\n    b.right = c;\n    if (c != null) {\n        c.parent = b;\n    }\n    updateHeight(b);\n    \n    // e-f\n    f.left = e;\n    if (e != null) {\n        e.parent = f;\n    }\n    updateHeight(f);\n    \n    // b-d-f\n    d.left = b;\n    d.right = f;\n    b.parent = d;\n    f.parent = d;\n    updateHeight(d);\n}\n```\n\n# 删除导致的失衡\n删除操作可能会导致父节点或祖先节点失衡（只有一个节点会失衡），其他节点都不可能失衡。\n![AVL树](AVL树/AVL树14.png)\n\n## LL-右旋转（单旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树15.png)  \n右旋转后恢复平衡（绿色节点存在的情况下）：\n![AVL树](AVL树/AVL树16.png)  \n右旋转后，祖先节点失去平衡（绿色节点不存在的情况下）：  \n如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层次的祖先节点失衡。极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整。\n![AVL树](AVL树/AVL树17.png)\n\n## RR-左旋转（单旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树18.png)  \n左旋转后恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树19.png)  \n左旋转后，祖先节点失去平衡（绿色节点不存在的情况下）：  \n![AVL树](AVL树/AVL树20.png)  \n\n## LR-RR左旋转，LL右旋转（双旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树21.png)  \n先左旋再右旋恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树22.png)  \n先左旋再右旋后，祖先节点失去平衡（绿色节点不存在的情况下）：\n![AVL树](AVL树/AVL树23.png)  \n\n## RL-LL右旋转，RR左旋转（双旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树24.png)  \n先右旋在左旋恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树25.png)  \n先右旋再左旋，祖先节点失去平衡（绿色节点不存在的情况下）：\n![AVL树](AVL树/AVL树26.png)  \n\n## CODE\n```\nprivate void remove(Node<E> node) {\n\t\t\n    //删除度为2的节点\n    if (node.isHasTwoChildren()) {\n        //找到后继节点\n        Node<E> s = successor(node);\n        //用后继节点的值覆盖度为2的节点的值\n        node.element = s.element;\n        //删除后继节点\n        node = s;\n    }\n    \n    //删除度为1或0的节点\n    Node<E> replacement = node.left != null ? node.left : node.right;\n    \n    if (replacement != null) { // node是度为1的节点\n        // 更改parent\n        replacement.parent = node.parent;\n        // 更改parent的left、right的指向\n        if (node.parent == null) { //node是度为1的节点并且是根节点\n            root = replacement;\n        } else if (node.parent.left == node) {\n            node.parent.left = replacement;\n        } else {\n            node.parent.right = replacement;\n        }\n        \n        // 删除之后的处理\n        afterRemove(node);\n    } else if (node.parent == null) { // node是叶子节点并且是根节点\n        root = null;\n        \n        // 删除之后的处理\n        afterRemove(node);\n    } else { // node是叶子节点，但不是根节点\n        if (node.parent.left == node) {\n            node.parent.left = null;\n        } else {\n            node.parent.right = null;\n        }\n        \n        // 删除之后的处理\n        afterRemove(node);\n    }\n}\n```\n\n### 删除后处理（afterRemove）\n在 BST 定义：\n```\nprotected void afterAdd(Node<E> node) { }\n```\n\n在 AVLTree 实现：\n```\nprotected void afterRemove(Node<E> node) {\n    while ((node = node.parent) != null) {\n        if (isBalanced(node)) {\n            // 更新高度\n            updateHeight(node);\t\n        } else {\n            // 恢复平衡\n            rebalance(node);\n        }\n    }\n}\n```\n\n# 总结\n* 添加  \n可能会导致所有祖先节点都失衡；  \n只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1)次调整】。\n\n* 删除  \n可能会导致父节点或祖先节点失衡（只有1个节点会失衡）；  \n恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要O(logn)次调整】。\n\n* 平均时间复杂度\n搜索：O(logn)；  \n添加：O(logn)，仅需O(1)次的旋转操作；  \n删除：O(logn)，最多需要O(logn)次的旋转操作。\n\n# 练习\n[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n```\npublic boolean isBalanced(TreeNode root) {\n    return height(root) >= 0;\n}\n\npublic int height(TreeNode root) {\n    if (root == null) return 0;\n    \n    int leftHeight = height(root.left);\n    int rightHeight = height(root.right);\t\t\n    /**\n     * 1. Math.abs(leftHeight - rightHeight) > 1  => -1\n     * 2. leftHeight == -1 || rightHeight == -1   => -1\n     */\n    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\n        return -1;\n    } else {\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```\n\nps:  \n[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  \n","source":"_posts/数据结构与算法/AVL树.md","raw":"---\ntitle: AVL树\ndate: 2021-01-15 18:25:13\ntags: 数据结构与算法\n---\n\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n\n<!-- more -->\n\n# 平衡二叉搜索树（Balanced Binary Search Tree）\n## 二叉搜索树的复杂度分析\n依次添加节点 `7、4、9、2、5、8、11` 得到的二叉搜索树，添加、删除和搜索操作的复杂度跟二叉搜索树的高度有关，O(h) == O(logn)。\n![AVL树](AVL树/AVL树01.png)\n\n依次添加节点 `2、4、5、7、8、9、11` 得到的二叉搜索树，添加、删除和搜索操作的复杂度跟节点个数有关，O(h) == O(n)。二叉搜索树退化成了链表。\n![AVL树](AVL树/AVL树02.png)\n\n当 n 比较大时，两者的性能差异比较大。如 n == 1000000 时，二叉搜索树的最低高度是 20。\n\n## 平衡（Balance）\n平衡：当节点数固定时，左右子树的高度越接近，这课二叉树就越平衡（高度越低）\n![AVL树](AVL树/AVL树03.png)\n\n## 理想平衡\n最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的。\n![AVL树](AVL树/AVL树04.png)\n\n## 如何改进二叉搜索树？\n因为节点的添加、删除顺序是无法限制的，可以认为是随机的，所以改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。\n![AVL树](AVL树/AVL树05.png)\n\n如果按照图中的调整方式再继续调整其它节点的位置，就可以达到理想平衡。但是调整的次数太多，反而增加了时间复杂度。所以，比较合理的改进方案是：用尽量少的调整次数达到适合平衡即可，即平衡二叉搜索树。\n\n## 经典的平衡二叉搜索树\n平衡二叉搜索树简称：BBST。\n\n### AVL 树\nWindows NT 内核中广泛使用\n\n### 红黑树\n1. C++ STL（比如：map、set）；\n2. Java 的 TreeMap、TreeSet、HashMap、HashSet；\n3. Linux 的进度调整；\n4. Ngix 的 timer 管理；\n\nAVL 树、红黑树一般也称为自平衡的二叉搜索树。\n\n# AVL 树\n\n## 平衡因子\n平衡因子（Balance Factor）：某节点的左右子树的高度差。\n\nAVL树的特点：\n1. 每个节点的平衡因子只可能是 1、0、-1（绝对值 <= 1，如果超过 1，称之为“失衡”）；\n2. 每个节点的左右子树高度差不超过 1；\n3. 搜索、添加和删除的时间复杂度是 O(logn)；  \n![AVL树](AVL树/AVL树06.png)\n\n## 继承结构\n创建 AVLTree 继承自 BST。红黑树同理，创建 RBTree 继承自 BST。\n![AVL树](AVL树/AVL树07.png)\n\n# 添加导致的失衡\n下面这个子树原本是平衡的，添加节点`13`后出现失衡。最坏情况是导致节点`13`的所有祖先节点都失衡（`14`、`15`、`9`及其父节点）。节点`13`的父节点、非祖先节点都不可能失衡。\n![AVL树](AVL树/AVL树08.png)\n\n## LL-右旋转（单旋）\n`n`（node）、`p`（paren）和`g`（grandparent），`T0`（n的左子树）、`T1`（n的右子树）、`T2`（p的右子树）、`T3`（g的右子树）。\n\n1. `g.left = p.right`\n2. `p.right = g`\n3. 让`p`成为这棵子树的根节点\n4. 更新 `T2`、`p`、`g` 的 parent 属性\n5. 先后更新 `g`、`p` 的高度\n\n旋转后的子树又恢复了平衡，仍然是一棵二叉搜索树：T0 < g < T1 < p < T2 < n < T3。\n\n注意：一定要修改 `T2`、`p`、`g` 的 parent 属性；依次更新 `g`、`p` 的高度（因为旋转后，`g` 是 `p` 的右子树，所以先计算子树的高度，然后 +1 就是 `p` 的高度）。\n![AVL树](AVL树/AVL树09.png)\n\n## RR-左旋转（单旋）\n1. `g.right = p.left`\n2. `p.left = g`\n3. 让`p`成为这个子树的根节点\n4. 更新 `T1`、`p`、`g` 的 parent 属性\n5. 先后更新 `g`、`p` 的高度\n\n旋转后的子树又恢复了平衡，仍然是一棵二叉搜索树：T0 < g < T1 < p < T2 < n < T3。\n![AVL树](AVL树/AVL树10.png)\n\n## LR-RR左旋转，LL右旋转（双旋）\n![AVL树](AVL树/AVL树11.png)\n\n## RL-LL右旋转，RR左旋转（双旋）\n![AVL树](AVL树/AVL树12.png)\n\n## CODE\n```\npublic void add(E element) {\n    elementNotNullCheck(element);\n    //添加第一个节点\n    if (root == null) {\n        root = createNode(element, null);\n        size++;\n        // 新添加节点之后的处理\n        afterAdd(root);\n        return;\n    }\n    // 添加的不是第一个节点\n    // 找到父节点\n    Node<E> parent = root;\n    Node<E> node = root;\n    int cmp = 0;\n    while (node != null) {\n        cmp = compare(element, node.element);\n        parent = node;\n        if (cmp > 0) {\n            node = node.right;\n        } else if (cmp < 0) {\n            node = node.left;\n        } else {\n            node.element = element;\n            return;\n        }\n    }\n    Node<E> newNode = createNode(element, parent);\n    if (cmp > 0) {\n        parent.right = newNode;\n    } else {\n        parent.left = newNode;\n    }\n    \n    size++;\n    // 新添加节点之后的处理\n    afterAdd(newNode);\n}\n```\n\n### 添加处理（affterAdd）\n在节点的添加、删除操作之后，先办法让二叉搜索树恢复平衡（减小树的高度）。  \n在 BST 定义：\n```\nprotected void afterAdd(Node<E> node) { }\n```\n\n在 AVLTree 实现：\n```\n@Override\nprotected void afterAdd(Node<E> node) {\n    while ((node = node.parent) != null) {\n        if (isBalanced(node)) {\n            // 更新高度\n            updateHeight(node);\n        } else {\n            // 恢复平衡\n            rebalance(node);\n            // 整棵树恢复平衡\n            break;\n        }\n    }\n}\n\nprivate boolean isBalanced(Node<E> node) {\n    return Math.abs(((AVLNode<E>)node).balanceFactor()) <= 1;\n}\n\nprivate void updateHeight(Node<E> node) {\n    ((AVLNode<E>)node).updateHeight();\n}\n```\n\n### AVLNode\n1. 因为 Node 里用不到 height 属性，所以定义 AVLNode 继承自 Node，添加 height 属性；\n2. `isBalanced()` 是否平衡；\n3. `updateHeight()` 更新高度；\n4. `tallerChild()` 高度较高的子树，用于恢复平衡；\n```\nprivate static class AVLNode<E> extends Node<E> {\n    //叶子节点高度默认1\n    int height = 1;\n    \n    public AVLNode(E element, Node<E> parent) {\n        super(element, parent);\n    }\n    \n    public int balanceFactor() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        return leftHeight - rightHeight;\n    }\n    \n    public void updateHeight() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        height= 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    public Node<E> tallerChild() {\n        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;\n        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;\n        if (leftHeight > rightHeight) return left;\n        if (leftHeight < rightHeight) return right;\n        return isLeftChild() ? left : right;\n    }\n}\n```\n\n### 恢复平衡\n```\n// 恢复平衡\nprivate void rebalance(Node<E> grand) {\n    Node<E> parent = ((AVLNode<E>)grand).tallerChild();\n    Node<E> node = ((AVLNode<E>)parent).tallerChild();\n    if (parent.isLeftChild()) { //L\n        if (node.isLeftChild()) { //LL\n            roteRight(grand);\n        } else { //LR\n            roteLeft(parent);\n            roteRight(grand);\n        }\n    } else { //R\n        if (node.isLeftChild()) { //RL\n            roteRight(parent);\n            roteLeft(grand);\n        } else { //RR\n            roteLeft(grand);\n        }\n    }\n}\n\n//左旋转（RR）\nprivate void roteLeft(Node<E> grand) {\n    Node<E> parent = grand.right;\n    Node<E> child = parent.left;\n    grand.right = child;\n    parent.left = grand;\n    \n    //让parent成为子树的根节点\n    parent.parent = grand.parent;\n    if (grand.isLeftChild()) {\n        grand.parent.left = parent;\n    } else if (grand.isRightChild()) {\n        grand.parent.right = parent;\n    } else {\n        root = parent;\n    }\n    \n    //更新child的parent\n    if (child != null) {\n        child.parent = grand;\n    }\n    \n    //更新grand的parent\n    grand.parent = parent;\n    \n    //更新高度\n    updateHeight(grand);\n    updateHeight(parent);\n}\n\n//右旋转（LL）\nprivate void roteRight(Node<E> grand) {\n    Node<E> parent = grand.left;\n    Node<E> child = parent.right;\n    grand.left = child;\n    parent.right = grand;\n    \n    //让parent成为子树的根节点\n    parent.parent = grand.parent;\n    if (grand.isLeftChild()) {\n        grand.parent.left = parent;\n    } else if (grand.isRightChild()) {\n        grand.parent.right = parent;\n    } else {\n        root = parent;\n    }\n    \n    //更新child的parent\n    if (child != null) {\n        child.parent = parent;\n    }\n    \n    //更新grand的parent\n    grand.parent = parent;\n    \n    //更新高度\n    updateHeight(grand);\n    updateHeight(parent);\n}\n```\n\n### 统一所有旋转操作\n综上所述，失去平衡的情况有四种：LL、RR、LR 和 RL。这四种情况再恢复平衡后是一样的结构：\n1. `d` 是根节点；\n2. `b` 和 `f` 分别是 `d` 的左子树和右子树；\n3. `a` 和 `c` 分别是 `b` 的左子树和右子树，`e` 和 `g` 分别是 `f` 的左子树和右子树；\n\n（`a` 和 `g` 在操作前后是没有变化的，所以这里的 `a` 和 `g` 可以不做处理）\n![AVL树](AVL树/AVL树13.png)\n```\nprivate void rebalance(Node<E> grand) {\n    Node<E> parent = ((AVLNode<E>)grand).tallerChild();\n    Node<E> node = ((AVLNode<E>)parent).tallerChild();\n    if (parent.isLeftChild()) { //L\n        if (node.isLeftChild()) { //LL\n            rote(grand, node, node.right, parent, parent.right, grand);\n        } else { //LR\n            rote(grand, parent, node.left, node, node.right, grand);\n        }\n    } else { //R\n        if (node.isLeftChild()) { //RL\n            rote(grand, grand, node.left, node, node.right, parent);\n        } else { //RR\n            rote(grand, grand, parent.left, parent, node.left, node);\n        }\n    }\n}\n\nprivate void rote(\n        Node<E> r, \n        Node<E> b, Node<E> c,\n        Node<E> d,\n        Node<E> e, Node<E> f) {\n    // 让 d 成为子树的根节点\n    d.parent = r.parent;\n    if (r.isLeftChild()) {\n        r.parent.left = d;\n    } else if (r.isRightChild()) {\n        r.parent.right = d;\n    } else {\n        root = d;\n    }\n    \n    // b-c\n    b.right = c;\n    if (c != null) {\n        c.parent = b;\n    }\n    updateHeight(b);\n    \n    // e-f\n    f.left = e;\n    if (e != null) {\n        e.parent = f;\n    }\n    updateHeight(f);\n    \n    // b-d-f\n    d.left = b;\n    d.right = f;\n    b.parent = d;\n    f.parent = d;\n    updateHeight(d);\n}\n```\n\n# 删除导致的失衡\n删除操作可能会导致父节点或祖先节点失衡（只有一个节点会失衡），其他节点都不可能失衡。\n![AVL树](AVL树/AVL树14.png)\n\n## LL-右旋转（单旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树15.png)  \n右旋转后恢复平衡（绿色节点存在的情况下）：\n![AVL树](AVL树/AVL树16.png)  \n右旋转后，祖先节点失去平衡（绿色节点不存在的情况下）：  \n如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层次的祖先节点失衡。极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整。\n![AVL树](AVL树/AVL树17.png)\n\n## RR-左旋转（单旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树18.png)  \n左旋转后恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树19.png)  \n左旋转后，祖先节点失去平衡（绿色节点不存在的情况下）：  \n![AVL树](AVL树/AVL树20.png)  \n\n## LR-RR左旋转，LL右旋转（双旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树21.png)  \n先左旋再右旋恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树22.png)  \n先左旋再右旋后，祖先节点失去平衡（绿色节点不存在的情况下）：\n![AVL树](AVL树/AVL树23.png)  \n\n## RL-LL右旋转，RR左旋转（双旋）\n删除红色节点：  \n![AVL树](AVL树/AVL树24.png)  \n先右旋在左旋恢复平衡（绿色节点存在的情况下）：  \n![AVL树](AVL树/AVL树25.png)  \n先右旋再左旋，祖先节点失去平衡（绿色节点不存在的情况下）：\n![AVL树](AVL树/AVL树26.png)  \n\n## CODE\n```\nprivate void remove(Node<E> node) {\n\t\t\n    //删除度为2的节点\n    if (node.isHasTwoChildren()) {\n        //找到后继节点\n        Node<E> s = successor(node);\n        //用后继节点的值覆盖度为2的节点的值\n        node.element = s.element;\n        //删除后继节点\n        node = s;\n    }\n    \n    //删除度为1或0的节点\n    Node<E> replacement = node.left != null ? node.left : node.right;\n    \n    if (replacement != null) { // node是度为1的节点\n        // 更改parent\n        replacement.parent = node.parent;\n        // 更改parent的left、right的指向\n        if (node.parent == null) { //node是度为1的节点并且是根节点\n            root = replacement;\n        } else if (node.parent.left == node) {\n            node.parent.left = replacement;\n        } else {\n            node.parent.right = replacement;\n        }\n        \n        // 删除之后的处理\n        afterRemove(node);\n    } else if (node.parent == null) { // node是叶子节点并且是根节点\n        root = null;\n        \n        // 删除之后的处理\n        afterRemove(node);\n    } else { // node是叶子节点，但不是根节点\n        if (node.parent.left == node) {\n            node.parent.left = null;\n        } else {\n            node.parent.right = null;\n        }\n        \n        // 删除之后的处理\n        afterRemove(node);\n    }\n}\n```\n\n### 删除后处理（afterRemove）\n在 BST 定义：\n```\nprotected void afterAdd(Node<E> node) { }\n```\n\n在 AVLTree 实现：\n```\nprotected void afterRemove(Node<E> node) {\n    while ((node = node.parent) != null) {\n        if (isBalanced(node)) {\n            // 更新高度\n            updateHeight(node);\t\n        } else {\n            // 恢复平衡\n            rebalance(node);\n        }\n    }\n}\n```\n\n# 总结\n* 添加  \n可能会导致所有祖先节点都失衡；  \n只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1)次调整】。\n\n* 删除  \n可能会导致父节点或祖先节点失衡（只有1个节点会失衡）；  \n恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要O(logn)次调整】。\n\n* 平均时间复杂度\n搜索：O(logn)；  \n添加：O(logn)，仅需O(1)次的旋转操作；  \n删除：O(logn)，最多需要O(logn)次的旋转操作。\n\n# 练习\n[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n```\npublic boolean isBalanced(TreeNode root) {\n    return height(root) >= 0;\n}\n\npublic int height(TreeNode root) {\n    if (root == null) return 0;\n    \n    int leftHeight = height(root.left);\n    int rightHeight = height(root.right);\t\t\n    /**\n     * 1. Math.abs(leftHeight - rightHeight) > 1  => -1\n     * 2. leftHeight == -1 || rightHeight == -1   => -1\n     */\n    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\n        return -1;\n    } else {\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```\n\nps:  \n[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  \n","slug":"数据结构与算法/AVL树","published":1,"updated":"2023-08-22T09:52:14.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgut0024aq7k4wtfph6o"},{"title":"B树","date":"2021-02-19T09:08:12.000Z","_content":"\n[B树](https://baike.baidu.com/item/B%E6%A0%91/5411672?fr=aladdin#1)是一种平衡的多路搜索树，多用于文件系统，数据库的实现。\n\n<!-- more -->\n# B树\n一棵 m 阶B树是一棵平衡的 m 路搜索树。它或者是空树，或者是满足下列性质的树：\n1. 根节点至少有两个子树；\n2. 每个非根节点所包含的元素个数 `j` 满足：`┌m/2┐ - 1 <= j <= m - 1`；\n3. 除根节点以外的所有节点（不包含叶子节点）的度数正好是元素总数加1，故“内部子树”个数 `k`（度）满足：`┌m/2┐ <= k <= m`；\n4. 所有的叶子节点都位于同一层。\n![B树04.png](B树/B树04.png)\n\n## 特点\n* 一个节点可以存储超过两个元素，可以拥有超过两个节点。\n* 拥有二叉搜索树的一些性质，如：平衡，每个节点的所有子树高度一致。\n* 比较矮。\n* 每个节点中元素从小到大排列。\n\n## m 阶 B 树的性质（m >= 2）\n假设一个节点存储的元素个数为 `j`，则根节点：`1 <= j <= m-1`，非根节点：`┌m/2┐ - 1 <= j <= m - 1`。  \n\n如果有子节点，子节点个数 `y = j + 1`，则根节点的子节点个数：`2 <= y <= m`。非根节点的子节点个数：`┌m/2┐ <= y <= m`。  \n比如 m = 3，2 <= y <= 3，因此可以成为（2，3）树或 2-3 树；  \n比如 m = 4，2 <= y <= 4，因此可以成为（2，4）树或 2-3-4 树；  \n比如 m = 5，3 <= y <= 5，因此可以成为（3，5）树；  \n比如 m = 6，3 <= y <= 6，因此可以成为（3，6）树；  \n比如 m = 7，4 <= y <= 7，因此可以成为（4，7）树；  \n\n![B树01.png](B树/B树01.png)\n![B树02.png](B树/B树02.png)\n![B树03.png](B树/B树03.png)\n\n在数据库的实现中一般用 200~300 阶B树。\n\n# B树 VS 二叉搜索树\n二叉搜索树 -> 3阶B树\n![B树05.png](B树/B树05.png)\n![B树01.png](B树/B树01.png)\n\nB树和二叉搜索树，在逻辑上是等价的。拿一个二叉搜索树为例，通过多代节点合并，可以获得一个超级节点，如：  \n2 代合并的超级节点，最多拥有 4 个子节点（至少是 4 阶B树）；  \n3 代合并的超级节点，最多拥有 8 个子节点（至少是 8 阶B树）；  \nn 代合并的超级节点，最多拥有 2^n 个子节点（至少是 2^n 阶B树）；  \n\nm 阶B树，最多需要 log2(m) 带合并。\n\n2 代合并：\n![B树06.png](B树/B树06.png)\n\n# 搜索\n步骤：\n1. 先在节点内部从小到大开始搜索元素；\n2. 如果命中，搜索结束；\n3. 如果为命中，再去对应的子节点中搜索元素，重复步骤1；\n\n如：搜索 `52`\n![B树07.png](B树/B树07.png)\n搜索 `72`：\n![B树07.png](B树/B树07.png)\n\n# 添加\n新添加的元素必定是添加到叶子节点。  \n假设这是一棵4阶B树：\n![B树09.png](B树/B树09.png)\n添加 `55`：\n![B树10.png](B树/B树10.png)\n添加 `95`：\n![B树11.png](B树/B树11.png)\n\n# 上溢（overflow）\n插入 `98` 时，最右下角的叶子节点（`90、95、98、100`）的元素个数超过限制，这种现象可以称之为：上溢（overflow）。\n插入 `98`，产生上溢：\n![B树12.png](B树/B树12.png)\n\n## 上溢的解决\n1. `m` 阶B树上溢节点的元素个数必然等于 `m`。\n2. 假设上溢节点最中间元素的位置为 `k`，将 `k` 位置的元素向上与父节点合并。\n3. 将 [0, k-1] 和 [k+1, m-1] 位置的元素分裂成 2 个子节点，这 2 个子节点的元素个数必然都不会低于最低限制 `┌m/2┐ - 1`。\n4. 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决。最极端的情况，有可能一直分裂到根节点。\n\n假设有一个5阶B树，插入了 `34` 产生上溢：  \n从图中可以看到，上溢节点的元素个数等于5，即B树的阶数。\n![B树17.png](B树/B树17.png)  \n上溢节点最中间元素的位置为 `2`，将 `2` 位置的元素向上与父节点合并。  \n将 [0, 1] 和 [3, 4] 位置的元素分裂成2个子节点。这2个子节点的元素个数都等于2（必然都不低于最低限制`┌m/2┐ - 1`）。\n![B树18.png](B树/B树18.png)\n分裂完毕后，导致父节点上溢。按照上述方法，将最中间位置的元素向上与父节点合并。最极端的情况是，一直分裂到根节点。\n![B树19.png](B树/B树19.png)\n\n解决在插入 `98` 时产生的上溢：\n![B树13.png](B树/B树13.png)\n\n插入`52`：\n![B树14.png](B树/B树14.png)\n\n插入`54`，产生上溢:\n![B树15.png](B树/B树15.png)\n\n解决上溢：\n![B树16.png](B树/B树16.png)\n\n## 小结\n* 最极端的情况是，一直分裂到根节点，是唯一一种可以让 B 树长高的情况。\n\n# 删除\n\n## 叶子节点\n假设需要删除的元素在叶子节点中，那么直接删除即可：\n![B树20.png](B树/B树20.png)\n删除 `30`：\n![B树21.png](B树/B树21.png)\n\n## 非叶子节点\n假设需要删除的元素在非叶子节点中，则：\n1. 先找到前驱或后继元素；\n2. 覆盖所需删除的元素的值，再把前驱或后继元素删除。\n\n删除 `60`：  \n找到前驱元素（前驱节点里最靠右的元素）：\n![B树22.png](B树/B树22.png)\n覆盖所需删除的元素的值，再把前驱或后继元素删除：\n![B树23.png](B树/B树23.png)\n\n## 小结\n* 非叶子节点的前驱或后继元素，必定在叶子节点中\n* 删除前驱或后继元素，等同于删除叶子节点中的元素\n* 真正的删除元素都是繁盛在叶子节点中\n\n# 下溢\n设有一棵5阶B树：\n![B树24.png](B树/B树24.png)\n删除 `22`：叶子节点被删除一个元素，导致元素个数可能会低于最低限制（`┌m/2┐ - 1`），这种现象称为：下溢（underflow）。\n\n## 下溢的解决\n* 下溢节点的元素数量必然等于 `┌m/2┐ - 2`。\n\n### 元素个数 >= ┌m/2┐\n如果下溢节点临近的兄弟节点，有至少 `┌m/2┐` 个元素，可以向其借一个元素：  \n1. 将父节点的元素 `b` 插入到下溢节点的0位置（最小位置）；  \n2. 用兄弟节点的元素 `a`（最大的元素）替代父节点的元素 `b`。  \n\n这种操作就是“旋转”。\n![B树25.png](B树/B树25.png)\n\n### 元素个数 == ┌m/2┐-1\n如果下溢节点临近的兄弟节点只有 `┌m/2┐ - 1` 个元素：\n1. 将父节点的元素 `b` 挪下来跟左右子节点进行合并；\n2. 合并后的节点元素个数等于 `┌m/2┐ + ┌m/2┐ - 2`，不超过 `m-1`；\n\n这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直向上传播。\n![B树26.png](B树/B树26.png)\n\n## 小结\n* 最极端的情况是，一直下溢到根节点。根节点下溢导致根节点消失，与子节点合并成一个新的节点。这种情况是唯一一种可以让 B 树变矮的情况。\n\n# 练习\n设有一个4阶B树，则根节点的元素个数：`1 <= j <= 3`，非根节点的元素个数：`1 <= j <= 3`。\n\n依次添加`1`、`2`、`3`、`4`、`5`、`6`、`7`：  \n![B树27.gif](B树/B树27.gif)\n\n依次添加`8`、`9`、`10`、`11`：  \n![B树28.gif](B树/B树28.gif)\n\n依次添加`12`、`13`、`14`、`15`、`16`、`17`： \n![B树29.gif](B树/B树29.gif)\n\n依次添加`18`、`19`、`20`、`21`、`22`： \n![B树30.gif](B树/B树30.gif)\n\n\nps：[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)\n\n\n","source":"_posts/数据结构与算法/B树.md","raw":"---\ntitle: B树\ndate: 2021-02-19 17:08:12\ntags: 数据结构与算法\n---\n\n[B树](https://baike.baidu.com/item/B%E6%A0%91/5411672?fr=aladdin#1)是一种平衡的多路搜索树，多用于文件系统，数据库的实现。\n\n<!-- more -->\n# B树\n一棵 m 阶B树是一棵平衡的 m 路搜索树。它或者是空树，或者是满足下列性质的树：\n1. 根节点至少有两个子树；\n2. 每个非根节点所包含的元素个数 `j` 满足：`┌m/2┐ - 1 <= j <= m - 1`；\n3. 除根节点以外的所有节点（不包含叶子节点）的度数正好是元素总数加1，故“内部子树”个数 `k`（度）满足：`┌m/2┐ <= k <= m`；\n4. 所有的叶子节点都位于同一层。\n![B树04.png](B树/B树04.png)\n\n## 特点\n* 一个节点可以存储超过两个元素，可以拥有超过两个节点。\n* 拥有二叉搜索树的一些性质，如：平衡，每个节点的所有子树高度一致。\n* 比较矮。\n* 每个节点中元素从小到大排列。\n\n## m 阶 B 树的性质（m >= 2）\n假设一个节点存储的元素个数为 `j`，则根节点：`1 <= j <= m-1`，非根节点：`┌m/2┐ - 1 <= j <= m - 1`。  \n\n如果有子节点，子节点个数 `y = j + 1`，则根节点的子节点个数：`2 <= y <= m`。非根节点的子节点个数：`┌m/2┐ <= y <= m`。  \n比如 m = 3，2 <= y <= 3，因此可以成为（2，3）树或 2-3 树；  \n比如 m = 4，2 <= y <= 4，因此可以成为（2，4）树或 2-3-4 树；  \n比如 m = 5，3 <= y <= 5，因此可以成为（3，5）树；  \n比如 m = 6，3 <= y <= 6，因此可以成为（3，6）树；  \n比如 m = 7，4 <= y <= 7，因此可以成为（4，7）树；  \n\n![B树01.png](B树/B树01.png)\n![B树02.png](B树/B树02.png)\n![B树03.png](B树/B树03.png)\n\n在数据库的实现中一般用 200~300 阶B树。\n\n# B树 VS 二叉搜索树\n二叉搜索树 -> 3阶B树\n![B树05.png](B树/B树05.png)\n![B树01.png](B树/B树01.png)\n\nB树和二叉搜索树，在逻辑上是等价的。拿一个二叉搜索树为例，通过多代节点合并，可以获得一个超级节点，如：  \n2 代合并的超级节点，最多拥有 4 个子节点（至少是 4 阶B树）；  \n3 代合并的超级节点，最多拥有 8 个子节点（至少是 8 阶B树）；  \nn 代合并的超级节点，最多拥有 2^n 个子节点（至少是 2^n 阶B树）；  \n\nm 阶B树，最多需要 log2(m) 带合并。\n\n2 代合并：\n![B树06.png](B树/B树06.png)\n\n# 搜索\n步骤：\n1. 先在节点内部从小到大开始搜索元素；\n2. 如果命中，搜索结束；\n3. 如果为命中，再去对应的子节点中搜索元素，重复步骤1；\n\n如：搜索 `52`\n![B树07.png](B树/B树07.png)\n搜索 `72`：\n![B树07.png](B树/B树07.png)\n\n# 添加\n新添加的元素必定是添加到叶子节点。  \n假设这是一棵4阶B树：\n![B树09.png](B树/B树09.png)\n添加 `55`：\n![B树10.png](B树/B树10.png)\n添加 `95`：\n![B树11.png](B树/B树11.png)\n\n# 上溢（overflow）\n插入 `98` 时，最右下角的叶子节点（`90、95、98、100`）的元素个数超过限制，这种现象可以称之为：上溢（overflow）。\n插入 `98`，产生上溢：\n![B树12.png](B树/B树12.png)\n\n## 上溢的解决\n1. `m` 阶B树上溢节点的元素个数必然等于 `m`。\n2. 假设上溢节点最中间元素的位置为 `k`，将 `k` 位置的元素向上与父节点合并。\n3. 将 [0, k-1] 和 [k+1, m-1] 位置的元素分裂成 2 个子节点，这 2 个子节点的元素个数必然都不会低于最低限制 `┌m/2┐ - 1`。\n4. 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决。最极端的情况，有可能一直分裂到根节点。\n\n假设有一个5阶B树，插入了 `34` 产生上溢：  \n从图中可以看到，上溢节点的元素个数等于5，即B树的阶数。\n![B树17.png](B树/B树17.png)  \n上溢节点最中间元素的位置为 `2`，将 `2` 位置的元素向上与父节点合并。  \n将 [0, 1] 和 [3, 4] 位置的元素分裂成2个子节点。这2个子节点的元素个数都等于2（必然都不低于最低限制`┌m/2┐ - 1`）。\n![B树18.png](B树/B树18.png)\n分裂完毕后，导致父节点上溢。按照上述方法，将最中间位置的元素向上与父节点合并。最极端的情况是，一直分裂到根节点。\n![B树19.png](B树/B树19.png)\n\n解决在插入 `98` 时产生的上溢：\n![B树13.png](B树/B树13.png)\n\n插入`52`：\n![B树14.png](B树/B树14.png)\n\n插入`54`，产生上溢:\n![B树15.png](B树/B树15.png)\n\n解决上溢：\n![B树16.png](B树/B树16.png)\n\n## 小结\n* 最极端的情况是，一直分裂到根节点，是唯一一种可以让 B 树长高的情况。\n\n# 删除\n\n## 叶子节点\n假设需要删除的元素在叶子节点中，那么直接删除即可：\n![B树20.png](B树/B树20.png)\n删除 `30`：\n![B树21.png](B树/B树21.png)\n\n## 非叶子节点\n假设需要删除的元素在非叶子节点中，则：\n1. 先找到前驱或后继元素；\n2. 覆盖所需删除的元素的值，再把前驱或后继元素删除。\n\n删除 `60`：  \n找到前驱元素（前驱节点里最靠右的元素）：\n![B树22.png](B树/B树22.png)\n覆盖所需删除的元素的值，再把前驱或后继元素删除：\n![B树23.png](B树/B树23.png)\n\n## 小结\n* 非叶子节点的前驱或后继元素，必定在叶子节点中\n* 删除前驱或后继元素，等同于删除叶子节点中的元素\n* 真正的删除元素都是繁盛在叶子节点中\n\n# 下溢\n设有一棵5阶B树：\n![B树24.png](B树/B树24.png)\n删除 `22`：叶子节点被删除一个元素，导致元素个数可能会低于最低限制（`┌m/2┐ - 1`），这种现象称为：下溢（underflow）。\n\n## 下溢的解决\n* 下溢节点的元素数量必然等于 `┌m/2┐ - 2`。\n\n### 元素个数 >= ┌m/2┐\n如果下溢节点临近的兄弟节点，有至少 `┌m/2┐` 个元素，可以向其借一个元素：  \n1. 将父节点的元素 `b` 插入到下溢节点的0位置（最小位置）；  \n2. 用兄弟节点的元素 `a`（最大的元素）替代父节点的元素 `b`。  \n\n这种操作就是“旋转”。\n![B树25.png](B树/B树25.png)\n\n### 元素个数 == ┌m/2┐-1\n如果下溢节点临近的兄弟节点只有 `┌m/2┐ - 1` 个元素：\n1. 将父节点的元素 `b` 挪下来跟左右子节点进行合并；\n2. 合并后的节点元素个数等于 `┌m/2┐ + ┌m/2┐ - 2`，不超过 `m-1`；\n\n这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直向上传播。\n![B树26.png](B树/B树26.png)\n\n## 小结\n* 最极端的情况是，一直下溢到根节点。根节点下溢导致根节点消失，与子节点合并成一个新的节点。这种情况是唯一一种可以让 B 树变矮的情况。\n\n# 练习\n设有一个4阶B树，则根节点的元素个数：`1 <= j <= 3`，非根节点的元素个数：`1 <= j <= 3`。\n\n依次添加`1`、`2`、`3`、`4`、`5`、`6`、`7`：  \n![B树27.gif](B树/B树27.gif)\n\n依次添加`8`、`9`、`10`、`11`：  \n![B树28.gif](B树/B树28.gif)\n\n依次添加`12`、`13`、`14`、`15`、`16`、`17`： \n![B树29.gif](B树/B树29.gif)\n\n依次添加`18`、`19`、`20`、`21`、`22`： \n![B树30.gif](B树/B树30.gif)\n\n\nps：[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)\n\n\n","slug":"数据结构与算法/B树","published":1,"updated":"2023-08-22T09:52:14.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguu0026aq7kv2u4j2kz"},{"title":"二叉树","date":"2020-11-12T06:09:01.000Z","mathjax":true,"_content":"\n[二叉树（Binary tree）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin)是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。\n\n<!-- more -->\n\n# 树形结构\n二叉树：\n![二叉树01](二叉树/二叉树01.png)\n多叉树：\n![二叉树02](二叉树/二叉树02.png)\n\n## 树的基本概念\n \n* 节点  \n每一个数字都代表一个节点。\n* 根节点  \n`1` 是整棵数的根节点，一棵树只有一个根节点。\n* 父节点  \n`1` 是 `2、3、4、5、6` 的父节点，`2` 是 `21、22` 的父节点，`3` 是 `31` 的父节点，`5` 是 `51、52` 的父节点，`6` 是 `61` 的父节点，`22` 是 `221、222、223` 的父节点。\n* 子节点  \n`2、3、4、5、6` 是 `1` 的子节点，`21、22` 是 `2` 的子节点，`31` 是 `3` 的子节点，`51、52` 是 `5` 的子节点，`61` 是 `6` 的子节点，`221、222、223` 是 `22` 的子节点。\n* 兄弟节点  \n同一个父节点下的子节点互为兄弟节点，如 `2、3、4、5、6` 互为兄弟节点，`21、22` 互为兄弟节点，`51、52` 互为兄弟节点，`221、222、223` 互为兄弟节点。\n![二叉树03](二叉树/二叉树03.png)\n\n* 空树  \n一课树可以没有任何节点，称为空树（一课树可以只有1个节点，也就是只有根节点）。\n* 子树  \n`2、21、22、221、222、223` 与 `3、31` 与 `4` 与 `5、51、52` 与 `6、61` 都是 `1` 的子树。\n![二叉树04](二叉树/二叉树04.png)\n* 左子树  \n`21` 称为 `2` 的左子树。\n* 右子树  \n`22、221、222、223` 称为 `2` 的右子树。\n\n* 节点的度（degree）  \n即子树的个数，如 `1` 的度等于 5，`2` 的度等于 2，`3` 的度等于 1，`4` 的度等于 0，`5` 的度等于 2，`6` 的度等于 1，`22` 的度等于 3。\n![二叉树06](二叉树/二叉树06.png)\n* 树的度  \n所有节点度中的最大值，如上面这棵多叉树的度就是 `1` 的度，等于 5。\n* 叶子节点（leaf）  \n度为 0 的节点，如 `21`、`221`、`222`、`223`、`31`、`4`、`51`、`52`、`61` 都是叶子节点。\n![二叉树05](二叉树/二叉树05.png)\n* 非叶子节点  \n度不为 0 的节点。\n\n* 层数（level）  \n根节点在第 1 层，根节点的子节点在第 2 层，以此类推 `221` 在第四层（有些教程也从第 0 层开始计算）。\n* 节点的深度（depth）  \n从根节点到当前节点的唯一路径上的节点总数，`2` 的深度等于 2，`31` 的深度等于 3。\n![二叉树07](二叉树/二叉树07.png)\n* 节点的高度（height）  \n从当前节点到最远叶子节点的路径上的节点总数，`2` 的高度等于 3，`31` 的深度等于 0。\n* 树的深度  \n所有节点深度中的最大值，这个树的深度就是 `221`、`222`、`223` 的深度，等于 4。\n* 树的高度  \n所有节点高度中的最大值，这棵树的高度就是 `1` 的高度，等于 4。树的深度等于树的高度。\n\n## 有序树、无序树、森林\n\n* 有序树  \n树中的任意节点的子节点之间有顺序关系，如 `2、3、4、5、6` 按照大小关系从左至右排。  \n* 无序树  \n树中任意节点的子节点之间没有顺序关系，也成为“自由树”。\n* 森林  \n由 `m`（`m >= 0`）棵互不相交的树组成的集合。\n\n# 二叉树\n二叉树是有序树，二叉树的特点有：\n1. 每个节点的度最大为 2（最多拥有 2 棵子树，所以所有节点的度要么为 2，要么为 1，要么为 0）；\n2. 左子树和右子树是有顺序的，即使某节点只有一棵子树，也要区分左右子树（`49` 在左，`56` 在右；`96` 在右）。\n![二叉树08](二叉树/二叉树08.png)\n各种情况：\n![二叉树09](二叉树/二叉树09.png)\n只有左子树或者只有右子树的二叉树，从结构上看跟链表相似：\n![二叉树10](二叉树/二叉树10.png)\n\n## 二叉树的性质\n1. 非空二叉树的第 `i` 层，最多有 `2^(i-1)` 个节点（`i >= 1`）；\n2. 在高度为 `h` 的二叉树上最多有 `2^h - 1` 个节点（`h >= 1`）;\n3. 对于任何一棵非空二叉树，如果叶子节点个数为 `n0`，度为 2 的节点个数为 `n2`，则有：`n0 = n2 + 1`；  \n假设度为1的节点个数为 `n1`，那么二叉树的节点总数 `n = n0 + n1 + n2`，  \n二叉树的边数 `T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1`，  \n因此 `n0 = n2 + 1`。\n![二叉树11](二叉树/二叉树11.png)\n\n# 真二叉树\n真二叉树：所有的节点的度都要么为 0，要么为 2。\n![二叉树12](二叉树/二叉树12.png)\n\n# 满二叉树\n1. 满二叉树：最后一层节点的度为 0，其它节点度都为 2。\n2. 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多。\n3. 满二叉树一定是真二叉树，真二叉树不一定是满二叉树。\n4. 假设满二叉树的高度为 `h`（`h >= 1`），那么  \n第 `i` 层的节点数量：`2^(i-1)`；  \n叶子节点数量：`2^(h-1)`；  \n总结点数量 `n = 2^h - 1 = 2^0 + 2^1 + 2^2 + ... + 2^(h-1)`；  \n高度 `h = log(2)(n+1)`；\n![二叉树11](二叉树/二叉树11.png)\n\n# 完全二叉树\n完全二叉树：对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应。\n![二叉树14](二叉树/二叉树14.png)\n\n叶子节点只会出现在最后两层，最后一层的叶子节点都是靠左对齐。  \n完全二叉树从根节点至倒数第二层是一棵满二叉树。  \n满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。\n\n## 完全二叉树的性质\n1. 度为 1 的节点只有左子树。  \n2. 度为 1 的节点要么是 1 个，要么是 0 个。  \n3. 同样节点数量的二叉树，完全二叉树的高度最小。  \n4. 假设完全二叉树的高度为 `h`（`h >= 1`），那么  \n至少有 `2^(h-1)` 个节点（`2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 1`）；  \n最多有 `2^h - 1` 个节点（`2^0 + 2^1 + 2^2 + ... + 2^(h-2)`，即满二叉树）；  \n5. 假设总结点数量为 `n`，那么  \n`2^(h-1) <= n < 2^h`  ->  `h - 1 <= log(2)(n) < h`  ->  `h = floor(log(2)(n)) + 1`；  \n6. 一棵有 `n` 个节点的完全二叉树（`n > 0`），从上到下、从左到右对节点从 1 开始进行编号，对任意第 `i` 个节点：  \n如果 `i = 1`，它是根节点；  \n如果 `i > 1`，它的父节点编号为 `floor(i/2)`；  \n如果 `2i <= n`，它的左子节点编号为 `2i`；  \n如果 `2i > n`，它无左子节点；  \n如果 `2i + 1 <= n`，它的右子节点编号为 `2i + 1`；  \n如果 `2i + 1 > n`，它无右子节点；  \n\n![二叉树15](二叉树/二叉树15.png)\n\nps：`floor` 是向下取整；另外，`ceiling` 是向上取整；编程中的 `*`、`/` 都是向下取整。\n\n# 练习\n如果一个完全二叉树有 768 个节点，求叶子节点的个数？\n叶子节点个数为 768/2 = 389。\n\n解析：  \n设叶子节点个数为 `n0`，度为 1 的节点个数为 `n1`，度为 2 的节点个数为 `n2 `， \n则总结点个数 `n = n0 + n1 + n2`，  \n又 `n0 = n2 + 1`，所以 `n = 2 * n0 + n1 - 1`。\n\n因为完全二叉树的度为 1 的节点个数 `n1` 要么等于 0，要么等于 1，则  \n当 `n1 == 1` 时，`n = 2 * n0`，`n` 必然是偶数，所以叶子节点个数 `n0 = n/2`，非叶子节点个数 `n1 + n2 = n/2`；  \n当 `n1 == 0` 时，`n = 2 * n0 - 1`，`n` 必然是奇数，所有叶子节点个数 `n0 = (n + 1)/2`，非叶子节点个数 `n1 + n2 = (n - 1)/2`。\n\n（`n0 = (n + 1)/2` 可以写作 `n0 = n/2 + 1/2`，结合 `n1 == 1` 的情况（`n0 = n/2`），叶子节点个数可以总结为👇）\n\n综上，叶子节点个数 `n0 = floor((n + 1)/2) = ceiling(n/2)`，非叶子节点个数 `n1 + n2 = floor(n/2) = ceiling((n-1)/2)`。\n\n","source":"_posts/数据结构与算法/二叉树.md","raw":"---\ntitle: 二叉树\ndate: 2020-11-12 14:09:01\ntags: 数据结构与算法\nmathjax: true\n---\n\n[二叉树（Binary tree）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin)是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。\n\n<!-- more -->\n\n# 树形结构\n二叉树：\n![二叉树01](二叉树/二叉树01.png)\n多叉树：\n![二叉树02](二叉树/二叉树02.png)\n\n## 树的基本概念\n \n* 节点  \n每一个数字都代表一个节点。\n* 根节点  \n`1` 是整棵数的根节点，一棵树只有一个根节点。\n* 父节点  \n`1` 是 `2、3、4、5、6` 的父节点，`2` 是 `21、22` 的父节点，`3` 是 `31` 的父节点，`5` 是 `51、52` 的父节点，`6` 是 `61` 的父节点，`22` 是 `221、222、223` 的父节点。\n* 子节点  \n`2、3、4、5、6` 是 `1` 的子节点，`21、22` 是 `2` 的子节点，`31` 是 `3` 的子节点，`51、52` 是 `5` 的子节点，`61` 是 `6` 的子节点，`221、222、223` 是 `22` 的子节点。\n* 兄弟节点  \n同一个父节点下的子节点互为兄弟节点，如 `2、3、4、5、6` 互为兄弟节点，`21、22` 互为兄弟节点，`51、52` 互为兄弟节点，`221、222、223` 互为兄弟节点。\n![二叉树03](二叉树/二叉树03.png)\n\n* 空树  \n一课树可以没有任何节点，称为空树（一课树可以只有1个节点，也就是只有根节点）。\n* 子树  \n`2、21、22、221、222、223` 与 `3、31` 与 `4` 与 `5、51、52` 与 `6、61` 都是 `1` 的子树。\n![二叉树04](二叉树/二叉树04.png)\n* 左子树  \n`21` 称为 `2` 的左子树。\n* 右子树  \n`22、221、222、223` 称为 `2` 的右子树。\n\n* 节点的度（degree）  \n即子树的个数，如 `1` 的度等于 5，`2` 的度等于 2，`3` 的度等于 1，`4` 的度等于 0，`5` 的度等于 2，`6` 的度等于 1，`22` 的度等于 3。\n![二叉树06](二叉树/二叉树06.png)\n* 树的度  \n所有节点度中的最大值，如上面这棵多叉树的度就是 `1` 的度，等于 5。\n* 叶子节点（leaf）  \n度为 0 的节点，如 `21`、`221`、`222`、`223`、`31`、`4`、`51`、`52`、`61` 都是叶子节点。\n![二叉树05](二叉树/二叉树05.png)\n* 非叶子节点  \n度不为 0 的节点。\n\n* 层数（level）  \n根节点在第 1 层，根节点的子节点在第 2 层，以此类推 `221` 在第四层（有些教程也从第 0 层开始计算）。\n* 节点的深度（depth）  \n从根节点到当前节点的唯一路径上的节点总数，`2` 的深度等于 2，`31` 的深度等于 3。\n![二叉树07](二叉树/二叉树07.png)\n* 节点的高度（height）  \n从当前节点到最远叶子节点的路径上的节点总数，`2` 的高度等于 3，`31` 的深度等于 0。\n* 树的深度  \n所有节点深度中的最大值，这个树的深度就是 `221`、`222`、`223` 的深度，等于 4。\n* 树的高度  \n所有节点高度中的最大值，这棵树的高度就是 `1` 的高度，等于 4。树的深度等于树的高度。\n\n## 有序树、无序树、森林\n\n* 有序树  \n树中的任意节点的子节点之间有顺序关系，如 `2、3、4、5、6` 按照大小关系从左至右排。  \n* 无序树  \n树中任意节点的子节点之间没有顺序关系，也成为“自由树”。\n* 森林  \n由 `m`（`m >= 0`）棵互不相交的树组成的集合。\n\n# 二叉树\n二叉树是有序树，二叉树的特点有：\n1. 每个节点的度最大为 2（最多拥有 2 棵子树，所以所有节点的度要么为 2，要么为 1，要么为 0）；\n2. 左子树和右子树是有顺序的，即使某节点只有一棵子树，也要区分左右子树（`49` 在左，`56` 在右；`96` 在右）。\n![二叉树08](二叉树/二叉树08.png)\n各种情况：\n![二叉树09](二叉树/二叉树09.png)\n只有左子树或者只有右子树的二叉树，从结构上看跟链表相似：\n![二叉树10](二叉树/二叉树10.png)\n\n## 二叉树的性质\n1. 非空二叉树的第 `i` 层，最多有 `2^(i-1)` 个节点（`i >= 1`）；\n2. 在高度为 `h` 的二叉树上最多有 `2^h - 1` 个节点（`h >= 1`）;\n3. 对于任何一棵非空二叉树，如果叶子节点个数为 `n0`，度为 2 的节点个数为 `n2`，则有：`n0 = n2 + 1`；  \n假设度为1的节点个数为 `n1`，那么二叉树的节点总数 `n = n0 + n1 + n2`，  \n二叉树的边数 `T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1`，  \n因此 `n0 = n2 + 1`。\n![二叉树11](二叉树/二叉树11.png)\n\n# 真二叉树\n真二叉树：所有的节点的度都要么为 0，要么为 2。\n![二叉树12](二叉树/二叉树12.png)\n\n# 满二叉树\n1. 满二叉树：最后一层节点的度为 0，其它节点度都为 2。\n2. 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多。\n3. 满二叉树一定是真二叉树，真二叉树不一定是满二叉树。\n4. 假设满二叉树的高度为 `h`（`h >= 1`），那么  \n第 `i` 层的节点数量：`2^(i-1)`；  \n叶子节点数量：`2^(h-1)`；  \n总结点数量 `n = 2^h - 1 = 2^0 + 2^1 + 2^2 + ... + 2^(h-1)`；  \n高度 `h = log(2)(n+1)`；\n![二叉树11](二叉树/二叉树11.png)\n\n# 完全二叉树\n完全二叉树：对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应。\n![二叉树14](二叉树/二叉树14.png)\n\n叶子节点只会出现在最后两层，最后一层的叶子节点都是靠左对齐。  \n完全二叉树从根节点至倒数第二层是一棵满二叉树。  \n满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。\n\n## 完全二叉树的性质\n1. 度为 1 的节点只有左子树。  \n2. 度为 1 的节点要么是 1 个，要么是 0 个。  \n3. 同样节点数量的二叉树，完全二叉树的高度最小。  \n4. 假设完全二叉树的高度为 `h`（`h >= 1`），那么  \n至少有 `2^(h-1)` 个节点（`2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 1`）；  \n最多有 `2^h - 1` 个节点（`2^0 + 2^1 + 2^2 + ... + 2^(h-2)`，即满二叉树）；  \n5. 假设总结点数量为 `n`，那么  \n`2^(h-1) <= n < 2^h`  ->  `h - 1 <= log(2)(n) < h`  ->  `h = floor(log(2)(n)) + 1`；  \n6. 一棵有 `n` 个节点的完全二叉树（`n > 0`），从上到下、从左到右对节点从 1 开始进行编号，对任意第 `i` 个节点：  \n如果 `i = 1`，它是根节点；  \n如果 `i > 1`，它的父节点编号为 `floor(i/2)`；  \n如果 `2i <= n`，它的左子节点编号为 `2i`；  \n如果 `2i > n`，它无左子节点；  \n如果 `2i + 1 <= n`，它的右子节点编号为 `2i + 1`；  \n如果 `2i + 1 > n`，它无右子节点；  \n\n![二叉树15](二叉树/二叉树15.png)\n\nps：`floor` 是向下取整；另外，`ceiling` 是向上取整；编程中的 `*`、`/` 都是向下取整。\n\n# 练习\n如果一个完全二叉树有 768 个节点，求叶子节点的个数？\n叶子节点个数为 768/2 = 389。\n\n解析：  \n设叶子节点个数为 `n0`，度为 1 的节点个数为 `n1`，度为 2 的节点个数为 `n2 `， \n则总结点个数 `n = n0 + n1 + n2`，  \n又 `n0 = n2 + 1`，所以 `n = 2 * n0 + n1 - 1`。\n\n因为完全二叉树的度为 1 的节点个数 `n1` 要么等于 0，要么等于 1，则  \n当 `n1 == 1` 时，`n = 2 * n0`，`n` 必然是偶数，所以叶子节点个数 `n0 = n/2`，非叶子节点个数 `n1 + n2 = n/2`；  \n当 `n1 == 0` 时，`n = 2 * n0 - 1`，`n` 必然是奇数，所有叶子节点个数 `n0 = (n + 1)/2`，非叶子节点个数 `n1 + n2 = (n - 1)/2`。\n\n（`n0 = (n + 1)/2` 可以写作 `n0 = n/2 + 1/2`，结合 `n1 == 1` 的情况（`n0 = n/2`），叶子节点个数可以总结为👇）\n\n综上，叶子节点个数 `n0 = floor((n + 1)/2) = ceiling(n/2)`，非叶子节点个数 `n1 + n2 = floor(n/2) = ceiling((n-1)/2)`。\n\n","slug":"数据结构与算法/二叉树","published":1,"updated":"2023-08-22T09:52:14.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguw0029aq7ksoz1xk8v"},{"title":"二叉搜索树","date":"2020-11-18T06:29:12.000Z","_content":"\n[二叉搜索树（Binary Search Tree）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。\n\n<!-- more -->\n\n# 二叉搜索树\n\n## 思考：在 n 个动态的整数中搜索某个整数（查看其是否存在）？\n\n1. 使用动态数组，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n)；  \n![二叉搜索树01](二叉搜索树/二叉搜索树01.png)\n2. 使用有序的动态数组，使用二分搜索，最坏时间负载度：O(log(n))，但是添加和删除的平均时间复杂度是：O(n)；  \n![二叉搜索树02](二叉搜索树/二叉搜索树02.png)\n3. 使用二叉搜索树，添加、删除和搜索的最坏时间复杂度都是：O(log(n));\n\n## 二叉搜索树特性\n二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST。又被称为：二叉查找树、二叉排序树。二叉搜索树可以大大提高搜索数据的效率。  \n1. 若它的左子树不空，则左子树上所有结点的值均<u>小于</u>它的根结点的值；  \n2. 若它的右子树不空，则右子树上所有结点的值均<u>大于</u>它的根结点的值；  \n3. 它的左、右子树也分别为<u>二叉搜索树</u>。\n\n![二叉搜索树03](二叉搜索树/二叉搜索树03.png)\n使用二叉搜索树需要注意：  \n1. 存储的元素必须具备比较性，比如 `int`、`double` 等。\n2. 如果是自定义类型，需要指定比较方式。\n3. 存储的元素不可以是 `null`。\n\n# 接口设计\n```\n/*\n * 元素的数量\n */\npublic int size() {}\n/*\n * 是否为空\n */\npublic boolean isEmpty() {}\n/*\n * 清空所有元素\n */\npublic void clear() {}\n/*\n * 添加元素\n */\npublic void add(E element) {}\n/*\n * 删除元素\n */\npublic void remove(E element) {}\n/*\n * 是否包含某元素\n */\npublic void contains(E element) {}\n```\n\n## 添加节点\n1. 找到要添加到的位置，即找到该位置的父节点 `parent`；  \n2. 创建新节点 `node`；  \n3. 加入到树中：`parent.left = node` 或者 `parent.right = node`。\n\n注意：遇到值相等的元素可以覆盖旧值。\n\n如添加 `12`、`1`，先找到父节点 `11`、`2`：\n![二叉搜索树04](二叉搜索树/二叉搜索树04.png)\n创建新节点 `node`，加入到树中：\n![二叉搜索树05](二叉搜索树/二叉搜索树05.png)\n\n代码实现：\n```\npublic void add(E element) {\n\tif (root == null) {\n\t\troot = new Node<>(element, null);\n\t\treturn;\n\t}\n\t\n\tNode<E> node = root;\n\tNode<E> parent = root;\n\tint cmp = 0;\n\twhile (node != null) {\n\t\tparent = node;\n\t\tcmp = compare(element, node.element); // 返回值等于0：e1 == e2，大于0：e1 > e2，小于0：e1 < e2\n\n\t\tif (cmp > 0) {\n\t\t\tnode = node.right;\n\t\t} else if (cmp < 0) {\n\t\t\tnode = node.left;\n\t\t} else {\n\t\t\tnode.element = element; // 考虑到不同名字的 person，相等就覆盖\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tNode<E> newNode = new Node<>(element, parent);\n\tif (cmp > 0) {\n\t\tparent.right = newNode;\n\t} else {\n\t\tparent.left = newNode;\n\t}\n\t\n\tsize++;\n}\n```\n\n## 元素的比较方案设计\n### 方案一\n强制元素实现 `Comparable` 接口：\n```\npublic class BinarySearchTree<E extends Comparable> {\n    ...\n}\n```\n\n添加 `extends Comparable` 后，要加入到二叉搜索树的元素都必须实现 `Comparable` 接口。\n\n定义 Person 实现 `Comparable` 接口：\n```\npublic class Person implements Comparable<Person> {\n\tprivate int age;\n\t\n\t// 生成 age 的 get、set 方法\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Person e) {\n\t\treturn age - e.age;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn age + \"\";\n\t}\n}\n```\n\n### 方案二\n1. 允许外界传入一个 `Comparator` 自定义比较方案；\n2. 如果没有传入 `Comparator`，强制认定元素实现了 `Comparable` 接口。\n```\npublic class BinarySearchTree<E> {\n\n\tprivate Comparator<E> comparator;\n\n\tpublic BinarySearchTree() {\n\t\tthis(null);\n\t}\n\t\n\tpublic BinarySearchTree(Comparator<E> comparator) {\n\t\tthis.comparator = comparator;\n\t}\n    \n\tprivate int compare(E e1, E e2) {\n\t\tif (comparator != null) {\n\t\t\treturn comparator.compare(e1, e2);\n\t\t}\n\t\treturn ((Comparable<E>)e1).compareTo(e2);\n\t}\n}\n```\n\n## 打印器\n使用 [BinaryTrees](https://github.com/CoderMJLee/BinaryTrees) 打印二叉搜索树。\n\n1、实现 `BinaryTreeInfo` 接口\n```\npublic class BinarySearchTree<E> implements BinaryTreeInfo {\n\t...\n\n\t@Override\n\tpublic Object root() {\n\t\treturn root;\n\t}\n\n\t@Override\n\tpublic Object left(Object node) {\n\t\treturn ((Node<E>)node).left;\n\t}\n\n\t@Override\n\tpublic Object right(Object node) {\n\t\treturn ((Node<E>)node).right;\n\t}\n\n\t@Override\n\tpublic Object string(Object node) {\n\t\treturn ((Node<E>)node).element;\n\t}\n}\n```\n\n2、调用打印API `BinaryTrees.println(bst)`：\n```\nstatic void test() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t};\n\t\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);;\n}\n```\n\n### Comparable\n```\nstatic void test() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t};\n\t\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n}\n```\n\n打印结果：\n```\n    ┌──7──┐\n    │     │\n  ┌─4─┐ ┌─9─┐\n  │   │ │   │\n┌─2─┐ 5 8   11─┐\n│   │          │\n1   3          12\n```\n\n### Comparator\n```\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInteger data[] = new Integer[] {\n\t\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t\t};\n\t\t\n\t\tBinarySearchTree<Person> bst = new BinarySearchTree<>(new Comparator<Person>() {\n\t\t\tpublic int compare(Person o1, Person o2) {\n\t\t\t\treturn o1.getAge() - o2.getAge();\n\t\t\t}\n\t\t});\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tbst.add(new Person(data[i]));\n\t\t}\n\t\t\n\t\tBinaryTrees.println(bst);;\n\t}\n}\n```\n\n修改 `BinarySearchTree` 的 `string` 方法，查看更详细的打印信息：\n```\npublic Object string(Object node) {\n\tNode<E> myNode = (Node<E>)node;\n\tString parentString = \"null\";\n\tif (myNode.parent != null) {\n\t\tparentString = myNode.parent.element.toString();\n\t}\n\treturn myNode.element + \"_p(\" + parentString + \")\";\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)─┐\n   │        │                          │\n1_p(2)    3_p(2)                    12_p(11)\n```\n\n国外教材的说法  \nFull Binary Tree：完满二叉树（真二叉树）；  \nPerfect Binary Tree：完美二叉树（满二叉树）；  \nComplete Binary Tree：完全二叉树；\n\n# 遍历\n遍历是数据结构中的常见操作，线性数据结构（如：数组）的遍历比较简单，有两种：正序遍历和逆序遍历。二叉树的遍历方式有四种：  \n1. 前序遍历（Preorder Traversal）\n2. 中序遍历（Inorder Traversal）\n3. 后序遍历（Postorder Traversal）\n4. 层序遍历（Level Order Traversal）\n\n## 前序遍历\n访问顺序：\n1. 根节点；\n2. 前序遍历左子树；\n3. 前序遍历右子树。\n![二叉搜索树06](二叉搜索树/二叉搜索树06.png)\n\n### 递归\n<font color=#FF0000>7、</font><font color=#00BFF>4、2、1、3、5、</font><font color=#F0E68C>9、8、11、10、12</font>\n![二叉搜索树10](二叉搜索树/二叉搜索树10.png)\n\n代码实现：\n```\npublic void preorderTraversal() {\n\tpreorderTraversal(root);\n}\n\nprivate void preorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tSystem.out.println(node.element);\n\tpreorderTraversal(node.left);\n\tpreorderTraversal(node.right);\n}\n```\n\n### 非递归\n\n## 中序遍历\n访问顺序（升序）：\n1. 中序遍历左子树；\n2. 根节点；\n3. 中序遍历右子树。  \n![二叉搜索树07](二叉搜索树/二叉搜索树07.png) \n\n访问顺序（降序）：\n1. 中序遍历右子树；\n2. 根节点；\n3. 中序遍历左子树。\n![二叉搜索树08](二叉搜索树/二叉搜索树08.png)\n\n### 递归\n<font color=#00BFF>1、2、3、4、5、</font><font color=#FF0000>7、</font><font color=#F0E68C>8、9、10、11、12</font>（升序）\n![二叉搜索树11](二叉搜索树/二叉搜索树11.png)\n\n代码实现：\n```\npublic void inorderTraversal() {\n\tinorderTraversal(root);\n}\n\nprivate void inorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tinorderTraversal(node.left);\n\tSystem.out.println(node.element);\n\tinorderTraversal(node.right);\n}\n```\n\n### 非递归\n\n## 后序遍历\n访问顺序：\n1. 后序遍历左子树；\n2. 后序遍历右子树；\n3. 根节点。  \n![二叉搜索树09](二叉搜索树/二叉搜索树09.png)\n\n### 递归\n<font color=#00BFF>1、3、2、5、4、</font><font color=#F0E68C>8、10、12、11、9、</font><font color=#FF0000>7</font>\n![二叉搜索树12](二叉搜索树/二叉搜索树12.png)\n\n代码实现：\n```\npublic void postorderTraversal() {\n\tpostorderTraversal(root);\n}\n\nprivate void postorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tpostorderTraversal(node.left);\n\tpostorderTraversal(node.right);\n\tSystem.out.println(node.element);\n}\n```\n\n### 非递归\n\n## 层序遍历\n访问顺序：  \n1. 从上到下、从左到右依次访问每一个几点。\n\n<font color=#FF0000>7、</font><font color=#00BFF>4、9、</font><font color=#F0E68C>2、5、8、11、</font><font color=#32CD32>1、3、10、12</font>\n![二叉搜索树13](二叉搜索树/二叉搜索树13.png)\n\n代码实现：\n```\npublic void levelOrderTraversal() {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tSystem.out.println(node.element);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n```\n\n# 遍历接口\n## 前、中、后、层\n遍历接口提供一个回调方法，将遍历到的元素传到方法调用处处理：\n```\n/*\n * 回调方法（相当于 OC 的 block）\n */\npublic static interface Visitor<E> {\n\tvoid visit(E element);\n}\n```\n\n前序遍历、中序遍历、后序遍历和中序遍历：\n```\n/*\n * 前序遍历\n */\npublic void preorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpreorderTraversal(root, visitor);\n}\n\nprivate void preorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tvisitor.visit(node.element);\n\tpreorderTraversal(node.left, visitor);\n\tpreorderTraversal(node.right, visitor);\n}\n\n/*\n * 中序遍历\n */\npublic void inorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tinorderTraversal(root, visitor);\n}\n\nprivate void inorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tinorderTraversal(node.left, visitor);\n\tvisitor.visit(node.element);\n\tinorderTraversal(node.right, visitor);\n}\n\n/*\n * 后序遍历\n */\npublic void postorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpostorderTraversal(root, visitor);\n}\n\nprivate void postorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tpostorderTraversal(node.left, visitor);\n\tpostorderTraversal(node.right, visitor);\n\tvisitor.visit(node.element);\n}\n\n/*\n * 层序遍历（有回调）\n */\npublic void levelOrder(Visitor<E> visitor) {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tvisitor.visit(node.element);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n```\n\n测试\n```\nstatic void test3() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\tBinaryTrees.println(bst);\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"前序遍历：\");\n\tbst.preorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"中序遍历：\");\n\tbst.inorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"后序遍历：\");\n\tbst.postorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"层序遍历：\");\n\tbst.levelOrder(new Visitor<Integer>() {\t\t\t\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n\n前序遍历：7 4 2 1 3 5 9 8 11 10 12 \n中序遍历：1 2 3 4 5 7 8 9 10 11 12 \n后序遍历：1 3 2 5 4 8 10 12 11 9 7 \n层序遍历：7 4 9 2 5 8 11 1 3 10 12\n```\n\n## 遍历接口增强\n实现当遍历到指定节点时，停止遍历。\n\n### 层序遍历\n程序遍历的修改比较简单，只需要：\n1. 给 `Visitor.visit()` 方法增加返回值；\n2. 在处理元素的位置添加判断即可。\n\n```\n/*\n * 层序遍历（有回调）\n */\npublic void levelOrder(Visitor<E> visitor) {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tif (visitor.visit(node.element)) return; // 判断是否结束遍历\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n\n/*\n * 回调方法（相当于 OC 的 block）\n * 返回值：true（停止遍历）/false（继续遍历）\n */\npublic static interface Visitor<E> {\n\tboolean visit(E element);\n}\n```\n\n### 前、中、后\n前序遍历、中序遍历和后序遍历实现方式相同：\n1. Visitor 类中记录 isStop 变量（是否停止遍历的标签）；\n2. 在遍历过程中，添加是否停止遍历的判断。\n```\n/*\n * 回调方法（相当于 OC 的 block）\n * 返回值：true（停止遍历）/false（继续遍历）\n */\npublic static abstract class Visitor<E> {\n\tpublic boolean isStop;\n\tpublic abstract boolean visit(E element);\n}\n```\n\n前序遍历、中序遍历和后序遍历：\n```\n/*\n * 前序遍历\n */\npublic void preorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpreorderTraversal(root, visitor);\n}\n\nprivate void preorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tvisitor.isStop = visitor.visit(node.element);\n\tpreorderTraversal(node.left, visitor);\n\tpreorderTraversal(node.right, visitor);\n}\n\n/*\n * 中序遍历\n */\npublic void inorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tinorderTraversal(root, visitor);\n}\n\nprivate void inorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tinorderTraversal(node.left, visitor);\n\tif (visitor.isStop) return;\n\tvisitor.isStop = visitor.visit(node.element);\n\tinorderTraversal(node.right, visitor);\n}\n\n/*\n * 后序遍历\n */\npublic void postorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpostorderTraversal(root, visitor);\n}\n\nprivate void postorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tpostorderTraversal(node.left, visitor);\n\tpostorderTraversal(node.right, visitor);\n\tif (visitor.isStop) return;\n\tvisitor.isStop = visitor.visit(node.element);\n}\n```\n\n测试：设置遍历到 8 时停止遍历。\n```\nstatic void test3() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\tBinaryTrees.println(bst);\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"前序遍历：\");\n\tbst.preorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"中序遍历：\");\n\tbst.inorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"后序遍历：\");\n\tbst.postorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"层序遍历：\");\n\tbst.levelOrder(new Visitor<Integer>() {\t\t\t\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n\n前序遍历：7 4 2 1 3 5 9 8 \n中序遍历：1 2 3 4 5 7 8 \n后序遍历：1 3 2 5 4 8 \n层序遍历：7 4 9 2 5 8 \n```\n## 遍历的应用\n前序遍历：树状结构展示（注意左右子树的顺序）；  \n中序遍历：二叉搜索树的中序遍历按升序或降序处理节点；  \n后序遍历：适用于一些先子后父的操作；  \n层序遍历：计算二叉树的高度、判断一棵树是否为完全二叉树；\n\n# 练习Ⅰ\n## 树状打印二叉树\n```\npublic String toString() {\n\tStringBuilder sb = new StringBuilder();\n\ttoString(root, sb, \"\");\n\treturn sb.toString();\n}\n\nprivate void toString(Node<E> node, StringBuilder sb, String prefix) {\n\tif (node == null) return;\n\t\n\tsb.append(prefix).append(node.element).append(\"\\n\");\n\ttoString(node.left, sb, prefix + \"L_\");\n\ttoString(node.right, sb, prefix + \"R_\");\n}\n```\n\n测试：\n```\nstatic void test4() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tSystem.out.println(bst);\n}\n```\n\n打印结果：\n```\n7\nL_4\nL_L_2\nL_L_L_1\nL_L_R_3\nL_R_5\nR_9\nR_L_8\nR_R_11\nR_R_L_10\nR_R_R_12\n```\n\n上面👆的打印是通过前序遍历实现的，同样的也可以使用中序遍历、后序遍历实现。\n\n## 计算二叉树的高度\n\n### 递归\n```\npublic int height() {\n\treturn height(root);\n}\n\nprivate int height(Node<E> node) {\n\tif (node == null) return 0; // 设置递归停止条件\n\treturn 1 + Math.max(height(node.left), height(node.right)); // 取左右子树的高度中较大的一个加一\n}\n```\n\n### 迭代\n```\npublic int height() {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1; // 标记某一层节点的个数，默认一个（第一层的root节点）\n\tint height = 0;\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tlevelSize--; \n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\t// 等于0时，表示这一层的节点全部遍历完成了\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size(); // 开始记录下一层的节点个数\n\t\t\theight++; // 开始下一层遍历时，高度加一\n\t\t}\n\t}\n\treturn height;\n}\n```\n\n### 测试\n```\nstatic void test5() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n\t\n\tSystem.out.println(\"二叉树高度：\" + bst.height());\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n二叉树高度：4\n```\n\n## 完全二叉树的判断\n使用层序遍历：\n1. 如果树为空，返回 false；\n2. 如果 node.left != null，将 node.left 入队；\n3. 如果 node.left == null && node.right != null，返回 false；\n4. 如果 node.right != null，将 node.right 入队；\n5. 如果 node.right == null，则后边再遍历到的节点必须都是叶子节点，否则返回 false；\n6. 遍历结束，返回 true；\n\n```\npublic boolean isComplete() {\n\t\n\tif (root == null) return false;\n\t\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tboolean leaf = false;\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\t\n\t\tif (leaf && !node.isLeaf()) return false;\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.offer(node.left);\n\t\t} else if (node.right != null) { //即：node.left == null && node.right != null\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.offer(node.right);\t\n\t\t} else { // node.right == null\n\t\t\tleaf = true;\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n测试：\n```\nstatic void test6() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n\tSystem.out.println(bst.isComplete());\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)\n   │        │\n1_p(2)    3_p(2)\ntrue\n```\n\n## 翻转二叉树\n[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)  \n核心代码：\n```\nTreeNode temp = node.left;\nnode.left = node.right;\nnode.right = temp;\n```\n\n分别用前序遍历、中序遍历、后序遍历和层序遍历实现：\n```\n/*\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/*\n * 前序遍历\n */\npublic TreeNode invertTree(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\t\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\treturn root;\n}\n\n/*\n * 后序遍历\n */\npublic TreeNode invertTree2(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\treturn root;\n}\n\n/*\n * 中序遍历\n */\npublic TreeNode invertTree3(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tinvertTree(root.left);\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\t\n\tinvertTree(root.left);\n\treturn root;\n}\n\n/*\n * 层序遍历\n */\npublic TreeNode invertTree4(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\t\n\t\tTreeNode temp = node.left;\n\t\tnode.left = node.right;\n\t\tnode.right = temp;\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.offer(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.offer(node.right);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n# 重构二叉树\n以下两种方式，可以保证重构处唯一的一个二叉树。重构的原理是通过两种不同的遍历方式找到根节点，再用同样的方式找到每棵子树的根节点，以此类推：  \n1. 前序遍历 + 中序遍历：  \n![二叉搜索树14](二叉搜索树/二叉搜索树14.png)  \n2. 后序遍历 + 中序遍历：  \n![二叉搜索树15](二叉搜索树/二叉搜索树15.png)\n\n如：前序遍历：`4、2、1、3、6、5`，中序遍历：`1、2、3、4、5、6`。  \n1. 先根据前序遍历可以找到这棵二叉树的根节点 `4`；  \n2. 再结合中序遍历可以找到左子树的根节点 `2`，右子树的根节点 `6`；  \n3. 最后根据中序遍历可以知道 `2` 的左子树是 `1`，右子树是 `3`；`6` 的左子树是 `5`。  \n![二叉搜索树16](二叉搜索树/二叉搜索树16.png)\n\n“前序遍历 + 后序遍历”这种情况比较特殊，存在两种情况：  \n1. 如果是一棵真二叉树（Proper Binary Tree），结果是唯一的；\n![二叉搜索树17](二叉搜索树/二叉搜索树17.png)  \n重构方式同上👆。\n2. 否则不唯一；  \n![二叉搜索树18](二叉搜索树/二叉搜索树18.png)  \n因为只有一棵子树，所以从遍历结果不能确定子树究竟是左子树还是右子树。\n\n# 前驱节点\n前驱节点：中序遍历时的前一个节点。如果是二叉搜索树，前驱节点就是前一个比它小的节点。\n\n查找方式：\n1. `node.left != null`；  \n`predecessor = node.left.right.right.right...` 终止条件：`right == null`。  \n如：6、8、13\n![二叉搜索树19](二叉搜索树/二叉搜索树19.png)  \n2. `node.left == null && node.parent != null`;  \n`predecessor = node.parent.parent.parent...` 终止条件：`node` 在 `parent` 的右子树中（`node == node.parent.right`）。  \n如：7、11、9、1\n![二叉搜索树20](二叉搜索树/二叉搜索树20.png) \n3. `node.left == null && node.parent == null`，没有前驱节点（没有左子树的根节点）。\n\n代码实现：\n```\npublic Node<E> predecessor(Node<E> node) {\n\tif (node == null) return node;\n\t\n\tNode<E> p = node.left;\n\tif (p != null) {\n\t\twhile (p.right != null) {\n\t\t\tp = p.right;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\twhile (node.parent != null && node == node.parent.left) {\n\t\tnode = node.parent;\n\t}\n\treturn node.parent;\n}\n```\n\n# 后继节点\n后继节点：终须遍历时的后一个几点。如果是二叉搜索树，后继节点就是后一个比它大的节点。\n\n1. `node.right != null`；  \n`successor = node.right.left.left.left...` 终止条件：`left == null`。  \n如：1、8、4\n![二叉搜索树21](二叉搜索树/二叉搜索树21.png) \n2. `node.right == null && node.parent != null`；  \n`successor = node.parent.parent.parent...` 终止条件：`node` 在 `parent` 的左子树中（`node == node.parent.left`）。  \n如：7、6、3、11\n![二叉搜索树22](二叉搜索树/二叉搜索树22.png) \n3. `node.right == null && node.parent == null`，没有后继节点（没有右子树的根节点）。\n\n代码实现：\n```\npublic Node<E> successor(Node<E> node) {\n\tif (node == null) return node;\n\t\n\tNode<E> p = node.right;\n\tif (p != null) {\n\t\twhile (p.left != null) {\n\t\t\tp = p.left;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\twhile (node.parent != null && node == node.parent.right) {\n\t\tnode = node.parent;\n\t}\n\treturn node.parent;\n}\n```\n\n# 删除\n\n## 删除-叶子节点\n```\n//左子节点\nif (node == node.parent.left) {\n\tnode.parent.left = null;\n}\n\n//右子节点\nif (node == node.parent.right) {\n\tnode.parent.right = node;\n}\n\n//只有一个节点（root）\nif (node.parent == null) {\n\troot = null;\n}\n```\n![二叉搜索树24](二叉搜索树/二叉搜索树24.png)\n\n## 删除-度为1的节点\n用子节点代替原节点的位置，child 是 node.left 或者 node.right：\n```\n//如果node是左子节点\nif (node == node.parent.left) {\n\tchild.parent = node.parent;\n\tnode.parent.left = child;\n}\n\n//如果node是右子节点\nif (node == node.parent.right) {\n\tchild.parent = node.parent;\n\tnode.parent.right = child;\n}\n\n//如果node是根节点\nif (node.parent == null) {\n\troot = child;\n\tchild.parent = null;\n}\n```\n![二叉搜索树25](二叉搜索树/二叉搜索树25.png)\n\n## 删除-度为2的节点\n1. 先用前驱或后继节点的值覆盖原节点的值；\n2. 再删除相应的前驱或后继节点；\n3. 如果一个节点的度为2，那它的前驱、后继节点的度只能是1和0；  \n\n![二叉搜索树26](二叉搜索树/二叉搜索树26.png)\n\n## 代码实现\n```\npublic void remove(E element) {\n\tremove(node(element));\n}\n\nprivate void remove(Node<E> node) {\n\t\n\t//删除度为2的节点\n\tif (node.isHasTwoChildren()) {\n\t\t//找到后继节点\n\t\tNode<E> s = successor(node);\n\t\t//用后继节点的值覆盖度为2的节点的值\n\t\tnode.element = s.element;\n\t\t//删除后继节点\n\t\tnode = s;\n\t}\n\t\n\t//删除度为1或0的节点\n\tNode<E> replacement = node.left != null ? node.left : node.right;\n\t\n\tif (replacement != null) { // node是度为1的节点\n\t\t// 更改parent\n\t\treplacement.parent = node.parent;\n\t\t// 更改parent的left、right的指向\n\t\tif (node.parent == null) { //node是度为1的节点并且是根节点\n\t\t\troot = replacement;\n\t\t} else if (node.parent.left == node) {\n\t\t\tnode.parent.left = replacement;\n\t\t} else {\n\t\t\tnode.parent.right = replacement;\n\t\t}\n\t} else if (node.parent == null) { // node是叶子节点并且是根节点\n\t\troot = null;\n\t} else { // node是叶子节点，但不是根节点\n\t\tif (node.parent.left == node) {\n\t\t\tnode.parent.left = null;\n\t\t} else {\n\t\t\tnode.parent.right = null;\n\t\t}\n\t}\n}\n\n/*\n * 根据元素内容获取节点\n */\nprivate Node<E> node(E element) {\n\tNode<E> node = root;\n\twhile (node != null) {\n\t\tint cmp = compare(element, node.element);\n\t\tif (cmp == 0) return node;\n\t\tif (cmp > 0) {\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tnode = node.left;\n\t\t}\n\t}\n\treturn node;\n}\n```\n\n# 练习 Ⅱ\n## 二叉树的前序遍历\n[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\n递归：\n```\npublic List<Integer> preorderTraversal(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n\tpreorderTraversalRecursive(root, res);\n\treturn res;\n}\n\npublic void preorderTraversalRecursive(TreeNode root, List<Integer> res) {\n\tif (root == null) return;\n\n\tres.add(root.val);\n\tpreorderTraversalRecursive(root.left, res);\n\tpreorderTraversalRecursive(root.right, res);\n}\n```\n\n迭代：\n```\npublic List<Integer> preorderTraversalIterative(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n\tif (root == null) return res;\n\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tres.add(node.val);\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.pop();\n\t\tnode = node.right;\n\t}\n\treturn res;\n}\n```\n\n## 二叉树的中序遍历\n[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n递归：\n```\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    inorderTraversalRecursive(root, res);\n    return res;\n}\n\npublic void inorderTraversalRecursive(TreeNode root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tinorderTraversalRecursive(root.left, res);\n\tres.add(root.val);\n\tinorderTraversalRecursive(root.right, res);\n}\n```\n\n迭代：\n```\npublic List<Integer> inorderTraversalIterative(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    \n    Deque<TreeNode> stack = new LinkedList<>();\n    TreeNode node = root;\n    while (!stack.isEmpty() || node != null) {\n    \twhile (node != null) {\n        \tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n    \tnode = stack.pop();\n    \tres.add(node.val);\n    \tnode = node.right;\n\t}\n    return res;\n}\n```\n\n## 二叉树的后序遍历\n[45. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n递归：\n```\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    postorderTraversalRecursive(root, res);\n\treturn res; \n}\n\npublic void postorderTraversalRecursive(TreeNode root, List<Integer> res) {\n    if (root == null) return;\n    \n\tpostorderTraversalRecursive(root.left, res);\n\tpostorderTraversalRecursive(root.right, res);\n\tres.add(root.val);\n}\n```\n\n迭代：\n```\npublic List<Integer> postorderTraversalIterative(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n    if (root == null) return null;\n    \n    Deque<TreeNode> stack = new LinkedList<>();\n    TreeNode node = root;\n    TreeNode prev = null;\n    while (!stack.isEmpty() || node != null) {\n    \twhile (node != null) {\n        \tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n    \tnode = stack.pop();\n    \tif (node.right == null || node.right == prev) {\n\t\t\tres.add(node.val);\n\t\t\tprev = node;\n\t\t\tnode = null;\n\t\t} else {\n\t\t\tstack.push(node);\n\t\t\tnode = node.right;\n\t\t}\n\t}\n    \n    return res;\n}\n```\n\n## 二叉树的层序遍历\n[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n迭代：\n```\npublic List<List<Integer>> levelOrder(TreeNode root) {\n\tList<List<Integer>> res = new ArrayList<>();\n\tif (root == null) return res;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.add(root);\n\tint levelSize = 1;\n\tList<Integer> list = new ArrayList<Integer>();\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\tlist.add(node.val);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\tif (levelSize == 0) {\n\t\t\tres.add(list);\n\t\t\tlevelSize = queue.size();\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n## 二叉树的最大深度\n[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n递归：\n```\n/*\n * 递归\n */\npublic int maxDepth(TreeNode root) {\n\tif (root == null) return 0;\n\treturn 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n\n迭代：\n```\nlic int maxDepth(TreeNode root) {\n\tint height = 0;\n\tif (root == null) return height;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.add(root);\n\tint levelSize = 1;\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\t\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\theight++;\n\t\t}\n\t}\n\t\n\treturn height;\n}\n```\n\n## 二叉树的层次遍历 II\n[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n```\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n\tList<List<Integer>> res = new ArrayList<>();\n\tif (root == null) return res;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1;\n\tList<Integer> list = new ArrayList<>();\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\tlist.add(node.val);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\tres.add(0, list);\n\t\t\tlist = new ArrayList<>();\n\t\t}\n\t}\n\t\n\treturn res;\n}\n```\n\n## 二叉树最大宽度\n[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n```\npublic class _662_二叉树最大宽度 {\n    public int widthOfBinaryTree(TreeNode root) {\n    \tif (root == null) return 0;\n    \t\n    \tNode node = new Node(root, 0, 0);\n    \tQueue<Node> queue = new LinkedList<>();\n    \tqueue.offer(node);\n    \tint curDepth = 0, left = 0, ans = 0;\n    \twhile (!queue.isEmpty()) {\n    \t\tnode = queue.poll();\n    \t\t\n    \t\tif (node.treeNode != null) {\n\t\t\t\tqueue.offer(new Node(node.treeNode.left, node.depth + 1, node.pos * 2));\n\t\t\t\tqueue.offer(new Node(node.treeNode.right, node.depth + 1, node.pos * 2 + 1));\n\t\t\t\t\n\t\t\t\t//每开始遍历新的一层，记录最左边的pos\n\t\t\t\tif (curDepth != node.depth) {\n\t\t\t\t\tcurDepth = node.depth;\n\t\t\t\t\tleft = node.pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = Math.max(ans, node.pos - left + 1);\n\t\t\t}\n    \t}\n\n    \treturn ans;\n    }\n}\n\n//因为左右子树存在null的情况，所以创建新的Node包装TreeNode，这样就可以存储TreeNode==null情况\nclass Node {\n\tTreeNode treeNode;\n\tint depth, pos;\n\tpublic Node(TreeNode treeNode, int depth, int pos) {\n\t\tthis.treeNode = treeNode;\n\t\tthis.depth = depth;\n\t\tthis.pos = pos;\n\t}\n}\n```\n\n## N叉树的前序遍历\n[589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n```\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/*\n * 递归\n */\npublic List<Integer> preorder(Node root) {\n    List<Integer> res = new LinkedList<>();\n\tpreorderTraversal(root, res);\n\treturn res;\n}\n\npublic void preorderTraversal(Node root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tres.add(root.val);\n\tif (root.children != null) {\n\t\tfor (Node c : root.children) {\n\t\t\tpreorderTraversal(c, res);\n\t\t}\n\t}\n\treturn;\n}\n\n/*\n * 迭代\n */\npublic List<Integer> preorderIterative(Node root) {\n    List<Integer> res = new LinkedList<>();\n    if (root == null) return res;\n    \n    Deque<Node> stack = new LinkedList<>();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n    \tNode node = stack.pop();\n    \tres.add(node.val);\n    \t//反转一个 List（[v1, v2, v3] -> [v3, v2, v1]）\n    \tCollections.reverse(node.children);\n    \tfor (Node c : node.children) {\n\t\t\tstack.push(c);\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n## N叉树的后序遍历\n[590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n```\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/*\n * 递归\n */\npublic List<Integer> postorder(Node root) {\n\tList<Integer> res = new LinkedList<>();\n\tpostorderTraversal(root, res);\n    return res;\n}\n\npublic void postorderTraversal(Node root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tif (root.children != null) {\n\t\tfor (Node c : root.children) {\n\t\t\tpostorderTraversal(c, res);\n\t\t}\n\t}\n\t\n\tres.add(root.val);\n    return;\n}\n\n/*\n * 迭代\n */\npublic List<Integer> postorderIterative(Node root) {\n\tList<Integer> res = new LinkedList<>();\n\tif (root == null) return res;\n\t\n\tDeque<Node> stack = new LinkedList<>();\n\tstack.push(root);\n\twhile (!stack.isEmpty()) {\n\t\tNode node = stack.poll();\n\t\tres.add(0, node.val);\n\t\tfor (Node c : node.children) {\n\t\t\tstack.push(c);\n\t\t}\n\t}\n\t\n    return res;\n}\n```\n\n## N叉树的最大深度\n[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)\n```\n/*\n * 递归\n */\npublic int maxDepth(Node root) {\n\tif (root == null) return 0;\n\t\n\tint result = 1;\n\tfor (Node c : root.children) {\n\t\tresult = Math.max(result, 1 + maxDepth(c));\n\t}\n\treturn result;\n}\n\n/*\n * 迭代\n */\npublic int maxDepthIterative(Node root) {\n\tint height = 0;\n\tif (root == null) return height;\n    \n\tQueue<Node> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1;\n\twhile (!queue.isEmpty()) {\n\t\tNode node = queue.poll();\n\t\tlevelSize--;\n\t\tif (node.children != null) {\n\t\t\tfor (Node c : node.children) {\n\t\t\t\tqueue.offer(c);\n\t\t\t}\n\t\t}\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\theight++;\n\t\t}\n\t}\n\treturn height;\n}\n```\n\n## 二叉树展开为链表\n[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n```\n/*\n * 方法一：前序遍历-递归\n */\npublic void flatten(TreeNode root) {\n    List<TreeNode> list = new LinkedList<>();\n    preorderTraversal(root, list);\n    for (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i-1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n\npublic void preorderTraversal(TreeNode root, List<TreeNode> list) {\n    if (root == null) return;\n    \n    list.add(root);\n    preorderTraversal(root.left, list);\n    preorderTraversal(root.right, list);\n}\n\n/*\n * 方法一：前序遍历-迭代\n */\npublic void flattenIterative(TreeNode root) {\n    \n\tList<TreeNode> list = new LinkedList<>();\n\t\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tlist.add(node);\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.poll();\n\t\tnode = node.right;\n\t}\n\tfor (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i - 1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n/*\n * 方法一：前序遍历-迭代2\n */\npublic void flattenIterative2(TreeNode root) {\n    if (root == null) return;\n\tList<TreeNode> list = new LinkedList<>();\n\t\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode node = stack.poll();\n\t\tlist.add(node);\n\t\t\n\t\tif (node.right != null) {\n\t\t\tstack.push(node.right);\n\t\t}\n\t\t\n\t\tif (node.left != null) {\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n\tfor (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i - 1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n\n/*\n * 方法二：前序遍历和展开同步进行\n */\npublic void flattenIterative3(TreeNode root) {\n\tif (root == null) return;\n\t\n\t//前序遍历\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\tTreeNode prev = null;\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode curr = stack.poll();\n\t\tif (curr.right != null) {\n\t\t\tstack.push(curr.right);\n\t\t}\n\t\tif (curr.left != null) {\n\t\t\tstack.push(curr.left);\n\t\t}\n\t\t\n\t\t//展开\n\t\tif (prev != null) {\n\t\t\tprev.right = curr;\n\t\t\tprev.left = null;\t\n\t\t}\n\t\tprev = curr;\n\t}\n}\n\n/*\n * 方法三：寻找前驱节点\n */\npublic void flattenIteraltive4(TreeNode root) {\n\tif (root == null) return;\n\t\n\tTreeNode curr = root;\n\twhile (curr != null) {\n\t\tif (curr.left != null) {\n\t\t\tTreeNode next = curr.left;\n\t\t\t\n\t\t\t//寻找前驱节点\n\t\t\tTreeNode predecessor = curr.left;\n\t\t\twhile (predecessor.right != null) {\n\t\t\t\tpredecessor = predecessor.right;\n\t\t\t}\n\t\t\t\n\t\t\t//展开\n\t\t\tpredecessor.right = curr.right;\n\t\t\tcurr.right = next;\n\t\t\tcurr.left = null;\n\t\t}\n\t\tcurr = curr.right; //next\n\t}\n}\n```\n\n## 从中序与后序遍历序列构造二叉树\n[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n```\n/*\n * 方法一：递归\n */\nint post_idx;\nint[] inorder;\nint[] postorder;\nMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\n\npublic TreeNode helper(int in_left, int in_right) {\n\t//没有节点\n\tif (in_left > in_right) return null;\n\t\n\t//后序遍历结果中 post_idx 处的节点作为当前子树的根节点\n\tint root_val = postorder[post_idx];\n\tTreeNode root = new TreeNode(root_val);\n\t\n\t//根据 root 所在位置分成左右子树\n\tint index = idx_map.get(root_val);\n\t\n\t//下标减1（递归构建完右子树后，post_idx-- < index）\n\tpost_idx--;\n\t\n\t//递归-构建右子树\n\troot.right = helper(index + 1, in_right);\n\t\n\t//递归-构建左子树\n\troot.left = helper(in_left, index - 1);\n\t\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n\tthis.inorder = inorder;\n\tthis.postorder = postorder;\n\t\n\tpost_idx = postorder.length - 1;\n\t\n\tint idx = 0;\n\tfor (int val : inorder) {\n\t\tidx_map.put(val, idx++);\n\t}\n\n\treturn helper(0, post_idx);\n}\n\n/*\n * 方法二：迭代\n * \n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n * postorder = [15, 10, 9, 5, 4, 8, 7, 20, 3]\n */\npublic TreeNode buildTree2(int[] inorder, int[] postorder) {\n\tif (postorder == null || postorder.length == 0) {\n\t\treturn null;\n\t}\n\t\n\t//后序遍历的最后一个节点就是 root 节点\n\t//这些节点的顺序和它们在反向中序遍历（反向遍历inorder）中出现的顺序一定是相反的\n\tTreeNode root = new TreeNode(postorder[postorder.length - 1]);\n\t//使用栈存放后序遍历中的节点\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\t\n\t//用来记录子树里最右边的节点\n\tint inorderIndex = inorder.length - 1;\n\t//从后序遍历的倒数第二个几点开始，反向遍历 postorder\n\tfor (int i = postorder.length - 2; i >= 0; i--) {\n\t\tint postorderVal = postorder[i];\n\t\t//栈顶节点\n\t\tTreeNode node = stack.peek();\n\t\tif (node.val != inorder[inorderIndex]) {\n\t\t\t//node 不是最右边的节点，那么 postorderVal 是 node 的右节点\n\t\t\tnode.right = new TreeNode(postorderVal);\n\t\t\tstack.push(node.right);\n\t\t} else {\n\t\t\t//node 是最右边的节点，那么 postorderVal 是 node 的左节点\n\t\t\t//栈里的这些节点（右节点）的顺序和它们在反向中序遍历中出现的顺序一定是相反的\n\t\t\twhile (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n\t\t\t\tnode = stack.pop();\n\t\t\t\tinorderIndex--; //反向遍历 inorder\n\t\t\t}\n\t\t\t//因为 postorderVal 出现在了 node 与 node 在栈中的下一个节点的反向中序遍历之间，因此 postorderVal 就是 node 的左儿子。\n\t\t\tnode.left = new TreeNode(postorderVal);\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n## 从前序与中序遍历序列构造二叉树\n[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n![二叉搜索树23](二叉搜索树/二叉搜索树23.png)\n```\n/*\n * 方法一：递归\n * \n * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]\n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n */\nint preorderIndex;\nint[] preorder;\nint[] inorder;\nMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\npublic TreeNode helper(int in_left, int in_right) {\n\t\n\tif (in_left > in_right) {\n\t\treturn null;\n\t}\n\t\n\tTreeNode root = new TreeNode(preorder[preorderIndex]);\n\tint index = idx_map.get(root.val);\n\t\n\tpreorderIndex++;\n\t\n\t//遍历创建左子节点\n\troot.left = helper(in_left, index - 1);\n\t//遍历创建右子节点\n\troot.right = helper(index + 1, in_right);\n\t\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n\tthis.preorder = preorder;\n\tthis.inorder = inorder;\n\t\n\tfor (int i = 0; i < inorder.length; i++) {\n\t\tidx_map.put(inorder[i], i);\n\t}\n\t\n\treturn helper(0, preorder.length);\n}\n\n/*\n * 方法二：迭代\n * \n * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]\n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n */\npublic TreeNode buildTree2(int[] preorder, int[] inorder) {\n\tif (preorder == null || preorder.length == 0) {\n\t\treturn null;\n\t}\n\t//前序遍历的第一个节点就是root节点\n\tTreeNode root = new TreeNode(preorder[0]);\n\t//中序遍历的索引\n\tint inorderIndex = 0;\n\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\t\n\t//正序遍历 preorder\n\tfor (int i = 1; i < preorder.length; i++) {\n\t\tint preorderVal = preorder[i];\n\t\tTreeNode node = stack.peek();\n\t\tif (node.val != inorder[inorderIndex]) {\n\t\t\t// node 不是最左边的节点，那么 postorderVal 是 node 的左节点\n\t\t\tnode.left = new TreeNode(preorderVal);\n\t\t\tstack.push(node.left);\n\t\t} else {\n\t\t\t// node 是最左边的节点，那么 postorderVal 是 node 的右节点\n\t\t\twhile (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n\t\t\t\tnode = stack.pop();\n\t\t\t\tinorderIndex++;\n\t\t\t}\n\t\t\tnode.right = new TreeNode(preorderVal);\n\t\t\tstack.push(node.right);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n## 根据前序和后序遍历构造二叉树\n[889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n```\n/*\n * 方法一：递归\n */\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\n\tint N = pre.length;\n\tif (N == 0) {\n\t\treturn null;\n\t}\n\tTreeNode root = new TreeNode(pre[0]);\n\tif (N == 1) {\n\t\treturn root;\n\t}\n\t\n\t//令左分支有 L 个节点\n\tint L = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (post[i] == pre[1]) {\n\t\t\tL = i + 1; //L = post.indexOf(pre[1]) + 1\n\t\t}\n\t}\n\t\n\t//copyOfRange(int[] original, int from, int to)：包括下标from，不包括上标to\n\t//左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支\n\troot.left = constructFromPrePost(Arrays.copyOfRange(pre, 1,\tL + 1), Arrays.copyOfRange(post, 0, L));\n\t//右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支\n\troot.right = constructFromPrePost(Arrays.copyOfRange(pre, L + 1, N), Arrays.copyOfRange(post, L, N - 1));\n\t\n\treturn root;\n}\n```\n\n## 对称二叉树\n[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n```\n/*\n * 方法一：递归\n */\npublic boolean isSymmetric(TreeNode root) {\n\treturn check(root, root);\n}\n\npublic boolean check(TreeNode p, TreeNode q) {\n\t\n\tif (p == null && q == null) return true;\n\t\n\tif (p == null || q == null) return false;\n\t\n\treturn (p.val == q.val && check(p.left, q.right) && check(p.right, q.left));\n}\n\n/*\n * 方法二：迭代\n */\npublic boolean isSymmetric2(TreeNode root) {\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode p = queue.poll();\n\t\tTreeNode q = queue.poll();\n\t\tif (p == null && q == null) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (p == null || q == null || p.val != q.val) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tqueue.offer(p.left);\n\t\tqueue.offer(q.right);\n\t\t\n\t\tqueue.offer(p.right);\n\t\tqueue.offer(q.left);\n\t}\n\t\n\treturn true;\n}\n```\n\n# 练习 Ⅲ\n## 删除二叉搜索树中的节点\n[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n```\npublic int successor(TreeNode root) {\n\troot = root.right;\n\twhile (root.left != null) {\n\t\troot = root.left;\n\t}\n\treturn root.val;\n}\n\npublic int predecessor(TreeNode root) {\n\troot = root.left;\n\twhile (root.right != null) {\n\t\troot = root.right;\n\t}\n\treturn root.val;\n}\n\npublic TreeNode deleteNode(TreeNode root, int key) {\n\tif (root == null) return null;\n\t\n\tif (key > root.val) {\n\t\t//向又查找\n\t\troot.right = deleteNode(root.right, key);\n\t} else if (key < root.val) {\n\t\t//向左查找\n\t\troot.left = deleteNode(root.left, key);\n\t} else {\n\t\tif (root.left == null && root.right == null) { //删除叶子节点\n\t\t\troot = null;\n\t\t} else if (root.right != null) { //删除度为1的节点\n\t\t\troot.val = successor(root);\n\t\t\troot.right = deleteNode(root.right, root.val);\n\t\t} else { //删除度为1的节点\n\t\t\troot.val = predecessor(root);\n\t\t\troot.left = deleteNode(root.left, root.val);\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n## 二叉搜索树中的搜索\n[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n```\npublic TreeNode searchBST(TreeNode root, int val) {\n\tif (root == null) return null;\n\twhile (root != null) {\n\t\tif (val > root.val) {\n\t\t\troot = root.right;\n\t\t} else if (val < root.val) {\n\t\t\troot = root.left;\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n## 二叉搜索树中的插入操作\n[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n```\npublic TreeNode insertIntoBST(TreeNode root, int val) {\n\tif (root == null) return new TreeNode(val);\n\t\n\tTreeNode node = root;\n\tTreeNode parent = root;\n\tint cmp = 0;\n\twhile (node != null) {\n\t\tparent = node;\n\t\tif (val > node.val) {\n\t\t\tcmp = 1;\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tcmp = -1;\n\t\t\tnode = node.left;\n\t\t}\n\t}\n\t\n\tif (cmp > 0) {\n\t\tparent.right = new TreeNode(val);\n\t} else {\n\t\tparent.left = new TreeNode(val);\n\t}\n\t\n\treturn root;\n}\n```\n\n## 验证二叉搜索树\n[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n```\n/*\n * 递归\n *\n * 左子树不为空，则左子树上所有节点的值均小于它的根节点的值；\n * 右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n * 它的左右子树也为二叉搜索树。\n */\npublic boolean isValidBST(TreeNode root) {\n\treturn preorder(root, null, null);\n}\n\npublic boolean preorder(TreeNode root, Integer lower, Integer upper) {\n\tif (root == null) return true;\n\t\n\tif (lower != null && lower >= root.val) return false;\n\t\n\tif (upper != null && upper <= root.val) return false;\n\t\n\tif (!preorder(root.left, lower, root.val)) return false;\n\t\n\tif (!preorder(root.right, root.val, upper)) return false;\n\t\n\treturn true;\n}\n\n/*\n * 迭代\n * \n * 「中序遍历」得到的值构成的序列一定是升序的\n */\npublic boolean isValidBST2(TreeNode root) {\n\treturn inorder(root);\n}\n\npublic boolean inorder(TreeNode root) {\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\tTreeNode prev = null;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.pop();\n\t\tif (prev != null && prev.val >= node.val) {\n\t\t\treturn false;\n\t\t}\n\t\tprev = node;\n\t\tnode = node.right;\n\t}\n\treturn true;\n}\n```\n\n## 二叉搜索树的最小绝对差\n[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)\n```\nTreeNode prev;\nint ans;\n\npublic int getMinimumDifference(TreeNode root) {\n\tans = Integer.MAX_VALUE;\n\tinorder(root);\n\treturn ans;\n}\n\npublic void inorder(TreeNode root) {\n\tif (root == null) return;\n\t\n\tinorder(root.left);\n\t\n\tif (prev == null) {\n\t\tprev = root;\n\t} else {\n\t\tint cha = root.val - prev.val;\n\t\tans = ans > cha ? cha : ans;\n\t\tprev = root;\n\t}\n\t\n\tinorder(root.right);\n}\n```\n\n## 二叉搜索树节点最小距离\n[783. 二叉搜索树节点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)\n```\npublic class _783_二叉搜索树节点最小距离 {\n\tint preVal;\n\tint ans;\n    public int minDiffInBST(TreeNode root) {\n    \tpreVal = -1;\n    \tans = Integer.MAX_VALUE;\n    \tinorder(root);\n    \treturn ans;\n    }\n    \n    public void inorder(TreeNode root) {\n    \tif (root == null) return;\n    \t\n    \tinorder(root.left);\n    \t\n    \tif (preVal != -1) {\n    \t\tans = Math.min(ans, root.val - preVal);\n\t\t}\n    \tpreVal = root.val;\n    \t\n    \tinorder(root.right);\n    }\n}\n```\n\n## 将有序数组转换为二叉搜索树\n[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n```\npublic TreeNode sortedArrayToBST(int[] nums) {\n\treturn helper(nums, 0, nums.length-1);\n}\n\npublic TreeNode helper(int[] nums, int left, int right) {\n\tif (left > right) return null;\n\t\n\tint mid = (left + right) / 2;\n\t\n\tTreeNode root = new TreeNode(nums[mid]);\n\troot.left = helper(nums, left, mid-1);\n\troot.right = helper(nums, mid+1, right);\n\t\n\treturn root;\n}\n```\n\n## 二叉搜索树的范围和\n[938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n```\nint sum;\n\npublic int rangeSumBST(TreeNode root, int low, int high) {\n\tinorder(root, low, high);\n\treturn sum;\n}\n\npublic void inorder(TreeNode root, int low, int high) {\n\tif (root == null) return;\n\t\n\trangeSumBST(root.left, low, high);\n\n\tif (root.val >= low && root.val <= high) {\n\t\tsum += root.val;\n\t}\n\trangeSumBST(root.right, low, high);\n}\n```\n\n## 二叉搜索树的最近公共祖先\n[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n```\n/*\n * 方法一：两次遍历\n */\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\tList<TreeNode> path_p = path(root, p);\n\tList<TreeNode> path_q = path(root, q);\n\t\n\tTreeNode node = null;\n\tfor (int i = 0; i < path_p.size() && i < path_q.size(); i++) {\n\t\tif (path_p.get(i) == path_q.get(i)) {\n\t\t\tnode = path_p.get(i);\n\t\t}\n\t}\n\treturn node;\n}\n\npublic List<TreeNode> path(TreeNode root, TreeNode target) {\n\tList<TreeNode> path = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (node != target) {\n\t\tpath.add(node);\n\t\tif (node.val > target.val) {\n\t\t\tnode = node.left;\n\t\t} else if (node.val < target.val) {\n\t\t\tnode = node.right;\n\t\t}\n\t}\n\tpath.add(node);\n\treturn path;\n}\n\n/*\n * 方法一：一次遍历\n */\npublic TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\n\tTreeNode node = root;\n\t\n\twhile (node != null) {\n\t\tif (node.val > p.val && node.val > q.val) {\n\t\t\tnode = node.left;\n\t\t} else if (node.val < p.val && node.val < q.val) {\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn node;\n}\n```\n\n## 二叉搜索树中第K小的元素\n[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n```\npublic class _230_二叉搜索树中第K小的元素 {\n\tTreeNode targeTreeNode = null;\n\tint index = 0;\n\t/*\n\t * 迭代\n\t */\n\tpublic int kthSmallest(TreeNode root, int k) {\n\n\t\tif (root == null) return root.val;\n\t\t\n\t\t///递归\n\t\t//return inorder(root, k);\n\t\t\n\t\t///迭代\n\t\tindex = k;\n\t\thelper(root);\n\t\treturn targeTreeNode.val;\n    }\n\t\n\tpublic int inorder(TreeNode root, int k) {\n\t\t\n\t\tTreeNode targeTreeNode = root;\n\t\tDeque<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode node = root;\n\t\twhile (!stack.isEmpty() || node != null) {\n\t\t\twhile (node != null) {\n\t\t\t\tstack.push(node);\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tk--;\n\t\t\tif (k == 0) {\n\t\t\t\ttargeTreeNode = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node.right;\n\t\t}\n\t\t\n\t\treturn targeTreeNode.val;\n\t}\n\t\n\t/*\n\t * 递归\n\t */\n\tpublic void helper(TreeNode root) {\n\t\tif (root == null || targeTreeNode != null) return;\n\t\t\n\t\thelper(root.left);\n\t\tindex--;\n\t\tif (index == 0 && targeTreeNode == null) {\n\t\t\ttargeTreeNode = root;\n\t\t\treturn;\n\t\t}\n\t\thelper(root.right);\n\t}\n}\n```\n\n## 二叉搜索树迭代器\n[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n```\n/*\n * 迭代\n */\nclass BSTIterator {\n\tDeque<TreeNode> stack;\n\t\n    public BSTIterator(TreeNode root) {\n    \tstack = new LinkedList<>();\n    \tleftmostInorder(root);\n    }\n    \n    public void leftmostInorder(TreeNode root) {\n    \twhile (root != null) {\n\t\t\tstack.push(root);\n\t\t\troot = root.left;\n\t\t}\n\t}\n    \n    public int next() {\n    \tTreeNode node = stack.poll();\n    \tif (node.right != null) {\n    \t\tleftmostInorder(node.right);\n\t\t}\n    \treturn node.val;\n    }\n    \n    public boolean hasNext() {\n    \treturn !stack.isEmpty();\n    }\n}\n```\n\n## 恢复二叉搜索树\n[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n```\npublic class _99_恢复二叉搜索树 {\n\n\t/*\n\t * 方法一：显示中序遍历\n\t */\n\tpublic void recoverTree(TreeNode root) {\n\t\tList<Integer> res = new LinkedList<>();\n\t\tinorder(root, res);\n\t\tint[] swaped = findTwoSwaped(res);\n\t\trecover(root, 2, swaped[0], swaped[1]);\n    }\n\t\n\tpublic void inorder(TreeNode root, List<Integer> res) {\n\t\tif (root == null) return;\n\t\tinorder(root.left, res);\n\t\tres.add(root.val);\n\t\tinorder(root.right, res);\n\t}\n\t\n\tpublic int[] findTwoSwaped(List<Integer> res) {\n\t\tint n = res.size();\n\t\tint x = -1, y = -1;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (res.get(i) == res.get(i + 1)) { //找到异常节点（前面 > 后面）\n\t\t\t\ty = res.get(i + 1);//后\n\t\t\t\tif (x == -1) {\n\t\t\t\t\tx = res.get(i);//前\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\t\n\tpublic void recover(TreeNode root, int count, int x, int y) {\n\t\tif (root != null) {\n\t\t\tif (root.val == x || root.val == y) {\n\t\t\t\troot.val = root.val == x ? y : x;\n\t\t\t\tif (--count == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\trecover(root.left, count, x, y);\n\t\t\trecover(root.right, count, x, y);\n\t\t}\n\t}\n\t\n\t/*\n\t * 方法二：隐式中序遍历\n\t */\n\tpublic void recoverTree1(TreeNode root) {\n\t\tDeque<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode x = null, y = null, pred = null;\n\t\twhile (!stack.isEmpty() || root != null) {\n\t\t\twhile (root != null) {\n\t\t\t\tstack.push(root);\n\t\t\t\troot = root.left;\n\t\t\t}\n\t\t\troot = stack.pop();\n\t\t\t///保存两个被交换的数据\n\t\t\tif (pred != null && pred.val > root.val) { //找到异常节点（前面 > 后面）\n\t\t\t\ty = root;//后\n\t\t\t\tif (x == null) {\n\t\t\t\t\tx = pred;//前\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpred = root;\n\t\t\troot = root.right;\n\t\t}\n\t\t\n        swap(x, y);\n\t}\n\t\n\tpublic void swap(TreeNode x, TreeNode y) {\n\t\tint temp = x.val;\n\t\tx.val = y.val;\n\t\ty.val = temp;\n\t}\n\t\n\t/*\n\t * 方法三：Morris 中序遍历\n\t */\n\tpublic void recoverTree2(TreeNode root) {\n\t\tTreeNode x = null, y = null, pred = null;\n\t\tTreeNode cur = root;\n\t\twhile (cur != null) {\n\t\t\tif (cur.left != null) {\n\t\t\t\t/*\n\t\t\t\t * 步骤1（寻找前驱节点）\n\t\t\t\t * 1>一直向右找到最右端的节点即为前驱节点，停止遍历\n\t\t\t\t * 2>如果最右端的节点是 cur，表示上次循环经历过步骤2，停止遍历\n\t\t\t\t */\n\t\t\t\tTreeNode precessoNode = cur.left;\n\t\t\t\twhile (precessoNode.right != null && precessoNode.right != cur) {\n\t\t\t\t\tprecessoNode = precessoNode.right;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (precessoNode.right == null) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 步骤2\n\t\t\t\t\t * 1>让前驱节点的 right 指向当前节点（实现步骤4 -> 步骤1 -> 步骤3）\n\t\t\t\t\t * 2>继续遍历左子树\n\t\t\t\t\t */\n\t\t\t\t\tprecessoNode.right = cur;\n\t\t\t\t\tcur = cur.left;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * 所有右子树的节点（包含 cur）\n\t\t\t\t\t */\n\t\t\t\t\tif (pred != null && pred.val > cur.val) { //找到异常节点（前面 > 后面）\n\t\t\t\t\t\ty = cur; //后\n\t\t\t\t\t\tif (x == null) {\n\t\t\t\t\t\t\tx = pred; //前 \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpred = cur;\n\t\t\t\t\t/* \n\t\t\t\t\t * 步骤3（precessoNode.right == cur，上次循环步骤2处理的结果）\n\t\t\t\t\t * 1>去掉前驱节点和 cur 的关联（right = null）\n\t\t\t\t\t * 2>开始遍历 cur 的右子树\n\t\t\t\t\t */\n\t\t\t\t\tprecessoNode.right = null;\n\t\t\t\t\tcur = cur.right;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * 所有左子树的节点\n\t\t\t\t */\n\t\t\t\tif (pred != null && pred.val > cur.val) { //找到异常节点（前面 > 后面）\n\t\t\t\t\ty = cur; //后\n\t\t\t\t\tif (x == null) {\n\t\t\t\t\t\tx = pred; //前 \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpred = cur;\n\t\t\t\t/*\n\t\t\t\t * 步骤4遍历右子树\n\t\t\t\t * 第一种情况：遍历右子树\n\t\t\t\t * 第二种情况：回到父节点，去步骤3（呼应步骤2）\n\t\t\t\t */\n\t\t\t\tcur = cur.right;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(x, y);\n\t}\t\n}\n```\n\nps：  \n二叉树绘图网站  \n[520it](http://520it.com/binarytrees/)  \n[Binary Tree Visualiser](http://btv.melezinek.cz/binary-search-tree.html)  \n[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  \n[B-Tree](https://yangez.github.io/btree-js/)\n","source":"_posts/数据结构与算法/二叉搜索树.md","raw":"---\ntitle: 二叉搜索树\ndate: 2020-11-18 14:29:12\ntags: 数据结构与算法\n---\n\n[二叉搜索树（Binary Search Tree）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。\n\n<!-- more -->\n\n# 二叉搜索树\n\n## 思考：在 n 个动态的整数中搜索某个整数（查看其是否存在）？\n\n1. 使用动态数组，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n)；  \n![二叉搜索树01](二叉搜索树/二叉搜索树01.png)\n2. 使用有序的动态数组，使用二分搜索，最坏时间负载度：O(log(n))，但是添加和删除的平均时间复杂度是：O(n)；  \n![二叉搜索树02](二叉搜索树/二叉搜索树02.png)\n3. 使用二叉搜索树，添加、删除和搜索的最坏时间复杂度都是：O(log(n));\n\n## 二叉搜索树特性\n二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST。又被称为：二叉查找树、二叉排序树。二叉搜索树可以大大提高搜索数据的效率。  \n1. 若它的左子树不空，则左子树上所有结点的值均<u>小于</u>它的根结点的值；  \n2. 若它的右子树不空，则右子树上所有结点的值均<u>大于</u>它的根结点的值；  \n3. 它的左、右子树也分别为<u>二叉搜索树</u>。\n\n![二叉搜索树03](二叉搜索树/二叉搜索树03.png)\n使用二叉搜索树需要注意：  \n1. 存储的元素必须具备比较性，比如 `int`、`double` 等。\n2. 如果是自定义类型，需要指定比较方式。\n3. 存储的元素不可以是 `null`。\n\n# 接口设计\n```\n/*\n * 元素的数量\n */\npublic int size() {}\n/*\n * 是否为空\n */\npublic boolean isEmpty() {}\n/*\n * 清空所有元素\n */\npublic void clear() {}\n/*\n * 添加元素\n */\npublic void add(E element) {}\n/*\n * 删除元素\n */\npublic void remove(E element) {}\n/*\n * 是否包含某元素\n */\npublic void contains(E element) {}\n```\n\n## 添加节点\n1. 找到要添加到的位置，即找到该位置的父节点 `parent`；  \n2. 创建新节点 `node`；  \n3. 加入到树中：`parent.left = node` 或者 `parent.right = node`。\n\n注意：遇到值相等的元素可以覆盖旧值。\n\n如添加 `12`、`1`，先找到父节点 `11`、`2`：\n![二叉搜索树04](二叉搜索树/二叉搜索树04.png)\n创建新节点 `node`，加入到树中：\n![二叉搜索树05](二叉搜索树/二叉搜索树05.png)\n\n代码实现：\n```\npublic void add(E element) {\n\tif (root == null) {\n\t\troot = new Node<>(element, null);\n\t\treturn;\n\t}\n\t\n\tNode<E> node = root;\n\tNode<E> parent = root;\n\tint cmp = 0;\n\twhile (node != null) {\n\t\tparent = node;\n\t\tcmp = compare(element, node.element); // 返回值等于0：e1 == e2，大于0：e1 > e2，小于0：e1 < e2\n\n\t\tif (cmp > 0) {\n\t\t\tnode = node.right;\n\t\t} else if (cmp < 0) {\n\t\t\tnode = node.left;\n\t\t} else {\n\t\t\tnode.element = element; // 考虑到不同名字的 person，相等就覆盖\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tNode<E> newNode = new Node<>(element, parent);\n\tif (cmp > 0) {\n\t\tparent.right = newNode;\n\t} else {\n\t\tparent.left = newNode;\n\t}\n\t\n\tsize++;\n}\n```\n\n## 元素的比较方案设计\n### 方案一\n强制元素实现 `Comparable` 接口：\n```\npublic class BinarySearchTree<E extends Comparable> {\n    ...\n}\n```\n\n添加 `extends Comparable` 后，要加入到二叉搜索树的元素都必须实现 `Comparable` 接口。\n\n定义 Person 实现 `Comparable` 接口：\n```\npublic class Person implements Comparable<Person> {\n\tprivate int age;\n\t\n\t// 生成 age 的 get、set 方法\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Person e) {\n\t\treturn age - e.age;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn age + \"\";\n\t}\n}\n```\n\n### 方案二\n1. 允许外界传入一个 `Comparator` 自定义比较方案；\n2. 如果没有传入 `Comparator`，强制认定元素实现了 `Comparable` 接口。\n```\npublic class BinarySearchTree<E> {\n\n\tprivate Comparator<E> comparator;\n\n\tpublic BinarySearchTree() {\n\t\tthis(null);\n\t}\n\t\n\tpublic BinarySearchTree(Comparator<E> comparator) {\n\t\tthis.comparator = comparator;\n\t}\n    \n\tprivate int compare(E e1, E e2) {\n\t\tif (comparator != null) {\n\t\t\treturn comparator.compare(e1, e2);\n\t\t}\n\t\treturn ((Comparable<E>)e1).compareTo(e2);\n\t}\n}\n```\n\n## 打印器\n使用 [BinaryTrees](https://github.com/CoderMJLee/BinaryTrees) 打印二叉搜索树。\n\n1、实现 `BinaryTreeInfo` 接口\n```\npublic class BinarySearchTree<E> implements BinaryTreeInfo {\n\t...\n\n\t@Override\n\tpublic Object root() {\n\t\treturn root;\n\t}\n\n\t@Override\n\tpublic Object left(Object node) {\n\t\treturn ((Node<E>)node).left;\n\t}\n\n\t@Override\n\tpublic Object right(Object node) {\n\t\treturn ((Node<E>)node).right;\n\t}\n\n\t@Override\n\tpublic Object string(Object node) {\n\t\treturn ((Node<E>)node).element;\n\t}\n}\n```\n\n2、调用打印API `BinaryTrees.println(bst)`：\n```\nstatic void test() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t};\n\t\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);;\n}\n```\n\n### Comparable\n```\nstatic void test() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t};\n\t\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n}\n```\n\n打印结果：\n```\n    ┌──7──┐\n    │     │\n  ┌─4─┐ ┌─9─┐\n  │   │ │   │\n┌─2─┐ 5 8   11─┐\n│   │          │\n1   3          12\n```\n\n### Comparator\n```\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInteger data[] = new Integer[] {\n\t\t\t\t7, 4, 9, 2, 5, 8, 11, 3, 12, 1\n\t\t};\n\t\t\n\t\tBinarySearchTree<Person> bst = new BinarySearchTree<>(new Comparator<Person>() {\n\t\t\tpublic int compare(Person o1, Person o2) {\n\t\t\t\treturn o1.getAge() - o2.getAge();\n\t\t\t}\n\t\t});\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tbst.add(new Person(data[i]));\n\t\t}\n\t\t\n\t\tBinaryTrees.println(bst);;\n\t}\n}\n```\n\n修改 `BinarySearchTree` 的 `string` 方法，查看更详细的打印信息：\n```\npublic Object string(Object node) {\n\tNode<E> myNode = (Node<E>)node;\n\tString parentString = \"null\";\n\tif (myNode.parent != null) {\n\t\tparentString = myNode.parent.element.toString();\n\t}\n\treturn myNode.element + \"_p(\" + parentString + \")\";\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)─┐\n   │        │                          │\n1_p(2)    3_p(2)                    12_p(11)\n```\n\n国外教材的说法  \nFull Binary Tree：完满二叉树（真二叉树）；  \nPerfect Binary Tree：完美二叉树（满二叉树）；  \nComplete Binary Tree：完全二叉树；\n\n# 遍历\n遍历是数据结构中的常见操作，线性数据结构（如：数组）的遍历比较简单，有两种：正序遍历和逆序遍历。二叉树的遍历方式有四种：  \n1. 前序遍历（Preorder Traversal）\n2. 中序遍历（Inorder Traversal）\n3. 后序遍历（Postorder Traversal）\n4. 层序遍历（Level Order Traversal）\n\n## 前序遍历\n访问顺序：\n1. 根节点；\n2. 前序遍历左子树；\n3. 前序遍历右子树。\n![二叉搜索树06](二叉搜索树/二叉搜索树06.png)\n\n### 递归\n<font color=#FF0000>7、</font><font color=#00BFF>4、2、1、3、5、</font><font color=#F0E68C>9、8、11、10、12</font>\n![二叉搜索树10](二叉搜索树/二叉搜索树10.png)\n\n代码实现：\n```\npublic void preorderTraversal() {\n\tpreorderTraversal(root);\n}\n\nprivate void preorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tSystem.out.println(node.element);\n\tpreorderTraversal(node.left);\n\tpreorderTraversal(node.right);\n}\n```\n\n### 非递归\n\n## 中序遍历\n访问顺序（升序）：\n1. 中序遍历左子树；\n2. 根节点；\n3. 中序遍历右子树。  \n![二叉搜索树07](二叉搜索树/二叉搜索树07.png) \n\n访问顺序（降序）：\n1. 中序遍历右子树；\n2. 根节点；\n3. 中序遍历左子树。\n![二叉搜索树08](二叉搜索树/二叉搜索树08.png)\n\n### 递归\n<font color=#00BFF>1、2、3、4、5、</font><font color=#FF0000>7、</font><font color=#F0E68C>8、9、10、11、12</font>（升序）\n![二叉搜索树11](二叉搜索树/二叉搜索树11.png)\n\n代码实现：\n```\npublic void inorderTraversal() {\n\tinorderTraversal(root);\n}\n\nprivate void inorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tinorderTraversal(node.left);\n\tSystem.out.println(node.element);\n\tinorderTraversal(node.right);\n}\n```\n\n### 非递归\n\n## 后序遍历\n访问顺序：\n1. 后序遍历左子树；\n2. 后序遍历右子树；\n3. 根节点。  \n![二叉搜索树09](二叉搜索树/二叉搜索树09.png)\n\n### 递归\n<font color=#00BFF>1、3、2、5、4、</font><font color=#F0E68C>8、10、12、11、9、</font><font color=#FF0000>7</font>\n![二叉搜索树12](二叉搜索树/二叉搜索树12.png)\n\n代码实现：\n```\npublic void postorderTraversal() {\n\tpostorderTraversal(root);\n}\n\nprivate void postorderTraversal(Node<E> node) {\n\tif (node == null) return;\n\t\n\tpostorderTraversal(node.left);\n\tpostorderTraversal(node.right);\n\tSystem.out.println(node.element);\n}\n```\n\n### 非递归\n\n## 层序遍历\n访问顺序：  \n1. 从上到下、从左到右依次访问每一个几点。\n\n<font color=#FF0000>7、</font><font color=#00BFF>4、9、</font><font color=#F0E68C>2、5、8、11、</font><font color=#32CD32>1、3、10、12</font>\n![二叉搜索树13](二叉搜索树/二叉搜索树13.png)\n\n代码实现：\n```\npublic void levelOrderTraversal() {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tSystem.out.println(node.element);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n```\n\n# 遍历接口\n## 前、中、后、层\n遍历接口提供一个回调方法，将遍历到的元素传到方法调用处处理：\n```\n/*\n * 回调方法（相当于 OC 的 block）\n */\npublic static interface Visitor<E> {\n\tvoid visit(E element);\n}\n```\n\n前序遍历、中序遍历、后序遍历和中序遍历：\n```\n/*\n * 前序遍历\n */\npublic void preorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpreorderTraversal(root, visitor);\n}\n\nprivate void preorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tvisitor.visit(node.element);\n\tpreorderTraversal(node.left, visitor);\n\tpreorderTraversal(node.right, visitor);\n}\n\n/*\n * 中序遍历\n */\npublic void inorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tinorderTraversal(root, visitor);\n}\n\nprivate void inorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tinorderTraversal(node.left, visitor);\n\tvisitor.visit(node.element);\n\tinorderTraversal(node.right, visitor);\n}\n\n/*\n * 后序遍历\n */\npublic void postorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpostorderTraversal(root, visitor);\n}\n\nprivate void postorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null) return;\n\t\n\tpostorderTraversal(node.left, visitor);\n\tpostorderTraversal(node.right, visitor);\n\tvisitor.visit(node.element);\n}\n\n/*\n * 层序遍历（有回调）\n */\npublic void levelOrder(Visitor<E> visitor) {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tvisitor.visit(node.element);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n```\n\n测试\n```\nstatic void test3() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\tBinaryTrees.println(bst);\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"前序遍历：\");\n\tbst.preorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"中序遍历：\");\n\tbst.inorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"后序遍历：\");\n\tbst.postorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"层序遍历：\");\n\tbst.levelOrder(new Visitor<Integer>() {\t\t\t\n\t\t@Override\n\t\tpublic void visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t}\n\t});\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n\n前序遍历：7 4 2 1 3 5 9 8 11 10 12 \n中序遍历：1 2 3 4 5 7 8 9 10 11 12 \n后序遍历：1 3 2 5 4 8 10 12 11 9 7 \n层序遍历：7 4 9 2 5 8 11 1 3 10 12\n```\n\n## 遍历接口增强\n实现当遍历到指定节点时，停止遍历。\n\n### 层序遍历\n程序遍历的修改比较简单，只需要：\n1. 给 `Visitor.visit()` 方法增加返回值；\n2. 在处理元素的位置添加判断即可。\n\n```\n/*\n * 层序遍历（有回调）\n */\npublic void levelOrder(Visitor<E> visitor) {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tif (visitor.visit(node.element)) return; // 判断是否结束遍历\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t}\n}\n\n/*\n * 回调方法（相当于 OC 的 block）\n * 返回值：true（停止遍历）/false（继续遍历）\n */\npublic static interface Visitor<E> {\n\tboolean visit(E element);\n}\n```\n\n### 前、中、后\n前序遍历、中序遍历和后序遍历实现方式相同：\n1. Visitor 类中记录 isStop 变量（是否停止遍历的标签）；\n2. 在遍历过程中，添加是否停止遍历的判断。\n```\n/*\n * 回调方法（相当于 OC 的 block）\n * 返回值：true（停止遍历）/false（继续遍历）\n */\npublic static abstract class Visitor<E> {\n\tpublic boolean isStop;\n\tpublic abstract boolean visit(E element);\n}\n```\n\n前序遍历、中序遍历和后序遍历：\n```\n/*\n * 前序遍历\n */\npublic void preorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpreorderTraversal(root, visitor);\n}\n\nprivate void preorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tvisitor.isStop = visitor.visit(node.element);\n\tpreorderTraversal(node.left, visitor);\n\tpreorderTraversal(node.right, visitor);\n}\n\n/*\n * 中序遍历\n */\npublic void inorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tinorderTraversal(root, visitor);\n}\n\nprivate void inorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tinorderTraversal(node.left, visitor);\n\tif (visitor.isStop) return;\n\tvisitor.isStop = visitor.visit(node.element);\n\tinorderTraversal(node.right, visitor);\n}\n\n/*\n * 后序遍历\n */\npublic void postorderTraversal(Visitor<E> visitor) {\n\tif (visitor == null) return;\n\tpostorderTraversal(root, visitor);\n}\n\nprivate void postorderTraversal(Node<E> node, Visitor<E> visitor) {\n\tif (node == null || visitor.isStop) return;\n\t\n\tpostorderTraversal(node.left, visitor);\n\tpostorderTraversal(node.right, visitor);\n\tif (visitor.isStop) return;\n\tvisitor.isStop = visitor.visit(node.element);\n}\n```\n\n测试：设置遍历到 8 时停止遍历。\n```\nstatic void test3() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\tBinaryTrees.println(bst);\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"前序遍历：\");\n\tbst.preorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"中序遍历：\");\n\tbst.inorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"后序遍历：\");\n\tbst.postorderTraversal(new Visitor<Integer>() {\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n\tSystem.out.println();\n\t\n\tSystem.out.print(\"层序遍历：\");\n\tbst.levelOrder(new Visitor<Integer>() {\t\t\t\n\t\t@Override\n\t\tpublic boolean visit(Integer element) {\n\t\t\tSystem.out.print(element + \" \");\n\t\t\treturn element == 8;\n\t\t}\n\t});\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n\n前序遍历：7 4 2 1 3 5 9 8 \n中序遍历：1 2 3 4 5 7 8 \n后序遍历：1 3 2 5 4 8 \n层序遍历：7 4 9 2 5 8 \n```\n## 遍历的应用\n前序遍历：树状结构展示（注意左右子树的顺序）；  \n中序遍历：二叉搜索树的中序遍历按升序或降序处理节点；  \n后序遍历：适用于一些先子后父的操作；  \n层序遍历：计算二叉树的高度、判断一棵树是否为完全二叉树；\n\n# 练习Ⅰ\n## 树状打印二叉树\n```\npublic String toString() {\n\tStringBuilder sb = new StringBuilder();\n\ttoString(root, sb, \"\");\n\treturn sb.toString();\n}\n\nprivate void toString(Node<E> node, StringBuilder sb, String prefix) {\n\tif (node == null) return;\n\t\n\tsb.append(prefix).append(node.element).append(\"\\n\");\n\ttoString(node.left, sb, prefix + \"L_\");\n\ttoString(node.right, sb, prefix + \"R_\");\n}\n```\n\n测试：\n```\nstatic void test4() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tSystem.out.println(bst);\n}\n```\n\n打印结果：\n```\n7\nL_4\nL_L_2\nL_L_L_1\nL_L_R_3\nL_R_5\nR_9\nR_L_8\nR_R_11\nR_R_L_10\nR_R_R_12\n```\n\n上面👆的打印是通过前序遍历实现的，同样的也可以使用中序遍历、后序遍历实现。\n\n## 计算二叉树的高度\n\n### 递归\n```\npublic int height() {\n\treturn height(root);\n}\n\nprivate int height(Node<E> node) {\n\tif (node == null) return 0; // 设置递归停止条件\n\treturn 1 + Math.max(height(node.left), height(node.right)); // 取左右子树的高度中较大的一个加一\n}\n```\n\n### 迭代\n```\npublic int height() {\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1; // 标记某一层节点的个数，默认一个（第一层的root节点）\n\tint height = 0;\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\tlevelSize--; \n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\t// 等于0时，表示这一层的节点全部遍历完成了\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size(); // 开始记录下一层的节点个数\n\t\t\theight++; // 开始下一层遍历时，高度加一\n\t\t}\n\t}\n\treturn height;\n}\n```\n\n### 测试\n```\nstatic void test5() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11, 10, 12\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n\t\n\tSystem.out.println(\"二叉树高度：\" + bst.height());\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9) ┌─11_p(9)─┐\n   │        │                │         │\n1_p(2)    3_p(2)         10_p(11)   12_p(11)\n二叉树高度：4\n```\n\n## 完全二叉树的判断\n使用层序遍历：\n1. 如果树为空，返回 false；\n2. 如果 node.left != null，将 node.left 入队；\n3. 如果 node.left == null && node.right != null，返回 false；\n4. 如果 node.right != null，将 node.right 入队；\n5. 如果 node.right == null，则后边再遍历到的节点必须都是叶子节点，否则返回 false；\n6. 遍历结束，返回 true；\n\n```\npublic boolean isComplete() {\n\t\n\tif (root == null) return false;\n\t\n\tQueue<Node<E>> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tboolean leaf = false;\n\t\n\twhile (!queue.isEmpty()) {\n\t\tNode<E> node = queue.poll();\n\t\t\n\t\tif (leaf && !node.isLeaf()) return false;\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.offer(node.left);\n\t\t} else if (node.right != null) { //即：node.left == null && node.right != null\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.offer(node.right);\t\n\t\t} else { // node.right == null\n\t\t\tleaf = true;\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n测试：\n```\nstatic void test6() {\n\tInteger data[] = new Integer[] {\n\t\t\t7, 4, 2, 1, 3, 5, 9, 8, 11\n\t};\n\tBinarySearchTree<Integer> bst = new BinarySearchTree<>();\n\tfor (int i = 0; i < data.length; i++) {\n\t\tbst.add(data[i]);\n\t}\n\t\n\tBinaryTrees.println(bst);\n\tSystem.out.println(bst.isComplete());\n}\n```\n\n打印结果：\n```\n             ┌───7_p(null)───┐\n             │               │\n        ┌─4_p(7)─┐       ┌─9_p(7)─┐\n        │        │       │        │\n   ┌─2_p(4)─┐  5_p(4) 8_p(9)   11_p(9)\n   │        │\n1_p(2)    3_p(2)\ntrue\n```\n\n## 翻转二叉树\n[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)  \n核心代码：\n```\nTreeNode temp = node.left;\nnode.left = node.right;\nnode.right = temp;\n```\n\n分别用前序遍历、中序遍历、后序遍历和层序遍历实现：\n```\n/*\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/*\n * 前序遍历\n */\npublic TreeNode invertTree(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\t\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\treturn root;\n}\n\n/*\n * 后序遍历\n */\npublic TreeNode invertTree2(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\treturn root;\n}\n\n/*\n * 中序遍历\n */\npublic TreeNode invertTree3(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tinvertTree(root.left);\n\t\n\tTreeNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\t\n\tinvertTree(root.left);\n\treturn root;\n}\n\n/*\n * 层序遍历\n */\npublic TreeNode invertTree4(TreeNode root) {\n\tif (root == null) return root;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\t\n\t\tTreeNode temp = node.left;\n\t\tnode.left = node.right;\n\t\tnode.right = temp;\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.offer(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.offer(node.right);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n# 重构二叉树\n以下两种方式，可以保证重构处唯一的一个二叉树。重构的原理是通过两种不同的遍历方式找到根节点，再用同样的方式找到每棵子树的根节点，以此类推：  \n1. 前序遍历 + 中序遍历：  \n![二叉搜索树14](二叉搜索树/二叉搜索树14.png)  \n2. 后序遍历 + 中序遍历：  \n![二叉搜索树15](二叉搜索树/二叉搜索树15.png)\n\n如：前序遍历：`4、2、1、3、6、5`，中序遍历：`1、2、3、4、5、6`。  \n1. 先根据前序遍历可以找到这棵二叉树的根节点 `4`；  \n2. 再结合中序遍历可以找到左子树的根节点 `2`，右子树的根节点 `6`；  \n3. 最后根据中序遍历可以知道 `2` 的左子树是 `1`，右子树是 `3`；`6` 的左子树是 `5`。  \n![二叉搜索树16](二叉搜索树/二叉搜索树16.png)\n\n“前序遍历 + 后序遍历”这种情况比较特殊，存在两种情况：  \n1. 如果是一棵真二叉树（Proper Binary Tree），结果是唯一的；\n![二叉搜索树17](二叉搜索树/二叉搜索树17.png)  \n重构方式同上👆。\n2. 否则不唯一；  \n![二叉搜索树18](二叉搜索树/二叉搜索树18.png)  \n因为只有一棵子树，所以从遍历结果不能确定子树究竟是左子树还是右子树。\n\n# 前驱节点\n前驱节点：中序遍历时的前一个节点。如果是二叉搜索树，前驱节点就是前一个比它小的节点。\n\n查找方式：\n1. `node.left != null`；  \n`predecessor = node.left.right.right.right...` 终止条件：`right == null`。  \n如：6、8、13\n![二叉搜索树19](二叉搜索树/二叉搜索树19.png)  \n2. `node.left == null && node.parent != null`;  \n`predecessor = node.parent.parent.parent...` 终止条件：`node` 在 `parent` 的右子树中（`node == node.parent.right`）。  \n如：7、11、9、1\n![二叉搜索树20](二叉搜索树/二叉搜索树20.png) \n3. `node.left == null && node.parent == null`，没有前驱节点（没有左子树的根节点）。\n\n代码实现：\n```\npublic Node<E> predecessor(Node<E> node) {\n\tif (node == null) return node;\n\t\n\tNode<E> p = node.left;\n\tif (p != null) {\n\t\twhile (p.right != null) {\n\t\t\tp = p.right;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\twhile (node.parent != null && node == node.parent.left) {\n\t\tnode = node.parent;\n\t}\n\treturn node.parent;\n}\n```\n\n# 后继节点\n后继节点：终须遍历时的后一个几点。如果是二叉搜索树，后继节点就是后一个比它大的节点。\n\n1. `node.right != null`；  \n`successor = node.right.left.left.left...` 终止条件：`left == null`。  \n如：1、8、4\n![二叉搜索树21](二叉搜索树/二叉搜索树21.png) \n2. `node.right == null && node.parent != null`；  \n`successor = node.parent.parent.parent...` 终止条件：`node` 在 `parent` 的左子树中（`node == node.parent.left`）。  \n如：7、6、3、11\n![二叉搜索树22](二叉搜索树/二叉搜索树22.png) \n3. `node.right == null && node.parent == null`，没有后继节点（没有右子树的根节点）。\n\n代码实现：\n```\npublic Node<E> successor(Node<E> node) {\n\tif (node == null) return node;\n\t\n\tNode<E> p = node.right;\n\tif (p != null) {\n\t\twhile (p.left != null) {\n\t\t\tp = p.left;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\twhile (node.parent != null && node == node.parent.right) {\n\t\tnode = node.parent;\n\t}\n\treturn node.parent;\n}\n```\n\n# 删除\n\n## 删除-叶子节点\n```\n//左子节点\nif (node == node.parent.left) {\n\tnode.parent.left = null;\n}\n\n//右子节点\nif (node == node.parent.right) {\n\tnode.parent.right = node;\n}\n\n//只有一个节点（root）\nif (node.parent == null) {\n\troot = null;\n}\n```\n![二叉搜索树24](二叉搜索树/二叉搜索树24.png)\n\n## 删除-度为1的节点\n用子节点代替原节点的位置，child 是 node.left 或者 node.right：\n```\n//如果node是左子节点\nif (node == node.parent.left) {\n\tchild.parent = node.parent;\n\tnode.parent.left = child;\n}\n\n//如果node是右子节点\nif (node == node.parent.right) {\n\tchild.parent = node.parent;\n\tnode.parent.right = child;\n}\n\n//如果node是根节点\nif (node.parent == null) {\n\troot = child;\n\tchild.parent = null;\n}\n```\n![二叉搜索树25](二叉搜索树/二叉搜索树25.png)\n\n## 删除-度为2的节点\n1. 先用前驱或后继节点的值覆盖原节点的值；\n2. 再删除相应的前驱或后继节点；\n3. 如果一个节点的度为2，那它的前驱、后继节点的度只能是1和0；  \n\n![二叉搜索树26](二叉搜索树/二叉搜索树26.png)\n\n## 代码实现\n```\npublic void remove(E element) {\n\tremove(node(element));\n}\n\nprivate void remove(Node<E> node) {\n\t\n\t//删除度为2的节点\n\tif (node.isHasTwoChildren()) {\n\t\t//找到后继节点\n\t\tNode<E> s = successor(node);\n\t\t//用后继节点的值覆盖度为2的节点的值\n\t\tnode.element = s.element;\n\t\t//删除后继节点\n\t\tnode = s;\n\t}\n\t\n\t//删除度为1或0的节点\n\tNode<E> replacement = node.left != null ? node.left : node.right;\n\t\n\tif (replacement != null) { // node是度为1的节点\n\t\t// 更改parent\n\t\treplacement.parent = node.parent;\n\t\t// 更改parent的left、right的指向\n\t\tif (node.parent == null) { //node是度为1的节点并且是根节点\n\t\t\troot = replacement;\n\t\t} else if (node.parent.left == node) {\n\t\t\tnode.parent.left = replacement;\n\t\t} else {\n\t\t\tnode.parent.right = replacement;\n\t\t}\n\t} else if (node.parent == null) { // node是叶子节点并且是根节点\n\t\troot = null;\n\t} else { // node是叶子节点，但不是根节点\n\t\tif (node.parent.left == node) {\n\t\t\tnode.parent.left = null;\n\t\t} else {\n\t\t\tnode.parent.right = null;\n\t\t}\n\t}\n}\n\n/*\n * 根据元素内容获取节点\n */\nprivate Node<E> node(E element) {\n\tNode<E> node = root;\n\twhile (node != null) {\n\t\tint cmp = compare(element, node.element);\n\t\tif (cmp == 0) return node;\n\t\tif (cmp > 0) {\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tnode = node.left;\n\t\t}\n\t}\n\treturn node;\n}\n```\n\n# 练习 Ⅱ\n## 二叉树的前序遍历\n[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\n递归：\n```\npublic List<Integer> preorderTraversal(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n\tpreorderTraversalRecursive(root, res);\n\treturn res;\n}\n\npublic void preorderTraversalRecursive(TreeNode root, List<Integer> res) {\n\tif (root == null) return;\n\n\tres.add(root.val);\n\tpreorderTraversalRecursive(root.left, res);\n\tpreorderTraversalRecursive(root.right, res);\n}\n```\n\n迭代：\n```\npublic List<Integer> preorderTraversalIterative(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n\tif (root == null) return res;\n\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tres.add(node.val);\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.pop();\n\t\tnode = node.right;\n\t}\n\treturn res;\n}\n```\n\n## 二叉树的中序遍历\n[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n递归：\n```\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    inorderTraversalRecursive(root, res);\n    return res;\n}\n\npublic void inorderTraversalRecursive(TreeNode root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tinorderTraversalRecursive(root.left, res);\n\tres.add(root.val);\n\tinorderTraversalRecursive(root.right, res);\n}\n```\n\n迭代：\n```\npublic List<Integer> inorderTraversalIterative(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    \n    Deque<TreeNode> stack = new LinkedList<>();\n    TreeNode node = root;\n    while (!stack.isEmpty() || node != null) {\n    \twhile (node != null) {\n        \tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n    \tnode = stack.pop();\n    \tres.add(node.val);\n    \tnode = node.right;\n\t}\n    return res;\n}\n```\n\n## 二叉树的后序遍历\n[45. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n递归：\n```\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    postorderTraversalRecursive(root, res);\n\treturn res; \n}\n\npublic void postorderTraversalRecursive(TreeNode root, List<Integer> res) {\n    if (root == null) return;\n    \n\tpostorderTraversalRecursive(root.left, res);\n\tpostorderTraversalRecursive(root.right, res);\n\tres.add(root.val);\n}\n```\n\n迭代：\n```\npublic List<Integer> postorderTraversalIterative(TreeNode root) {\n\tList<Integer> res = new ArrayList<Integer>();\n    if (root == null) return null;\n    \n    Deque<TreeNode> stack = new LinkedList<>();\n    TreeNode node = root;\n    TreeNode prev = null;\n    while (!stack.isEmpty() || node != null) {\n    \twhile (node != null) {\n        \tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n    \tnode = stack.pop();\n    \tif (node.right == null || node.right == prev) {\n\t\t\tres.add(node.val);\n\t\t\tprev = node;\n\t\t\tnode = null;\n\t\t} else {\n\t\t\tstack.push(node);\n\t\t\tnode = node.right;\n\t\t}\n\t}\n    \n    return res;\n}\n```\n\n## 二叉树的层序遍历\n[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n迭代：\n```\npublic List<List<Integer>> levelOrder(TreeNode root) {\n\tList<List<Integer>> res = new ArrayList<>();\n\tif (root == null) return res;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.add(root);\n\tint levelSize = 1;\n\tList<Integer> list = new ArrayList<Integer>();\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\tlist.add(node.val);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\tif (levelSize == 0) {\n\t\t\tres.add(list);\n\t\t\tlevelSize = queue.size();\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n## 二叉树的最大深度\n[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n递归：\n```\n/*\n * 递归\n */\npublic int maxDepth(TreeNode root) {\n\tif (root == null) return 0;\n\treturn 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n\n迭代：\n```\nlic int maxDepth(TreeNode root) {\n\tint height = 0;\n\tif (root == null) return height;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.add(root);\n\tint levelSize = 1;\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\t\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\theight++;\n\t\t}\n\t}\n\t\n\treturn height;\n}\n```\n\n## 二叉树的层次遍历 II\n[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n```\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n\tList<List<Integer>> res = new ArrayList<>();\n\tif (root == null) return res;\n\t\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1;\n\tList<Integer> list = new ArrayList<>();\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode node = queue.poll();\n\t\tlevelSize--;\n\t\tlist.add(node.val);\n\t\t\n\t\tif (node.left != null) {\n\t\t\tqueue.add(node.left);\n\t\t}\n\t\t\n\t\tif (node.right != null) {\n\t\t\tqueue.add(node.right);\n\t\t}\n\t\t\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\tres.add(0, list);\n\t\t\tlist = new ArrayList<>();\n\t\t}\n\t}\n\t\n\treturn res;\n}\n```\n\n## 二叉树最大宽度\n[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n```\npublic class _662_二叉树最大宽度 {\n    public int widthOfBinaryTree(TreeNode root) {\n    \tif (root == null) return 0;\n    \t\n    \tNode node = new Node(root, 0, 0);\n    \tQueue<Node> queue = new LinkedList<>();\n    \tqueue.offer(node);\n    \tint curDepth = 0, left = 0, ans = 0;\n    \twhile (!queue.isEmpty()) {\n    \t\tnode = queue.poll();\n    \t\t\n    \t\tif (node.treeNode != null) {\n\t\t\t\tqueue.offer(new Node(node.treeNode.left, node.depth + 1, node.pos * 2));\n\t\t\t\tqueue.offer(new Node(node.treeNode.right, node.depth + 1, node.pos * 2 + 1));\n\t\t\t\t\n\t\t\t\t//每开始遍历新的一层，记录最左边的pos\n\t\t\t\tif (curDepth != node.depth) {\n\t\t\t\t\tcurDepth = node.depth;\n\t\t\t\t\tleft = node.pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = Math.max(ans, node.pos - left + 1);\n\t\t\t}\n    \t}\n\n    \treturn ans;\n    }\n}\n\n//因为左右子树存在null的情况，所以创建新的Node包装TreeNode，这样就可以存储TreeNode==null情况\nclass Node {\n\tTreeNode treeNode;\n\tint depth, pos;\n\tpublic Node(TreeNode treeNode, int depth, int pos) {\n\t\tthis.treeNode = treeNode;\n\t\tthis.depth = depth;\n\t\tthis.pos = pos;\n\t}\n}\n```\n\n## N叉树的前序遍历\n[589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n```\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/*\n * 递归\n */\npublic List<Integer> preorder(Node root) {\n    List<Integer> res = new LinkedList<>();\n\tpreorderTraversal(root, res);\n\treturn res;\n}\n\npublic void preorderTraversal(Node root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tres.add(root.val);\n\tif (root.children != null) {\n\t\tfor (Node c : root.children) {\n\t\t\tpreorderTraversal(c, res);\n\t\t}\n\t}\n\treturn;\n}\n\n/*\n * 迭代\n */\npublic List<Integer> preorderIterative(Node root) {\n    List<Integer> res = new LinkedList<>();\n    if (root == null) return res;\n    \n    Deque<Node> stack = new LinkedList<>();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n    \tNode node = stack.pop();\n    \tres.add(node.val);\n    \t//反转一个 List（[v1, v2, v3] -> [v3, v2, v1]）\n    \tCollections.reverse(node.children);\n    \tfor (Node c : node.children) {\n\t\t\tstack.push(c);\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n## N叉树的后序遍历\n[590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n```\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/*\n * 递归\n */\npublic List<Integer> postorder(Node root) {\n\tList<Integer> res = new LinkedList<>();\n\tpostorderTraversal(root, res);\n    return res;\n}\n\npublic void postorderTraversal(Node root, List<Integer> res) {\n\tif (root == null) return;\n\t\n\tif (root.children != null) {\n\t\tfor (Node c : root.children) {\n\t\t\tpostorderTraversal(c, res);\n\t\t}\n\t}\n\t\n\tres.add(root.val);\n    return;\n}\n\n/*\n * 迭代\n */\npublic List<Integer> postorderIterative(Node root) {\n\tList<Integer> res = new LinkedList<>();\n\tif (root == null) return res;\n\t\n\tDeque<Node> stack = new LinkedList<>();\n\tstack.push(root);\n\twhile (!stack.isEmpty()) {\n\t\tNode node = stack.poll();\n\t\tres.add(0, node.val);\n\t\tfor (Node c : node.children) {\n\t\t\tstack.push(c);\n\t\t}\n\t}\n\t\n    return res;\n}\n```\n\n## N叉树的最大深度\n[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)\n```\n/*\n * 递归\n */\npublic int maxDepth(Node root) {\n\tif (root == null) return 0;\n\t\n\tint result = 1;\n\tfor (Node c : root.children) {\n\t\tresult = Math.max(result, 1 + maxDepth(c));\n\t}\n\treturn result;\n}\n\n/*\n * 迭代\n */\npublic int maxDepthIterative(Node root) {\n\tint height = 0;\n\tif (root == null) return height;\n    \n\tQueue<Node> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tint levelSize = 1;\n\twhile (!queue.isEmpty()) {\n\t\tNode node = queue.poll();\n\t\tlevelSize--;\n\t\tif (node.children != null) {\n\t\t\tfor (Node c : node.children) {\n\t\t\t\tqueue.offer(c);\n\t\t\t}\n\t\t}\n\t\tif (levelSize == 0) {\n\t\t\tlevelSize = queue.size();\n\t\t\theight++;\n\t\t}\n\t}\n\treturn height;\n}\n```\n\n## 二叉树展开为链表\n[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n```\n/*\n * 方法一：前序遍历-递归\n */\npublic void flatten(TreeNode root) {\n    List<TreeNode> list = new LinkedList<>();\n    preorderTraversal(root, list);\n    for (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i-1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n\npublic void preorderTraversal(TreeNode root, List<TreeNode> list) {\n    if (root == null) return;\n    \n    list.add(root);\n    preorderTraversal(root.left, list);\n    preorderTraversal(root.right, list);\n}\n\n/*\n * 方法一：前序遍历-迭代\n */\npublic void flattenIterative(TreeNode root) {\n    \n\tList<TreeNode> list = new LinkedList<>();\n\t\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tlist.add(node);\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.poll();\n\t\tnode = node.right;\n\t}\n\tfor (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i - 1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n/*\n * 方法一：前序遍历-迭代2\n */\npublic void flattenIterative2(TreeNode root) {\n    if (root == null) return;\n\tList<TreeNode> list = new LinkedList<>();\n\t\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode node = stack.poll();\n\t\tlist.add(node);\n\t\t\n\t\tif (node.right != null) {\n\t\t\tstack.push(node.right);\n\t\t}\n\t\t\n\t\tif (node.left != null) {\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n\tfor (int i = 1; i < list.size(); i++) {\n\t\tTreeNode node1 = list.get(i - 1);\n\t\tTreeNode node2 = list.get(i);\n\t\tnode1.right = node2;\n\t\tnode1.left = null;\n\t}\n}\n\n/*\n * 方法二：前序遍历和展开同步进行\n */\npublic void flattenIterative3(TreeNode root) {\n\tif (root == null) return;\n\t\n\t//前序遍历\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\tTreeNode prev = null;\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode curr = stack.poll();\n\t\tif (curr.right != null) {\n\t\t\tstack.push(curr.right);\n\t\t}\n\t\tif (curr.left != null) {\n\t\t\tstack.push(curr.left);\n\t\t}\n\t\t\n\t\t//展开\n\t\tif (prev != null) {\n\t\t\tprev.right = curr;\n\t\t\tprev.left = null;\t\n\t\t}\n\t\tprev = curr;\n\t}\n}\n\n/*\n * 方法三：寻找前驱节点\n */\npublic void flattenIteraltive4(TreeNode root) {\n\tif (root == null) return;\n\t\n\tTreeNode curr = root;\n\twhile (curr != null) {\n\t\tif (curr.left != null) {\n\t\t\tTreeNode next = curr.left;\n\t\t\t\n\t\t\t//寻找前驱节点\n\t\t\tTreeNode predecessor = curr.left;\n\t\t\twhile (predecessor.right != null) {\n\t\t\t\tpredecessor = predecessor.right;\n\t\t\t}\n\t\t\t\n\t\t\t//展开\n\t\t\tpredecessor.right = curr.right;\n\t\t\tcurr.right = next;\n\t\t\tcurr.left = null;\n\t\t}\n\t\tcurr = curr.right; //next\n\t}\n}\n```\n\n## 从中序与后序遍历序列构造二叉树\n[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n```\n/*\n * 方法一：递归\n */\nint post_idx;\nint[] inorder;\nint[] postorder;\nMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\n\npublic TreeNode helper(int in_left, int in_right) {\n\t//没有节点\n\tif (in_left > in_right) return null;\n\t\n\t//后序遍历结果中 post_idx 处的节点作为当前子树的根节点\n\tint root_val = postorder[post_idx];\n\tTreeNode root = new TreeNode(root_val);\n\t\n\t//根据 root 所在位置分成左右子树\n\tint index = idx_map.get(root_val);\n\t\n\t//下标减1（递归构建完右子树后，post_idx-- < index）\n\tpost_idx--;\n\t\n\t//递归-构建右子树\n\troot.right = helper(index + 1, in_right);\n\t\n\t//递归-构建左子树\n\troot.left = helper(in_left, index - 1);\n\t\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n\tthis.inorder = inorder;\n\tthis.postorder = postorder;\n\t\n\tpost_idx = postorder.length - 1;\n\t\n\tint idx = 0;\n\tfor (int val : inorder) {\n\t\tidx_map.put(val, idx++);\n\t}\n\n\treturn helper(0, post_idx);\n}\n\n/*\n * 方法二：迭代\n * \n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n * postorder = [15, 10, 9, 5, 4, 8, 7, 20, 3]\n */\npublic TreeNode buildTree2(int[] inorder, int[] postorder) {\n\tif (postorder == null || postorder.length == 0) {\n\t\treturn null;\n\t}\n\t\n\t//后序遍历的最后一个节点就是 root 节点\n\t//这些节点的顺序和它们在反向中序遍历（反向遍历inorder）中出现的顺序一定是相反的\n\tTreeNode root = new TreeNode(postorder[postorder.length - 1]);\n\t//使用栈存放后序遍历中的节点\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\t\n\t//用来记录子树里最右边的节点\n\tint inorderIndex = inorder.length - 1;\n\t//从后序遍历的倒数第二个几点开始，反向遍历 postorder\n\tfor (int i = postorder.length - 2; i >= 0; i--) {\n\t\tint postorderVal = postorder[i];\n\t\t//栈顶节点\n\t\tTreeNode node = stack.peek();\n\t\tif (node.val != inorder[inorderIndex]) {\n\t\t\t//node 不是最右边的节点，那么 postorderVal 是 node 的右节点\n\t\t\tnode.right = new TreeNode(postorderVal);\n\t\t\tstack.push(node.right);\n\t\t} else {\n\t\t\t//node 是最右边的节点，那么 postorderVal 是 node 的左节点\n\t\t\t//栈里的这些节点（右节点）的顺序和它们在反向中序遍历中出现的顺序一定是相反的\n\t\t\twhile (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n\t\t\t\tnode = stack.pop();\n\t\t\t\tinorderIndex--; //反向遍历 inorder\n\t\t\t}\n\t\t\t//因为 postorderVal 出现在了 node 与 node 在栈中的下一个节点的反向中序遍历之间，因此 postorderVal 就是 node 的左儿子。\n\t\t\tnode.left = new TreeNode(postorderVal);\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n## 从前序与中序遍历序列构造二叉树\n[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n![二叉搜索树23](二叉搜索树/二叉搜索树23.png)\n```\n/*\n * 方法一：递归\n * \n * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]\n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n */\nint preorderIndex;\nint[] preorder;\nint[] inorder;\nMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\npublic TreeNode helper(int in_left, int in_right) {\n\t\n\tif (in_left > in_right) {\n\t\treturn null;\n\t}\n\t\n\tTreeNode root = new TreeNode(preorder[preorderIndex]);\n\tint index = idx_map.get(root.val);\n\t\n\tpreorderIndex++;\n\t\n\t//遍历创建左子节点\n\troot.left = helper(in_left, index - 1);\n\t//遍历创建右子节点\n\troot.right = helper(index + 1, in_right);\n\t\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n\tthis.preorder = preorder;\n\tthis.inorder = inorder;\n\t\n\tfor (int i = 0; i < inorder.length; i++) {\n\t\tidx_map.put(inorder[i], i);\n\t}\n\t\n\treturn helper(0, preorder.length);\n}\n\n/*\n * 方法二：迭代\n * \n * preorder = [3, 9, 15, 10, 20, 7, 5, 8, 4]\n * inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]\n */\npublic TreeNode buildTree2(int[] preorder, int[] inorder) {\n\tif (preorder == null || preorder.length == 0) {\n\t\treturn null;\n\t}\n\t//前序遍历的第一个节点就是root节点\n\tTreeNode root = new TreeNode(preorder[0]);\n\t//中序遍历的索引\n\tint inorderIndex = 0;\n\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tstack.push(root);\n\t\n\t//正序遍历 preorder\n\tfor (int i = 1; i < preorder.length; i++) {\n\t\tint preorderVal = preorder[i];\n\t\tTreeNode node = stack.peek();\n\t\tif (node.val != inorder[inorderIndex]) {\n\t\t\t// node 不是最左边的节点，那么 postorderVal 是 node 的左节点\n\t\t\tnode.left = new TreeNode(preorderVal);\n\t\t\tstack.push(node.left);\n\t\t} else {\n\t\t\t// node 是最左边的节点，那么 postorderVal 是 node 的右节点\n\t\t\twhile (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n\t\t\t\tnode = stack.pop();\n\t\t\t\tinorderIndex++;\n\t\t\t}\n\t\t\tnode.right = new TreeNode(preorderVal);\n\t\t\tstack.push(node.right);\n\t\t}\n\t}\n\t\n\treturn root;\n}\n```\n\n## 根据前序和后序遍历构造二叉树\n[889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n```\n/*\n * 方法一：递归\n */\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\n\tint N = pre.length;\n\tif (N == 0) {\n\t\treturn null;\n\t}\n\tTreeNode root = new TreeNode(pre[0]);\n\tif (N == 1) {\n\t\treturn root;\n\t}\n\t\n\t//令左分支有 L 个节点\n\tint L = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (post[i] == pre[1]) {\n\t\t\tL = i + 1; //L = post.indexOf(pre[1]) + 1\n\t\t}\n\t}\n\t\n\t//copyOfRange(int[] original, int from, int to)：包括下标from，不包括上标to\n\t//左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支\n\troot.left = constructFromPrePost(Arrays.copyOfRange(pre, 1,\tL + 1), Arrays.copyOfRange(post, 0, L));\n\t//右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支\n\troot.right = constructFromPrePost(Arrays.copyOfRange(pre, L + 1, N), Arrays.copyOfRange(post, L, N - 1));\n\t\n\treturn root;\n}\n```\n\n## 对称二叉树\n[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n```\n/*\n * 方法一：递归\n */\npublic boolean isSymmetric(TreeNode root) {\n\treturn check(root, root);\n}\n\npublic boolean check(TreeNode p, TreeNode q) {\n\t\n\tif (p == null && q == null) return true;\n\t\n\tif (p == null || q == null) return false;\n\t\n\treturn (p.val == q.val && check(p.left, q.right) && check(p.right, q.left));\n}\n\n/*\n * 方法二：迭代\n */\npublic boolean isSymmetric2(TreeNode root) {\n\tQueue<TreeNode> queue = new LinkedList<>();\n\tqueue.offer(root);\n\tqueue.offer(root);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tTreeNode p = queue.poll();\n\t\tTreeNode q = queue.poll();\n\t\tif (p == null && q == null) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (p == null || q == null || p.val != q.val) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tqueue.offer(p.left);\n\t\tqueue.offer(q.right);\n\t\t\n\t\tqueue.offer(p.right);\n\t\tqueue.offer(q.left);\n\t}\n\t\n\treturn true;\n}\n```\n\n# 练习 Ⅲ\n## 删除二叉搜索树中的节点\n[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n```\npublic int successor(TreeNode root) {\n\troot = root.right;\n\twhile (root.left != null) {\n\t\troot = root.left;\n\t}\n\treturn root.val;\n}\n\npublic int predecessor(TreeNode root) {\n\troot = root.left;\n\twhile (root.right != null) {\n\t\troot = root.right;\n\t}\n\treturn root.val;\n}\n\npublic TreeNode deleteNode(TreeNode root, int key) {\n\tif (root == null) return null;\n\t\n\tif (key > root.val) {\n\t\t//向又查找\n\t\troot.right = deleteNode(root.right, key);\n\t} else if (key < root.val) {\n\t\t//向左查找\n\t\troot.left = deleteNode(root.left, key);\n\t} else {\n\t\tif (root.left == null && root.right == null) { //删除叶子节点\n\t\t\troot = null;\n\t\t} else if (root.right != null) { //删除度为1的节点\n\t\t\troot.val = successor(root);\n\t\t\troot.right = deleteNode(root.right, root.val);\n\t\t} else { //删除度为1的节点\n\t\t\troot.val = predecessor(root);\n\t\t\troot.left = deleteNode(root.left, root.val);\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n## 二叉搜索树中的搜索\n[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n```\npublic TreeNode searchBST(TreeNode root, int val) {\n\tif (root == null) return null;\n\twhile (root != null) {\n\t\tif (val > root.val) {\n\t\t\troot = root.right;\n\t\t} else if (val < root.val) {\n\t\t\troot = root.left;\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n## 二叉搜索树中的插入操作\n[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n```\npublic TreeNode insertIntoBST(TreeNode root, int val) {\n\tif (root == null) return new TreeNode(val);\n\t\n\tTreeNode node = root;\n\tTreeNode parent = root;\n\tint cmp = 0;\n\twhile (node != null) {\n\t\tparent = node;\n\t\tif (val > node.val) {\n\t\t\tcmp = 1;\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tcmp = -1;\n\t\t\tnode = node.left;\n\t\t}\n\t}\n\t\n\tif (cmp > 0) {\n\t\tparent.right = new TreeNode(val);\n\t} else {\n\t\tparent.left = new TreeNode(val);\n\t}\n\t\n\treturn root;\n}\n```\n\n## 验证二叉搜索树\n[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n```\n/*\n * 递归\n *\n * 左子树不为空，则左子树上所有节点的值均小于它的根节点的值；\n * 右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n * 它的左右子树也为二叉搜索树。\n */\npublic boolean isValidBST(TreeNode root) {\n\treturn preorder(root, null, null);\n}\n\npublic boolean preorder(TreeNode root, Integer lower, Integer upper) {\n\tif (root == null) return true;\n\t\n\tif (lower != null && lower >= root.val) return false;\n\t\n\tif (upper != null && upper <= root.val) return false;\n\t\n\tif (!preorder(root.left, lower, root.val)) return false;\n\t\n\tif (!preorder(root.right, root.val, upper)) return false;\n\t\n\treturn true;\n}\n\n/*\n * 迭代\n * \n * 「中序遍历」得到的值构成的序列一定是升序的\n */\npublic boolean isValidBST2(TreeNode root) {\n\treturn inorder(root);\n}\n\npublic boolean inorder(TreeNode root) {\n\tDeque<TreeNode> stack = new LinkedList<>();\n\tTreeNode node = root;\n\tTreeNode prev = null;\n\twhile (!stack.isEmpty() || node != null) {\n\t\twhile (node != null) {\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tnode = stack.pop();\n\t\tif (prev != null && prev.val >= node.val) {\n\t\t\treturn false;\n\t\t}\n\t\tprev = node;\n\t\tnode = node.right;\n\t}\n\treturn true;\n}\n```\n\n## 二叉搜索树的最小绝对差\n[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)\n```\nTreeNode prev;\nint ans;\n\npublic int getMinimumDifference(TreeNode root) {\n\tans = Integer.MAX_VALUE;\n\tinorder(root);\n\treturn ans;\n}\n\npublic void inorder(TreeNode root) {\n\tif (root == null) return;\n\t\n\tinorder(root.left);\n\t\n\tif (prev == null) {\n\t\tprev = root;\n\t} else {\n\t\tint cha = root.val - prev.val;\n\t\tans = ans > cha ? cha : ans;\n\t\tprev = root;\n\t}\n\t\n\tinorder(root.right);\n}\n```\n\n## 二叉搜索树节点最小距离\n[783. 二叉搜索树节点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)\n```\npublic class _783_二叉搜索树节点最小距离 {\n\tint preVal;\n\tint ans;\n    public int minDiffInBST(TreeNode root) {\n    \tpreVal = -1;\n    \tans = Integer.MAX_VALUE;\n    \tinorder(root);\n    \treturn ans;\n    }\n    \n    public void inorder(TreeNode root) {\n    \tif (root == null) return;\n    \t\n    \tinorder(root.left);\n    \t\n    \tif (preVal != -1) {\n    \t\tans = Math.min(ans, root.val - preVal);\n\t\t}\n    \tpreVal = root.val;\n    \t\n    \tinorder(root.right);\n    }\n}\n```\n\n## 将有序数组转换为二叉搜索树\n[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n```\npublic TreeNode sortedArrayToBST(int[] nums) {\n\treturn helper(nums, 0, nums.length-1);\n}\n\npublic TreeNode helper(int[] nums, int left, int right) {\n\tif (left > right) return null;\n\t\n\tint mid = (left + right) / 2;\n\t\n\tTreeNode root = new TreeNode(nums[mid]);\n\troot.left = helper(nums, left, mid-1);\n\troot.right = helper(nums, mid+1, right);\n\t\n\treturn root;\n}\n```\n\n## 二叉搜索树的范围和\n[938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n```\nint sum;\n\npublic int rangeSumBST(TreeNode root, int low, int high) {\n\tinorder(root, low, high);\n\treturn sum;\n}\n\npublic void inorder(TreeNode root, int low, int high) {\n\tif (root == null) return;\n\t\n\trangeSumBST(root.left, low, high);\n\n\tif (root.val >= low && root.val <= high) {\n\t\tsum += root.val;\n\t}\n\trangeSumBST(root.right, low, high);\n}\n```\n\n## 二叉搜索树的最近公共祖先\n[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n```\n/*\n * 方法一：两次遍历\n */\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\tList<TreeNode> path_p = path(root, p);\n\tList<TreeNode> path_q = path(root, q);\n\t\n\tTreeNode node = null;\n\tfor (int i = 0; i < path_p.size() && i < path_q.size(); i++) {\n\t\tif (path_p.get(i) == path_q.get(i)) {\n\t\t\tnode = path_p.get(i);\n\t\t}\n\t}\n\treturn node;\n}\n\npublic List<TreeNode> path(TreeNode root, TreeNode target) {\n\tList<TreeNode> path = new LinkedList<>();\n\tTreeNode node = root;\n\twhile (node != target) {\n\t\tpath.add(node);\n\t\tif (node.val > target.val) {\n\t\t\tnode = node.left;\n\t\t} else if (node.val < target.val) {\n\t\t\tnode = node.right;\n\t\t}\n\t}\n\tpath.add(node);\n\treturn path;\n}\n\n/*\n * 方法一：一次遍历\n */\npublic TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\n\tTreeNode node = root;\n\t\n\twhile (node != null) {\n\t\tif (node.val > p.val && node.val > q.val) {\n\t\t\tnode = node.left;\n\t\t} else if (node.val < p.val && node.val < q.val) {\n\t\t\tnode = node.right;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn node;\n}\n```\n\n## 二叉搜索树中第K小的元素\n[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n```\npublic class _230_二叉搜索树中第K小的元素 {\n\tTreeNode targeTreeNode = null;\n\tint index = 0;\n\t/*\n\t * 迭代\n\t */\n\tpublic int kthSmallest(TreeNode root, int k) {\n\n\t\tif (root == null) return root.val;\n\t\t\n\t\t///递归\n\t\t//return inorder(root, k);\n\t\t\n\t\t///迭代\n\t\tindex = k;\n\t\thelper(root);\n\t\treturn targeTreeNode.val;\n    }\n\t\n\tpublic int inorder(TreeNode root, int k) {\n\t\t\n\t\tTreeNode targeTreeNode = root;\n\t\tDeque<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode node = root;\n\t\twhile (!stack.isEmpty() || node != null) {\n\t\t\twhile (node != null) {\n\t\t\t\tstack.push(node);\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tk--;\n\t\t\tif (k == 0) {\n\t\t\t\ttargeTreeNode = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node.right;\n\t\t}\n\t\t\n\t\treturn targeTreeNode.val;\n\t}\n\t\n\t/*\n\t * 递归\n\t */\n\tpublic void helper(TreeNode root) {\n\t\tif (root == null || targeTreeNode != null) return;\n\t\t\n\t\thelper(root.left);\n\t\tindex--;\n\t\tif (index == 0 && targeTreeNode == null) {\n\t\t\ttargeTreeNode = root;\n\t\t\treturn;\n\t\t}\n\t\thelper(root.right);\n\t}\n}\n```\n\n## 二叉搜索树迭代器\n[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n```\n/*\n * 迭代\n */\nclass BSTIterator {\n\tDeque<TreeNode> stack;\n\t\n    public BSTIterator(TreeNode root) {\n    \tstack = new LinkedList<>();\n    \tleftmostInorder(root);\n    }\n    \n    public void leftmostInorder(TreeNode root) {\n    \twhile (root != null) {\n\t\t\tstack.push(root);\n\t\t\troot = root.left;\n\t\t}\n\t}\n    \n    public int next() {\n    \tTreeNode node = stack.poll();\n    \tif (node.right != null) {\n    \t\tleftmostInorder(node.right);\n\t\t}\n    \treturn node.val;\n    }\n    \n    public boolean hasNext() {\n    \treturn !stack.isEmpty();\n    }\n}\n```\n\n## 恢复二叉搜索树\n[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n```\npublic class _99_恢复二叉搜索树 {\n\n\t/*\n\t * 方法一：显示中序遍历\n\t */\n\tpublic void recoverTree(TreeNode root) {\n\t\tList<Integer> res = new LinkedList<>();\n\t\tinorder(root, res);\n\t\tint[] swaped = findTwoSwaped(res);\n\t\trecover(root, 2, swaped[0], swaped[1]);\n    }\n\t\n\tpublic void inorder(TreeNode root, List<Integer> res) {\n\t\tif (root == null) return;\n\t\tinorder(root.left, res);\n\t\tres.add(root.val);\n\t\tinorder(root.right, res);\n\t}\n\t\n\tpublic int[] findTwoSwaped(List<Integer> res) {\n\t\tint n = res.size();\n\t\tint x = -1, y = -1;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (res.get(i) == res.get(i + 1)) { //找到异常节点（前面 > 后面）\n\t\t\t\ty = res.get(i + 1);//后\n\t\t\t\tif (x == -1) {\n\t\t\t\t\tx = res.get(i);//前\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\t\n\tpublic void recover(TreeNode root, int count, int x, int y) {\n\t\tif (root != null) {\n\t\t\tif (root.val == x || root.val == y) {\n\t\t\t\troot.val = root.val == x ? y : x;\n\t\t\t\tif (--count == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\trecover(root.left, count, x, y);\n\t\t\trecover(root.right, count, x, y);\n\t\t}\n\t}\n\t\n\t/*\n\t * 方法二：隐式中序遍历\n\t */\n\tpublic void recoverTree1(TreeNode root) {\n\t\tDeque<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode x = null, y = null, pred = null;\n\t\twhile (!stack.isEmpty() || root != null) {\n\t\t\twhile (root != null) {\n\t\t\t\tstack.push(root);\n\t\t\t\troot = root.left;\n\t\t\t}\n\t\t\troot = stack.pop();\n\t\t\t///保存两个被交换的数据\n\t\t\tif (pred != null && pred.val > root.val) { //找到异常节点（前面 > 后面）\n\t\t\t\ty = root;//后\n\t\t\t\tif (x == null) {\n\t\t\t\t\tx = pred;//前\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpred = root;\n\t\t\troot = root.right;\n\t\t}\n\t\t\n        swap(x, y);\n\t}\n\t\n\tpublic void swap(TreeNode x, TreeNode y) {\n\t\tint temp = x.val;\n\t\tx.val = y.val;\n\t\ty.val = temp;\n\t}\n\t\n\t/*\n\t * 方法三：Morris 中序遍历\n\t */\n\tpublic void recoverTree2(TreeNode root) {\n\t\tTreeNode x = null, y = null, pred = null;\n\t\tTreeNode cur = root;\n\t\twhile (cur != null) {\n\t\t\tif (cur.left != null) {\n\t\t\t\t/*\n\t\t\t\t * 步骤1（寻找前驱节点）\n\t\t\t\t * 1>一直向右找到最右端的节点即为前驱节点，停止遍历\n\t\t\t\t * 2>如果最右端的节点是 cur，表示上次循环经历过步骤2，停止遍历\n\t\t\t\t */\n\t\t\t\tTreeNode precessoNode = cur.left;\n\t\t\t\twhile (precessoNode.right != null && precessoNode.right != cur) {\n\t\t\t\t\tprecessoNode = precessoNode.right;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (precessoNode.right == null) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 步骤2\n\t\t\t\t\t * 1>让前驱节点的 right 指向当前节点（实现步骤4 -> 步骤1 -> 步骤3）\n\t\t\t\t\t * 2>继续遍历左子树\n\t\t\t\t\t */\n\t\t\t\t\tprecessoNode.right = cur;\n\t\t\t\t\tcur = cur.left;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * 所有右子树的节点（包含 cur）\n\t\t\t\t\t */\n\t\t\t\t\tif (pred != null && pred.val > cur.val) { //找到异常节点（前面 > 后面）\n\t\t\t\t\t\ty = cur; //后\n\t\t\t\t\t\tif (x == null) {\n\t\t\t\t\t\t\tx = pred; //前 \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpred = cur;\n\t\t\t\t\t/* \n\t\t\t\t\t * 步骤3（precessoNode.right == cur，上次循环步骤2处理的结果）\n\t\t\t\t\t * 1>去掉前驱节点和 cur 的关联（right = null）\n\t\t\t\t\t * 2>开始遍历 cur 的右子树\n\t\t\t\t\t */\n\t\t\t\t\tprecessoNode.right = null;\n\t\t\t\t\tcur = cur.right;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * 所有左子树的节点\n\t\t\t\t */\n\t\t\t\tif (pred != null && pred.val > cur.val) { //找到异常节点（前面 > 后面）\n\t\t\t\t\ty = cur; //后\n\t\t\t\t\tif (x == null) {\n\t\t\t\t\t\tx = pred; //前 \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpred = cur;\n\t\t\t\t/*\n\t\t\t\t * 步骤4遍历右子树\n\t\t\t\t * 第一种情况：遍历右子树\n\t\t\t\t * 第二种情况：回到父节点，去步骤3（呼应步骤2）\n\t\t\t\t */\n\t\t\t\tcur = cur.right;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(x, y);\n\t}\t\n}\n```\n\nps：  \n二叉树绘图网站  \n[520it](http://520it.com/binarytrees/)  \n[Binary Tree Visualiser](http://btv.melezinek.cz/binary-search-tree.html)  \n[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)  \n[B-Tree](https://yangez.github.io/btree-js/)\n","slug":"数据结构与算法/二叉搜索树","published":1,"updated":"2023-08-22T09:52:14.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguw002baq7kkj0fyfi8"},{"title":"动态数组","date":"2020-10-15T06:41:12.000Z","_content":"\n[动态数组](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/10997983?fr=aladdin)是指在声明时没有确定数组大小的数组，即忽略圆括号中的下标；当要用它时，可随时用ReDim语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。\n\n<!-- more -->\n\n# 数据结构\n[数据结构](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin)是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。\n\n## 数据的逻辑结构\n指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括：\n1. 集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；\n2. 线性结构：数据结构中的元素存在一对一的相互关系；  \n3. 树形结构：数据结构中的元素存在一对多的相互关系； \n4. 图形结构：数据结构中的元素存在多对多的相互关系。\n![动态数组02](动态数组/动态数组02.png)\n线性结构包括：线性表、数组、链表、栈、队列和哈希表。  \n树形结构包括：二叉树、AVL树、红黑树、B树、堆、Trie、哈夫曼树和并查集。  \n图形结构包括：邻接矩阵和邻接表。\n\n## 常用的数据结构：\n![动态数组01](动态数组/动态数组01.png)\n\n## 线性表\n[线性表](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin)是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。\n\n![动态数组03](动态数组/动态数组03.png)\na1 是首节点（首元素），an 是为节点（尾元素）。  \na1 是 a2 的前驱，a2 是 a1 的后继。\n\nps：[什么是线性表](http://data.biancheng.net/view/157.html)\n\n## 数组\n[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097?fr=aladdin)是一种顺序存储的线性表，所有元素的内存地址是连续的。一维数组是最简单的数组，其逻辑结构是线性表。\n```\nint[] array = new int[]{11, 22, 33};\n```\n![动态数组04](动态数组/动态数组04.png)\n\n在很多编程语言中，数组都有个致命的缺点，无法动态修改容量。怎么实现一个容量可以动态修改的数组呢？👇\n\nps：[什么是数组](http://data.biancheng.net/view/181.html)\n\n# 动态数组\n\n## 接口设计\n```\npublic class ArrayList<E> {\n\t\n\t/**\n\t * 清除所有元素\n\t */\n\tpublic void clear() {}\n\n\t/**\n\t * 元素的数量\n\t * @return\n\t */\n\tpublic int size() {}\n\n\t/**\n\t * 是否为空\n\t * @return\n\t */\n\tpublic boolean isEmpty() {}\n\n\t/**\n\t * 是否包含某个元素\n\t * @param element\n\t * @return\n\t */\n\tpublic boolean contains(E element) {}\n\n\t/**\n\t * 添加元素到尾部\n\t * @param element\n\t */\n\tpublic void add(E element) {} \n\n\t/**\n\t * 获取index位置的元素\n\t * @param index\n\t * @return\n\t */\n\tpublic E get(int index) {}\n\n\t/**\n\t * 设置index位置的元素\n\t * @param index\n\t * @param element\n\t * @return 原来的元素ֵ\n\t */\n\tpublic E set(int index, E element) {}\n\n\t/**\n\t * 在index位置插入一个元素\n\t * @param index\n\t * @param element\n\t */\n\tpublic void add(int index, E element) {}\n\n\t/**\n\t * 删除index位置的元素\n\t * @param index\n\t * @return\n\t */\n\tpublic E remove(int index) {}\n\n\t/**\n\t * 查看元素的索引\n\t * @param element\n\t * @return\n\t */\n\tpublic int indexOf(E element) {}\n}\n```\n\n## 实现方案\n![动态数组05](动态数组/动态数组05.png)\n\n定义 size 记录数组的大小，定义 elements 存储元素。\n```\npublic class ArrayList<E> {\n\n\t/*\n\t * 元素的数量\n\t */\n\tprivate int size;\n\t\n    /*\n\t * 所有的元素\n\t */\n\tprivate E[] elements;\n\t\n    /*\n\t * 默认容量\n\t */\n\tprivate static final int DEFAULT_CAPACITY = 10;\n\t\n    /*\n\t * 构造方法\n\t */\n\tpublic ArrayList(int capacity) {\n\t\tcapacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;\n\t\telements = (E[]) new Object[capacity];\n\t}\n\t\n    /*\n\t * 构造方法\n\t */\n\tpublic ArrayList() {\n\t\tthis(DEFAULT_CAPACITY);\n\t}\n}\n```\n\n## 添加元素\n![动态数组06](动态数组/动态数组06.png)\n添加新元素，就是在 size 处添加新元素，代码实现：\n```\npublic void add(int element) {\n    elements[size++] = element;\n}\n```\n\n## 删除元素\nsize 等于 7，index 等于 3：\n![动态数组07](动态数组/动态数组07.png)\n从 `index + 1` 处开始依次向前移动，最后一个元素不做处理（因为执行了 `size--`，所以最后一个元素不会被外界访问到）：\n```\npublic E remove(int index) {\n\tint old = elements[index];\n\tfor (int i = index + 1; i < size; i++) {\n\t\telements[i - 1] = elements[i];\n\t} \n\telements[--size] = null;\n\treturn old;\n}\n```\n\n## 插入元素\nsize 等于 5，index 等于 2：\n![动态数组08](动态数组/动态数组08.png)\n从 `size - 1` 处开始依次向后移动，最后覆盖 index 处的元素：\n```\npublic void add(int index, int element) {\n\tfor (int i = size; i > index; i--) {\n\t\telements[i] = elements[i - 1];\n\t}\n\telements[index] = element;\n\tsize++;\n}\n```\n\n## 扩容\n![动态数组09](动态数组/动态数组09.png)\n创建新的数组，新数组的容量为旧数组容量的1.5倍（iOS 1.6倍, java 1.5倍）。\n```\nprivate void ensureCapacity(int capacity) {\n    int oldCapacity = elements.length;\n    if (oldCapacity >= capacity) return;\n    \n    int newCapacity = oldCapacity + (oldCapacity >> 1); // >> 表示除以2\n    int[] newElements = new int[newCapacity];\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    elements = newElements;\n}\n```\n\n## 缩容\n如果内存使用比较紧张，动态数组有比较多的剩余空间，可以考虑进行缩容操作。比如剩余空间占总容量的一半时，就进行缩容。\n```\nprivate void trim() {\n    int oldCapacity = elements.length;\n    int newCapacity = oldCapacity >> 1;\n    // 剩余空间小于一半 || 空间大小 <= 默认空间\n    if (size >= newCapacity || oldCapacity <= DEFAULT_CAPACITY) return;\n    \n    E[] newElements = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    elements = newElements;\n}\n```\n\n如果扩容倍数、缩容时机设计不得当，有可能会导致复杂度震荡。比如缩容时机改为 `size > newCapacity`，此时容量等于数组的一半时，新增加元素需要扩容，删除元素需要缩容，那么复杂度就一直是 O(n)。\n\n在 clear() 和 remove() 方法里进行缩容：\n```\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n    \n    // 缩容\n    if (elements != null && elements.length > DEFAULT_CAPACITY) {\n        elements = (E[]) new Object[DEFAULT_CAPACITY];\n    }\n}\n\npublic E remove(int index) {\n    rangeCheck(index);\n    E old = elements[index];\n    for (int i = index + 1; i < size; i++) {\n        elements[i - 1] = elements[i];\n    } \n    elements[--size] = null;\n    \n    // 缩容\n    trim();\n    \n    return old;\n}\n```\n\n## 泛型\n使用泛型技术可以让动态数组更加通用，可以存放任何数据类型。  \nE 表示泛型：\n```\npublic class ArrayList<E> {\n    private int size;\n    private E[] elements;\n}\n```\n\n使用 Object 创建的数组可以存放所有对象类型，因为所有的类都继承自Object。\n```\nelements = (E[]) new Object[capacity];\n```\n\n示例：\n```\nArrayList<Integer> ints = new ArrayList<>();\nints.add(10);\n\nArrayList<Object> objs = new ArrayList<>();\nobjs.add(10);\nobjs.add(new Person(10, \"Tom\"));\n```\n\n# 对象数组\n数组中存放的是对象地址。\n![动态数组10](动态数组/动态数组10.png)\n\n## 删除元素\n删除元素时，需要将数组对应的位置设为 null：\n```\n/**\n* 清除所有元素\n*/\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n}\n/**\n* 删除index位置的元素\n* @param index\n* @return\n*/\npublic E remove(int index) {\n    rangeCheck(index);\n    E old = elements[index];\n    for (int i = index + 1; i < size; i++) {\n        elements[i - 1] = elements[i];\n    }\n    elements[--size] = null;\n    return old;\n}\n```\n\n在调用 `clear()` 方法时，Java 的垃圾回收机制不会立即执行，可以通过 `System.gc()` 让垃圾回收机制立即启动：\n```\npersons.clear();\n// 提示JVM进行垃圾回收\nSystem.gc();\n```\n\n## 查找元素\n如果数组支持 null，需要修改 `indexOf()` 方法：\n```\npublic int indexOf(E element) {\n    if (element == null) {\n        for (int i = 0; i < size; i++) {\n            if (elements[i] == null) return i;\n        }\n    } else {\n        for (int i = 0; i < size; i++) {\n            //if (elements[i] == element) return i; // == 比较内存地址\n            if (elements[i].equals(element)) return i; // 重写 equals()。Integer 调用 equals()，内部比较的是数值\n        }\n    }\n    return ELEMENT_NOT_FOUND;\n}\n```\n\n## 判等\nPerson 类里实现 `equals()` 方法（age 相等 -> 两个 Person 对象相等）：\n```\npublic boolean equals(Object obj) {\n\tif (obj == null) return false;\n\tif (obj instanceof Person) {\n\t\tPerson person = (Person)obj;\n\t\treturn this.age == person.age;\n\t}\n\treturn false;\n}\n```\n\n# 源码分析\n\n## ArrayList\nJDK中内置了一个动态数组类：java.util.ArrayList。  \n\n方式一：\n如果 Eclipse 里没有加载这个包，可以手动导入：\n![动态数组11](动态数组/动态数组11.png)\n\n按住 command 点击 ArrayList：\n```\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tjava.util.ArrayList<E>\n\t}\n}\n```\n\n方式二：\n![动态数组12](动态数组/动态数组12.png)\n\n## 代码\n### 变量\n```\n/**\n * Default initial capacity.\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n\n/**\n * Shared empty array instance used for empty instances.\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * Shared empty array instance used for default sized empty instances. We\n * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n * first element is added.\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n/**\n * The array buffer into which the elements of the ArrayList are stored.\n * The capacity of the ArrayList is the length of this array buffer. Any\n * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n * will be expanded to DEFAULT_CAPACITY when the first element is added.\n */\ntransient Object[] elementData; // non-private to simplify nested class access\n\n/**\n * The size of the ArrayList (the number of elements it contains).\n *\n * @serial\n */\nprivate int size;\n```\n\n### 构造方法\n```\n/**\n * Constructs an empty list with the specified initial capacity.\n *\n * @param  initialCapacity  the initial capacity of the list\n * @throws IllegalArgumentException if the specified initial capacity\n *         is negative\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n/**\n * Constructs an empty list with an initial capacity of ten.\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n### 数组大小\n```\n//**\n * Returns the number of elements in this list.\n *\n * @return the number of elements in this list\n */\npublic int size() {\n    return size;\n}\n```\n\n### 判空\n```\n/**\n * Returns {@code true} if this list contains no elements.\n *\n * @return {@code true} if this list contains no elements\n */\npublic boolean isEmpty() {\n    return size == 0;\n}\n```\n\n### 查找\n```\n/**\n * Returns {@code true} if this list contains the specified element.\n * More formally, returns {@code true} if and only if this list contains\n * at least one element {@code e} such that\n * {@code Objects.equals(o, e)}.\n *\n * @param o element whose presence in this list is to be tested\n * @return {@code true} if this list contains the specified element\n */\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n\n/**\n * Returns the index of the first occurrence of the specified element\n * in this list, or -1 if this list does not contain the element.\n * More formally, returns the lowest index {@code i} such that\n * {@code Objects.equals(o, get(i))},\n * or -1 if there is no such index.\n */\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = start; i < end; i++) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n### 获取\n```\n/**\n * Returns the element at the specified position in this list.\n *\n * @param  index index of the element to return\n * @return the element at the specified position in this list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    Objects.checkIndex(index, size);\n    return elementData(index);\n}\n```\n\n### 修改\n```\n/**\n * Replaces the element at the specified position in this list with\n * the specified element.\n *\n * @param index index of the element to replace\n * @param element element to be stored at the specified position\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    Objects.checkIndex(index, size);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n```\n\n### 添加\n```\n/**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n */\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\n/**\n * Inserts the specified element at the specified position in this\n * list. Shifts the element currently at that position (if any) and\n * any subsequent elements to the right (adds one to their indices).\n *\n * @param index index at which the specified element is to be inserted\n * @param element element to be inserted\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    modCount++;\n    final int s;\n    Object[] elementData;\n    if ((s = size) == (elementData = this.elementData).length)\n        elementData = grow();\n    System.arraycopy(elementData, index,\n                     elementData, index + 1,\n                     s - index);\n    elementData[index] = element;\n    size = s + 1;\n}\n```\n\n### 删除\n```\n/**\n * Removes the element at the specified position in this list.\n * Shifts any subsequent elements to the left (subtracts one from their\n * indices).\n *\n * @param index the index of the element to be removed\n * @return the element that was removed from the list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E remove(int index) {\n    Objects.checkIndex(index, size);\n    final Object[] es = elementData;\n\n    @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n    fastRemove(es, index);\n\n    return oldValue;\n}\n```\n\n### 清空\n```\n/**\n * Removes all of the elements from this list.  The list will\n * be empty after this call returns.\n */\npublic void clear() {\n    modCount++;\n    final Object[] es = elementData;\n    for (int to = size, i = size = 0; i < to; i++)\n        es[i] = null;\n}\n```\n\n### 扩容\n```\n**\n * Increases the capacity of this {@code ArrayList} instance, if\n * necessary, to ensure that it can hold at least the number of elements\n * specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\npublic void ensureCapacity(int minCapacity) {\n    if (minCapacity > elementData.length\n        && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n             && minCapacity <= DEFAULT_CAPACITY)) {\n        modCount++;\n        grow(minCapacity);\n    }\n}\n\n/**\n * Increases the capacity to ensure that it can hold at least the\n * number of elements specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n * @throws OutOfMemoryError if minCapacity is less than zero\n */\nprivate Object[] grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n\nprivate Object[] grow() {\n    return grow(size + 1);\n}\n```\n\n# 测试\n使用 Asserts（断言）进行测试：\n![动态数组13](动态数组/动态数组13.png)\n\n# 复杂度分析\n\nps：[自定义ArrayList（代码）](https://github.com/KevinYangGit/Data-Structures)  \n\n\n","source":"_posts/数据结构与算法/动态数组.md","raw":"---\ntitle: 动态数组\ndate: 2020-10-15 14:41:12\ntags: 数据结构与算法\n---\n\n[动态数组](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/10997983?fr=aladdin)是指在声明时没有确定数组大小的数组，即忽略圆括号中的下标；当要用它时，可随时用ReDim语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。\n\n<!-- more -->\n\n# 数据结构\n[数据结构](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin)是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。\n\n## 数据的逻辑结构\n指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括：\n1. 集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；\n2. 线性结构：数据结构中的元素存在一对一的相互关系；  \n3. 树形结构：数据结构中的元素存在一对多的相互关系； \n4. 图形结构：数据结构中的元素存在多对多的相互关系。\n![动态数组02](动态数组/动态数组02.png)\n线性结构包括：线性表、数组、链表、栈、队列和哈希表。  \n树形结构包括：二叉树、AVL树、红黑树、B树、堆、Trie、哈夫曼树和并查集。  \n图形结构包括：邻接矩阵和邻接表。\n\n## 常用的数据结构：\n![动态数组01](动态数组/动态数组01.png)\n\n## 线性表\n[线性表](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin)是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。\n\n![动态数组03](动态数组/动态数组03.png)\na1 是首节点（首元素），an 是为节点（尾元素）。  \na1 是 a2 的前驱，a2 是 a1 的后继。\n\nps：[什么是线性表](http://data.biancheng.net/view/157.html)\n\n## 数组\n[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097?fr=aladdin)是一种顺序存储的线性表，所有元素的内存地址是连续的。一维数组是最简单的数组，其逻辑结构是线性表。\n```\nint[] array = new int[]{11, 22, 33};\n```\n![动态数组04](动态数组/动态数组04.png)\n\n在很多编程语言中，数组都有个致命的缺点，无法动态修改容量。怎么实现一个容量可以动态修改的数组呢？👇\n\nps：[什么是数组](http://data.biancheng.net/view/181.html)\n\n# 动态数组\n\n## 接口设计\n```\npublic class ArrayList<E> {\n\t\n\t/**\n\t * 清除所有元素\n\t */\n\tpublic void clear() {}\n\n\t/**\n\t * 元素的数量\n\t * @return\n\t */\n\tpublic int size() {}\n\n\t/**\n\t * 是否为空\n\t * @return\n\t */\n\tpublic boolean isEmpty() {}\n\n\t/**\n\t * 是否包含某个元素\n\t * @param element\n\t * @return\n\t */\n\tpublic boolean contains(E element) {}\n\n\t/**\n\t * 添加元素到尾部\n\t * @param element\n\t */\n\tpublic void add(E element) {} \n\n\t/**\n\t * 获取index位置的元素\n\t * @param index\n\t * @return\n\t */\n\tpublic E get(int index) {}\n\n\t/**\n\t * 设置index位置的元素\n\t * @param index\n\t * @param element\n\t * @return 原来的元素ֵ\n\t */\n\tpublic E set(int index, E element) {}\n\n\t/**\n\t * 在index位置插入一个元素\n\t * @param index\n\t * @param element\n\t */\n\tpublic void add(int index, E element) {}\n\n\t/**\n\t * 删除index位置的元素\n\t * @param index\n\t * @return\n\t */\n\tpublic E remove(int index) {}\n\n\t/**\n\t * 查看元素的索引\n\t * @param element\n\t * @return\n\t */\n\tpublic int indexOf(E element) {}\n}\n```\n\n## 实现方案\n![动态数组05](动态数组/动态数组05.png)\n\n定义 size 记录数组的大小，定义 elements 存储元素。\n```\npublic class ArrayList<E> {\n\n\t/*\n\t * 元素的数量\n\t */\n\tprivate int size;\n\t\n    /*\n\t * 所有的元素\n\t */\n\tprivate E[] elements;\n\t\n    /*\n\t * 默认容量\n\t */\n\tprivate static final int DEFAULT_CAPACITY = 10;\n\t\n    /*\n\t * 构造方法\n\t */\n\tpublic ArrayList(int capacity) {\n\t\tcapacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;\n\t\telements = (E[]) new Object[capacity];\n\t}\n\t\n    /*\n\t * 构造方法\n\t */\n\tpublic ArrayList() {\n\t\tthis(DEFAULT_CAPACITY);\n\t}\n}\n```\n\n## 添加元素\n![动态数组06](动态数组/动态数组06.png)\n添加新元素，就是在 size 处添加新元素，代码实现：\n```\npublic void add(int element) {\n    elements[size++] = element;\n}\n```\n\n## 删除元素\nsize 等于 7，index 等于 3：\n![动态数组07](动态数组/动态数组07.png)\n从 `index + 1` 处开始依次向前移动，最后一个元素不做处理（因为执行了 `size--`，所以最后一个元素不会被外界访问到）：\n```\npublic E remove(int index) {\n\tint old = elements[index];\n\tfor (int i = index + 1; i < size; i++) {\n\t\telements[i - 1] = elements[i];\n\t} \n\telements[--size] = null;\n\treturn old;\n}\n```\n\n## 插入元素\nsize 等于 5，index 等于 2：\n![动态数组08](动态数组/动态数组08.png)\n从 `size - 1` 处开始依次向后移动，最后覆盖 index 处的元素：\n```\npublic void add(int index, int element) {\n\tfor (int i = size; i > index; i--) {\n\t\telements[i] = elements[i - 1];\n\t}\n\telements[index] = element;\n\tsize++;\n}\n```\n\n## 扩容\n![动态数组09](动态数组/动态数组09.png)\n创建新的数组，新数组的容量为旧数组容量的1.5倍（iOS 1.6倍, java 1.5倍）。\n```\nprivate void ensureCapacity(int capacity) {\n    int oldCapacity = elements.length;\n    if (oldCapacity >= capacity) return;\n    \n    int newCapacity = oldCapacity + (oldCapacity >> 1); // >> 表示除以2\n    int[] newElements = new int[newCapacity];\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    elements = newElements;\n}\n```\n\n## 缩容\n如果内存使用比较紧张，动态数组有比较多的剩余空间，可以考虑进行缩容操作。比如剩余空间占总容量的一半时，就进行缩容。\n```\nprivate void trim() {\n    int oldCapacity = elements.length;\n    int newCapacity = oldCapacity >> 1;\n    // 剩余空间小于一半 || 空间大小 <= 默认空间\n    if (size >= newCapacity || oldCapacity <= DEFAULT_CAPACITY) return;\n    \n    E[] newElements = (E[]) new Object[newCapacity];\n    for (int i = 0; i < size; i++) {\n        newElements[i] = elements[i];\n    }\n    elements = newElements;\n}\n```\n\n如果扩容倍数、缩容时机设计不得当，有可能会导致复杂度震荡。比如缩容时机改为 `size > newCapacity`，此时容量等于数组的一半时，新增加元素需要扩容，删除元素需要缩容，那么复杂度就一直是 O(n)。\n\n在 clear() 和 remove() 方法里进行缩容：\n```\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n    \n    // 缩容\n    if (elements != null && elements.length > DEFAULT_CAPACITY) {\n        elements = (E[]) new Object[DEFAULT_CAPACITY];\n    }\n}\n\npublic E remove(int index) {\n    rangeCheck(index);\n    E old = elements[index];\n    for (int i = index + 1; i < size; i++) {\n        elements[i - 1] = elements[i];\n    } \n    elements[--size] = null;\n    \n    // 缩容\n    trim();\n    \n    return old;\n}\n```\n\n## 泛型\n使用泛型技术可以让动态数组更加通用，可以存放任何数据类型。  \nE 表示泛型：\n```\npublic class ArrayList<E> {\n    private int size;\n    private E[] elements;\n}\n```\n\n使用 Object 创建的数组可以存放所有对象类型，因为所有的类都继承自Object。\n```\nelements = (E[]) new Object[capacity];\n```\n\n示例：\n```\nArrayList<Integer> ints = new ArrayList<>();\nints.add(10);\n\nArrayList<Object> objs = new ArrayList<>();\nobjs.add(10);\nobjs.add(new Person(10, \"Tom\"));\n```\n\n# 对象数组\n数组中存放的是对象地址。\n![动态数组10](动态数组/动态数组10.png)\n\n## 删除元素\n删除元素时，需要将数组对应的位置设为 null：\n```\n/**\n* 清除所有元素\n*/\npublic void clear() {\n    for (int i = 0; i < size; i++) {\n        elements[i] = null;\n    }\n    size = 0;\n}\n/**\n* 删除index位置的元素\n* @param index\n* @return\n*/\npublic E remove(int index) {\n    rangeCheck(index);\n    E old = elements[index];\n    for (int i = index + 1; i < size; i++) {\n        elements[i - 1] = elements[i];\n    }\n    elements[--size] = null;\n    return old;\n}\n```\n\n在调用 `clear()` 方法时，Java 的垃圾回收机制不会立即执行，可以通过 `System.gc()` 让垃圾回收机制立即启动：\n```\npersons.clear();\n// 提示JVM进行垃圾回收\nSystem.gc();\n```\n\n## 查找元素\n如果数组支持 null，需要修改 `indexOf()` 方法：\n```\npublic int indexOf(E element) {\n    if (element == null) {\n        for (int i = 0; i < size; i++) {\n            if (elements[i] == null) return i;\n        }\n    } else {\n        for (int i = 0; i < size; i++) {\n            //if (elements[i] == element) return i; // == 比较内存地址\n            if (elements[i].equals(element)) return i; // 重写 equals()。Integer 调用 equals()，内部比较的是数值\n        }\n    }\n    return ELEMENT_NOT_FOUND;\n}\n```\n\n## 判等\nPerson 类里实现 `equals()` 方法（age 相等 -> 两个 Person 对象相等）：\n```\npublic boolean equals(Object obj) {\n\tif (obj == null) return false;\n\tif (obj instanceof Person) {\n\t\tPerson person = (Person)obj;\n\t\treturn this.age == person.age;\n\t}\n\treturn false;\n}\n```\n\n# 源码分析\n\n## ArrayList\nJDK中内置了一个动态数组类：java.util.ArrayList。  \n\n方式一：\n如果 Eclipse 里没有加载这个包，可以手动导入：\n![动态数组11](动态数组/动态数组11.png)\n\n按住 command 点击 ArrayList：\n```\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tjava.util.ArrayList<E>\n\t}\n}\n```\n\n方式二：\n![动态数组12](动态数组/动态数组12.png)\n\n## 代码\n### 变量\n```\n/**\n * Default initial capacity.\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n\n/**\n * Shared empty array instance used for empty instances.\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * Shared empty array instance used for default sized empty instances. We\n * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n * first element is added.\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n/**\n * The array buffer into which the elements of the ArrayList are stored.\n * The capacity of the ArrayList is the length of this array buffer. Any\n * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n * will be expanded to DEFAULT_CAPACITY when the first element is added.\n */\ntransient Object[] elementData; // non-private to simplify nested class access\n\n/**\n * The size of the ArrayList (the number of elements it contains).\n *\n * @serial\n */\nprivate int size;\n```\n\n### 构造方法\n```\n/**\n * Constructs an empty list with the specified initial capacity.\n *\n * @param  initialCapacity  the initial capacity of the list\n * @throws IllegalArgumentException if the specified initial capacity\n *         is negative\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n/**\n * Constructs an empty list with an initial capacity of ten.\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n### 数组大小\n```\n//**\n * Returns the number of elements in this list.\n *\n * @return the number of elements in this list\n */\npublic int size() {\n    return size;\n}\n```\n\n### 判空\n```\n/**\n * Returns {@code true} if this list contains no elements.\n *\n * @return {@code true} if this list contains no elements\n */\npublic boolean isEmpty() {\n    return size == 0;\n}\n```\n\n### 查找\n```\n/**\n * Returns {@code true} if this list contains the specified element.\n * More formally, returns {@code true} if and only if this list contains\n * at least one element {@code e} such that\n * {@code Objects.equals(o, e)}.\n *\n * @param o element whose presence in this list is to be tested\n * @return {@code true} if this list contains the specified element\n */\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n\n/**\n * Returns the index of the first occurrence of the specified element\n * in this list, or -1 if this list does not contain the element.\n * More formally, returns the lowest index {@code i} such that\n * {@code Objects.equals(o, get(i))},\n * or -1 if there is no such index.\n */\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = start; i < end; i++) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n### 获取\n```\n/**\n * Returns the element at the specified position in this list.\n *\n * @param  index index of the element to return\n * @return the element at the specified position in this list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    Objects.checkIndex(index, size);\n    return elementData(index);\n}\n```\n\n### 修改\n```\n/**\n * Replaces the element at the specified position in this list with\n * the specified element.\n *\n * @param index index of the element to replace\n * @param element element to be stored at the specified position\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    Objects.checkIndex(index, size);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n```\n\n### 添加\n```\n/**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n */\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\n/**\n * Inserts the specified element at the specified position in this\n * list. Shifts the element currently at that position (if any) and\n * any subsequent elements to the right (adds one to their indices).\n *\n * @param index index at which the specified element is to be inserted\n * @param element element to be inserted\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    modCount++;\n    final int s;\n    Object[] elementData;\n    if ((s = size) == (elementData = this.elementData).length)\n        elementData = grow();\n    System.arraycopy(elementData, index,\n                     elementData, index + 1,\n                     s - index);\n    elementData[index] = element;\n    size = s + 1;\n}\n```\n\n### 删除\n```\n/**\n * Removes the element at the specified position in this list.\n * Shifts any subsequent elements to the left (subtracts one from their\n * indices).\n *\n * @param index the index of the element to be removed\n * @return the element that was removed from the list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E remove(int index) {\n    Objects.checkIndex(index, size);\n    final Object[] es = elementData;\n\n    @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n    fastRemove(es, index);\n\n    return oldValue;\n}\n```\n\n### 清空\n```\n/**\n * Removes all of the elements from this list.  The list will\n * be empty after this call returns.\n */\npublic void clear() {\n    modCount++;\n    final Object[] es = elementData;\n    for (int to = size, i = size = 0; i < to; i++)\n        es[i] = null;\n}\n```\n\n### 扩容\n```\n**\n * Increases the capacity of this {@code ArrayList} instance, if\n * necessary, to ensure that it can hold at least the number of elements\n * specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\npublic void ensureCapacity(int minCapacity) {\n    if (minCapacity > elementData.length\n        && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n             && minCapacity <= DEFAULT_CAPACITY)) {\n        modCount++;\n        grow(minCapacity);\n    }\n}\n\n/**\n * Increases the capacity to ensure that it can hold at least the\n * number of elements specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n * @throws OutOfMemoryError if minCapacity is less than zero\n */\nprivate Object[] grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n\nprivate Object[] grow() {\n    return grow(size + 1);\n}\n```\n\n# 测试\n使用 Asserts（断言）进行测试：\n![动态数组13](动态数组/动态数组13.png)\n\n# 复杂度分析\n\nps：[自定义ArrayList（代码）](https://github.com/KevinYangGit/Data-Structures)  \n\n\n","slug":"数据结构与算法/动态数组","published":1,"updated":"2023-08-22T09:52:14.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgux002daq7k2h90v57v"},{"title":"复杂度","date":"2020-10-09T02:27:38.000Z","_content":"\n斐波那契数 & 算法的评估 & 时间复杂度的估算 & 大O表示法 & 斐波那契数复杂度分析\n<!-- more -->\n\n# 算法\n[算法](https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025?fr=aladdin)是用于解决特定问题的一系列的执行步骤。如：  \n```\n// 计算a跟b的和\npublic static int plus(int a, int b) {\n    return a + b;\n}\n\n// 计算1+2+3+...+n的和\npublic static int sum(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; i++) {\n        result += i;\n    }\n    return result;\n}\n```\n\n# 例一\n使用不同的算法解决同一个问题，效率可能相差非常大。如：求第n个斐波那契数。\n\n👉 斐波那契数列又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。\n\n方式一：\n```\npublic static int fib1(int n) {\n    if (n <= 1) return n;\n    return fib1(n - 1) + fib1(n - 2);\n}\n\npublic static void main(String[] args) {\n    System.out.println(fib1(1));\n    System.out.println(fib1(2));\n    System.out.println(fib1(3));\n    System.out.println(fib1(4));\n    System.out.println(fib1(64));\n}\n```\n\n打印结果：\n```\n1\n1\n2\n3\n```\n\n从打印结果可以看到，第1、2、3、4个斐波那契数能够正常打印，而第64个斐波那契数却无法正常打印。\n\n方式二：\n```\n/*\n* 下标：0 1 2 3 4 5 6 7\n* 数值：0 1 1 2 3 5 8 13 ...\n*/\npublic static int fib2(int n) {\n    if (n <= 1) return n;\n    \n    int first = 0;\n    int second = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = first + second;\n        first = second;\n        second = sum;\n    }\n    return second;\n}\n\npublic static void main(String[] args) {\n    System.out.println(fib2(64));\n}\n```\n\n打印结果：\n```\n695895453\n```\n\n# 算法的评估\n## 事后统计法\n如果单从执行效率上进行评估，可以比较不同算法对同一组输入的执行处理时间，这种方案也叫作：事后统计法。\n\n* 优点：\n  从执行处理时间可以直观的看出来算法的优劣；\n* 缺点：\n  执行时间严重依赖硬件以及运行时葛总不确定的环境因素；\n  必须编写相应的测算代码（Times）；\n  测试数据的选择比较难保证公正性；\n\n使用自定义工具 Times 查看两种实现方式的执行时间：\n```\npublic static void main(String[] args) {\n    int n = 44;\n\n    Times.test(\"fib1\", new Task() {\n        public void execute() {\n            System.out.println(fib1(n));\n        }\n    });\n\n    Times.test(\"fib2\", new Task() {\n        public void execute() {\n            System.out.println(fib2(n));\n        }\n    });\n}\n```\n\n打印结果：\n```\n695895453\n【fib1】\n开始：17:58:32.163\n-298632863\n结束：17:59:19.046\n耗时：46.883秒\n-------------------------------------\n【fib2】\n开始：17:59:19.047\n-1109825406\n结束：17:59:19.047\n耗时：0.0秒\n-------------------------------------\n```\n\n从打印结果可以看到，fib1 是非常耗时的，而 fib2 在同样的数据条件下，执行时间基本为0。\n\n## 算法的优劣\n一般从以下维度评估算法的优劣：  \n* 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）。\n* 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）。\n* 空间复杂度（space complexity）：估算所需占用的存储空间。\n\n# 时间复杂度\n[时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/5930669?fromtitle=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&fromid=1894057&fr=aladdin)：在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n\n## 大O表示法\n一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度。  \n\n[大O表示法](https://baike.baidu.com/item/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/1851162?fr=aladdin)：算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”。\n\n使用大O表示法时会忽略常数、系数、低阶，如：\n```\n9 >> O(1)\n2*n + 3 >> O(n)\nn^2 + 2n + 6 >> O(n^2)\n4*n^3 + 3*n^2 + 22*n + 100 >> O(n^3)\n```\n\n👉 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率。\n\n对数：`8 = 2^3  ->  3 = log2(8)`、`16 = 2^4  ->  4 = log2(16)`\n\n对数阶的细节：  \n对数阶一般省略底数，如：`log2(n) = log2(9) * log9(n)`，省略常数项后就是 `log2(n) = log9(n)`，所以 log2(n)、log9(n) 统称为 logn。\n\n示例：\n```\n// O(1)\npublic static void test1(int n) {\n    // 1\n    if (n > 10) { \n        System.out.println(\"n > 10\");\n    } else if (n > 5) { // 2\n        System.out.println(\"n > 5\");\n    } else {\n        System.out.println(\"n <= 5\"); \n    }\n    \n    // 1 + 4 + 4 + 4\n    for (int i = 0; i < 4; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test2(int n) {\n    // 1 + 3n\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test3(int n) {\n    // 1 + 2n + n * (1 + 3n)\n    // 1 + 2n + n + 3n^2\n    // 3n^2 + 3n + 1\n    // O(n^2)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n\n// O(n)\npublic static void test4(int n) {\n    // 1 + 2n + n * (1 + 45)\n    // 1 + 2n + 46n\n    // 48n + 1\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 15; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n\n/* 对数\n *  8 = 2^3  ->  3 = log2(8)\n * 16 = 2^4  ->  4 = log2(16)\n */\n\n// O(logn)\npublic static void test5(int n) {\n    // log2(n)\n    while ((n = n / 2) > 0) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(logn + nlogn) -> O(logn)\npublic static void test6(int n) {\n    // log5(n)\n    while ((n = n / 5) > 0) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(nlogn)\npublic static void test7(int n) {\n    // 1 + 2*log2(n) + log2(n) * (1 + 3n)\n    // 1 + 3*log2(n) + 2 * nlog2(n)\n    for (int i = 1; i < n; i = i * 2) {\n        // 1 + 3n\n        for (int j = 0; j < n; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n```\n\n## 常见的复杂度  \nO(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)\n![复杂度01](复杂度/复杂度01.png)\n\n使用[函数图像绘制工具](https://zh.numberempire.com/graphingcalculator.php)绘制 `log(n),n,n*log(n),n^2,n^3,2^n`：\n\n数据规模比较小时\n![复杂度02](复杂度/复杂度02.png)\n数据规模比较大时\n![复杂度03](复杂度/复杂度03.png)\n\n## 多个数据规模的情况\n```\n// O(n + k)\npublic static void test(int n, int k) {\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n    \n    for (int i = 0; i < k; i++) {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 空间复杂度\n```\n// O(1)\npublic static void test1(int n) {\n    if (n > 10) { \n        System.out.println(\"n > 10\");\n    } else if (n > 5) { // 2\n        System.out.println(\"n > 5\");\n    } else {\n        System.out.println(\"n <= 5\"); \n    }\n    \n    // 只初始化了一个 i\n    for (int i = 0; i < 4; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(1)\npublic static void test2(int n) {\n    // 只初始化了一个 i\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test10(int n) {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    int[] array = new int[n]; // 申请大小为n的空间\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i] + c);\n    }\n}\n```\n\n# 例一的时间复杂度\n```\n// O(2^n)\npublic static int fib1(int n) {\n    if (n <= 1) return n;\n    return fib1(n - 1) + fib1(n - 2);\n}\n\n// O(n)\npublic static int fib2(int n) {\n    if (n <= 1) return n;\n    \n    int first = 0;\n    int second = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = first + second;\n        first = second;\n        second = sum;\n    }\n    return second;\n}\n```\n\n在 fib1 中，如果 n = 5，那么结果就是：1 + 2 + 4 + 8 = 2^0 + 2^1 + 2^2 + 2^3 = 2^4 - 1，即 fib1(n) = 2^(n-1) - 1 = 0.5 * 2^n - 1，所以 fib1(n) 的复杂度为 O(2^n)。\n![复杂度04](复杂度/复杂度04.png)\n\n使用[函数图像绘制工具](https://zh.numberempire.com/graphingcalculator.php)绘制 `n,2^n`：\n![复杂度05](复杂度/复杂度05.png)\n\n可以看出 fib1(n) 和 fib2(n) 的差别很大，如果有一台1GHz的普通计算机，运算速度为10^9次每秒，让 n = 64，那么：  \nO(n)大约耗时6.4 * 10^-8秒  \nO(2^n)大约耗时584.94年\n\nfib2 补充一：\n```\n// O(n)\npublic static int fib2(int N) {\n    if (N <= 1) return N;\n\n    int first = 0;\n    int second = 1;\n    while(N-- > 1) {\n        second += first;\n        first = second - first;\n    }\n    return second;\n}\n```\n\nfib2 补充二：使用斐波那契公式\n![复杂度06](复杂度/复杂度06.png)\n```\n// O(1)\npublic static int fib2(int N) {\n    double c = Math.sqrt(5); // 根号5\n    return (int)((Math.pow((1 + c) / 2, N) - Math.pow((1 - c) / 2, N)) / c);\n}\n```\n\n👉 注意：这里是假定 sqrt 和 pow 的时间复杂度都是 O(1) 的前提下，得出 fib3 的时间复杂度是 O(1)。实际情况还得根据使用的 sqrt 和 pow 的真实时间复杂度而定，比如有些 pow 实现的真实复杂度是 O(logn)。\n\n# 算法的优化方向\n\n* 用尽量稍等存储空间\n* 用尽量少的执行步骤\n* 空间换时间\n* 时间换空间\n\nps：  \n[leetcode](https://leetcode-cn.com/)\n[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)","source":"_posts/数据结构与算法/复杂度.md","raw":"---\ntitle: 复杂度\ndate: 2020-10-09 10:27:38\ntags: 数据结构与算法\n---\n\n斐波那契数 & 算法的评估 & 时间复杂度的估算 & 大O表示法 & 斐波那契数复杂度分析\n<!-- more -->\n\n# 算法\n[算法](https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025?fr=aladdin)是用于解决特定问题的一系列的执行步骤。如：  \n```\n// 计算a跟b的和\npublic static int plus(int a, int b) {\n    return a + b;\n}\n\n// 计算1+2+3+...+n的和\npublic static int sum(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; i++) {\n        result += i;\n    }\n    return result;\n}\n```\n\n# 例一\n使用不同的算法解决同一个问题，效率可能相差非常大。如：求第n个斐波那契数。\n\n👉 斐波那契数列又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。\n\n方式一：\n```\npublic static int fib1(int n) {\n    if (n <= 1) return n;\n    return fib1(n - 1) + fib1(n - 2);\n}\n\npublic static void main(String[] args) {\n    System.out.println(fib1(1));\n    System.out.println(fib1(2));\n    System.out.println(fib1(3));\n    System.out.println(fib1(4));\n    System.out.println(fib1(64));\n}\n```\n\n打印结果：\n```\n1\n1\n2\n3\n```\n\n从打印结果可以看到，第1、2、3、4个斐波那契数能够正常打印，而第64个斐波那契数却无法正常打印。\n\n方式二：\n```\n/*\n* 下标：0 1 2 3 4 5 6 7\n* 数值：0 1 1 2 3 5 8 13 ...\n*/\npublic static int fib2(int n) {\n    if (n <= 1) return n;\n    \n    int first = 0;\n    int second = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = first + second;\n        first = second;\n        second = sum;\n    }\n    return second;\n}\n\npublic static void main(String[] args) {\n    System.out.println(fib2(64));\n}\n```\n\n打印结果：\n```\n695895453\n```\n\n# 算法的评估\n## 事后统计法\n如果单从执行效率上进行评估，可以比较不同算法对同一组输入的执行处理时间，这种方案也叫作：事后统计法。\n\n* 优点：\n  从执行处理时间可以直观的看出来算法的优劣；\n* 缺点：\n  执行时间严重依赖硬件以及运行时葛总不确定的环境因素；\n  必须编写相应的测算代码（Times）；\n  测试数据的选择比较难保证公正性；\n\n使用自定义工具 Times 查看两种实现方式的执行时间：\n```\npublic static void main(String[] args) {\n    int n = 44;\n\n    Times.test(\"fib1\", new Task() {\n        public void execute() {\n            System.out.println(fib1(n));\n        }\n    });\n\n    Times.test(\"fib2\", new Task() {\n        public void execute() {\n            System.out.println(fib2(n));\n        }\n    });\n}\n```\n\n打印结果：\n```\n695895453\n【fib1】\n开始：17:58:32.163\n-298632863\n结束：17:59:19.046\n耗时：46.883秒\n-------------------------------------\n【fib2】\n开始：17:59:19.047\n-1109825406\n结束：17:59:19.047\n耗时：0.0秒\n-------------------------------------\n```\n\n从打印结果可以看到，fib1 是非常耗时的，而 fib2 在同样的数据条件下，执行时间基本为0。\n\n## 算法的优劣\n一般从以下维度评估算法的优劣：  \n* 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）。\n* 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）。\n* 空间复杂度（space complexity）：估算所需占用的存储空间。\n\n# 时间复杂度\n[时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/5930669?fromtitle=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&fromid=1894057&fr=aladdin)：在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n\n## 大O表示法\n一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度。  \n\n[大O表示法](https://baike.baidu.com/item/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/1851162?fr=aladdin)：算法的时间复杂度通常用大O符号表述，定义为T[n] = O(f(n))。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”。\n\n使用大O表示法时会忽略常数、系数、低阶，如：\n```\n9 >> O(1)\n2*n + 3 >> O(n)\nn^2 + 2n + 6 >> O(n^2)\n4*n^3 + 3*n^2 + 22*n + 100 >> O(n^3)\n```\n\n👉 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率。\n\n对数：`8 = 2^3  ->  3 = log2(8)`、`16 = 2^4  ->  4 = log2(16)`\n\n对数阶的细节：  \n对数阶一般省略底数，如：`log2(n) = log2(9) * log9(n)`，省略常数项后就是 `log2(n) = log9(n)`，所以 log2(n)、log9(n) 统称为 logn。\n\n示例：\n```\n// O(1)\npublic static void test1(int n) {\n    // 1\n    if (n > 10) { \n        System.out.println(\"n > 10\");\n    } else if (n > 5) { // 2\n        System.out.println(\"n > 5\");\n    } else {\n        System.out.println(\"n <= 5\"); \n    }\n    \n    // 1 + 4 + 4 + 4\n    for (int i = 0; i < 4; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test2(int n) {\n    // 1 + 3n\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test3(int n) {\n    // 1 + 2n + n * (1 + 3n)\n    // 1 + 2n + n + 3n^2\n    // 3n^2 + 3n + 1\n    // O(n^2)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n\n// O(n)\npublic static void test4(int n) {\n    // 1 + 2n + n * (1 + 45)\n    // 1 + 2n + 46n\n    // 48n + 1\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 15; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n\n/* 对数\n *  8 = 2^3  ->  3 = log2(8)\n * 16 = 2^4  ->  4 = log2(16)\n */\n\n// O(logn)\npublic static void test5(int n) {\n    // log2(n)\n    while ((n = n / 2) > 0) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(logn + nlogn) -> O(logn)\npublic static void test6(int n) {\n    // log5(n)\n    while ((n = n / 5) > 0) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(nlogn)\npublic static void test7(int n) {\n    // 1 + 2*log2(n) + log2(n) * (1 + 3n)\n    // 1 + 3*log2(n) + 2 * nlog2(n)\n    for (int i = 1; i < n; i = i * 2) {\n        // 1 + 3n\n        for (int j = 0; j < n; j++) {\n            System.out.println(\"test\");\n        }\n    }\n}\n```\n\n## 常见的复杂度  \nO(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)\n![复杂度01](复杂度/复杂度01.png)\n\n使用[函数图像绘制工具](https://zh.numberempire.com/graphingcalculator.php)绘制 `log(n),n,n*log(n),n^2,n^3,2^n`：\n\n数据规模比较小时\n![复杂度02](复杂度/复杂度02.png)\n数据规模比较大时\n![复杂度03](复杂度/复杂度03.png)\n\n## 多个数据规模的情况\n```\n// O(n + k)\npublic static void test(int n, int k) {\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n    \n    for (int i = 0; i < k; i++) {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 空间复杂度\n```\n// O(1)\npublic static void test1(int n) {\n    if (n > 10) { \n        System.out.println(\"n > 10\");\n    } else if (n > 5) { // 2\n        System.out.println(\"n > 5\");\n    } else {\n        System.out.println(\"n <= 5\"); \n    }\n    \n    // 只初始化了一个 i\n    for (int i = 0; i < 4; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(1)\npublic static void test2(int n) {\n    // 只初始化了一个 i\n    for (int i = 0; i < n; i++) {\n        System.out.println(\"test\");\n    }\n}\n\n// O(n)\npublic static void test10(int n) {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    int[] array = new int[n]; // 申请大小为n的空间\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i] + c);\n    }\n}\n```\n\n# 例一的时间复杂度\n```\n// O(2^n)\npublic static int fib1(int n) {\n    if (n <= 1) return n;\n    return fib1(n - 1) + fib1(n - 2);\n}\n\n// O(n)\npublic static int fib2(int n) {\n    if (n <= 1) return n;\n    \n    int first = 0;\n    int second = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = first + second;\n        first = second;\n        second = sum;\n    }\n    return second;\n}\n```\n\n在 fib1 中，如果 n = 5，那么结果就是：1 + 2 + 4 + 8 = 2^0 + 2^1 + 2^2 + 2^3 = 2^4 - 1，即 fib1(n) = 2^(n-1) - 1 = 0.5 * 2^n - 1，所以 fib1(n) 的复杂度为 O(2^n)。\n![复杂度04](复杂度/复杂度04.png)\n\n使用[函数图像绘制工具](https://zh.numberempire.com/graphingcalculator.php)绘制 `n,2^n`：\n![复杂度05](复杂度/复杂度05.png)\n\n可以看出 fib1(n) 和 fib2(n) 的差别很大，如果有一台1GHz的普通计算机，运算速度为10^9次每秒，让 n = 64，那么：  \nO(n)大约耗时6.4 * 10^-8秒  \nO(2^n)大约耗时584.94年\n\nfib2 补充一：\n```\n// O(n)\npublic static int fib2(int N) {\n    if (N <= 1) return N;\n\n    int first = 0;\n    int second = 1;\n    while(N-- > 1) {\n        second += first;\n        first = second - first;\n    }\n    return second;\n}\n```\n\nfib2 补充二：使用斐波那契公式\n![复杂度06](复杂度/复杂度06.png)\n```\n// O(1)\npublic static int fib2(int N) {\n    double c = Math.sqrt(5); // 根号5\n    return (int)((Math.pow((1 + c) / 2, N) - Math.pow((1 - c) / 2, N)) / c);\n}\n```\n\n👉 注意：这里是假定 sqrt 和 pow 的时间复杂度都是 O(1) 的前提下，得出 fib3 的时间复杂度是 O(1)。实际情况还得根据使用的 sqrt 和 pow 的真实时间复杂度而定，比如有些 pow 实现的真实复杂度是 O(logn)。\n\n# 算法的优化方向\n\n* 用尽量稍等存储空间\n* 用尽量少的执行步骤\n* 空间换时间\n* 时间换空间\n\nps：  \n[leetcode](https://leetcode-cn.com/)\n[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)","slug":"数据结构与算法/复杂度","published":1,"updated":"2023-08-22T09:52:14.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmguz002gaq7k25huq6n7"},{"title":"栈","date":"2020-10-30T03:53:52.000Z","_content":"\n[栈（stack）](https://baike.baidu.com/item/%E6%A0%88/12808149?fr=aladdin)又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n<!-- more -->\n\n# 栈\n栈是一种特殊的线性表，智能在一端进行操作：  \n往栈中添加元素的操作，一般叫做 push，入栈；  \n从栈中移除元素的操作，一般叫做 pop，出栈（只能移除站定元素，也叫做：弹出栈顶元素）；  \n后进先出的原则，Last In First Out ~ LIFO。  \n\n![栈01](栈/栈01.png)\n\n## 接口设计\n```\npublic class Stack<E> {\n\t/*\n\t * 清空\n\t */\n\tpublic void clear() {\n\t\t\n\t}\n\t/*\n\t * 大小\n\t */\n\tpublic int size() {\n\t\treturn 0;\n\t}\n\t/*\n\t * 判空\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn false;\n\t}\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\t\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn null;\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn null;\n\t}\n}\n```\n\n因为动态数组和双向链表在添加删除随后一个元素的复杂度都是 O(1) 级别，所以这两种数据结构都可以用来实现栈。下面是采用动态数组实现的栈。\n![栈02](栈/栈02.png)\n\n## 实现-继承\n采用继承的方式实现栈，继承 ArrayList 实现：\n```\nimport com.yq.list.ArrayList;\n\npublic class Stack<E> extends ArrayList<E>{\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\tadd(element);\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn remove(size-1);\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn get(size-1);\n\t}\n}\n```\n\n`clear()`、`size()`和`isEmpty()` 父类已经实现了。\n\n测试：\n```\npublic static void main(String[] args) {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.push(4);\n\t\n\twhile (!stack.isEmpty()) {\n\t\tSystem.out.println(stack.pop());\n\t}\n}\n```\n\n打印结果：\n```\n4\n3\n2\n1\n```\n\n继承可以实现栈的效果，但是却存在一个问题：stack 可以访问到 ArrayList 所有的开放接口，`stack.add()`、`stack.remove()` 等。解决方案👇。\n\n## 实现-组合\n采用组合的方式实现栈，实现：\n```\npublic class Stack2<E> {\n\tArrayList<E> list = new ArrayList<>();\n\t/*\n\t * 清空\n\t */\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\t/*\n\t * 大小\n\t */\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\t/*\n\t * 判空\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\tlist.add(element);\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn list.remove(list.size()-1);\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn list.get(list.size()-1);\n\t}\n}\n```\n\n测试：\n```\nstatic void testStack2() {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.push(4);\n\t\n\twhile (!stack.isEmpty()) {\n\t\tSystem.out.println(stack.pop());\n\t}\n}\n\npublic static void main(String[] args) {\n\ttestStack2();\n}\n```\n\n打印结果：\n```\n4\n3\n2\n1\n```\n\n## 应用\n游览器的前进和后退就是通过栈来实现的：\n\n依次访问 jd.com、qq.com 和 baidu.com：\n![栈03](栈/栈03.png)\n后退\n![栈04](栈/栈04.png)\n后退\n![栈05](栈/栈05.png)\n前进\n![栈06](栈/栈06.png)\n访问 taobao.com\n![栈07](栈/栈07.png)\n\n类似场景：软件的撤销、恢复功能。\n\n## 源码分析\nStack 继承自 Vector，Vector 也是动态数组，相较于 ArrayList，Vector 是线程安全的。\n```\npublic class Stack<E> extends Vector<E> {\n\t/**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * <blockquote><pre>\n     * addElement(item)</pre></blockquote>\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the {@code item} argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the {@code Vector} object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the {@code Vector} object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  {@code true} if and only if this stack contains\n     *          no items; {@code false} otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n\t...\n}\n```\n\n# 练习\n## 有效的括号\n[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n1. 遇见左字符，将左字符入栈；\n2. 遇见右字符：  \n   如果展示空的，说明括号无效；  \n   如果站不为空，将栈顶字符出出栈，与右字符匹配：  \n   -> 如果左右字符不匹配 -> 括号无效；  \n   -> 如果左右字符匹配 -> 继续扫描下一个字符；\n3. 所有字符扫描完毕后：  \n   栈为空 -> 括号有效；  \n   栈不为空 -> 括号无效；\n```\npublic boolean isValid(String s) {\n\tStack<Character> stack = new Stack<>();\n\t\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tchar c = s.charAt(i);\n\t\tif (c == '(' || c == '[' || c == '{') {\n\t\t\tstack.push(c);\n\t\t} else {\n\t\t\tif (stack.isEmpty()) return false;\n\t\t\t\n\t\t\tchar left = stack.pop();\n\t\t\tif (left == '(' && c != ')') return false;\n\t\t\tif (left == '[' && c != ']') return false;\n\t\t\tif (left == '{' && c != '}') return false;\n\t\t}\t\n\t}\n\t\n\treturn stack.isEmpty();\n}\n```\n\n## 括号的分数\n[856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)  \n[括号的分数 - 方法二：栈](https://leetcode-cn.com/problems/score-of-parentheses/solution/gua-hao-de-fen-shu-fang-fa-er-zhan-by-yang-h6/)\n```\n/*\n * ()、(()(、()( 对于只有一层括号的情况，top == 0：\n * 1. 取出 top = pop();\n * 2. 修改 top = 1，并 push(top);\n * 3. 判断前一项是否可加\n *  \n * 示例：\n * ( : [0] ~> () : [1] \n * (()( : [0, 1, 0] ~> (()() : [0, 2]\n * ()(：[1, 0] ~> ()()：[2]\n */\n /* \n * (())、(()()) 对于外层有括号的情况，top != 0：\n * 1. 取出 top = pop();\n * 2. 修改 top *=2，并 push(top);\n * 3. 判断前一项是否可加；\n * \n * 示例：\n * (() : [0, 1] ~> (()) : [2]\n * (()() : [0, 1, 1] ~> (()()) : [4]\n * (()(( : [0, 1, 0, 0] ~> (()(() : [0, 1, 1]\n */\nstatic int scoreOfParentheses6(String S) {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(0);\n\tfor (char c : S.toCharArray()) {\n\t\tif (c == '(') {\n\t\t\tstack.push(0);\n\t\t} else {\n\t\t\tint top = stack.pop();\n\t\t\tint left = stack.pop();\n\t\t\tstack.push(left + Math.max(2 * top, 1));\n\t\t}\n\t}\n\treturn stack.pop();\n}\n```\n\n## 逆波兰表达式求值\n[逆波兰表达式](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/9841727?fr=aladdin)\n![栈08](栈/栈08.png)\n[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n```\nstatic int evalRPN(String[] tokens) {\n\tStack<Integer> stack = new Stack<>(); \n\tfor (String s : tokens) {\n\t\tif (s == \"+\") {\n\t\t\tstack.push(stack.pop() + stack.pop());\n\t\t} else if (s == \"-\") {\n\t\t\tstack.push(-(stack.pop() - stack.pop()));\n\t\t} else if (s == \"*\") {\n\t\t\tstack.push(stack.pop() * stack.pop());\n\t\t} else if (s == \"/\") {\n\t\t\tInteger s1 = stack.pop();\n\t\t\tstack.push(stack.pop() / s1);\n\t\t} else {\n\t\t\tstack.push(Integer.valueOf(s));\n\t\t}\n\t}\n\treturn stack.pop();\n}\n```\n\nps：  \n[前缀表达式](https://baike.baidu.com/item/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F)  \n[中缀表达式](https://baike.baidu.com/item/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F)  \n[后缀表达式](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437?fromtitle=%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&fromid=6160580)\n## 基本计算器\n[224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)\n```\nstatic int calculate(String s) {\n\tStack<Integer> stack = new Stack<>();\n\tint res = 0;\n\tint operand = 0; //位数\n\tint sign = 1; //+：1，-：-1\n\t\n\tfor (char c : s.toCharArray()) {\n\t\tif (c == ' ')\n\t\t\tcontinue;\n\t\t\n\t\tif (c >= '0' && c <= '9') {\n\t\t\toperand = operand*10 + (c - '0');\n\t\t} else if (c == '+' || c == '-') {\n\t\t\tres += operand*sign;\n\t\t\toperand = 0; // 重置位数\n\t\t\tsign = c == '+' ? 1 : -1; // 重置符号\n\t\t\t\n\t\t} else if (c == '(') {\n\t\t\tstack.push(res);\n\t\t\tstack.push(sign);\n\t\t\tres = 0;\n\t\t\tsign = 1;\n\t\t} else { // c == ')'\n\t\t\tres += operand*sign;\n\t\t\toperand = 0;\n\t\t\t\n\t\t\tint a = stack.pop(); //上一次的 sign\n\t\t\tint b = stack.pop(); //上一次的 sum\n\t\t\t\n\t\t\tres += b*a;\n\t\t}\n\t}\n\treturn res + sign * operand;\n}\n```\n\n","source":"_posts/数据结构与算法/栈.md","raw":"---\ntitle: 栈\ndate: 2020-10-30 11:53:52\ntags: 数据结构与算法\n---\n\n[栈（stack）](https://baike.baidu.com/item/%E6%A0%88/12808149?fr=aladdin)又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n<!-- more -->\n\n# 栈\n栈是一种特殊的线性表，智能在一端进行操作：  \n往栈中添加元素的操作，一般叫做 push，入栈；  \n从栈中移除元素的操作，一般叫做 pop，出栈（只能移除站定元素，也叫做：弹出栈顶元素）；  \n后进先出的原则，Last In First Out ~ LIFO。  \n\n![栈01](栈/栈01.png)\n\n## 接口设计\n```\npublic class Stack<E> {\n\t/*\n\t * 清空\n\t */\n\tpublic void clear() {\n\t\t\n\t}\n\t/*\n\t * 大小\n\t */\n\tpublic int size() {\n\t\treturn 0;\n\t}\n\t/*\n\t * 判空\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn false;\n\t}\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\t\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn null;\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn null;\n\t}\n}\n```\n\n因为动态数组和双向链表在添加删除随后一个元素的复杂度都是 O(1) 级别，所以这两种数据结构都可以用来实现栈。下面是采用动态数组实现的栈。\n![栈02](栈/栈02.png)\n\n## 实现-继承\n采用继承的方式实现栈，继承 ArrayList 实现：\n```\nimport com.yq.list.ArrayList;\n\npublic class Stack<E> extends ArrayList<E>{\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\tadd(element);\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn remove(size-1);\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn get(size-1);\n\t}\n}\n```\n\n`clear()`、`size()`和`isEmpty()` 父类已经实现了。\n\n测试：\n```\npublic static void main(String[] args) {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.push(4);\n\t\n\twhile (!stack.isEmpty()) {\n\t\tSystem.out.println(stack.pop());\n\t}\n}\n```\n\n打印结果：\n```\n4\n3\n2\n1\n```\n\n继承可以实现栈的效果，但是却存在一个问题：stack 可以访问到 ArrayList 所有的开放接口，`stack.add()`、`stack.remove()` 等。解决方案👇。\n\n## 实现-组合\n采用组合的方式实现栈，实现：\n```\npublic class Stack2<E> {\n\tArrayList<E> list = new ArrayList<>();\n\t/*\n\t * 清空\n\t */\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\t/*\n\t * 大小\n\t */\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\t/*\n\t * 判空\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t/*\n\t * 入栈\n\t */\n\tpublic void push(E element) {\n\t\tlist.add(element);\n\t}\n\t/*\n\t * 出栈\n\t */\n\tpublic E pop() {\n\t\treturn list.remove(list.size()-1);\n\t}\n\t/*\n\t * 获取顶部元素\n\t */\n\tpublic E top() {\n\t\treturn list.get(list.size()-1);\n\t}\n}\n```\n\n测试：\n```\nstatic void testStack2() {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.push(4);\n\t\n\twhile (!stack.isEmpty()) {\n\t\tSystem.out.println(stack.pop());\n\t}\n}\n\npublic static void main(String[] args) {\n\ttestStack2();\n}\n```\n\n打印结果：\n```\n4\n3\n2\n1\n```\n\n## 应用\n游览器的前进和后退就是通过栈来实现的：\n\n依次访问 jd.com、qq.com 和 baidu.com：\n![栈03](栈/栈03.png)\n后退\n![栈04](栈/栈04.png)\n后退\n![栈05](栈/栈05.png)\n前进\n![栈06](栈/栈06.png)\n访问 taobao.com\n![栈07](栈/栈07.png)\n\n类似场景：软件的撤销、恢复功能。\n\n## 源码分析\nStack 继承自 Vector，Vector 也是动态数组，相较于 ArrayList，Vector 是线程安全的。\n```\npublic class Stack<E> extends Vector<E> {\n\t/**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * <blockquote><pre>\n     * addElement(item)</pre></blockquote>\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the {@code item} argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the {@code Vector} object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the {@code Vector} object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  {@code true} if and only if this stack contains\n     *          no items; {@code false} otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n\t...\n}\n```\n\n# 练习\n## 有效的括号\n[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n1. 遇见左字符，将左字符入栈；\n2. 遇见右字符：  \n   如果展示空的，说明括号无效；  \n   如果站不为空，将栈顶字符出出栈，与右字符匹配：  \n   -> 如果左右字符不匹配 -> 括号无效；  \n   -> 如果左右字符匹配 -> 继续扫描下一个字符；\n3. 所有字符扫描完毕后：  \n   栈为空 -> 括号有效；  \n   栈不为空 -> 括号无效；\n```\npublic boolean isValid(String s) {\n\tStack<Character> stack = new Stack<>();\n\t\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tchar c = s.charAt(i);\n\t\tif (c == '(' || c == '[' || c == '{') {\n\t\t\tstack.push(c);\n\t\t} else {\n\t\t\tif (stack.isEmpty()) return false;\n\t\t\t\n\t\t\tchar left = stack.pop();\n\t\t\tif (left == '(' && c != ')') return false;\n\t\t\tif (left == '[' && c != ']') return false;\n\t\t\tif (left == '{' && c != '}') return false;\n\t\t}\t\n\t}\n\t\n\treturn stack.isEmpty();\n}\n```\n\n## 括号的分数\n[856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)  \n[括号的分数 - 方法二：栈](https://leetcode-cn.com/problems/score-of-parentheses/solution/gua-hao-de-fen-shu-fang-fa-er-zhan-by-yang-h6/)\n```\n/*\n * ()、(()(、()( 对于只有一层括号的情况，top == 0：\n * 1. 取出 top = pop();\n * 2. 修改 top = 1，并 push(top);\n * 3. 判断前一项是否可加\n *  \n * 示例：\n * ( : [0] ~> () : [1] \n * (()( : [0, 1, 0] ~> (()() : [0, 2]\n * ()(：[1, 0] ~> ()()：[2]\n */\n /* \n * (())、(()()) 对于外层有括号的情况，top != 0：\n * 1. 取出 top = pop();\n * 2. 修改 top *=2，并 push(top);\n * 3. 判断前一项是否可加；\n * \n * 示例：\n * (() : [0, 1] ~> (()) : [2]\n * (()() : [0, 1, 1] ~> (()()) : [4]\n * (()(( : [0, 1, 0, 0] ~> (()(() : [0, 1, 1]\n */\nstatic int scoreOfParentheses6(String S) {\n\tStack<Integer> stack = new Stack<>();\n\tstack.push(0);\n\tfor (char c : S.toCharArray()) {\n\t\tif (c == '(') {\n\t\t\tstack.push(0);\n\t\t} else {\n\t\t\tint top = stack.pop();\n\t\t\tint left = stack.pop();\n\t\t\tstack.push(left + Math.max(2 * top, 1));\n\t\t}\n\t}\n\treturn stack.pop();\n}\n```\n\n## 逆波兰表达式求值\n[逆波兰表达式](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/9841727?fr=aladdin)\n![栈08](栈/栈08.png)\n[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n```\nstatic int evalRPN(String[] tokens) {\n\tStack<Integer> stack = new Stack<>(); \n\tfor (String s : tokens) {\n\t\tif (s == \"+\") {\n\t\t\tstack.push(stack.pop() + stack.pop());\n\t\t} else if (s == \"-\") {\n\t\t\tstack.push(-(stack.pop() - stack.pop()));\n\t\t} else if (s == \"*\") {\n\t\t\tstack.push(stack.pop() * stack.pop());\n\t\t} else if (s == \"/\") {\n\t\t\tInteger s1 = stack.pop();\n\t\t\tstack.push(stack.pop() / s1);\n\t\t} else {\n\t\t\tstack.push(Integer.valueOf(s));\n\t\t}\n\t}\n\treturn stack.pop();\n}\n```\n\nps：  \n[前缀表达式](https://baike.baidu.com/item/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F)  \n[中缀表达式](https://baike.baidu.com/item/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F)  \n[后缀表达式](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437?fromtitle=%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&fromid=6160580)\n## 基本计算器\n[224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)\n```\nstatic int calculate(String s) {\n\tStack<Integer> stack = new Stack<>();\n\tint res = 0;\n\tint operand = 0; //位数\n\tint sign = 1; //+：1，-：-1\n\t\n\tfor (char c : s.toCharArray()) {\n\t\tif (c == ' ')\n\t\t\tcontinue;\n\t\t\n\t\tif (c >= '0' && c <= '9') {\n\t\t\toperand = operand*10 + (c - '0');\n\t\t} else if (c == '+' || c == '-') {\n\t\t\tres += operand*sign;\n\t\t\toperand = 0; // 重置位数\n\t\t\tsign = c == '+' ? 1 : -1; // 重置符号\n\t\t\t\n\t\t} else if (c == '(') {\n\t\t\tstack.push(res);\n\t\t\tstack.push(sign);\n\t\t\tres = 0;\n\t\t\tsign = 1;\n\t\t} else { // c == ')'\n\t\t\tres += operand*sign;\n\t\t\toperand = 0;\n\t\t\t\n\t\t\tint a = stack.pop(); //上一次的 sign\n\t\t\tint b = stack.pop(); //上一次的 sum\n\t\t\t\n\t\t\tres += b*a;\n\t\t}\n\t}\n\treturn res + sign * operand;\n}\n```\n\n","slug":"数据结构与算法/栈","published":1,"updated":"2023-08-22T09:52:14.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv0002iaq7khza5fryu"},{"title":"环境搭建","date":"2020-09-29T06:33:46.000Z","_content":"\nJSK & Eclipse\n<!-- more -->\n\n# JDK\n## 下载 JDK\n下载地址：[JDK](https://www.oracle.com/java/technologies/javase-downloads.html)  \n👇\n![环境搭建01](环境搭建/环境搭建01.png)\n👇\n![环境搭建02](环境搭建/环境搭建02.png)\n\n## 安装 JDK\n双击下载好的 jdk-14.0.2_osx-x64_bin.dmg，进行安装。  \n👇（继续 -> 安装 -> 关闭）\n![环境搭建03](环境搭建/环境搭建03.png)\n👇 查看安装路径。\n![环境搭建04](环境搭建/环境搭建04.png)\n👇 在终端输入 `java -version` 查看 java 的版本信息，安装完成。\n![环境搭建05](环境搭建/环境搭建05.png)\n\n# Eclipse\n## 下载 Eclipse\n下载地址：[Eclipse](https://www.eclipse.org/downloads/)  \n👇 选择其他类型的下载包。\n![环境搭建06](环境搭建/环境搭建06.png)\n👇\n![环境搭建07](环境搭建/环境搭建07.png)\n👇 修改下载地址。\n![环境搭建08](环境搭建/环境搭建08.png)\n👇 选择国内的下载地址，稍等片刻，下载完成。\n![环境搭建08](环境搭建/环境搭建09.png)\n\n## 安装 Eclipse\n双击下载好的 eclipse-java-2020-09-R-macosx-cocoa-x86_64.dmg，进行安装。\n\n## 运行 Eclipse\n👇 设置工作空间（存放代码的文件），勾选了默认工作空间后，在下次启动时会默认使用本次设置的工作空间，就不会弹出这个对话框了。\n![环境搭建10](环境搭建/环境搭建10.png)\n👇 进入工作台。\n![环境搭建11](环境搭建/环境搭建11.png)\n👇 去掉不常用的工具栏。Outline 是 .java 类的接口列表（Window -> Show View -> Outline）。\n![环境搭建12](环境搭建/环境搭建12.png)\n👇 添加日志控制台 Console（Window -> Show View -> Console）。\n![环境搭建13](环境搭建/环境搭建13.png)\n\n## 创建项目\n方式一：File -> New -> Java Project\n![环境搭建14](环境搭建/环境搭建14.png) \n方式二：Create a Java Project\n![环境搭建15](环境搭建/环境搭建15.png) \n👇\n![环境搭建16](环境搭建/环境搭建16.png) \n👇\n![环境搭建17](环境搭建/环境搭建17.png) \n👇 src 是 source 的意思，用来存放代码。右键创建 Class。\n![环境搭建18](环境搭建/环境搭建18.png) \n👇 设置 Class 的名称，勾选辅助生成 `main()` 方法。\n![环境搭建19](环境搭建/环境搭建19.png)\n👇 在新创建的 MyClass.java 文件里添加代码 `System.out.println(\"Hello World!\");`，文件上方会出现一个 `*`，使用 `command + s` 保存后，`*` 会自动消失。双击红框出的导航栏可以放大缩小代码区域。\n![环境搭建20](环境搭建/环境搭建20.png) \n👇 如果没有保存直接运行会出现这个对话框，勾选 Always save resources before launching 会在运行程序前自动保存。\n![环境搭建23](环境搭建/环境搭建23.png)  \n👇 运行程序：右击 -> Run As -> Java Application。\n![环境搭建21](环境搭建/环境搭建21.png) \n\n## 切换工作空间\nFile -> Switch Workspace -> others\n![环境搭建24](环境搭建/环境搭建24.png) \n👇 选择新的工作空间\n![环境搭建25](环境搭建/环境搭建25.png) \n\n## 修改字体\nEclipse -> Preference -> General -> Appearance -> Colors and Fonts -> Basic -> Text Font -> Edit\n![环境搭建22](环境搭建/环境搭建22.png) \n\n## 设置文件编码为 UTF-8\n文件编码如果设置错误的话可能会导致文字显示乱码，UTF-8 几乎覆盖了世界上所有的文字。\n\nEclipse -> Preference -> General -> Content Types -> Text\n![环境搭建26](环境搭建/环境搭建26.png) \n\n## 新建项目\n👇 关闭项目\n![环境搭建27](环境搭建/环境搭建27.png) \n👇 新建项目（右键 -> New -> Java Project）\n![环境搭建28](环境搭建/环境搭建28.png) \n👇\n![环境搭建29](环境搭建/环境搭建29.png) \n👇\n![环境搭建30](环境搭建/环境搭建30.png) \n\n## 删除项目\n选中文件 -> 右键 -> Delete。如果勾选了 Delete project contents on disk 会将工作空间里的文件也删除掉。\n![环境搭建31](环境搭建/环境搭建31.png) \n\n## 导入项目\n方式一：  \nFile -> Import  \n方式二：  \n👇 点击 Import projects\n![环境搭建32](环境搭建/环境搭建32.png) \n👇 选中 General -> Existing Projects into Workspace\n![环境搭建33](环境搭建/环境搭建33.png) \n👇 点击 Browse 找到要添加的项目。完成。\n![环境搭建34](环境搭建/环境搭建34.png) \n\n## 增强代码提示\nEclipse -> Preference -> Java -> Editor -> Content Assist -> Auto Activation -> Auto activation triggers for Java:\n\n添加下面这段内容：\n```\n.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n```\n![环境搭建35](环境搭建/环境搭建35.png) \n\n## 断点调试\n1. 双击边栏添加断点；\n2. 点击调试；\n![环境搭建36](环境搭建/环境搭建36.png) \n\nps：\n\n代码对齐：`command + shift + F`\n生成代码：`alt + command + s`。如：选择 `Generate Constructor use Fields` 生成指定成员变量的构造方法：\n```\npublic class Person {\n\tprivate int age;\n\tprivate String name;\n\t// 构造方法\n\tpublic Person(int age, String name) {\n\t\tsuper();\n\t\tthis.age = age;\n\t\tthis.name = name;\n\t}\n}\n```\n\n选择 `Generate toString()` 生成 `toString()` 方法：\n```\npublic String toString() {\n\treturn \"Person [age=\" + age + \", name=\" + name + \"]\";\n}\n```\n\n\n\n\n","source":"_posts/数据结构与算法/环境搭建.md","raw":"---\ntitle: 环境搭建\ndate: 2020-09-29 14:33:46\ntags: 数据结构与算法\n---\n\nJSK & Eclipse\n<!-- more -->\n\n# JDK\n## 下载 JDK\n下载地址：[JDK](https://www.oracle.com/java/technologies/javase-downloads.html)  \n👇\n![环境搭建01](环境搭建/环境搭建01.png)\n👇\n![环境搭建02](环境搭建/环境搭建02.png)\n\n## 安装 JDK\n双击下载好的 jdk-14.0.2_osx-x64_bin.dmg，进行安装。  \n👇（继续 -> 安装 -> 关闭）\n![环境搭建03](环境搭建/环境搭建03.png)\n👇 查看安装路径。\n![环境搭建04](环境搭建/环境搭建04.png)\n👇 在终端输入 `java -version` 查看 java 的版本信息，安装完成。\n![环境搭建05](环境搭建/环境搭建05.png)\n\n# Eclipse\n## 下载 Eclipse\n下载地址：[Eclipse](https://www.eclipse.org/downloads/)  \n👇 选择其他类型的下载包。\n![环境搭建06](环境搭建/环境搭建06.png)\n👇\n![环境搭建07](环境搭建/环境搭建07.png)\n👇 修改下载地址。\n![环境搭建08](环境搭建/环境搭建08.png)\n👇 选择国内的下载地址，稍等片刻，下载完成。\n![环境搭建08](环境搭建/环境搭建09.png)\n\n## 安装 Eclipse\n双击下载好的 eclipse-java-2020-09-R-macosx-cocoa-x86_64.dmg，进行安装。\n\n## 运行 Eclipse\n👇 设置工作空间（存放代码的文件），勾选了默认工作空间后，在下次启动时会默认使用本次设置的工作空间，就不会弹出这个对话框了。\n![环境搭建10](环境搭建/环境搭建10.png)\n👇 进入工作台。\n![环境搭建11](环境搭建/环境搭建11.png)\n👇 去掉不常用的工具栏。Outline 是 .java 类的接口列表（Window -> Show View -> Outline）。\n![环境搭建12](环境搭建/环境搭建12.png)\n👇 添加日志控制台 Console（Window -> Show View -> Console）。\n![环境搭建13](环境搭建/环境搭建13.png)\n\n## 创建项目\n方式一：File -> New -> Java Project\n![环境搭建14](环境搭建/环境搭建14.png) \n方式二：Create a Java Project\n![环境搭建15](环境搭建/环境搭建15.png) \n👇\n![环境搭建16](环境搭建/环境搭建16.png) \n👇\n![环境搭建17](环境搭建/环境搭建17.png) \n👇 src 是 source 的意思，用来存放代码。右键创建 Class。\n![环境搭建18](环境搭建/环境搭建18.png) \n👇 设置 Class 的名称，勾选辅助生成 `main()` 方法。\n![环境搭建19](环境搭建/环境搭建19.png)\n👇 在新创建的 MyClass.java 文件里添加代码 `System.out.println(\"Hello World!\");`，文件上方会出现一个 `*`，使用 `command + s` 保存后，`*` 会自动消失。双击红框出的导航栏可以放大缩小代码区域。\n![环境搭建20](环境搭建/环境搭建20.png) \n👇 如果没有保存直接运行会出现这个对话框，勾选 Always save resources before launching 会在运行程序前自动保存。\n![环境搭建23](环境搭建/环境搭建23.png)  \n👇 运行程序：右击 -> Run As -> Java Application。\n![环境搭建21](环境搭建/环境搭建21.png) \n\n## 切换工作空间\nFile -> Switch Workspace -> others\n![环境搭建24](环境搭建/环境搭建24.png) \n👇 选择新的工作空间\n![环境搭建25](环境搭建/环境搭建25.png) \n\n## 修改字体\nEclipse -> Preference -> General -> Appearance -> Colors and Fonts -> Basic -> Text Font -> Edit\n![环境搭建22](环境搭建/环境搭建22.png) \n\n## 设置文件编码为 UTF-8\n文件编码如果设置错误的话可能会导致文字显示乱码，UTF-8 几乎覆盖了世界上所有的文字。\n\nEclipse -> Preference -> General -> Content Types -> Text\n![环境搭建26](环境搭建/环境搭建26.png) \n\n## 新建项目\n👇 关闭项目\n![环境搭建27](环境搭建/环境搭建27.png) \n👇 新建项目（右键 -> New -> Java Project）\n![环境搭建28](环境搭建/环境搭建28.png) \n👇\n![环境搭建29](环境搭建/环境搭建29.png) \n👇\n![环境搭建30](环境搭建/环境搭建30.png) \n\n## 删除项目\n选中文件 -> 右键 -> Delete。如果勾选了 Delete project contents on disk 会将工作空间里的文件也删除掉。\n![环境搭建31](环境搭建/环境搭建31.png) \n\n## 导入项目\n方式一：  \nFile -> Import  \n方式二：  \n👇 点击 Import projects\n![环境搭建32](环境搭建/环境搭建32.png) \n👇 选中 General -> Existing Projects into Workspace\n![环境搭建33](环境搭建/环境搭建33.png) \n👇 点击 Browse 找到要添加的项目。完成。\n![环境搭建34](环境搭建/环境搭建34.png) \n\n## 增强代码提示\nEclipse -> Preference -> Java -> Editor -> Content Assist -> Auto Activation -> Auto activation triggers for Java:\n\n添加下面这段内容：\n```\n.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n```\n![环境搭建35](环境搭建/环境搭建35.png) \n\n## 断点调试\n1. 双击边栏添加断点；\n2. 点击调试；\n![环境搭建36](环境搭建/环境搭建36.png) \n\nps：\n\n代码对齐：`command + shift + F`\n生成代码：`alt + command + s`。如：选择 `Generate Constructor use Fields` 生成指定成员变量的构造方法：\n```\npublic class Person {\n\tprivate int age;\n\tprivate String name;\n\t// 构造方法\n\tpublic Person(int age, String name) {\n\t\tsuper();\n\t\tthis.age = age;\n\t\tthis.name = name;\n\t}\n}\n```\n\n选择 `Generate toString()` 生成 `toString()` 方法：\n```\npublic String toString() {\n\treturn \"Person [age=\" + age + \", name=\" + name + \"]\";\n}\n```\n\n\n\n\n","slug":"数据结构与算法/环境搭建","published":1,"updated":"2023-08-22T09:52:14.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv2002laq7kyein6k9z"},{"title":"队列","date":"2020-11-06T08:13:04.000Z","_content":"\n[队列](https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481?fr=aladdin)是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。\n\n<!-- more -->\n\n# 队列\n![队列02](队列/队列02.png)\n队列是一种特殊的线性表，只能在头尾两端进行操作：  \n队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队；  \n队头（front）：只能从队头移除元素，一般叫做 deQueue，出队；  \n先进先出的原则，First In First Out，FIFO  \n\n入队：\n![队列01](队列/队列01.png)\n出队：\n![队列03](队列/队列03.png)\n\n## 通过双向链表实现\n动态数组和链表都可以用来实现队列。因为队列主要是在头尾操作元素，所以优先使用双向链表实现队列。\n```\npublic class Queue<E> {\n\tLinkedList<E> list = new LinkedList<>();\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\n\tpublic void enQueue(E element) {\n\t\tlist.add(element);\n\t}\n\n\tpublic E deQueue() {\n\t\treturn list.remove(0);\n\t}\n\n\tpublic E front() {\n\t\treturn list.get(0);\n\t}\n}\n```\n\n测试：\n```\npublic static void main(String[] args) {\n\tQueue<Integer> queue = new Queue<>();\n\tqueue.enQueue(11);\n\tqueue.enQueue(22);\n\tqueue.enQueue(33);\n\tqueue.enQueue(44);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueue());\n\t}\n}\n```\n\n打印结果：\n```\n11\n22\n33\n44\n```\n\n## 通过栈实现\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/)\n入队：\n![队列04](队列/队列04.png)\n出队：\n![队列05](队列/队列05.png)\n```\nStack<Integer> inStack;\nStack<Integer> outStack;\n\npublic _232_用栈实现队列() {\n\tinStack = new Stack<>();\n\toutStack = new Stack<>();\n}\n\n/** 入栈 */\npublic void push(int x) {\n\tinStack.push(x);\n}\n\n/** 出栈 */\npublic int pop() {\n\tcheckOutStack();\n\treturn outStack.pop();\n}\n\n/** 首元素 */\npublic int peek() {\n\tcheckOutStack();\n\treturn outStack.peek();\n}\n\n/** 判空 */\npublic boolean empty() {\n\treturn inStack.isEmpty() && outStack.isEmpty();\n}\n\nprivate void checkOutStack() {\n\tif (outStack.isEmpty()) {\n\t\twhile (!inStack.isEmpty()) {\n\t\t\toutStack.push(inStack.pop());\n\t\t}\n\t}\n}\n```\n\n## 源码分析\nQueue.class 文件里只有定义没有实现：\n```\npublic interface Queue<E> extends Collection<E> {\n    boolean add(E e);\n    \n    // 入队\n    boolean offer(E e);\n    \n    E remove();\n    \n    // 出队\n    E poll();\n\n    E element();\n    \n    // 首元素\n    E peek();\n}\n```\n\n在 Queue.class 文件里的注释可以看到，Queue 是在 LinkedList.class 里实现的：\n```\n/**\n * Retrieves, but does not remove, the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n\n/**\n * Retrieves, but does not remove, the head (first element) of this list.\n *\n * @return the head of this list\n * @throws NoSuchElementException if this list is empty\n * @since 1.5\n */\npublic E element() {\n    return getFirst();\n}\n\n/**\n * Retrieves and removes the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\n/**\n * Retrieves and removes the head (first element) of this list.\n *\n * @return the head of this list\n * @throws NoSuchElementException if this list is empty\n * @since 1.5\n */\npublic E remove() {\n    return removeFirst();\n}\n\n/**\n * Adds the specified element as the tail (last element) of this list.\n *\n * @param e the element to add\n * @return {@code true} (as specified by {@link Queue#offer})\n * @since 1.5\n */\npublic boolean offer(E e) {\n    return add(e);\n}\n```\n\n# 双端队列\n[双端队列](https://baike.baidu.com/item/deque/849385?fromtitle=%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97&fromid=2968804&fr=aladdin)是能在头尾两端进行添加、删除操作的队列。\n```\npublic class Deque<E> {\n\t\n\tLinkedList<E> list = new LinkedList<>();\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\n\tpublic void enQueueRear(E element) {\n\t\tlist.add(element);\n\t}\n\n\tpublic E deQueueFront() {\n\t\treturn list.remove(0);\n\t}\n\n\tpublic void enQueueFront(E element) {\n\t\tlist.add(0, element);\n\t}\n\n\tpublic E deQueueRear() {\n\t\treturn list.remove(list.size()-1);\n\t}\n\n\tpublic E front() {\n\t\treturn list.get(0);\n\t}\n\n\tpublic E rear() {\n\t\treturn list.get(list.size()-1);\n\t}\n}\n```\n\n测试：\n```\nstatic void test1() {\n\tDeque<Integer> queue = new Deque<>();\n\tqueue.enQueueFront(11);\n\tqueue.enQueueFront(22);\n\tqueue.enQueueRear(33);\n\tqueue.enQueueRear(44);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueueFront());\n\t}\n}\n\npublic static void main(String[] args) {\n\ttest1();\n}\n```\n\n打印结果：\n```\n22\n11\n33\n44\n```\n\n## 源码分析\n同 Queue 的源码分析👆。\n\n# 循环队列\n[循环队列](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/3685773?fr=aladdin)底层使用数组实现的，实现思路可以参考[链表](http://kevinyanggit.github.io/2020/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/)中的动态数组优化。\n\n对于一个队列：\n![队列06](队列/队列06.png)\n队头的两个元素依次出栈，`front` 指向 `2`：\n![队列07](队列/队列07.png)\n队尾依次入栈66、77、88、99，其中88、99超出数组大小，放到数组的 `0` 和 `1` 处（`(front + index) % elements.length`）：\n![队列08](队列/队列08.png)\n\nps：`%` 运算符的优化 - 已知 n>=0，m>=0，n < 2m，则 n%m 等价于 `n - (m > n ? 0 : m)`。\n\n代码实现：\n```\npublic class CircleQueue<E> {\n\t/*\n\t * 首元素\n\t */\n\tprivate int front;\n\t/*\n\t * 数据大小\n\t */\n\tprivate int size;\n\t/*\n\t * 容器\n\t */\n\tprivate E[] elements;\n\t/*\n\t * 默认容量\n\t */\n\tprivate static final int DEFAULT_CAPICATY = 10;\n\t\n\tpublic CircleQueue() {\n\t\telements = (E[]) new Object[DEFAULT_CAPICATY];\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void clear() {\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\telements[Index(i)] = null;\n\t\t}\n\t\tsize = 0;\n\t\tfront = 0;\n\t}\n\n\tpublic void enQueue(E element) {\n\t\tensureCapicity(size + 1);\n\t\telements[Index(size)] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueue() {\n\t\tE element = elements[front];\n\t\telements[front] = null;\n\t\tfront = Index(1);\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic E front() {\n\t\treturn elements[front];\n\t}\n\t\n\t/*\n\t * 已知 n>=0，m>=0，n < 2m，则 n%m 等价于\n\t * n - (m > n ? 0 : m)\n\t */\n\tprivate int Index(int index) {\n\t\tindex += front;\n\t\treturn index - (elements.length > index ? 0 : elements.length);\n\t}\n\t\n\tprivate void ensureCapicity(int capicaty) {\n\t\tint oldCapicaty = elements.length;\n\t\tif (oldCapicaty >= capicaty) return;\n\t\tint newCapicaty = oldCapicaty + (oldCapicaty >> 1);\n\t\tE[] newElements = (E[]) new Object[newCapicaty];\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tnewElements[i] = elements[Index(i)];\n\t\t}\n\t\telements = newElements;\n\t\tfront = 0;\n\t}\n\t\n\tpublic String toString() {\n\t\tStringBuilder string = new StringBuilder();\n\t\tstring.append(\"capicaty=\").append(elements.length)\n\t\t.append(\" size=\").append(size)\n\t\t.append(\" front=\").append(front)\n\t\t.append(\", [\");\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tstring.append(\", \");\n\t\t\t}\n\t\t\tstring.append(elements[i]);\n\t\t}\n\t\tstring.append(\"]\");\n\t\treturn string.toString();\n\t}\n}\n```\n\n测试：\n```\nstatic void test2() {\n\tCircleQueue<Integer> queue = new CircleQueue<>();\n\t// capicaty=10 size=10 front=0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueue(i);\n\t}\n\t// capicaty=10 size=5 front=5, [null, null, null, null, null, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 5; i++) {\n\t\tqueue.deQueue();\n\t}\n\t// capicaty=10 size=10 front=5, [10, 11, 12, 13, 14, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 5; i++) {\n\t\tqueue.enQueue(i+10);\n\t}\n\t// capicaty=22 size=20 front=0, [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, null, null]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueue(i);\n\t}\n\tSystem.out.println(queue);\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueue());\n\t}\n}\n```\n\n# 循环双端队列\n[循环双端队列]()可以进行两端添加、删除操作的循环队列，实现思路可以循环队列和[链表](http://kevinyanggit.github.io/2020/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/)中的动态数组优化。\n\n对于一个队列：\n![队列07](队列/队列07.png)\n队头入栈22，因为 `front` 指向的位置是队列 `0` 的位置，在 `front` 的左边入栈，也就相当于在队列 `-1` 的位置入栈(`(front - 1) % elements.length`)：\n![队列09](队列/队列09.png)\n\n代码实现：\n```\npublic class CircleDeque<E> {\n\tprivate int front;\n\tprivate int size;\n\tprivate E[] elements;\n\tprivate static final int DEFAULT_CAPICITY = 10;\n\t\n\tpublic CircleDeque() {\n\t\telements = (E[]) new Object[DEFAULT_CAPICITY];\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void clear() {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\telements[Index(i)] = null;\n\t\t}\n\t\tsize = 0;\n\t\tfront = 0;\n\t}\n\n\tpublic void enQueueRear(E element) {\n\t\tensureCapicity(size+1);\n\t\telements[Index(size)] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueueFront() {\n\t\tE element = elements[front];\n\t\telements[front] = null;\n\t\tfront = Index(1);\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic void enQueueFront(E element) {\n\t\tensureCapicity(size+1);\n\t\tfront = Index(-1);\n\t\telements[front] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueueRear() {\n\t\tE element = elements[Index(size - 1)];\n\t\telements[Index(size - 1)] = null;\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic E front() {\n\t\treturn elements[front];\n\t}\n\n\tpublic E rear() {\n\t\treturn elements[Index(size - 1)];\n\t}\n\t\n\tprivate int Index(int index) {\n\t\tindex += front;\n\t\tif (index < 0) {\n\t\t\treturn index + elements.length;\n\t\t}\n\t\treturn index - (elements.length > index ? 0 : elements.length);\n\t}\n\t\n\tprivate void ensureCapicity(int capicity) {\n\t\tint oldCapicity = elements.length;\n\t\tif (oldCapicity >= capicity) return;\n\t\toldCapicity = oldCapicity + (oldCapicity >> 1);\n\t\tE[] newElements = (E[]) new Object[oldCapicity];\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tnewElements[i] = elements[Index(i)];\n\t\t}\n\t\telements = newElements;\n\t\tfront = 0;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder string = new StringBuilder();\n\t\tstring.append(\"capicity=\").append(elements.length)\n\t\t.append(\" size=\").append(size)\n\t\t.append(\" front=\").append(front)\n\t\t.append(\", [\");\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tstring.append(\", \");\n\t\t\t}\n\t\t\tstring.append(elements[i]);\n\t\t}\n\t\tstring.append(\"]\");\n\t\treturn string.toString();\n\t}\n}\n```\n\n测试：\n```\nstatic void test3() {\n\tCircleDeque<Integer> queue = new CircleDeque<>();\n\t// capicity=22 size=20 front=20, [8, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, null, null, 10, 9]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueueFront(i + 1);\n\t\tqueue.enQueueRear(i + 100);\n\t}\n\t// capicity=22 size=14 front=1, [null, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, null, null, null, null, null, null, null]\n\tfor (int i = 0; i < 3; i++) {\n\t\tqueue.deQueueFront();\n\t\tqueue.deQueueRear();\n\t}\n\t\n\t// capicity=22 size=16 front=0, [11, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, 12, null, null, null, null, null, null]\n\tqueue.enQueueFront(11);\n\tqueue.enQueueRear(12);\n\t\n\tSystem.out.println(queue);\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueueFront());\n\t}\n}\n```\n\n# 练习\n[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n```\npublic class _225_用队列实现栈 {\n\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n    \n    public _225_用队列实现栈() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n    \n    /** 元素 x 入栈 */\n    public void push(int x) {\n        queue2.add(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    /** 移除栈顶元素 */\n    public int pop() {\n        return queue1.poll();\n    }\n    \n    /** 获取栈顶元素 */\n    public int top() {\n        return queue1.peek();\n    }\n    \n    /** 返回栈是否为空 */\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n```\n\n.\n","source":"_posts/数据结构与算法/队列.md","raw":"---\ntitle: 队列\ndate: 2020-11-06 16:13:04\ntags: 数据结构与算法\n---\n\n[队列](https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481?fr=aladdin)是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。\n\n<!-- more -->\n\n# 队列\n![队列02](队列/队列02.png)\n队列是一种特殊的线性表，只能在头尾两端进行操作：  \n队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队；  \n队头（front）：只能从队头移除元素，一般叫做 deQueue，出队；  \n先进先出的原则，First In First Out，FIFO  \n\n入队：\n![队列01](队列/队列01.png)\n出队：\n![队列03](队列/队列03.png)\n\n## 通过双向链表实现\n动态数组和链表都可以用来实现队列。因为队列主要是在头尾操作元素，所以优先使用双向链表实现队列。\n```\npublic class Queue<E> {\n\tLinkedList<E> list = new LinkedList<>();\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\n\tpublic void enQueue(E element) {\n\t\tlist.add(element);\n\t}\n\n\tpublic E deQueue() {\n\t\treturn list.remove(0);\n\t}\n\n\tpublic E front() {\n\t\treturn list.get(0);\n\t}\n}\n```\n\n测试：\n```\npublic static void main(String[] args) {\n\tQueue<Integer> queue = new Queue<>();\n\tqueue.enQueue(11);\n\tqueue.enQueue(22);\n\tqueue.enQueue(33);\n\tqueue.enQueue(44);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueue());\n\t}\n}\n```\n\n打印结果：\n```\n11\n22\n33\n44\n```\n\n## 通过栈实现\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/)\n入队：\n![队列04](队列/队列04.png)\n出队：\n![队列05](队列/队列05.png)\n```\nStack<Integer> inStack;\nStack<Integer> outStack;\n\npublic _232_用栈实现队列() {\n\tinStack = new Stack<>();\n\toutStack = new Stack<>();\n}\n\n/** 入栈 */\npublic void push(int x) {\n\tinStack.push(x);\n}\n\n/** 出栈 */\npublic int pop() {\n\tcheckOutStack();\n\treturn outStack.pop();\n}\n\n/** 首元素 */\npublic int peek() {\n\tcheckOutStack();\n\treturn outStack.peek();\n}\n\n/** 判空 */\npublic boolean empty() {\n\treturn inStack.isEmpty() && outStack.isEmpty();\n}\n\nprivate void checkOutStack() {\n\tif (outStack.isEmpty()) {\n\t\twhile (!inStack.isEmpty()) {\n\t\t\toutStack.push(inStack.pop());\n\t\t}\n\t}\n}\n```\n\n## 源码分析\nQueue.class 文件里只有定义没有实现：\n```\npublic interface Queue<E> extends Collection<E> {\n    boolean add(E e);\n    \n    // 入队\n    boolean offer(E e);\n    \n    E remove();\n    \n    // 出队\n    E poll();\n\n    E element();\n    \n    // 首元素\n    E peek();\n}\n```\n\n在 Queue.class 文件里的注释可以看到，Queue 是在 LinkedList.class 里实现的：\n```\n/**\n * Retrieves, but does not remove, the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n\n/**\n * Retrieves, but does not remove, the head (first element) of this list.\n *\n * @return the head of this list\n * @throws NoSuchElementException if this list is empty\n * @since 1.5\n */\npublic E element() {\n    return getFirst();\n}\n\n/**\n * Retrieves and removes the head (first element) of this list.\n *\n * @return the head of this list, or {@code null} if this list is empty\n * @since 1.5\n */\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\n/**\n * Retrieves and removes the head (first element) of this list.\n *\n * @return the head of this list\n * @throws NoSuchElementException if this list is empty\n * @since 1.5\n */\npublic E remove() {\n    return removeFirst();\n}\n\n/**\n * Adds the specified element as the tail (last element) of this list.\n *\n * @param e the element to add\n * @return {@code true} (as specified by {@link Queue#offer})\n * @since 1.5\n */\npublic boolean offer(E e) {\n    return add(e);\n}\n```\n\n# 双端队列\n[双端队列](https://baike.baidu.com/item/deque/849385?fromtitle=%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97&fromid=2968804&fr=aladdin)是能在头尾两端进行添加、删除操作的队列。\n```\npublic class Deque<E> {\n\t\n\tLinkedList<E> list = new LinkedList<>();\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\t\n\tpublic void clear() {\n\t\tlist.clear();\n\t}\n\n\tpublic void enQueueRear(E element) {\n\t\tlist.add(element);\n\t}\n\n\tpublic E deQueueFront() {\n\t\treturn list.remove(0);\n\t}\n\n\tpublic void enQueueFront(E element) {\n\t\tlist.add(0, element);\n\t}\n\n\tpublic E deQueueRear() {\n\t\treturn list.remove(list.size()-1);\n\t}\n\n\tpublic E front() {\n\t\treturn list.get(0);\n\t}\n\n\tpublic E rear() {\n\t\treturn list.get(list.size()-1);\n\t}\n}\n```\n\n测试：\n```\nstatic void test1() {\n\tDeque<Integer> queue = new Deque<>();\n\tqueue.enQueueFront(11);\n\tqueue.enQueueFront(22);\n\tqueue.enQueueRear(33);\n\tqueue.enQueueRear(44);\n\t\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueueFront());\n\t}\n}\n\npublic static void main(String[] args) {\n\ttest1();\n}\n```\n\n打印结果：\n```\n22\n11\n33\n44\n```\n\n## 源码分析\n同 Queue 的源码分析👆。\n\n# 循环队列\n[循环队列](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/3685773?fr=aladdin)底层使用数组实现的，实现思路可以参考[链表](http://kevinyanggit.github.io/2020/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/)中的动态数组优化。\n\n对于一个队列：\n![队列06](队列/队列06.png)\n队头的两个元素依次出栈，`front` 指向 `2`：\n![队列07](队列/队列07.png)\n队尾依次入栈66、77、88、99，其中88、99超出数组大小，放到数组的 `0` 和 `1` 处（`(front + index) % elements.length`）：\n![队列08](队列/队列08.png)\n\nps：`%` 运算符的优化 - 已知 n>=0，m>=0，n < 2m，则 n%m 等价于 `n - (m > n ? 0 : m)`。\n\n代码实现：\n```\npublic class CircleQueue<E> {\n\t/*\n\t * 首元素\n\t */\n\tprivate int front;\n\t/*\n\t * 数据大小\n\t */\n\tprivate int size;\n\t/*\n\t * 容器\n\t */\n\tprivate E[] elements;\n\t/*\n\t * 默认容量\n\t */\n\tprivate static final int DEFAULT_CAPICATY = 10;\n\t\n\tpublic CircleQueue() {\n\t\telements = (E[]) new Object[DEFAULT_CAPICATY];\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void clear() {\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\telements[Index(i)] = null;\n\t\t}\n\t\tsize = 0;\n\t\tfront = 0;\n\t}\n\n\tpublic void enQueue(E element) {\n\t\tensureCapicity(size + 1);\n\t\telements[Index(size)] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueue() {\n\t\tE element = elements[front];\n\t\telements[front] = null;\n\t\tfront = Index(1);\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic E front() {\n\t\treturn elements[front];\n\t}\n\t\n\t/*\n\t * 已知 n>=0，m>=0，n < 2m，则 n%m 等价于\n\t * n - (m > n ? 0 : m)\n\t */\n\tprivate int Index(int index) {\n\t\tindex += front;\n\t\treturn index - (elements.length > index ? 0 : elements.length);\n\t}\n\t\n\tprivate void ensureCapicity(int capicaty) {\n\t\tint oldCapicaty = elements.length;\n\t\tif (oldCapicaty >= capicaty) return;\n\t\tint newCapicaty = oldCapicaty + (oldCapicaty >> 1);\n\t\tE[] newElements = (E[]) new Object[newCapicaty];\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tnewElements[i] = elements[Index(i)];\n\t\t}\n\t\telements = newElements;\n\t\tfront = 0;\n\t}\n\t\n\tpublic String toString() {\n\t\tStringBuilder string = new StringBuilder();\n\t\tstring.append(\"capicaty=\").append(elements.length)\n\t\t.append(\" size=\").append(size)\n\t\t.append(\" front=\").append(front)\n\t\t.append(\", [\");\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tstring.append(\", \");\n\t\t\t}\n\t\t\tstring.append(elements[i]);\n\t\t}\n\t\tstring.append(\"]\");\n\t\treturn string.toString();\n\t}\n}\n```\n\n测试：\n```\nstatic void test2() {\n\tCircleQueue<Integer> queue = new CircleQueue<>();\n\t// capicaty=10 size=10 front=0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueue(i);\n\t}\n\t// capicaty=10 size=5 front=5, [null, null, null, null, null, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 5; i++) {\n\t\tqueue.deQueue();\n\t}\n\t// capicaty=10 size=10 front=5, [10, 11, 12, 13, 14, 5, 6, 7, 8, 9]\n\tfor (int i = 0; i < 5; i++) {\n\t\tqueue.enQueue(i+10);\n\t}\n\t// capicaty=22 size=20 front=0, [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, null, null]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueue(i);\n\t}\n\tSystem.out.println(queue);\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueue());\n\t}\n}\n```\n\n# 循环双端队列\n[循环双端队列]()可以进行两端添加、删除操作的循环队列，实现思路可以循环队列和[链表](http://kevinyanggit.github.io/2020/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/)中的动态数组优化。\n\n对于一个队列：\n![队列07](队列/队列07.png)\n队头入栈22，因为 `front` 指向的位置是队列 `0` 的位置，在 `front` 的左边入栈，也就相当于在队列 `-1` 的位置入栈(`(front - 1) % elements.length`)：\n![队列09](队列/队列09.png)\n\n代码实现：\n```\npublic class CircleDeque<E> {\n\tprivate int front;\n\tprivate int size;\n\tprivate E[] elements;\n\tprivate static final int DEFAULT_CAPICITY = 10;\n\t\n\tpublic CircleDeque() {\n\t\telements = (E[]) new Object[DEFAULT_CAPICITY];\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void clear() {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\telements[Index(i)] = null;\n\t\t}\n\t\tsize = 0;\n\t\tfront = 0;\n\t}\n\n\tpublic void enQueueRear(E element) {\n\t\tensureCapicity(size+1);\n\t\telements[Index(size)] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueueFront() {\n\t\tE element = elements[front];\n\t\telements[front] = null;\n\t\tfront = Index(1);\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic void enQueueFront(E element) {\n\t\tensureCapicity(size+1);\n\t\tfront = Index(-1);\n\t\telements[front] = element;\n\t\tsize++;\n\t}\n\n\tpublic E deQueueRear() {\n\t\tE element = elements[Index(size - 1)];\n\t\telements[Index(size - 1)] = null;\n\t\tsize--;\n\t\treturn element;\n\t}\n\n\tpublic E front() {\n\t\treturn elements[front];\n\t}\n\n\tpublic E rear() {\n\t\treturn elements[Index(size - 1)];\n\t}\n\t\n\tprivate int Index(int index) {\n\t\tindex += front;\n\t\tif (index < 0) {\n\t\t\treturn index + elements.length;\n\t\t}\n\t\treturn index - (elements.length > index ? 0 : elements.length);\n\t}\n\t\n\tprivate void ensureCapicity(int capicity) {\n\t\tint oldCapicity = elements.length;\n\t\tif (oldCapicity >= capicity) return;\n\t\toldCapicity = oldCapicity + (oldCapicity >> 1);\n\t\tE[] newElements = (E[]) new Object[oldCapicity];\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tnewElements[i] = elements[Index(i)];\n\t\t}\n\t\telements = newElements;\n\t\tfront = 0;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder string = new StringBuilder();\n\t\tstring.append(\"capicity=\").append(elements.length)\n\t\t.append(\" size=\").append(size)\n\t\t.append(\" front=\").append(front)\n\t\t.append(\", [\");\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tstring.append(\", \");\n\t\t\t}\n\t\t\tstring.append(elements[i]);\n\t\t}\n\t\tstring.append(\"]\");\n\t\treturn string.toString();\n\t}\n}\n```\n\n测试：\n```\nstatic void test3() {\n\tCircleDeque<Integer> queue = new CircleDeque<>();\n\t// capicity=22 size=20 front=20, [8, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, null, null, 10, 9]\n\tfor (int i = 0; i < 10; i++) {\n\t\tqueue.enQueueFront(i + 1);\n\t\tqueue.enQueueRear(i + 100);\n\t}\n\t// capicity=22 size=14 front=1, [null, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, null, null, null, null, null, null, null]\n\tfor (int i = 0; i < 3; i++) {\n\t\tqueue.deQueueFront();\n\t\tqueue.deQueueRear();\n\t}\n\t\n\t// capicity=22 size=16 front=0, [11, 7, 6, 5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, 12, null, null, null, null, null, null]\n\tqueue.enQueueFront(11);\n\tqueue.enQueueRear(12);\n\t\n\tSystem.out.println(queue);\n\twhile (!queue.isEmpty()) {\n\t\tSystem.out.println(queue.deQueueFront());\n\t}\n}\n```\n\n# 练习\n[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n```\npublic class _225_用队列实现栈 {\n\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n    \n    public _225_用队列实现栈() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n    \n    /** 元素 x 入栈 */\n    public void push(int x) {\n        queue2.add(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    /** 移除栈顶元素 */\n    public int pop() {\n        return queue1.poll();\n    }\n    \n    /** 获取栈顶元素 */\n    public int top() {\n        return queue1.peek();\n    }\n    \n    /** 返回栈是否为空 */\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n```\n\n.\n","slug":"数据结构与算法/队列","published":1,"updated":"2023-08-22T09:52:14.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv4002naq7kkkmhh3mr"},{"title":"链表","date":"2020-10-20T08:41:50.000Z","_content":"\n[链表](https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin)是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n<!-- more -->\n\n# 单向链表\n动态数组在扩容时，如果新扩出来的空间没有使用到，就造成了内存空间的大量浪费。而链表则是用到多少就申请多少内存空间。\n\n线性表的链式存储表示的特点是用一组任意的存储单元存储线性表的数据元素。这组存储单元可以是连续的，也可以是不连续的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n![链表01](链表/链表01.png)\n\n## 自定义链表\n### 链表的设计\n定义 size 记录链表的大小，定义 firt 指向第一个节点（头结点）。每个节点里定义 element 存储数据，定义 next 指向下一个节点（存储下一个结点地址）。\n![链表02](链表/链表02.png)\n\n### 接口设计\n![链表04](链表/链表04.png)\n创建一个接口类 List，用来定义 ArrayList 和 LinkedList 的公共接口（右键 -> new -> Interface）：\n```\npublic interface List<E> {\n    /**\n     * 错误码\n     */\n    public static final int ELEMENT_NOT_FOUND = -1;\n    /**\n     * 清除所有元素\n     */\n    public void clear();\n    /**\n     * 元素的数量\n     * @return\n     */\n    public int size();\n    /**\n     * 是否为空\n     * @return\n     */\n    public boolean isEmpty();\n    /**\n     * 是否包含某个元素\n     * @param element\n     * @return\n     */\n    public boolean contains(E element);\n    /**\n     * 添加元素到尾部\n     * @param element\n     */\n    public void add(E element); \n    /**\n     * 获取index位置的元素\n     * @param index\n     * @return\n     */\n    public E get(int index);\n    /**\n     * 设置index位置的元素\n     * @param index\n     * @param element\n     * @return 原来的元素ֵ\n     */\n    public E set(int index, E element);\n    /**\n     * 在index位置插入一个元素\n     * @param index\n     * @param element\n     */\n    public void add(int index, E element);\n    /**\n     * 删除index位置的元素\n     * @param index\n     * @return\n     */\n    public E remove(int index);\n    /**\n     * 查看元素的索引\n     * @param element\n     * @return\n     */\n    public int indexOf(E element);\n}\n```\n\n创建一个抽象类 AbstractList，实现 ArrayList 和 LinkedList 有相同实现的方法：\n```\n// implements 实现接口\n// abstract 抽象类：1、可以选择实现接口；2、抽象类无法被创建（new AbstractList<>()）\npublic abstract class AbstractList<E> implements List<E>{\n    \n    protected int size; // protected 子类可以访问\n    \n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    @Override\n    public boolean contains(E element) {\n        return indexOf(element) != ELEMENT_NOT_FOUND;\n    }\n\n    @Override\n    public void add(E element) {\n        add(size, element);\n    }\n    \n    protected void outOfBounds(int index) {\n        throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size\" + size);\n    }\n    \n    protected void rangeCheck(int index) {\n        if (index < 0 || index >= size) {\n            outOfBounds(index);\n        }\n    }\n    \n    protected void rangeCheckForAdd(int index) {\n        if (index < 0 || index > size) {\n            outOfBounds(index);\n        }\n    }\n}\n```\n\n让 ArrayList 和 LinkedList 继承自 AbstractList：\n```\n// 动态数组\npublic class ArrayList<E> extends AbstractList<E> { \n    // 实现剩余方法\n}\n\n// 链表\npublic class LinkedList<E> extends AbstractList<E> {\n    // 实现剩余方法\n}\n```\n\nps：  \n实现 List 接口的快捷方式：\n![链表03](链表/链表03.png)\n\n### clear\n```\npublic void clear() {\n    size = 0;\n    first = null;\n}\n```\n图解：\n![链表05](链表/链表05.png)\n\n### get/set\n定义 `node(int index)` 方法，查找指定 index 处的 node 并返回：\n```\npublic E get(int index) {\n    return node(index).element;\n}\n\npublic E set(int index, E element) {\n    Node<E> node = node(index);\n    E old = node.element;\n    node.element = element;\n    return old;\n}\n\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    for (int i = 0; i < index; i++) {\n        node = node.next;\n    }\n    return node;\n}\n```\n\n### add\n添加新的 newNode：\n![链表06](链表/链表06.png)\n\n#### index == 1\n要添加一个 node 到 index == 1 的位置，只需要找到 index - 1 处的 prev，那么 index == 1 处就是 prev.next。让新添加的 newNode 的 next 指向 prev.next，再让 prev 的 next 指针指向 newNode：\n![链表07](链表/链表07.png)\n\n#### index == size\n要添加一个 node 到 index == size 的位置，只需要找到 index - 1 处的 prev，那么 index == size 处就是 prev.next（null）。让新添加的 newNode 的 next 指向 prev.next，再让 prev 的 next 指针指向 newNode：\n![链表09](链表/链表09.png)\n\n#### index == 0\n要添加一个 node 到 index == 0 的位置，只需要让新添加的 newNode 的 next 指向 first，再让 first 指向 newNode：\n![链表08](链表/链表08.png)\n\n#### 代码实现\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == 0) {\n        first = new Node<>(element, first);\n    } else {\n        Node<E> prev = node(index - 1);\n        prev.next = new Node<>(element, prev.next); \n    }\n    size++;\n}\n```\n\n### remove\n1. 要删除 index == 1 处的 node，只需要找到 index - 1 出的 prev，让 `prev.next = prev.next.next`。\n2. 要删除 index == 0 处的 node，只需要让 `first = first.next`。\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (index == 0) {\n        first = first.next;\n    } else {\n        Node<E> prev = node(index - 1);\n        node = prev.next;\n        prev.next = node.next;  \n    }\n    size--;\n    return node.element;\n}\n```\n图解：\n![链表10](链表/链表10.png)\n\n### indexOf\n```\npublic int indexOf(E element) {\n    if (element == null) {\n        Node<E> node = first;\n        for (int i = 0; i < size; i++) {\n            if (node.element == null) return i;\n            \n            node = node.next;\n        }\n    } else {\n        Node<E> node = first;\n        for (int i = 0; i < size; i++) {\n            if (node.element.equals(element)) return i;\n            \n            node = node.next;\n        }   \n    }\n    return ELEMENT_NOT_FOUND;\n}\n```\n\nps：[VisuAlgo](https://visualgo.net/zh) 以动画的方式展示了数据结构基本操作的原理，还有代码实现。\n\n## 练习\n链表的题目会用到一个 ListNode 节点类，所以先创建一个节点类：\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n    }\n}\n```\n\n### 删除链表中的节点\n基本操作：  \n1. 以题目的类型和题目名称分别创建“链表”包和“_237_删除链表中的节点”文件；\n2. 保存改题目的连接：[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)，方便以后查看；\n3. 拷贝网页中的条件及题目；\n![链表11](链表/链表11.png)\n\n分析：删除指定节点 node，可以将 node 下一个节点的内容覆盖掉 node 的内容，让后将 node 的下一个节点删除掉 `node.next = node.next.next`：\n```\npublic void deleteNode(ListNode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n}\n```\n图解：\n![链表12](链表/链表12.png)\n\n### 反转一个链表\n[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n![链表13](链表/链表13.png)\n#### 递归\n[5, 4, 3, 2, 1] 传入4，reverseList(4) -> [1, 2, 3, 4]：\n![链表14](链表/链表14.png)\n代码实现：\n```\n//[5, 4, 3, 2, 1], head：5\npublic ListNode reverseList(ListNode head) {\n    // 添加边界，避免死循环\n    // head == null 表示没有元素\n    // head.next == null 表示只有一个元素\n    if (head == null || head.next == null) return head;\n    \n    // 1->2, 2->3, 3->4, 4->5\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n}\n```\n\n#### 迭代\nnewHead, head -> [5, 4, 3, 2, 1]  \nnewHead -> [5], head -> [4, 3, 2, 1]  \nnewHead -> [5, 4], head -> [3, 2, 1]  \n...\n![链表15](链表/链表15.png)\n代码实现：\n```\npublic ListNode reverseList2(ListNode head) {\n    if (head == null || head.next == null) return head;\n    \n    ListNode newHead = null;\n    while (head != null) {\n        ListNode tmp = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = tmp;\n    }\n    return newHead;\n}\n```\n\n### 判断一个链表是否有环\n[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)  \n快慢指针：slow 移动1个元素/次，fast 移动2个元素/次，当 slow 和 fast 相遇的时候，说明链表有环。\n![链表16](链表/链表16.png)\n代码实现：\n```\npublic boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) return false;\n    \n    ListNode slow = head;\n    ListNode fast = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}\n```\n\n### 移除链表元素\n[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n```\npublic ListNode removeElements(ListNode head, int val) {\n    if (head == null) return head;\n    \n    // 遍历链表\n    ListNode node = head;\n    while (node.next != null) {\n        if (node.next.val == val) {\n            node.next = node.next.next;\n        } else {\n            node = node.next;\n        }\n    }\n\n    // 判断头结点\n    if (head.val == val) {\n        if (head.next == null) {\n            return null;\n        } else {\n            head = head.next;\n        }\n    }\n    \n    return head;\n}\n```\n\n### 删除排序链表中的重复元素\n[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/)\n```\npublic ListNode deleteDuplicates(ListNode head) {\n    if (head == null || head.next == null) return head;\n    // 遍历链表\n    ListNode node = head;\n    while (node != null) {\n        \n        // 从 node 开始遍历链表\n        ListNode targetNode = node;\n        while (targetNode.next != null) {\n            if (targetNode.next.val == node.val) {\n                targetNode.next = targetNode.next.next;\n            } else {\n                targetNode = targetNode.next;   \n            }\n        }\n        \n        node = node.next;\n    }\n    \n    return head;\n}\n```\n\n### 链表的中间节点\n[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n```\npublic ListNode middleNode(ListNode head) {\n    int count = 0; // 标记链表长度\n    // 遍历链表\n    ListNode node = head;\n    while (node != null) {\n        count++;\n        node = node.next;\n    }\n    \n    count = count/2;\n    // 遍历链表\n    while (node != null) {\n        if (count > 0) {\n            count--;\n        } else {\n            break; // 此时 node 为中间节点\n        }\n        node = node.next;\n    }\n    \n    return node;\n}\n```\n\n## 虚拟结点\n在链表的最前面增加一个虚拟头结点（不存储数据），可以统一所有节点的处理逻辑，让代码更加精简：\n```\n// 添加构造方法，添加虚拟头结点\npublic LinkedList2() {\n    first = new Node<>(null, null);\n}\n\n// 修改add\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    Node<E> prev = index == 0 ? first : node(index - 1);\n    prev.next = new Node<>(element, prev.next);\n    size++;\n}\n\n// 修改remove\npublic E remove(int index) {\n    rangeCheck(index);\n    Node<E> prev = index == 0 ? first : node(index - 1);\n    Node<E> node = prev.next;\n    prev.next = node.next;\n    size--;\n    return node.element;\n}\n\n// 修改node\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first.next;\n    for (int i = 0; i < index; i++) {\n        node = node.next;\n    }\n    return node;\n}\n```\n\n## 复杂度分析\n![链表18](链表/链表18.png)\n\n### 动态数组\n#### add(E element)\n最好情况复杂度：在 `index == size` 处添加元素，不需要移动任何元素，复杂度 O(1)；  \n最坏情况复杂度：在 `index == size` 处添加元素时容量不够需要扩容，所有元素都要移动到新扩容的数组里，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 1 + 1 + ... + 1 + n) / n` -> O(2n/2)，复杂度 O(1)；  \n均摊复杂度：O(1)。\n\n均摊复杂度：假设最大容量是4，扩容相当于每次 add 的操作次数是 2，也就是O(1)复杂度：\n![链表19](链表/链表19.png)\n在经过连续的多次复杂度比较低的情况后，出现个别复杂度比较高的情况时，适合均摊复杂度。\n\n#### add(int index, E element)\n最好情况复杂度：在 `index == size` 处添加元素，不需要移动任何元素，复杂度 O(1)；  \n最坏情况复杂度：在 `index == 0` 处添加元素，所有元素都要向后移动一位，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### remove\n最好情况复杂度：删除 `index == size - 1` 处的元素，不需要移动任何元素，复杂度 O(1)； \n最坏情况复杂度：删除 `index == 0` 处的元素，所有元素都要向前移动一位，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### set & get\n数组的随机访问速度非常快，`elements[n]` 的效率与 n 是多少无关。\n![链表17](链表/链表17.png)\n\n### 单向链表\n#### add\n最好情况复杂度：在 `index == 0` 处添加元素，只需要创建一个新的节点，并让 first 指向该节点，复杂度 O(1)；  \n最坏情况复杂度：在 `index == size - 1` 处添加元素，需要遍历所有节点，才能找到最后一个节点，并让最后一个节点指向新创建的节点，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### remove\n最好情况复杂度：删除 `index == 0` 处的元素，只需要找到 first，并让 first 指向该节点的下一个节点，复杂度 O(1)；  \n最坏情况复杂度：删除 `index == size - 1` 处的元素，需要遍历所有节点，才能找到倒数第二个节点，并让倒数第二个节点指向 null，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### set & get\n最好情况复杂度：查找 `index == 0` 处的元素，不需要遍历，直接通过 `first.next` 就可以找到第一个节点，复杂度 O(1)；  \n最坏情况复杂度：查找 `index == size - 1` 处的元素，需要遍历所有节点，才能找到最后一个节点，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n\n# 双向链表\n![链表20](链表/链表20.png)\n双向链表的代码实现，是在单向链表的代码基础上进行以下修改👇。\n\n## set&get\n只需要修改 `node()` 方法即可：\n```\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    if (index < (size >> 1)) {\n        Node<E> node = first;\n        for (int i = 0; i < index; i++) {\n            node = node.next;\n        }\n        return node;\n    } else {\n        Node<E> node = last;\n        for (int i = size - 1; i > index; i--) {\n            node = node.prev;\n        }\n        return node;\n    }\n}\n```\n\n## add\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == size) {\n        Node<E> oldLast = last;\n        last = new Node<>(oldLast, element, null);\n        if (oldLast == null) { // 这是链表添加的第一个元素\n            first = last;\n        } else {\n            oldLast.next = last;\n        }\n    } else {\n        Node<E> next = node(index);\n        Node<E> prev = next.prev;\n        Node<E> node = new Node<>(prev, element, next);\n        next.prev = node;\n        \n        if (prev == null) { // index == 0\n            first = node;\n        } else {\n            prev.next = node;\n        }\n    }\n    size++;\n}\n```\n在 `0 < index < size` 处添加元素：\n![链表22](链表/链表22.png)\n在 `index == 0` 处添加元素：\n![链表21](链表/链表21.png)\n在 `index == size` 处添加元素，分为首次添加元素和非首次添加元素：  \n首次添加元素：\n![链表23](链表/链表23.png)\n非首次添加元素：\n![链表24](链表/链表24.png)\n\n## remove\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = node(index);\n    Node<E> prev = node.prev;\n    Node<E> next = node.next;\n    \n    if (prev == null) { // index == 0\n        first = next;\n    } else {\n        prev.next = next;\n    }\n    \n    if (next == null) { // index == size - 1\n        last = prev;\n    } else {\n        next.prev = prev;\n    }\n    \n    size--;\n    return node.element;\n}\n```\n删除 `0 < index < size` 处的元素：\n![链表25](链表/链表25.png)\n删除 `index == 0` 处的元素：\n![链表26](链表/链表26.png)\n\n## 测试\n修改 LinkedList 的 `toString()` 方法：\n```\npublic String toString() {\n    StringBuilder string = new StringBuilder();\n    string.append(\"size=\").append(size).append(\", [\");\n    Node<E> node = first;\n    for (int i = 0; i < size; i++) {\n        if (i != 0) {\n            string.append(\", \");\n        }\n        string.append(node);\n        \n        node = node.next;\n    }\n    string.append(\"]\");\n    return string.toString();\n}\n```\n\n在 `class Node<E>` 里重写 `toString()` 方法：\n```\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    \n    if (prev != null) {\n        sb.append(prev.element);\n    } else {\n        sb.append(\"null\");\n    }\n    \n    sb.append(\"_\").append(element).append(\"_\");\n\n    if (next != null) {\n        sb.append(next.element);\n    } else {\n        sb.append(\"null\");\n    }\n    \n    return sb.toString();\n}\n```\n\n在 Main.java 里添加测试代码：\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Integer> list = new LinkedList<>();\n        list.add(12);\n        list.add(0, 11);\n        list.add(13);\n        list.add(14);\n        list.add(15);\n        list.add(list.size(), 16);\n        \n        list.remove(1);\n        list.remove(2);\n        \n        System.out.println(list);\n    }\n}\n```\n\n打印结果：\n```\nsize=4, [null_11_13, 11_13_15, 13_15_16, 15_16_null]\n```\n\n## 双向链表 vs 单向链表\n单向链表：`1 + 2 + 3 + ... + n = (1 + n) * n/2 = n/2 + (n^2)/2`，除以 n 平均一下是 `1/2 + n/2`；  \n双向链表：`(1 + 2 + 3 + ... + n/2) * 2 = ((1 + n/2) * n/2)/2 * 2 = n/2 + (n^2)/4`，除以 n 平均一下是 `1/2 + n/4`。\n\n## 双向链表 vs 动态数组\n动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）；   \n双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费。\n\n## 源码分析\n### 成员变量\n```\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n */\ntransient Node<E> last;\n```\n\n### add\n```\n/**\n * Inserts the specified element at the specified position in this list.\n * Shifts the element currently at that position (if any) and any\n * subsequent elements to the right (adds one to their indices).\n *\n * @param index index at which the specified element is to be inserted\n * @param element element to be inserted\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\n/**\n * Links e as last element.\n */\nvoid linkLast(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n\n/**\n * Inserts element e before non-null Node succ.\n */\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n### remove\n```\n/**\n * Removes the element at the specified position in this list.  Shifts any\n * subsequent elements to the left (subtracts one from their indices).\n * Returns the element that was removed from the list.\n *\n * @param index the index of the element to be removed\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\n/**\n * Unlinks non-null node x.\n */\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n### set&get\n```\n/**\n * Returns the element at the specified position in this list.\n *\n * @param index index of the element to return\n * @return the element at the specified position in this list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element.\n *\n * @param index index of the element to replace\n * @param element element to be stored at the specified position\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n\n/**\n * Returns the (non-null) Node at the specified element index.\n */\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n# 单向循环链表\n![链表27](链表/链表27.png)\n单向循环链表中只有一个元素的情况：\n![链表33](链表/链表33.png)\n在单向链表的代码基础上进行修改，需要修改的有 `add()` 和 `remove()` 方法。\n## add\n单向循环链表的添加，主要是在 `index == 0` 处的逻辑需要修改：\n1. 让最后面节点的 next 指向新添加的节点；\n2. 让 first 指向新添加的节点；\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == 0) {\n        Node<E> newFirst = new Node<>(element, first);\n        // 拿到最后一个节点\n        Node<E> last = (size == 0) ? newFirst : node(size - 1);\n        last.next = newFirst;\n        first = newFirst;\n    } else {\n        Node<E> prev = node(index - 1);\n        prev.next = new Node<>(element, prev.next); \n    }\n    size++;\n}\n```\n\n## remove\n单向循环链表的删除，主要是在 `index == 0` 处的逻辑需要修改：\n1. 如果链表中只有一个节点，直接让 `first = null`；\n2. 让 first 指向 `index == 1` 处的元素；\n3. 让 last 指向 `index == 1` 处的元素（`last.next = first`）；\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (index == 0) {\n        if (size == 1) {\n            first = null;\n        } else {\n            Node<E> last = node(size - 1); // 必须在 first = first.next 前获取\n            first = first.next;\n            last.next = first;\n        }\n    } else {\n        Node<E> prev = node(index - 1);\n        node = prev.next;\n        prev.next = node.next;  \n    }\n    size--;\n    return node.element;\n}\n```\n\n# 双向循环链表\n![链表28](链表/链表28.png)\n在双向链表的代码基础上进行修改，需要修改的有 `add()` 和 `remove()` 方法。\n## add\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == size) { // index == size\n        Node<E> oldLast = last;\n        last = new Node<>(oldLast, element, first);\n        if (oldLast == null) { // 这是链表添加的第一个元素\n            first = last;\n            first.prev = first;\n            first.next = first;\n        } else {\n            oldLast.next = last;\n            first.prev = last;\n        }\n    } else {\n        Node<E> next = node(index);\n        Node<E> prev = next.prev;\n        Node<E> node = new Node<>(prev, element, next);\n        next.prev = node;\n        prev.next = node; // 双向链表中，prev 一定不为 null\n        \n        if (next == first) { // index == 0\n            first = node;\n        }\n    }\n    size++;\n}\n```\n![链表29](链表/链表29.png)\n双向循环链表中只有一个节点的情况：\n![链表30](链表/链表30.png)\n\n## remove\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (size == 0) {\n        first = null;\n        last = null;\n    } else {\n        node = node(index);\n        Node<E> prev = node.prev;\n        Node<E> next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        \n        if (node == first) { // index == 0\n            first = next;\n        }\n        \n        if (node == last) { // index == size - 1\n            last = prev;\n        }\n    }\n    size--;\n    return node.element;\n}\n```\n\n## 练习 - 约瑟夫问题\n从1开始数，数到三就去掉：\n![链表31](链表/链表31.png)\n\n为了发挥循环链表的最大威力，增设1个成员变量、3个方法：\n1. `current`：用于指向某个节点；\n2. `void reset()`：让 `current` 指向头结点 `first`；\n3. `E next()`：让 `current` 往后走一步，也就是 `current = current.next`;\n4. `E remove()`：删除 `current` 指向的节点，删除成功后让 `current` 指向下一个节点；\n![链表32](链表/链表32.png)\n\n相关代码：\n```\npublic void reset() {\n    current = first;\n}\n\npublic E next() {\n    if (current == null) return null;\n    \n    current = current.next;\n    return current.element;\n}\n\npublic E remove() {\n    if (current == null) return null;\n    \n    E element = remove(current);\n    if (size == 0) {\n        current = null;\n    } else {\n        current = current.next;\n    }\n    \n    return element;\n}\n\npublic E remove(int index) {\n    rangeCheck(index);\n    return remove(node(index));\n}\n\npublic E remove(Node<E> node) {\n    if (size == 0) {\n        first = null;\n        last = null;\n    } else {\n        Node<E> prev = node.prev;\n        Node<E> next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        \n        if (node == first) { // index == 0\n            first = next;\n        }\n        \n        if (node == last) { // index == size - 1\n            last = prev;\n        }\n    }\n    size--;\n    return node.element;\n}\n```\n\n测试：\n```\nstatic void josephus() {\n    CircleLinkedList<Integer> list = new CircleLinkedList<>();\n    for (int i = 1; i <= 8; i++) {\n        list.add(i);\n    }\n    \n    // 指向头结点（指向1）\n    list.reset();\n    \n    while (!list.isEmpty()) {\n        list.next();\n        list.next();\n        System.out.println(list.remove());\n    }\n}\n```\n\n打印结果：\n```\n3\n6\n1\n5\n2\n8\n4\n7\n```\n\n# 静态链表\n单向链表、双向链表、单向循环链表和双向循环链表，都是依赖于指针实现的。在早期的编程语言中，有些是没有指针的，比如 BASIC、FORTRAN 语言。它们通过数组来模拟链表，成为静态链表。\n\n在一个数组中，每个元素存放两个数据，一个是数值，一个是下一个元素的索引。比如第一个元素是的值是 11，下一个元素是索引为 3 的元素（44）：\n![链表34](链表/链表34.png)\n相当于下面这个链表：\n![链表35](链表/链表35.png)\n\n* 思考：如果数组的每个元素只能存放1个数据呢？  \n  使用2个数组，一个数组存放索引关系，另一个数组存放值。\n\n# 动态数组优化\n定义变量 `int first`，标记首元素的索引。如获取 index 的元素可以通过 `first + index % elements.length` 对应元素的坐标。\n\n## remove\n### 删除首元素 \n当前数组 `first == 0`：\n![链表36](链表/链表36.png)\n删除首元素，让 `first = 1`：\n![链表37](链表/链表37.png)\n删除首元素，让 `first = 2`：\n![链表38](链表/链表38.png)\n### 删除中间元素\n当前数组 `first == 0`：\n![链表43](链表/链表43.png)\n删除1处的元素，让0处的元素向后移动一位，覆盖掉1处的元素，并将0处的元素清空，最后让 `first = 1`：\n![链表44](链表/链表44.png)\n代码实现：\n```\npublic E remove(int index) {\n\trangeCheck(index);\n\t\n\tint oldIndex = (first + index) % elements.length;\n\tE old = elements[oldIndex];\n\t\n\tif (index * 2 >= size) {\n\t\tfor (int i = index + 1; i < size; i++) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[nextIndex] = elements[newIndex];\n\t\t}\n\t\tint last = (first + size - 1) % elements.length;\n\t\telements[last] = null;\n\t} else {\n\t\tfor (int i = index; i > 0; i--) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\telements[first] = null;\n\t\tfirst = (first + 1) < elements.length ? first + 1 : 0;\n\t}\n\tsize--;\n\ttrim();\n\treturn old;\n}\n```\n\n## add\n### 在末尾添加\n当前数组 `first == 2`：\n![链表38](链表/链表38.png)\n在数组末尾添加，此时不需要修改 first， `first = 2`：\n### 在头部添加\n![链表39](链表/链表39.png)\n在数组的头部添加元素，让 `first = 1`：\n![链表40](链表/链表40.png)\n在数组的头部添加元素，让 `first = 0`：\n![链表41](链表/链表41.png)\n在数组的头部添加元素，让 `first = 8`：\n![链表42](链表/链表42.png)\n### 在中间添加\n当前数组 `first == 1`：\n![链表40](链表/链表40.png)\n在 3 处插入99，只需要让1、2处的元素往前移动一位，让 `first = 0`：\n![链表43](链表/链表43.png)\n代买实现：\n```\npublic void add(int index, E element) {\n\trangeCheckForAdd(index);\n\t\n\tensureCapacity(size + 1);\n\t\n\tif (index * 2 >= size) {\n\t\tfor (int i = size; i > index; i--) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\tindex = (first + index) % elements.length;\n\t\telements[index] = element;\n\t} else {\n\t\tfirst = (first - 1) >= 0 ? first - 1 : elements.length - 1;\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i + 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\tindex = (first + index) % elements.length;\n\t\telements[index] = element;\n\t}\n\tSystem.out.println(first);\n\tsize++;\n}\n```\n## set&get\n通过 `first + index % elements.length` 对应元素的坐标，然后获取元素：\n```\npublic E get(int index) { //O(1)\n\trangeCheck(index);\n\tindex = (first + index) % elements.length;\n\treturn elements[index];\n}\n\npublic E set(int index, E element) { //O(1)\n\trangeCheck(index);\n\tindex = (first + index) % elements.length;\n\tE old = elements[index];\n\telements[index] = element;\n\treturn old;\n}\n```\n\n## 扩容\n当数组装满后，新创建一个容量扩大1.5倍的数组，将原数组里的元素移动到新数组里，从0开始填充，`first = 0`。\n```\nprivate void ensureCapacity(int capacity) {\n\tint oldCapacity = elements.length;\n\tif (oldCapacity >= capacity) return;\n\t// 新容量为就容量的1.5倍\n\tint newCapacity = oldCapacity + (oldCapacity >> 1); //iOS 1.6, java 1.5, >> 表示除以2\n\tE[] newElements = (E[]) new Object[newCapacity];\n\tfor (int i = 0; i < size; i++) {\n\t\tint index = (first + i) % elements.length;\n\t\tnewElements[i] = elements[index];\n\t}\n\telements = newElements;\n\tfirst = 0;\n\t\n\tSystem.out.println(oldCapacity + \"扩容为\" + newCapacity);\n}\n```\n\n## 缩容\n当数组满足缩容条件时，新创建一个容量按规则缩小的数组，将原数组里的元素移动到新数组里，从0开始填充，`first = 0`。\n```\nprivate void trim() {\n\tint oldCapacity = elements.length;\n\tint newCapacity = oldCapacity >> 1;\n\t// 剩余空间小于一半 || 空间大小 <= 默认空间\n\tif (size >= newCapacity || oldCapacity <= DEFAULT_CAPACITY) return;\n\t\n\tE[] newElements = (E[]) new Object[newCapacity];\n\tfor (int i = 0; i < size; i++) {\n\t\tint newIndex = (first + i) % elements.length;\n\t\tnewElements[i] = elements[newIndex];\n\t}\n\telements = newElements;\n\tfirst = 0;\n\t\n\tSystem.out.println(oldCapacity + \"缩容为\" + newCapacity);\n}\n```\n\n## 后期优化\n```\nprivate int Index(int index) {\n    index += first;\n    if (index < 0) {\n        return index + elements.length;\n    }\n\treturn index % elements.length;\n}\n\nprivate void rightMoveFitst() {\n\tfirst = Index(1);\n}\n\nprivate void leftMoveFitst() {\n\tfirst = Index(-1);\n}\n```\n","source":"_posts/数据结构与算法/链表.md","raw":"---\ntitle: 链表\ndate: 2020-10-20 16:41:50\ntags: 数据结构与算法\n---\n\n[链表](https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin)是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n<!-- more -->\n\n# 单向链表\n动态数组在扩容时，如果新扩出来的空间没有使用到，就造成了内存空间的大量浪费。而链表则是用到多少就申请多少内存空间。\n\n线性表的链式存储表示的特点是用一组任意的存储单元存储线性表的数据元素。这组存储单元可以是连续的，也可以是不连续的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n![链表01](链表/链表01.png)\n\n## 自定义链表\n### 链表的设计\n定义 size 记录链表的大小，定义 firt 指向第一个节点（头结点）。每个节点里定义 element 存储数据，定义 next 指向下一个节点（存储下一个结点地址）。\n![链表02](链表/链表02.png)\n\n### 接口设计\n![链表04](链表/链表04.png)\n创建一个接口类 List，用来定义 ArrayList 和 LinkedList 的公共接口（右键 -> new -> Interface）：\n```\npublic interface List<E> {\n    /**\n     * 错误码\n     */\n    public static final int ELEMENT_NOT_FOUND = -1;\n    /**\n     * 清除所有元素\n     */\n    public void clear();\n    /**\n     * 元素的数量\n     * @return\n     */\n    public int size();\n    /**\n     * 是否为空\n     * @return\n     */\n    public boolean isEmpty();\n    /**\n     * 是否包含某个元素\n     * @param element\n     * @return\n     */\n    public boolean contains(E element);\n    /**\n     * 添加元素到尾部\n     * @param element\n     */\n    public void add(E element); \n    /**\n     * 获取index位置的元素\n     * @param index\n     * @return\n     */\n    public E get(int index);\n    /**\n     * 设置index位置的元素\n     * @param index\n     * @param element\n     * @return 原来的元素ֵ\n     */\n    public E set(int index, E element);\n    /**\n     * 在index位置插入一个元素\n     * @param index\n     * @param element\n     */\n    public void add(int index, E element);\n    /**\n     * 删除index位置的元素\n     * @param index\n     * @return\n     */\n    public E remove(int index);\n    /**\n     * 查看元素的索引\n     * @param element\n     * @return\n     */\n    public int indexOf(E element);\n}\n```\n\n创建一个抽象类 AbstractList，实现 ArrayList 和 LinkedList 有相同实现的方法：\n```\n// implements 实现接口\n// abstract 抽象类：1、可以选择实现接口；2、抽象类无法被创建（new AbstractList<>()）\npublic abstract class AbstractList<E> implements List<E>{\n    \n    protected int size; // protected 子类可以访问\n    \n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    @Override\n    public boolean contains(E element) {\n        return indexOf(element) != ELEMENT_NOT_FOUND;\n    }\n\n    @Override\n    public void add(E element) {\n        add(size, element);\n    }\n    \n    protected void outOfBounds(int index) {\n        throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size\" + size);\n    }\n    \n    protected void rangeCheck(int index) {\n        if (index < 0 || index >= size) {\n            outOfBounds(index);\n        }\n    }\n    \n    protected void rangeCheckForAdd(int index) {\n        if (index < 0 || index > size) {\n            outOfBounds(index);\n        }\n    }\n}\n```\n\n让 ArrayList 和 LinkedList 继承自 AbstractList：\n```\n// 动态数组\npublic class ArrayList<E> extends AbstractList<E> { \n    // 实现剩余方法\n}\n\n// 链表\npublic class LinkedList<E> extends AbstractList<E> {\n    // 实现剩余方法\n}\n```\n\nps：  \n实现 List 接口的快捷方式：\n![链表03](链表/链表03.png)\n\n### clear\n```\npublic void clear() {\n    size = 0;\n    first = null;\n}\n```\n图解：\n![链表05](链表/链表05.png)\n\n### get/set\n定义 `node(int index)` 方法，查找指定 index 处的 node 并返回：\n```\npublic E get(int index) {\n    return node(index).element;\n}\n\npublic E set(int index, E element) {\n    Node<E> node = node(index);\n    E old = node.element;\n    node.element = element;\n    return old;\n}\n\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    for (int i = 0; i < index; i++) {\n        node = node.next;\n    }\n    return node;\n}\n```\n\n### add\n添加新的 newNode：\n![链表06](链表/链表06.png)\n\n#### index == 1\n要添加一个 node 到 index == 1 的位置，只需要找到 index - 1 处的 prev，那么 index == 1 处就是 prev.next。让新添加的 newNode 的 next 指向 prev.next，再让 prev 的 next 指针指向 newNode：\n![链表07](链表/链表07.png)\n\n#### index == size\n要添加一个 node 到 index == size 的位置，只需要找到 index - 1 处的 prev，那么 index == size 处就是 prev.next（null）。让新添加的 newNode 的 next 指向 prev.next，再让 prev 的 next 指针指向 newNode：\n![链表09](链表/链表09.png)\n\n#### index == 0\n要添加一个 node 到 index == 0 的位置，只需要让新添加的 newNode 的 next 指向 first，再让 first 指向 newNode：\n![链表08](链表/链表08.png)\n\n#### 代码实现\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == 0) {\n        first = new Node<>(element, first);\n    } else {\n        Node<E> prev = node(index - 1);\n        prev.next = new Node<>(element, prev.next); \n    }\n    size++;\n}\n```\n\n### remove\n1. 要删除 index == 1 处的 node，只需要找到 index - 1 出的 prev，让 `prev.next = prev.next.next`。\n2. 要删除 index == 0 处的 node，只需要让 `first = first.next`。\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (index == 0) {\n        first = first.next;\n    } else {\n        Node<E> prev = node(index - 1);\n        node = prev.next;\n        prev.next = node.next;  \n    }\n    size--;\n    return node.element;\n}\n```\n图解：\n![链表10](链表/链表10.png)\n\n### indexOf\n```\npublic int indexOf(E element) {\n    if (element == null) {\n        Node<E> node = first;\n        for (int i = 0; i < size; i++) {\n            if (node.element == null) return i;\n            \n            node = node.next;\n        }\n    } else {\n        Node<E> node = first;\n        for (int i = 0; i < size; i++) {\n            if (node.element.equals(element)) return i;\n            \n            node = node.next;\n        }   \n    }\n    return ELEMENT_NOT_FOUND;\n}\n```\n\nps：[VisuAlgo](https://visualgo.net/zh) 以动画的方式展示了数据结构基本操作的原理，还有代码实现。\n\n## 练习\n链表的题目会用到一个 ListNode 节点类，所以先创建一个节点类：\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n    }\n}\n```\n\n### 删除链表中的节点\n基本操作：  \n1. 以题目的类型和题目名称分别创建“链表”包和“_237_删除链表中的节点”文件；\n2. 保存改题目的连接：[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)，方便以后查看；\n3. 拷贝网页中的条件及题目；\n![链表11](链表/链表11.png)\n\n分析：删除指定节点 node，可以将 node 下一个节点的内容覆盖掉 node 的内容，让后将 node 的下一个节点删除掉 `node.next = node.next.next`：\n```\npublic void deleteNode(ListNode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n}\n```\n图解：\n![链表12](链表/链表12.png)\n\n### 反转一个链表\n[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n![链表13](链表/链表13.png)\n#### 递归\n[5, 4, 3, 2, 1] 传入4，reverseList(4) -> [1, 2, 3, 4]：\n![链表14](链表/链表14.png)\n代码实现：\n```\n//[5, 4, 3, 2, 1], head：5\npublic ListNode reverseList(ListNode head) {\n    // 添加边界，避免死循环\n    // head == null 表示没有元素\n    // head.next == null 表示只有一个元素\n    if (head == null || head.next == null) return head;\n    \n    // 1->2, 2->3, 3->4, 4->5\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n}\n```\n\n#### 迭代\nnewHead, head -> [5, 4, 3, 2, 1]  \nnewHead -> [5], head -> [4, 3, 2, 1]  \nnewHead -> [5, 4], head -> [3, 2, 1]  \n...\n![链表15](链表/链表15.png)\n代码实现：\n```\npublic ListNode reverseList2(ListNode head) {\n    if (head == null || head.next == null) return head;\n    \n    ListNode newHead = null;\n    while (head != null) {\n        ListNode tmp = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = tmp;\n    }\n    return newHead;\n}\n```\n\n### 判断一个链表是否有环\n[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)  \n快慢指针：slow 移动1个元素/次，fast 移动2个元素/次，当 slow 和 fast 相遇的时候，说明链表有环。\n![链表16](链表/链表16.png)\n代码实现：\n```\npublic boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) return false;\n    \n    ListNode slow = head;\n    ListNode fast = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}\n```\n\n### 移除链表元素\n[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n```\npublic ListNode removeElements(ListNode head, int val) {\n    if (head == null) return head;\n    \n    // 遍历链表\n    ListNode node = head;\n    while (node.next != null) {\n        if (node.next.val == val) {\n            node.next = node.next.next;\n        } else {\n            node = node.next;\n        }\n    }\n\n    // 判断头结点\n    if (head.val == val) {\n        if (head.next == null) {\n            return null;\n        } else {\n            head = head.next;\n        }\n    }\n    \n    return head;\n}\n```\n\n### 删除排序链表中的重复元素\n[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/)\n```\npublic ListNode deleteDuplicates(ListNode head) {\n    if (head == null || head.next == null) return head;\n    // 遍历链表\n    ListNode node = head;\n    while (node != null) {\n        \n        // 从 node 开始遍历链表\n        ListNode targetNode = node;\n        while (targetNode.next != null) {\n            if (targetNode.next.val == node.val) {\n                targetNode.next = targetNode.next.next;\n            } else {\n                targetNode = targetNode.next;   \n            }\n        }\n        \n        node = node.next;\n    }\n    \n    return head;\n}\n```\n\n### 链表的中间节点\n[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n```\npublic ListNode middleNode(ListNode head) {\n    int count = 0; // 标记链表长度\n    // 遍历链表\n    ListNode node = head;\n    while (node != null) {\n        count++;\n        node = node.next;\n    }\n    \n    count = count/2;\n    // 遍历链表\n    while (node != null) {\n        if (count > 0) {\n            count--;\n        } else {\n            break; // 此时 node 为中间节点\n        }\n        node = node.next;\n    }\n    \n    return node;\n}\n```\n\n## 虚拟结点\n在链表的最前面增加一个虚拟头结点（不存储数据），可以统一所有节点的处理逻辑，让代码更加精简：\n```\n// 添加构造方法，添加虚拟头结点\npublic LinkedList2() {\n    first = new Node<>(null, null);\n}\n\n// 修改add\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    Node<E> prev = index == 0 ? first : node(index - 1);\n    prev.next = new Node<>(element, prev.next);\n    size++;\n}\n\n// 修改remove\npublic E remove(int index) {\n    rangeCheck(index);\n    Node<E> prev = index == 0 ? first : node(index - 1);\n    Node<E> node = prev.next;\n    prev.next = node.next;\n    size--;\n    return node.element;\n}\n\n// 修改node\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first.next;\n    for (int i = 0; i < index; i++) {\n        node = node.next;\n    }\n    return node;\n}\n```\n\n## 复杂度分析\n![链表18](链表/链表18.png)\n\n### 动态数组\n#### add(E element)\n最好情况复杂度：在 `index == size` 处添加元素，不需要移动任何元素，复杂度 O(1)；  \n最坏情况复杂度：在 `index == size` 处添加元素时容量不够需要扩容，所有元素都要移动到新扩容的数组里，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 1 + 1 + ... + 1 + n) / n` -> O(2n/2)，复杂度 O(1)；  \n均摊复杂度：O(1)。\n\n均摊复杂度：假设最大容量是4，扩容相当于每次 add 的操作次数是 2，也就是O(1)复杂度：\n![链表19](链表/链表19.png)\n在经过连续的多次复杂度比较低的情况后，出现个别复杂度比较高的情况时，适合均摊复杂度。\n\n#### add(int index, E element)\n最好情况复杂度：在 `index == size` 处添加元素，不需要移动任何元素，复杂度 O(1)；  \n最坏情况复杂度：在 `index == 0` 处添加元素，所有元素都要向后移动一位，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### remove\n最好情况复杂度：删除 `index == size - 1` 处的元素，不需要移动任何元素，复杂度 O(1)； \n最坏情况复杂度：删除 `index == 0` 处的元素，所有元素都要向前移动一位，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### set & get\n数组的随机访问速度非常快，`elements[n]` 的效率与 n 是多少无关。\n![链表17](链表/链表17.png)\n\n### 单向链表\n#### add\n最好情况复杂度：在 `index == 0` 处添加元素，只需要创建一个新的节点，并让 first 指向该节点，复杂度 O(1)；  \n最坏情况复杂度：在 `index == size - 1` 处添加元素，需要遍历所有节点，才能找到最后一个节点，并让最后一个节点指向新创建的节点，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### remove\n最好情况复杂度：删除 `index == 0` 处的元素，只需要找到 first，并让 first 指向该节点的下一个节点，复杂度 O(1)；  \n最坏情况复杂度：删除 `index == size - 1` 处的元素，需要遍历所有节点，才能找到倒数第二个节点，并让倒数第二个节点指向 null，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n#### set & get\n最好情况复杂度：查找 `index == 0` 处的元素，不需要遍历，直接通过 `first.next` 就可以找到第一个节点，复杂度 O(1)；  \n最坏情况复杂度：查找 `index == size - 1` 处的元素，需要遍历所有节点，才能找到最后一个节点，复杂度 O(n)；  \n平均情况复杂度：所有情况的移动次数相加再除以元素个数：`(1 + 2 + 3 + ... + n) / n` -> O(n/2)，复杂度 O(n)。\n\n# 双向链表\n![链表20](链表/链表20.png)\n双向链表的代码实现，是在单向链表的代码基础上进行以下修改👇。\n\n## set&get\n只需要修改 `node()` 方法即可：\n```\nprivate Node<E> node(int index) {\n    rangeCheck(index);\n    \n    if (index < (size >> 1)) {\n        Node<E> node = first;\n        for (int i = 0; i < index; i++) {\n            node = node.next;\n        }\n        return node;\n    } else {\n        Node<E> node = last;\n        for (int i = size - 1; i > index; i--) {\n            node = node.prev;\n        }\n        return node;\n    }\n}\n```\n\n## add\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == size) {\n        Node<E> oldLast = last;\n        last = new Node<>(oldLast, element, null);\n        if (oldLast == null) { // 这是链表添加的第一个元素\n            first = last;\n        } else {\n            oldLast.next = last;\n        }\n    } else {\n        Node<E> next = node(index);\n        Node<E> prev = next.prev;\n        Node<E> node = new Node<>(prev, element, next);\n        next.prev = node;\n        \n        if (prev == null) { // index == 0\n            first = node;\n        } else {\n            prev.next = node;\n        }\n    }\n    size++;\n}\n```\n在 `0 < index < size` 处添加元素：\n![链表22](链表/链表22.png)\n在 `index == 0` 处添加元素：\n![链表21](链表/链表21.png)\n在 `index == size` 处添加元素，分为首次添加元素和非首次添加元素：  \n首次添加元素：\n![链表23](链表/链表23.png)\n非首次添加元素：\n![链表24](链表/链表24.png)\n\n## remove\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = node(index);\n    Node<E> prev = node.prev;\n    Node<E> next = node.next;\n    \n    if (prev == null) { // index == 0\n        first = next;\n    } else {\n        prev.next = next;\n    }\n    \n    if (next == null) { // index == size - 1\n        last = prev;\n    } else {\n        next.prev = prev;\n    }\n    \n    size--;\n    return node.element;\n}\n```\n删除 `0 < index < size` 处的元素：\n![链表25](链表/链表25.png)\n删除 `index == 0` 处的元素：\n![链表26](链表/链表26.png)\n\n## 测试\n修改 LinkedList 的 `toString()` 方法：\n```\npublic String toString() {\n    StringBuilder string = new StringBuilder();\n    string.append(\"size=\").append(size).append(\", [\");\n    Node<E> node = first;\n    for (int i = 0; i < size; i++) {\n        if (i != 0) {\n            string.append(\", \");\n        }\n        string.append(node);\n        \n        node = node.next;\n    }\n    string.append(\"]\");\n    return string.toString();\n}\n```\n\n在 `class Node<E>` 里重写 `toString()` 方法：\n```\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    \n    if (prev != null) {\n        sb.append(prev.element);\n    } else {\n        sb.append(\"null\");\n    }\n    \n    sb.append(\"_\").append(element).append(\"_\");\n\n    if (next != null) {\n        sb.append(next.element);\n    } else {\n        sb.append(\"null\");\n    }\n    \n    return sb.toString();\n}\n```\n\n在 Main.java 里添加测试代码：\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Integer> list = new LinkedList<>();\n        list.add(12);\n        list.add(0, 11);\n        list.add(13);\n        list.add(14);\n        list.add(15);\n        list.add(list.size(), 16);\n        \n        list.remove(1);\n        list.remove(2);\n        \n        System.out.println(list);\n    }\n}\n```\n\n打印结果：\n```\nsize=4, [null_11_13, 11_13_15, 13_15_16, 15_16_null]\n```\n\n## 双向链表 vs 单向链表\n单向链表：`1 + 2 + 3 + ... + n = (1 + n) * n/2 = n/2 + (n^2)/2`，除以 n 平均一下是 `1/2 + n/2`；  \n双向链表：`(1 + 2 + 3 + ... + n/2) * 2 = ((1 + n/2) * n/2)/2 * 2 = n/2 + (n^2)/4`，除以 n 平均一下是 `1/2 + n/4`。\n\n## 双向链表 vs 动态数组\n动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）；   \n双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费。\n\n## 源码分析\n### 成员变量\n```\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n */\ntransient Node<E> last;\n```\n\n### add\n```\n/**\n * Inserts the specified element at the specified position in this list.\n * Shifts the element currently at that position (if any) and any\n * subsequent elements to the right (adds one to their indices).\n *\n * @param index index at which the specified element is to be inserted\n * @param element element to be inserted\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\n/**\n * Links e as last element.\n */\nvoid linkLast(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n\n/**\n * Inserts element e before non-null Node succ.\n */\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n### remove\n```\n/**\n * Removes the element at the specified position in this list.  Shifts any\n * subsequent elements to the left (subtracts one from their indices).\n * Returns the element that was removed from the list.\n *\n * @param index the index of the element to be removed\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\n/**\n * Unlinks non-null node x.\n */\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n### set&get\n```\n/**\n * Returns the element at the specified position in this list.\n *\n * @param index index of the element to return\n * @return the element at the specified position in this list\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element.\n *\n * @param index index of the element to replace\n * @param element element to be stored at the specified position\n * @return the element previously at the specified position\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n\n/**\n * Returns the (non-null) Node at the specified element index.\n */\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n# 单向循环链表\n![链表27](链表/链表27.png)\n单向循环链表中只有一个元素的情况：\n![链表33](链表/链表33.png)\n在单向链表的代码基础上进行修改，需要修改的有 `add()` 和 `remove()` 方法。\n## add\n单向循环链表的添加，主要是在 `index == 0` 处的逻辑需要修改：\n1. 让最后面节点的 next 指向新添加的节点；\n2. 让 first 指向新添加的节点；\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == 0) {\n        Node<E> newFirst = new Node<>(element, first);\n        // 拿到最后一个节点\n        Node<E> last = (size == 0) ? newFirst : node(size - 1);\n        last.next = newFirst;\n        first = newFirst;\n    } else {\n        Node<E> prev = node(index - 1);\n        prev.next = new Node<>(element, prev.next); \n    }\n    size++;\n}\n```\n\n## remove\n单向循环链表的删除，主要是在 `index == 0` 处的逻辑需要修改：\n1. 如果链表中只有一个节点，直接让 `first = null`；\n2. 让 first 指向 `index == 1` 处的元素；\n3. 让 last 指向 `index == 1` 处的元素（`last.next = first`）；\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (index == 0) {\n        if (size == 1) {\n            first = null;\n        } else {\n            Node<E> last = node(size - 1); // 必须在 first = first.next 前获取\n            first = first.next;\n            last.next = first;\n        }\n    } else {\n        Node<E> prev = node(index - 1);\n        node = prev.next;\n        prev.next = node.next;  \n    }\n    size--;\n    return node.element;\n}\n```\n\n# 双向循环链表\n![链表28](链表/链表28.png)\n在双向链表的代码基础上进行修改，需要修改的有 `add()` 和 `remove()` 方法。\n## add\n```\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    \n    if (index == size) { // index == size\n        Node<E> oldLast = last;\n        last = new Node<>(oldLast, element, first);\n        if (oldLast == null) { // 这是链表添加的第一个元素\n            first = last;\n            first.prev = first;\n            first.next = first;\n        } else {\n            oldLast.next = last;\n            first.prev = last;\n        }\n    } else {\n        Node<E> next = node(index);\n        Node<E> prev = next.prev;\n        Node<E> node = new Node<>(prev, element, next);\n        next.prev = node;\n        prev.next = node; // 双向链表中，prev 一定不为 null\n        \n        if (next == first) { // index == 0\n            first = node;\n        }\n    }\n    size++;\n}\n```\n![链表29](链表/链表29.png)\n双向循环链表中只有一个节点的情况：\n![链表30](链表/链表30.png)\n\n## remove\n```\npublic E remove(int index) {\n    rangeCheck(index);\n    \n    Node<E> node = first;\n    if (size == 0) {\n        first = null;\n        last = null;\n    } else {\n        node = node(index);\n        Node<E> prev = node.prev;\n        Node<E> next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        \n        if (node == first) { // index == 0\n            first = next;\n        }\n        \n        if (node == last) { // index == size - 1\n            last = prev;\n        }\n    }\n    size--;\n    return node.element;\n}\n```\n\n## 练习 - 约瑟夫问题\n从1开始数，数到三就去掉：\n![链表31](链表/链表31.png)\n\n为了发挥循环链表的最大威力，增设1个成员变量、3个方法：\n1. `current`：用于指向某个节点；\n2. `void reset()`：让 `current` 指向头结点 `first`；\n3. `E next()`：让 `current` 往后走一步，也就是 `current = current.next`;\n4. `E remove()`：删除 `current` 指向的节点，删除成功后让 `current` 指向下一个节点；\n![链表32](链表/链表32.png)\n\n相关代码：\n```\npublic void reset() {\n    current = first;\n}\n\npublic E next() {\n    if (current == null) return null;\n    \n    current = current.next;\n    return current.element;\n}\n\npublic E remove() {\n    if (current == null) return null;\n    \n    E element = remove(current);\n    if (size == 0) {\n        current = null;\n    } else {\n        current = current.next;\n    }\n    \n    return element;\n}\n\npublic E remove(int index) {\n    rangeCheck(index);\n    return remove(node(index));\n}\n\npublic E remove(Node<E> node) {\n    if (size == 0) {\n        first = null;\n        last = null;\n    } else {\n        Node<E> prev = node.prev;\n        Node<E> next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        \n        if (node == first) { // index == 0\n            first = next;\n        }\n        \n        if (node == last) { // index == size - 1\n            last = prev;\n        }\n    }\n    size--;\n    return node.element;\n}\n```\n\n测试：\n```\nstatic void josephus() {\n    CircleLinkedList<Integer> list = new CircleLinkedList<>();\n    for (int i = 1; i <= 8; i++) {\n        list.add(i);\n    }\n    \n    // 指向头结点（指向1）\n    list.reset();\n    \n    while (!list.isEmpty()) {\n        list.next();\n        list.next();\n        System.out.println(list.remove());\n    }\n}\n```\n\n打印结果：\n```\n3\n6\n1\n5\n2\n8\n4\n7\n```\n\n# 静态链表\n单向链表、双向链表、单向循环链表和双向循环链表，都是依赖于指针实现的。在早期的编程语言中，有些是没有指针的，比如 BASIC、FORTRAN 语言。它们通过数组来模拟链表，成为静态链表。\n\n在一个数组中，每个元素存放两个数据，一个是数值，一个是下一个元素的索引。比如第一个元素是的值是 11，下一个元素是索引为 3 的元素（44）：\n![链表34](链表/链表34.png)\n相当于下面这个链表：\n![链表35](链表/链表35.png)\n\n* 思考：如果数组的每个元素只能存放1个数据呢？  \n  使用2个数组，一个数组存放索引关系，另一个数组存放值。\n\n# 动态数组优化\n定义变量 `int first`，标记首元素的索引。如获取 index 的元素可以通过 `first + index % elements.length` 对应元素的坐标。\n\n## remove\n### 删除首元素 \n当前数组 `first == 0`：\n![链表36](链表/链表36.png)\n删除首元素，让 `first = 1`：\n![链表37](链表/链表37.png)\n删除首元素，让 `first = 2`：\n![链表38](链表/链表38.png)\n### 删除中间元素\n当前数组 `first == 0`：\n![链表43](链表/链表43.png)\n删除1处的元素，让0处的元素向后移动一位，覆盖掉1处的元素，并将0处的元素清空，最后让 `first = 1`：\n![链表44](链表/链表44.png)\n代码实现：\n```\npublic E remove(int index) {\n\trangeCheck(index);\n\t\n\tint oldIndex = (first + index) % elements.length;\n\tE old = elements[oldIndex];\n\t\n\tif (index * 2 >= size) {\n\t\tfor (int i = index + 1; i < size; i++) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[nextIndex] = elements[newIndex];\n\t\t}\n\t\tint last = (first + size - 1) % elements.length;\n\t\telements[last] = null;\n\t} else {\n\t\tfor (int i = index; i > 0; i--) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\telements[first] = null;\n\t\tfirst = (first + 1) < elements.length ? first + 1 : 0;\n\t}\n\tsize--;\n\ttrim();\n\treturn old;\n}\n```\n\n## add\n### 在末尾添加\n当前数组 `first == 2`：\n![链表38](链表/链表38.png)\n在数组末尾添加，此时不需要修改 first， `first = 2`：\n### 在头部添加\n![链表39](链表/链表39.png)\n在数组的头部添加元素，让 `first = 1`：\n![链表40](链表/链表40.png)\n在数组的头部添加元素，让 `first = 0`：\n![链表41](链表/链表41.png)\n在数组的头部添加元素，让 `first = 8`：\n![链表42](链表/链表42.png)\n### 在中间添加\n当前数组 `first == 1`：\n![链表40](链表/链表40.png)\n在 3 处插入99，只需要让1、2处的元素往前移动一位，让 `first = 0`：\n![链表43](链表/链表43.png)\n代买实现：\n```\npublic void add(int index, E element) {\n\trangeCheckForAdd(index);\n\t\n\tensureCapacity(size + 1);\n\t\n\tif (index * 2 >= size) {\n\t\tfor (int i = size; i > index; i--) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i - 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\tindex = (first + index) % elements.length;\n\t\telements[index] = element;\n\t} else {\n\t\tfirst = (first - 1) >= 0 ? first - 1 : elements.length - 1;\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tint newIndex = (first + i) % elements.length;\n\t\t\tint nextIndex = (first + i + 1) % elements.length;\n\t\t\telements[newIndex] = elements[nextIndex];\n\t\t}\n\t\tindex = (first + index) % elements.length;\n\t\telements[index] = element;\n\t}\n\tSystem.out.println(first);\n\tsize++;\n}\n```\n## set&get\n通过 `first + index % elements.length` 对应元素的坐标，然后获取元素：\n```\npublic E get(int index) { //O(1)\n\trangeCheck(index);\n\tindex = (first + index) % elements.length;\n\treturn elements[index];\n}\n\npublic E set(int index, E element) { //O(1)\n\trangeCheck(index);\n\tindex = (first + index) % elements.length;\n\tE old = elements[index];\n\telements[index] = element;\n\treturn old;\n}\n```\n\n## 扩容\n当数组装满后，新创建一个容量扩大1.5倍的数组，将原数组里的元素移动到新数组里，从0开始填充，`first = 0`。\n```\nprivate void ensureCapacity(int capacity) {\n\tint oldCapacity = elements.length;\n\tif (oldCapacity >= capacity) return;\n\t// 新容量为就容量的1.5倍\n\tint newCapacity = oldCapacity + (oldCapacity >> 1); //iOS 1.6, java 1.5, >> 表示除以2\n\tE[] newElements = (E[]) new Object[newCapacity];\n\tfor (int i = 0; i < size; i++) {\n\t\tint index = (first + i) % elements.length;\n\t\tnewElements[i] = elements[index];\n\t}\n\telements = newElements;\n\tfirst = 0;\n\t\n\tSystem.out.println(oldCapacity + \"扩容为\" + newCapacity);\n}\n```\n\n## 缩容\n当数组满足缩容条件时，新创建一个容量按规则缩小的数组，将原数组里的元素移动到新数组里，从0开始填充，`first = 0`。\n```\nprivate void trim() {\n\tint oldCapacity = elements.length;\n\tint newCapacity = oldCapacity >> 1;\n\t// 剩余空间小于一半 || 空间大小 <= 默认空间\n\tif (size >= newCapacity || oldCapacity <= DEFAULT_CAPACITY) return;\n\t\n\tE[] newElements = (E[]) new Object[newCapacity];\n\tfor (int i = 0; i < size; i++) {\n\t\tint newIndex = (first + i) % elements.length;\n\t\tnewElements[i] = elements[newIndex];\n\t}\n\telements = newElements;\n\tfirst = 0;\n\t\n\tSystem.out.println(oldCapacity + \"缩容为\" + newCapacity);\n}\n```\n\n## 后期优化\n```\nprivate int Index(int index) {\n    index += first;\n    if (index < 0) {\n        return index + elements.length;\n    }\n\treturn index % elements.length;\n}\n\nprivate void rightMoveFitst() {\n\tfirst = Index(1);\n}\n\nprivate void leftMoveFitst() {\n\tfirst = Index(-1);\n}\n```\n","slug":"数据结构与算法/链表","published":1,"updated":"2023-08-22T09:52:14.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv5002paq7k3swohwmu"},{"title":"Flutter之基础Widget","date":"2023-11-03T07:36:24.000Z","_content":"\n[Text](#text)\n[Button](#button)\n[Image](#image)\n[TextField](#textfield)\n[Form表单](#form表单)\n[ProgressIndicator](#progressindicator)\n\n<!-- more -->\n\n## Text\n\n```dart\nconst Text(\n  String this.data, {      // 文本内容\n  super.key,               // 唯一标识\n  this.style,              // 文本样式\n  this.strutStyle,         // 文本结构样式\n  this.textAlign,          // 文本对齐方式\n  this.textDirection,      // 文本方向\n  this.locale,             // 语言\n  this.softWrap,           // 是否自动换行\n  this.overflow,           // 超出是否截断\n  this.textScaleFactor,    // 文本缩放比例\n  this.maxLines,           // 最大行数\n  this.semanticsLabel,     // 语义标签\n  this.textWidthBasis,     // 文本宽度基准\n  this.textHeightBehavior, // 文本高度行为\n  this.selectionColor,     // 选中颜色\n}) : textSpan = null;      // 文本段落\n```\n\n### 文本展示\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Text\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\n文本展示\n */\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(\n        border: Border.all(width: 1, color: Colors.red),\n      ),\n      child: const Text(\n        \"《登高》唐·杜甫风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\",\n        style: TextStyle(\n          fontSize: 18,\n          color: Colors.black,\n        ),\n      ),\n    );\n  }\n}\n```\n\n![01](Flutter之基础Widget/01.png)\n\n`Container` 的定义：\n\n```dart\nclass Container extends StatelessWidget {\n  Container({\n    super.key,                     // 唯一标识\n    this.alignment,                // 对其方式\n    this.padding,                  // 内边距\n    this.color,                    // 背景色\n    this.decoration,               // 背景装饰\n    this.foregroundDecoration,     // 前景装饰\n    double? width,                 // 宽度\n    double? height,                // 高度\n    BoxConstraints? constraints,   // 约束\n    this.margin,                   // 外边距\n    this.transform,                // 变换\n    this.transformAlignment,       // 变换对齐方式\n    this.child,                    // 子组件\n    this.clipBehavior = Clip.none, // 裁剪行为\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n}\n```\n\n`BoxDecoration` 的定义：\n\n```dart\nclass BoxDecoration extends Decoration {\n  const BoxDecoration({\n    this.color,                       // 颜色\n    this.image,                       // 图片\n    this.border,                      // 边框\n    this.borderRadius,                // 圆角\n    this.boxShadow,                   // 阴影\n    this.gradient,                    // 渐变\n    this.backgroundBlendMode,         // 混合模式\n    this.shape = BoxShape.rectangle,  // 形状\n  }) : assert(\n         backgroundBlendMode == null || color != null || gradient != null,\n         \"backgroundBlendMode applies to BoxDecoration's background color or \"\n         'gradient, but no color or gradient was provided.',\n       );\n}\n```\n\n### 基本属性\n\n```dart\n/*\nText 的基本属性\n */\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Text(\n      \"《登高》唐·杜甫风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\",\n      textAlign: TextAlign.center, // 居中对齐\n      maxLines: 2, // 最大显示两行\n      overflow: TextOverflow.ellipsis, // 超出部分显示 ...\n      textScaleFactor: 1.25, // 文本放大 1.25 倍\n      style: TextStyle(\n        fontSize: 18,\n        color: Colors.black,\n      ),\n    );\n  }\n}\n```\n\n![02](Flutter之基础Widget/02.png)\n\n### 富文本\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(\n        border: Border.all(width: 1, color: Colors.red),\n      ),\n      child: Text.rich(\n        TextSpan(\n          children: [\n            TextSpan(\n                text: \"《登高》\",\n                style: TextStyle(\n                    fontSize: 25,\n                    fontWeight: FontWeight.bold,\n                    color: Colors.red)),\n            TextSpan(\n                text: \"唐·杜甫\",\n                style: TextStyle(fontSize: 18, color: Colors.blue)),\n            TextSpan(\n                text:\n                    \"\\n风急天高猿啸哀，渚清沙白鸟飞回。\\n无边落木萧萧下，不尽长江滚滚来。\\n万里悲秋常作客，百年多病独登台。\\n艰难苦恨繁霜鬓，潦倒新停浊酒杯。\"),\n          ],\n        ),\n        style: TextStyle(fontSize: 16, color: Colors.green),\n        textAlign: TextAlign.center,\n      ),\n    );\n  }\n}\n```\n\n![03](Flutter之基础Widget/03.png)\n\n## Button\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Text\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\n///  * [ElevatedButton], a filled button whose material elevates when pressed .\n///  * [FilledButton], a filled button that doesn't elevate when pressed.\n///  * [FilledButton.tonal], a filled button variant that uses a secondary fill color.\n///  * [OutlinedButton], a button with an outlined border and no fill color.\n///  * [TextButton], a button with no outline or fill color.\n */\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          /*\n          1.\"圆形\"按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          FloatingActionButton(\n            onPressed: () {\n              print(\"FloatingActionButton Click\");\n            },\n            child: Text(\"FloatingActionButton\"),\n          ),\n\n          /*\n          2.“漂浮”按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          ElevatedButton(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            child: Text(\n              \"ElevatedButton\",\n              style: TextStyle(color: Colors.red),\n            ),\n          ),\n\n          /*\n          3.“全圆角”按钮，默认按钮两侧全圆角，不带阴影\n          */\n          FilledButton(\n            onPressed: () {\n              print(\"FilledButton Click\");\n            },\n            child: Text(\"FilledButton\"),\n          ),\n\n          /*\n          4.默认有一个边框，不带阴影切背景透明。按下后，边框颜色会变亮。同时出现背景和阴影（较弱）\n          */\n          OutlinedButton(\n            onPressed: () {\n              print(\"OutlinedButton Click\");\n            },\n            child: Text(\"OutlinedButton\"),\n          ),\n\n          /*\n          5.文本按钮，默认背景透明不带阴影。按下后，会有背景色\n          */\n          TextButton(\n            onPressed: () {\n              print(\"TextButton Click\");\n            },\n            child: Text(\"TextButton\"),\n          ),\n\n          /*\n          6.一个可点击的icon，不包括文字，默认没有背景，点击后出背景\n          */\n          IconButton(\n            onPressed: () {\n              print(\"IconButton Click\");\n            },\n            icon: Icon(Icons.thumb_up),\n          ),\n\n          /*\n          7.带图标和文字的按钮\n          */\n          ElevatedButton.icon(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            icon: Icon(Icons.send),\n            label: Text(\"发送\"),\n          ),\n\n          /*\n          8.带图标和文字的按钮\n          */\n          OutlinedButton.icon(\n            onPressed: () {\n              print(\"OutlinedButton Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"添加\"),\n          ),\n\n          /*\n          9.带图标和文字的按钮\n          */\n          TextButton.icon(\n            onPressed: () {\n              print(\"TextButton Click\");\n            },\n            icon: Icon(Icons.info),\n            label: Text(\"详情\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n```\n\n![04](Flutter之基础Widget/04.png)\n\n### 浮动按钮\n\n圆形浮动按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n\n```dart\n// 浮动按钮\nclass FloatingActionButton extends StatelessWidget {\n  const FloatingActionButton({\n    super.key,                              //唯一标识\n    this.child,                             // 子控件（通常为Icon）         \n    this.tooltip,                           // 悬浮按钮的提示文本\n    this.foregroundColor,                   // 悬浮按钮的前景色\n    this.backgroundColor,                   // 背景色\n    this.focusColor,                        // 悬浮按钮获得焦点时的前景色\n    this.hoverColor,                        // 悬浮按钮悬停时的前景色\n    this.splashColor,                       // 悬浮按钮的点击效果时的前景色\n    this.heroTag = const _DefaultHeroTag(), // 标记\n    this.elevation,                         // 悬浮按钮的z轴高度\n    this.focusElevation,                    // 悬浮按钮获得焦点时的z轴高度\n    this.hoverElevation,                    // 悬浮按钮悬停时的z轴高度\n    this.highlightElevation,                // 悬浮按钮的点击效果时的z轴高度\n    this.disabledElevation,                 // 悬浮按钮禁用时的z轴高度\n    required this.onPressed,                // 悬浮按钮的点击事件\n    this.mouseCursor,                       // 悬浮按钮的鼠标光标\n    this.mini = false,                      // 是否为迷你悬浮按钮\n    this.shape,                             // 悬浮按钮的形状\n    this.clipBehavior = Clip.none,          // 边缘裁剪方式\n    this.focusNode,                         // 焦点节点\n    this.autofocus = false,                 // 自动获取焦点\n    this.materialTapTargetSize,             // 悬浮按钮的尺寸\n    this.isExtended = false,                // 是否为扩展的悬浮按钮\n    this.enableFeedback,                    // 是否为反馈悬浮按钮\n  }) : assert(elevation == null || elevation >= 0.0),\n        assert(focusElevation == null || focusElevation >= 0.0),\n        assert(hoverElevation == null || hoverElevation >= 0.0),\n        assert(highlightElevation == null || highlightElevation >= 0.0),\n        assert(disabledElevation == null || disabledElevation >= 0.0),\n        _floatingActionButtonType = mini ? _FloatingActionButtonType.small : _FloatingActionButtonType.regular,\n        _extendedLabel = null,\n        extendedIconLabelSpacing = null,\n        extendedPadding = null,\n        extendedTextStyle = null;\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          /*\n          1.\"圆形\"按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          FloatingActionButton(\n            onPressed: () {\n              print(\"FloatingActionButton Click\");\n            },\n            child: Text(\"01\"),\n          ),\n          FloatingActionButton.small(\n            onPressed: () {\n              print(\"FloatingActionButton.small Click\");\n            },\n            child: Text(\"02\"),\n          ),\n          FloatingActionButton.large(\n            onPressed: () {},\n            child: Text(\"03\"),\n          ),\n          // 全角\n          FloatingActionButton.extended(\n            onPressed: () {\n              print(\"FloatingActionButton.extended Click\");\n            },\n            label: Text(\"- 04 -\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![05](Flutter之基础Widget/05.png)\n\n### 漂浮按钮\n\n\"漂浮\"按钮，它默认带有阴影和灰色背景。按下后，阴影会变大。\n\n```dart\nclass ElevatedButton extends ButtonStyleButton {\n  const ElevatedButton({\n    super.key,                      //唯一标识\n    required super.onPressed,       // 点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    required super.child,           \n  });\n}\n```\n\n实列\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // “01” 按钮\n          ElevatedButton(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            child: Text(\"01\"),\n          ),\n          // “+ 02” 按钮\n          ElevatedButton.icon(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![06](Flutter之基础Widget/06.png)\n\n### 全角按钮\n\n```dart\nclass FilledButton extends ButtonStyleButton {\n  const FilledButton({\n    super.key,                      // 唯一标识\n    required super.onPressed,       // 点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    required super.child,\n  }) : _variant = _FilledButtonVariant.filled;\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          FilledButton(\n            onPressed: () {\n              print(\"FilledButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          FilledButton.icon(\n            onPressed: () {\n              print(\"FilledButton.icon Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n          FilledButton.tonal(\n            onPressed: () {\n              print(\"FilledButton.tonal Click\");\n            },\n            child: Text(\"03\"),\n          ),\n          FilledButton.tonalIcon(\n            onPressed: () {\n              print(\"FilledButton.tonalIcon Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"04\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![07](Flutter之基础Widget/07.png)\n\n### 边框按钮\n\n默认有一个边框，不带阴影切背景透明。按下后，边框颜色会变亮。同时出现背景和阴影（较弱）。\n\n```dart\nclass OutlinedButton extends ButtonStyleButton {\n    const OutlinedButton({\n      super.key,                      // 唯一标识\n      required super.onPressed,       // 点击事件\n      super.onLongPress,              // 长按事件\n      super.onHover,                  // 悬停事件\n      super.onFocusChange,            // 焦点改变事件\n      super.style,                    // 按钮样式\n      super.focusNode,                // 焦点节点\n      super.autofocus = false,        // 是否自动获取焦点\n      super.clipBehavior = Clip.none, // 边缘裁剪方式\n      super.statesController,         // 状态控制器\n      required super.child,\n    });\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          OutlinedButton(\n            onPressed: () {\n              print(\"OutlinedButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          OutlinedButton.icon(\n            onPressed: () {\n              print(\"OutlinedButton.icon click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`01` 按钮是点击后的样式。\n\n![08](Flutter之基础Widget/08.png)\n\n### 文本按钮\n\n```dart\nclass TextButton extends ButtonStyleButton {\n  const TextButton({\n    super.key,\n    required super.onPressed,       // 按钮点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    super.isSemanticButton,         // 语义化按钮\n    required Widget super.child,\n  });\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextButton(\n            onPressed: () {\n              print(\"TextButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          TextButton(\n            onPressed: () {\n              print(\"TextButton 02 click\");\n            },\n            child: Text(\"02\"),\n          ),\n          TextButton.icon(\n            onPressed: () {\n              print(\"TextButton.icon click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"03\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`02` 按钮是点击时的样式。\n\n![09](Flutter之基础Widget/09.png)\n\n### 图标按钮\n\n```dart\nclass IconButton extends StatelessWidget {\n  const IconButton({\n    super.key,\n    this.iconSize,           // 图标大小\n    this.visualDensity,      // 视觉密度\n    this.padding,            // 内边距\n    this.alignment,          // 对齐方式\n    this.splashRadius,       // 闪动半径\n    this.color,              // 颜色\n    this.focusColor,         // 焦点颜色\n    this.hoverColor,         // 悬停颜色\n    this.highlightColor,     // 高亮颜色\n    this.splashColor,        // 闪动颜色\n    this.disabledColor,      // 禁用颜色\n    required this.onPressed, // 按钮点击事件\n    this.mouseCursor,        //\n    this.focusNode,          // 焦点节点\n    this.autofocus = false,  // 是否自动获取焦点\n    this.tooltip,            // 提示文本\n    this.enableFeedback,     // 是否为反馈按钮\n    this.constraints,        //\n    this.style,              // 样式\n    this.isSelected,         // 是否选中\n    this.selectedIcon,       // 选中图标\n    required this.icon,\n  }) : assert(splashRadius == null || splashRadius > 0),\n        _variant = _IconButtonVariant.standard;\n}\n```\n\n<!-- 示例 -->\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          IconButton(\n            onPressed: () {\n              print(\"IconButton click\");\n            },\n            icon: Icon(Icons.add),\n          ),\n          IconButton.filled(\n            onPressed: () {\n              print(\"IconButton.filled click\");\n            },\n            icon: Icon(Icons.send),\n          ),\n          IconButton.filledTonal(\n            onPressed: () {\n              print(\"IconButton.filledTonal click\");\n            },\n            icon: Icon(Icons.search),\n          ),\n          IconButton.outlined(\n            onPressed: () {\n              print(\"IconButton.outlined click\");\n            },\n            icon: Icon(Icons.list),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`+` 按钮是点击时的样式。\n\n![10](Flutter之基础Widget/10.png\n\n### 自定义按钮\n\n继承自 `ButtonStyleButton` 的按钮有\n\n1. `FloatingActionButton`\n2. `ElevatedButton`\n3. `FilledButton`\n4. `OutlinedButton`\n5. `TextButton`\n\n在 VSCode 中可以通过「右键」+「转到实现」也可以查看（选中 ButtonStyleButton 字段），在 Android Studio 中可以使用快捷键 `optino + command + b` 查看。\n\n![11](Flutter之基础Widget/11.png)\n\n```dart\nabstract class ButtonStyleButton extends StatefulWidget {\n  const ButtonStyleButton({\n    super.key,\n    required this.onPressed,     // 点击事件\n    required this.onLongPress,   // 长按事件\n    required this.onHover,       // 悬停事件\n    required this.onFocusChange, // 焦点事件\n    required this.style,         // 按钮样式\n    required this.focusNode,     // 焦点节点\n    required this.autofocus,     // 自动获取焦点\n    required this.clipBehavior,  // 裁剪行为\n    this.statesController,       // 状态控制器\n    this.isSemanticButton = true,// 语义按钮\n    required this.child,\n  });\n}\n```\n\n按钮样式:\n\n```dart\nclass ButtonStyle with Diagnosticable {\n  /// Create a [ButtonStyle].\n  const ButtonStyle({\n    this.textStyle,        // 文本样式\n    this.backgroundColor,  // 背景颜色\n    this.foregroundColor,  // 前景颜色\n    this.overlayColor,     // 覆盖颜色\n    this.shadowColor,      // 阴影颜色\n    this.surfaceTintColor, // 表面着色颜色\n    this.elevation,        // 阴影\n    this.padding,          // 内边距\n    this.minimumSize,      // 最小尺寸\n    this.fixedSize,        // 固定尺寸\n    this.maximumSize,      // 最大尺寸\n    this.iconColor,        // 图标颜色\n    this.iconSize,         // 图标尺寸\n    this.side,             // 边框\n    this.shape,            // 形状\n    this.mouseCursor,      // 鼠标光标\n    this.visualDensity,    // 视觉密度\n    this.tapTargetSize,    // 触摸目标尺寸\n    this.animationDuration,// 动画时长\n    this.enableFeedback,   // 反馈\n    this.alignment,        // 文本对齐方式\n    this.splashFactory,    // 溅射工厂\n  });\n}\n```\n\n自定义按钮：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextButton(\n            child: Text(\n              \"自定义样式\",\n              style: TextStyle(color: Colors.red), // 字体颜色\n            ),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.lightGreen, // 背景色\n              shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(10)), // 设置圆角\n              elevation: 2, // 通过添加阴影，设置按钮漂浮高度\n            ),\n            onPressed: () {\n              print(\"FilledButton click\");\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![12](Flutter之基础Widget/12.png)\n\n## Image\n\n### 加载网络图片\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"图片\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Container(\n            width: 300,\n            height: 400,\n            decoration: BoxDecoration(\n              border: Border.all(color: Colors.red, width: 2),\n            ),\n            child: Image.network(\n              \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n              alignment: Alignment.center,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之基础Widget/13.png)\n\n### 加载本地图片\n\n加载本地图片，需要先将图片放到`assets`目录下，然后通过`Image.asset`加载。\n\n![16](Flutter之基础Widget/16.png)\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 300,\n        height: 400,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 2),\n        ),\n        child: Image.asset('assets/images/01.png'),\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之基础Widget/13.png)\n\n### 填充方式\n\n- `fill`：填充，图片会根据容器的尺寸进行拉伸\n- `contain`：包含，图片会保持宽高比，并缩放至完全适应容器\n- `cover`：覆盖，图片会保持宽高比，并缩放至完全覆盖容器\n- `fitWidth`：填充宽度，图片会保持宽高比，并缩放至容器宽度\n- `fitHeight`：填充高度，图片会保持宽高比，并缩放至容器高度\n- `none`：不填充，图片会保持原始大小，并居中显示\n\n#### fill\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Container(\n            width: 300,\n            height: 400,\n            decoration: BoxDecoration(\n              border: Border.all(color: Colors.red, width: 2),\n            ),\n            child: Image.network(\n              \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n              alignment: Alignment.center,\n              fit: BoxFit.fill,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![14](Flutter之基础Widget/14.png)\n\n#### contain\n\n默认填充方式\n\n```dart\nfit: BoxFit.contain,\n```\n\n![13](Flutter之基础Widget/13.png)\n\n#### cover\n\n```dart\nfit: BoxFit.cover,\n```\n\n![15](Flutter之基础Widget/15.png)\n\n#### fitWidth\n\n```dart\nfit: BoxFit.fitWidth,\n```\n\n![13](Flutter之基础Widget/13.png)\n\n#### fitHeight\n\n```dart\nfit: BoxFit.fitHeight,\n```\n\n![15](Flutter之基础Widget/15.png)\n\n### 头像\n\n#### 方式一：CircleAvatar\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 2),\n        ),\n        child: CircleAvatar(\n          radius: 100,\n          backgroundImage: AssetImage('assets/images/01.png'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![17](Flutter之基础Widget/17.png)\n\n`CircleAvatar` 的定义：\n\n```dart\nclass CircleAvatar extends StatelessWidget {\n  const CircleAvatar({\n    super.key,                   // 唯一标识\n    this.child,                  // 子控件\n    this.backgroundColor,        // 背景颜色\n    this.backgroundImage,        // 背景图片\n    this.foregroundImage,        // 前景图片\n    this.onBackgroundImageError, // 背景图片错误回调\n    this.onForegroundImageError, // 前景图片错误回调\n    this.foregroundColor,        // 前景颜色\n    this.radius,                 // 半径\n    this.minRadius,              // 最小半径\n    this.maxRadius,              // 最大半径\n  }) : assert(radius == null || (minRadius == null && maxRadius == null)),\n       assert(backgroundImage != null || onBackgroundImageError == null),\n       assert(foregroundImage != null || onForegroundImageError== null);\n}\n```\n\n#### 方式二：Container+BoxDecoration\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 10),\n          borderRadius: BorderRadius.all(Radius.circular(100)),\n          image: DecorationImage(\n            image: AssetImage(\"assets/images/01.png\"),\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![18](Flutter之基础Widget/18.png)\n\n`DecorationImage` 的定义：\n\n```dart\nclass DecorationImage {\n  const DecorationImage({\n    required this.image,                    // 图片\n    this.onError,                           // 错误回调\n    this.colorFilter,                       // 颜色过滤器\n    this.fit,                               // 填充方式\n    this.alignment = Alignment.center,      // 位置\n    this.centerSlice,                       // 切片\n    this.repeat = ImageRepeat.noRepeat,     // 重复方式\n    this.matchTextDirection = false,        // 文本方向\n    this.scale = 1.0,                       // 缩放\n    this.opacity = 1.0,                     // 透明度\n    this.filterQuality = FilterQuality.low, // 过滤器\n    this.invertColors = false,              // 反色\n    this.isAntiAlias = false,               // 抗锯齿\n  });\n}\n```\n\n#### 方式三：ClipOval\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container\n      (\n        decoration: BoxDecoration(\n          border: Border.all(width: 2, color: Colors.red),\n        ),\n        child: ClipOval(\n          child: Image.network(\n            \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n            fit: BoxFit.cover,\n            width: 200,\n            height: 200,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![19](Flutter之基础Widget/19.png)\n\n`ClipOval` 的定义：\n\n```dart\nclass ClipOval extends SingleChildRenderObjectWidget {\n  const ClipOval({\n    super.key,\n    this.clipper, // 裁剪\n    this.clipBehavior = Clip.antiAlias, // 边缘裁剪方式\n    super.child,\n  });\n}\n```\n\n### 圆角图片\n\n![20](Flutter之基础Widget/20.png)\n\n#### 方式一：Container+BoxDecoration\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(width: 2, color: Colors.red),\n          borderRadius: BorderRadius.circular(10),\n        ),\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(10),\n          child: Image.network(\n            'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg',\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n#### 方式二：ClipRRect\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(20),\n          child: Image.network(\n            'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg',\n            width: 200,\n            height: 200,\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## TextField\n\n定义：\n\n```dart\nclass TextField extends StatefulWidget {\n  const TextField({\n    super.key,                                         // 唯一标识\n    this.controller,                                   // 控制器（👇）\n    this.focusNode,                                    // 焦点\n    this.undoController,                               // 撤销控制器\n    this.decoration = const InputDecoration(),         // 装饰器\n    TextInputType? keyboardType,                       // 键盘类型\n    this.textInputAction,                              // 文本输入动作\n    this.textCapitalization = TextCapitalization.none, // 文本大写\n    this.style,                                        // 样式\n    this.strutStyle,                                   // 结构样式\n    this.textAlign = TextAlign.start,                  // 文本对齐\n    this.textAlignVertical,                            // 文本垂直对齐\n    this.textDirection,                                // 文本方向\n    this.readOnly = false,                             // 只读\n    @Deprecated(\n      'Use `contextMenuBuilder` instead. '\n      'This feature was deprecated after v3.3.0-0.5.pre.',\n    )\n    this.toolbarOptions,              // 工具栏选项（长按或鼠标右击时出现的菜单，包括 copy、cut、paste 以及 selectAll。）\n    this.showCursor,                  // 显示光标\n    this.autofocus = false,           // 自动聚焦\n    this.obscuringCharacter = '•',    // 隐藏字符\n    this.obscureText = false,         // 隐藏文本\n    this.autocorrect = true,          // 自动更正\n    SmartDashesType? smartDashesType, // 智能断句\n    SmartQuotesType? smartQuotesType, // 智能引号\n    this.enableSuggestions = true,    // 启用建议\n    this.maxLines = 1,                // 最大行数\n    this.minLines,                    // 最小行数\n    this.expands = false,             // 扩展\n    this.maxLength,                   // 最大长度\n    this.maxLengthEnforcement,        // 当输入文本长度超过maxLength时如何处理，如截断、超出等。\n    this.onChanged,                   // 改变\n    this.onEditingComplete,           // 完成编辑\n    this.onSubmitted,                 // 提交\n    this.onAppPrivateCommand,\n    this.inputFormatters,             // 用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验\n    this.enabled,                     // 如果为false，则输入框会被禁用，禁用状态不能响应输入和事件，同时显示禁用态样式（在其decoration中定义）\n    this.cursorWidth = 2.0,           // 光标宽度\n    this.cursorHeight,                // 光标高度\n    this.cursorRadius,                // 光标半径\n    this.cursorOpacityAnimates,\n    this.cursorColor,                 // 光标颜色\n    this.selectionHeightStyle = ui.BoxHeightStyle.tight,\n    this.selectionWidthStyle = ui.BoxWidthStyle.tight,\n    this.keyboardAppearance,\n    this.scrollPadding = const EdgeInsets.all(20.0),\n    this.dragStartBehavior = DragStartBehavior.start,\n    bool? enableInteractiveSelection,\n    this.selectionControls,\n    this.onTap,\n    this.onTapOutside,\n    this.mouseCursor,\n    this.buildCounter,\n    this.scrollController,\n    this.scrollPhysics,\n    this.autofillHints = const <String>[],\n    this.contentInsertionConfiguration,\n    this.clipBehavior = Clip.hardEdge,\n    this.restorationId,\n    this.scribbleEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contextMenuBuilder = _defaultContextMenuBuilder,\n    this.canRequestFocus = true,\n    this.spellCheckConfiguration,\n    this.magnifierConfiguration,\n  }) : assert(obscuringCharacter.length == 1),\n       smartDashesType = smartDashesType ?? (obscureText ? SmartDashesType.disabled : SmartDashesType.enabled),\n       smartQuotesType = smartQuotesType ?? (obscureText ? SmartQuotesType.disabled : SmartQuotesType.enabled),\n       assert(maxLines == null || maxLines > 0),\n       assert(minLines == null || minLines > 0),\n       assert(\n         (maxLines == null) || (minLines == null) || (maxLines >= minLines),\n         \"minLines can't be greater than maxLines\",\n       ),\n       assert(\n         !expands || (maxLines == null && minLines == null),\n         'minLines and maxLines must be null when expands is true.',\n       ),\n       assert(!obscureText || maxLines == 1, 'Obscured fields cannot be multiline.'),\n       assert(maxLength == null || maxLength == TextField.noMaxLength || maxLength > 0),\n       // Assert the following instead of setting it directly to avoid surprising the user by silently changing the value they set.\n       assert(\n         !identical(textInputAction, TextInputAction.newline) ||\n         maxLines == 1 ||\n         !identical(keyboardType, TextInputType.text),\n         'Use keyboardType TextInputType.multiline when using TextInputAction.newline on a multiline TextField.',\n       ),\n       keyboardType = keyboardType ?? (maxLines == 1 ? TextInputType.text : TextInputType.multiline),\n       enableInteractiveSelection = enableInteractiveSelection ?? (!readOnly || !obscureText);\n}\n```\n\n### TextField 示例及监听\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"TextField\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          MyTextField(),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyTextField extends StatefulWidget {\n  @override\n  _MyTextFieldState createState() => _MyTextFieldState();\n}\n\nclass _MyTextFieldState extends State<MyTextField> {\n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      // 样式\n      decoration: InputDecoration(\n        icon: Icon(Icons.phone),  // 图标\n        labelText: \"手机号\",       // 标签\n        hintText: \"请输入手机号\",   // 输入框提示文字\n        border: InputBorder.none, // 边框\n        filled: true,             // 是否填充\n        fillColor: Colors.yellow, // 填充颜色\n      ),\n      // 监听-输入事件\n      onChanged: (value) {\n        print(\"onChange: $value\");\n      },\n      // 监听-提交事件（回车键）\n      onSubmitted: (value) {\n        print(\"onSubmitted: $value\");\n      },\n      cursorWidth: 1, // 光标宽度\n      cursorColor: Colors.red, // 光标颜色\n    );\n  }\n}\n```\n\n打印信息：\n\n```js\nflutter: onChange: 1\nflutter: onChange: 12\nflutter: onChange: 123\nflutter: onChange: 1234\nflutter: onChange: 12345\nflutter: onChange: 123456\nflutter: onSubmitted: 123456\n```\n\n![21](Flutter之基础Widget/21.png)\n\n### TextField的controller\n\n`TextField` 的 `controller` 属性，用于获取输入框的值，并控制输入框的值。包括设置/获取编辑框的内容，选择编辑内容，监听编辑文本的变化等。需要指定 `TextEditingController` 对象与文本框绑定，如果没有指定，则使用默认的 `TextEditingController`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"TextField\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          MyTextField(),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyTextField extends StatefulWidget {\n  @override\n  _MyTextFieldState createState() => _MyTextFieldState();\n}\n\nclass _MyTextFieldState extends State<MyTextField> {\n  // 1.创建监听器\n  final _textEditingController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    // 2.设置默认值\n    _textEditingController.text = \"Hello World\";\n    // 3.监听文本框\n    _textEditingController.addListener(() {\n      print(\n          \"TextEditingController.addListener: ${_textEditingController.text}\");\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      // 4.设置监听器\n      controller: _textEditingController,\n      decoration: InputDecoration(\n        icon: Icon(Icons.password),\n        labelText: \"密码\",\n        hintText: \"请输入密码\",\n        // border: InputBorder.none, // 边框\n        filled: true,\n        fillColor: Colors.yellow,\n      ),\n      onChanged: (value) {\n        print(value);\n      },\n      onSubmitted: (value) {\n        print(value);\n      },\n    );\n  }\n}\n```\n\n![22](Flutter之基础Widget/22.png)\n\n## Form表单\n\nForm 表单用于将多个输入控件封装起来，并且提供一些辅助功能，比如验证、自动补全、错误提示等。\n\n`TextField` 就是 `Form` 表单的一个子类，在验证过程中，`Form` 表单会自动调用 `TextField` 的 `validate()` 方法，如果 `validate()` 返回 `true`，则表示验证通过，否则表示验证失败。\n\n`Form` 表单可以清除所有输入框的值，也可以重置所有输入框的值。\n\n```dart\nclass Form extends StatefulWidget {\n  const Form({\n    super.key,                          // 唯一标识\n    required this.child,                // 子控件\n    this.onWillPop,                     // 返回键按下时触发\n    this.onChanged,                     // 输入框内容改变时触发\n    AutovalidateMode? autovalidateMode, // 自动验证模式\n  }) : autovalidateMode = autovalidateMode ?? AutovalidateMode.disabled; // 默认关闭自动验证\n}\n```\n\n### FormField\n\n```dart\nclass FormField<T> extends StatefulWidget {\n  const FormField({\n    super.key,                         // 唯一标识\n    required this.builder,             // 构建子控件\n    this.onSaved,                      // 保存回调\n    this.validator,                    // 验证回调\n    this.initialValue,                 // 初始值\n    this.enabled = true,               // 是否可用\n    AutovalidateMode? autovalidateMode,// 自动验证模式\n    this.restorationId,                // 恢复标识\n  }) : autovalidateMode = autovalidateMode ?? AutovalidateMode.disabled;\n}\n```\n\n`FormField` 是一个抽象类，它有两个子类：`TextFormField` 和 `DropdownButtonFormField`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"Form\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: MyForm(),\n    );\n  }\n}\n\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.person),\n              labelText: \"用户名或手机号\",\n            ),\n          ),\n          TextFormField(\n            obscureText: true,\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"密码\",\n            ),\n          ),\n          SizedBox(height: 20), // 输入框和按钮的间距\n          Container(            // 按钮\n            width: double.infinity,\n            height: 44,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![23](Flutter之基础Widget/23.png)\n\n### FormState\n\n`FormState` 是 `Form` 的内部类，它继承自 `State`，用于保存 `Form` 表单的状态。`FormState` 有一个字段 `_formKey`，它是 `GlobalKey<FormState>` 类型的，用于保存 Form 表单的标识。\n\n1. `FormState.save()` 会调用 `Form` 子孙控件的 `save()` 方法，保存表单。\n\n2. `FormState.reset()` 会调用 `Form` 子孙控件的 `reset()` 方法，重置表单。\n\n3. `FormState.validate()` 会调用 `Form` 子孙控件的 `validate()` 方法，验证表单。\n\n#### 保存表单 FormState.save()\n\n```dart\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  final registerFormKey = GlobalKey<FormState>(); // 1.创建标识\n  late String username, password;\n\n  void registerForm() {\n    registerFormKey.currentState?.save(); // 3.登录时，调用 save() 方法\n    print(\"username: $username, password: $password\");\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: registerFormKey, // 2.注册标识，用于获取FormState\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.person),\n              labelText: \"用户名或手机号\",\n            ),\n            onSaved: (value) {\n              print(\"username: $value\");\n              this.username = value ?? \"\"; // 5.保存用户名\n            },\n          ),\n          TextFormField(\n            obscureText: true,\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"密码\",\n            ),\n            onSaved: (value) {\n              print(\"onSaved: $value\");\n              this.password = value ?? \"\"; // 6.保存密码\n            },\n          ),\n          SizedBox(height: 20), // 输入框和按钮的间距\n          Container(\n            // 按钮\n            width: double.infinity,\n            height: 44,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n                this.registerForm();\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![24](Flutter之基础Widget/24.png)\n\n#### 验证表单 FormState.validate()\n\n```dart\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  // 1.创建 GlobalKey\n  final registerFormKey = GlobalKey<FormState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: registerFormKey, // 2.设置GlobalKey，用户获取FormState\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.people),\n              labelText: \"用户名或手机号\",\n            ),\n            validator: (value) {\n              return value?.length == 0 ? \"用户名不能为空\" : null; // 4.验证表单子控件\n            },\n          ),\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"请输入密码\",\n            ),\n            validator: (value) {\n              return (value?.length ?? 0) < 6 ? \"密码长度不能小于6位\" : null; // 4.验证表单子控件\n            },\n          ),\n          SizedBox(\n            height: 20,\n          ),\n          Container(\n            width: double.infinity,\n            height: 40,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n                registerFormKey.currentState?.validate(); // 3.验证表单\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![25](Flutter之基础Widget/25.png)\n\n## ProgressIndicator\n\nMaterial 中的进度指示器包括两种：\n\n- LinerProgressIndicator：线性进度指示器\n- CircularProgressIndicator：环形进度指示器\n\n### LinerProgressIndicator\n\n```dart\nclass LinearProgressIndicator extends ProgressIndicator {\n  const LinearProgressIndicator({\n    super.key,\n    super.value,                           // 0.0 ~ 1.0\n    super.backgroundColor,                 // 背景色\n    super.color,                           // 进度条颜色\n    super.valueColor,                      // 进度条颜色\n    this.minHeight,                        // 最小高度\n    super.semanticsLabel,                  // 语义标签\n    super.semanticsValue,                  // 语义值\n    this.borderRadius = BorderRadius.zero, // 圆角\n  }) : assert(minHeight == null || minHeight > 0);\n}\n```\n\n### CircularProgressIndicator\n\n```dart\nclass CircularProgressIndicator extends ProgressIndicator {\n  const CircularProgressIndicator({\n    super.key,\n    super.value,                          // 0.0 ~ 1.0\n    super.backgroundColor,                // 背景色\n    super.color,                          // 进度条颜色\n    super.valueColor,                     // 进度条颜色\n    this.strokeWidth = 4.0,               // 进度条宽度\n    this.strokeAlign = strokeAlignCenter, // 进度条对齐方式\n    super.semanticsLabel,                 // 语义标签\n    super.semanticsValue,                 // 语义值\n    this.strokeCap,                       // 进度条端点类型\n  }) : _indicatorType = _ActivityIndicatorType.material; // 进度条类型\n}\n```\n\n示例\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"Progress Indicator\"),\n        ),\n        body: Container(\n          padding: EdgeInsets.all(20),\n          child: MyBody(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MyProgressIndicator();\n  }\n}\n\nclass MyProgressIndicator extends StatefulWidget {\n  @override\n  _MyProgressIndicatorState createState() => _MyProgressIndicatorState();\n}\n\nclass _MyProgressIndicatorState extends State<MyProgressIndicator> {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 1.条形进度条。执行一个动画，进度条在滚动\n          LinearProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n          ),\n          SizedBox(height: 50),\n          // 2.条形进度条。进度条显示50%\n          LinearProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n            value: .5,\n          ),\n          SizedBox(height: 50),\n          // 3.圆形进度条。执行动画，进度条在转动\n          CircularProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n          ),\n          SizedBox(height: 50),\n          // 4.圆形进度条\n          CircularProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n            value: .5,\n          ),\n          SizedBox(height: 50),\n          // 5. 自定义尺寸-条形进度条\n          SizedBox(\n            height: 10,\n            child: LinearProgressIndicator(\n              backgroundColor: Colors.grey[200],\n              valueColor: AlwaysStoppedAnimation(Colors.blue),\n              value: .5,\n            ),\n          ),\n          SizedBox(height: 50),\n          // 6. 自定义尺寸-圆形进度条\n          SizedBox(\n            height: 88,\n            width: 100,\n            child: CircularProgressIndicator(\n                backgroundColor: Colors.grey[200],\n                valueColor: AlwaysStoppedAnimation(Colors.blue),\n                value: .7),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![26](Flutter之基础Widget/26.png)\n","source":"_posts/Flutter/Flutter之基础Widget.md","raw":"---\ntitle: Flutter之基础Widget\ndate: 2023-11-03 15:36:24\ntags: Flutter\n---\n\n[Text](#text)\n[Button](#button)\n[Image](#image)\n[TextField](#textfield)\n[Form表单](#form表单)\n[ProgressIndicator](#progressindicator)\n\n<!-- more -->\n\n## Text\n\n```dart\nconst Text(\n  String this.data, {      // 文本内容\n  super.key,               // 唯一标识\n  this.style,              // 文本样式\n  this.strutStyle,         // 文本结构样式\n  this.textAlign,          // 文本对齐方式\n  this.textDirection,      // 文本方向\n  this.locale,             // 语言\n  this.softWrap,           // 是否自动换行\n  this.overflow,           // 超出是否截断\n  this.textScaleFactor,    // 文本缩放比例\n  this.maxLines,           // 最大行数\n  this.semanticsLabel,     // 语义标签\n  this.textWidthBasis,     // 文本宽度基准\n  this.textHeightBehavior, // 文本高度行为\n  this.selectionColor,     // 选中颜色\n}) : textSpan = null;      // 文本段落\n```\n\n### 文本展示\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Text\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\n文本展示\n */\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(\n        border: Border.all(width: 1, color: Colors.red),\n      ),\n      child: const Text(\n        \"《登高》唐·杜甫风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\",\n        style: TextStyle(\n          fontSize: 18,\n          color: Colors.black,\n        ),\n      ),\n    );\n  }\n}\n```\n\n![01](Flutter之基础Widget/01.png)\n\n`Container` 的定义：\n\n```dart\nclass Container extends StatelessWidget {\n  Container({\n    super.key,                     // 唯一标识\n    this.alignment,                // 对其方式\n    this.padding,                  // 内边距\n    this.color,                    // 背景色\n    this.decoration,               // 背景装饰\n    this.foregroundDecoration,     // 前景装饰\n    double? width,                 // 宽度\n    double? height,                // 高度\n    BoxConstraints? constraints,   // 约束\n    this.margin,                   // 外边距\n    this.transform,                // 变换\n    this.transformAlignment,       // 变换对齐方式\n    this.child,                    // 子组件\n    this.clipBehavior = Clip.none, // 裁剪行为\n  }) : assert(margin == null || margin.isNonNegative),\n       assert(padding == null || padding.isNonNegative),\n       assert(decoration == null || decoration.debugAssertIsValid()),\n       assert(constraints == null || constraints.debugAssertIsValid()),\n       assert(decoration != null || clipBehavior == Clip.none),\n       assert(color == null || decoration == null,\n         'Cannot provide both a color and a decoration\\n'\n         'To provide both, use \"decoration: BoxDecoration(color: color)\".',\n       ),\n       constraints =\n        (width != null || height != null)\n          ? constraints?.tighten(width: width, height: height)\n            ?? BoxConstraints.tightFor(width: width, height: height)\n          : constraints;\n}\n```\n\n`BoxDecoration` 的定义：\n\n```dart\nclass BoxDecoration extends Decoration {\n  const BoxDecoration({\n    this.color,                       // 颜色\n    this.image,                       // 图片\n    this.border,                      // 边框\n    this.borderRadius,                // 圆角\n    this.boxShadow,                   // 阴影\n    this.gradient,                    // 渐变\n    this.backgroundBlendMode,         // 混合模式\n    this.shape = BoxShape.rectangle,  // 形状\n  }) : assert(\n         backgroundBlendMode == null || color != null || gradient != null,\n         \"backgroundBlendMode applies to BoxDecoration's background color or \"\n         'gradient, but no color or gradient was provided.',\n       );\n}\n```\n\n### 基本属性\n\n```dart\n/*\nText 的基本属性\n */\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Text(\n      \"《登高》唐·杜甫风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。\",\n      textAlign: TextAlign.center, // 居中对齐\n      maxLines: 2, // 最大显示两行\n      overflow: TextOverflow.ellipsis, // 超出部分显示 ...\n      textScaleFactor: 1.25, // 文本放大 1.25 倍\n      style: TextStyle(\n        fontSize: 18,\n        color: Colors.black,\n      ),\n    );\n  }\n}\n```\n\n![02](Flutter之基础Widget/02.png)\n\n### 富文本\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: BoxDecoration(\n        border: Border.all(width: 1, color: Colors.red),\n      ),\n      child: Text.rich(\n        TextSpan(\n          children: [\n            TextSpan(\n                text: \"《登高》\",\n                style: TextStyle(\n                    fontSize: 25,\n                    fontWeight: FontWeight.bold,\n                    color: Colors.red)),\n            TextSpan(\n                text: \"唐·杜甫\",\n                style: TextStyle(fontSize: 18, color: Colors.blue)),\n            TextSpan(\n                text:\n                    \"\\n风急天高猿啸哀，渚清沙白鸟飞回。\\n无边落木萧萧下，不尽长江滚滚来。\\n万里悲秋常作客，百年多病独登台。\\n艰难苦恨繁霜鬓，潦倒新停浊酒杯。\"),\n          ],\n        ),\n        style: TextStyle(fontSize: 16, color: Colors.green),\n        textAlign: TextAlign.center,\n      ),\n    );\n  }\n}\n```\n\n![03](Flutter之基础Widget/03.png)\n\n## Button\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHome(),\n    );\n  }\n}\n\nclass MyHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Text\"),\n      ),\n      body: MyBody(),\n    );\n  }\n}\n\n/*\n///  * [ElevatedButton], a filled button whose material elevates when pressed .\n///  * [FilledButton], a filled button that doesn't elevate when pressed.\n///  * [FilledButton.tonal], a filled button variant that uses a secondary fill color.\n///  * [OutlinedButton], a button with an outlined border and no fill color.\n///  * [TextButton], a button with no outline or fill color.\n */\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          /*\n          1.\"圆形\"按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          FloatingActionButton(\n            onPressed: () {\n              print(\"FloatingActionButton Click\");\n            },\n            child: Text(\"FloatingActionButton\"),\n          ),\n\n          /*\n          2.“漂浮”按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          ElevatedButton(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            child: Text(\n              \"ElevatedButton\",\n              style: TextStyle(color: Colors.red),\n            ),\n          ),\n\n          /*\n          3.“全圆角”按钮，默认按钮两侧全圆角，不带阴影\n          */\n          FilledButton(\n            onPressed: () {\n              print(\"FilledButton Click\");\n            },\n            child: Text(\"FilledButton\"),\n          ),\n\n          /*\n          4.默认有一个边框，不带阴影切背景透明。按下后，边框颜色会变亮。同时出现背景和阴影（较弱）\n          */\n          OutlinedButton(\n            onPressed: () {\n              print(\"OutlinedButton Click\");\n            },\n            child: Text(\"OutlinedButton\"),\n          ),\n\n          /*\n          5.文本按钮，默认背景透明不带阴影。按下后，会有背景色\n          */\n          TextButton(\n            onPressed: () {\n              print(\"TextButton Click\");\n            },\n            child: Text(\"TextButton\"),\n          ),\n\n          /*\n          6.一个可点击的icon，不包括文字，默认没有背景，点击后出背景\n          */\n          IconButton(\n            onPressed: () {\n              print(\"IconButton Click\");\n            },\n            icon: Icon(Icons.thumb_up),\n          ),\n\n          /*\n          7.带图标和文字的按钮\n          */\n          ElevatedButton.icon(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            icon: Icon(Icons.send),\n            label: Text(\"发送\"),\n          ),\n\n          /*\n          8.带图标和文字的按钮\n          */\n          OutlinedButton.icon(\n            onPressed: () {\n              print(\"OutlinedButton Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"添加\"),\n          ),\n\n          /*\n          9.带图标和文字的按钮\n          */\n          TextButton.icon(\n            onPressed: () {\n              print(\"TextButton Click\");\n            },\n            icon: Icon(Icons.info),\n            label: Text(\"详情\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n```\n\n![04](Flutter之基础Widget/04.png)\n\n### 浮动按钮\n\n圆形浮动按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n\n```dart\n// 浮动按钮\nclass FloatingActionButton extends StatelessWidget {\n  const FloatingActionButton({\n    super.key,                              //唯一标识\n    this.child,                             // 子控件（通常为Icon）         \n    this.tooltip,                           // 悬浮按钮的提示文本\n    this.foregroundColor,                   // 悬浮按钮的前景色\n    this.backgroundColor,                   // 背景色\n    this.focusColor,                        // 悬浮按钮获得焦点时的前景色\n    this.hoverColor,                        // 悬浮按钮悬停时的前景色\n    this.splashColor,                       // 悬浮按钮的点击效果时的前景色\n    this.heroTag = const _DefaultHeroTag(), // 标记\n    this.elevation,                         // 悬浮按钮的z轴高度\n    this.focusElevation,                    // 悬浮按钮获得焦点时的z轴高度\n    this.hoverElevation,                    // 悬浮按钮悬停时的z轴高度\n    this.highlightElevation,                // 悬浮按钮的点击效果时的z轴高度\n    this.disabledElevation,                 // 悬浮按钮禁用时的z轴高度\n    required this.onPressed,                // 悬浮按钮的点击事件\n    this.mouseCursor,                       // 悬浮按钮的鼠标光标\n    this.mini = false,                      // 是否为迷你悬浮按钮\n    this.shape,                             // 悬浮按钮的形状\n    this.clipBehavior = Clip.none,          // 边缘裁剪方式\n    this.focusNode,                         // 焦点节点\n    this.autofocus = false,                 // 自动获取焦点\n    this.materialTapTargetSize,             // 悬浮按钮的尺寸\n    this.isExtended = false,                // 是否为扩展的悬浮按钮\n    this.enableFeedback,                    // 是否为反馈悬浮按钮\n  }) : assert(elevation == null || elevation >= 0.0),\n        assert(focusElevation == null || focusElevation >= 0.0),\n        assert(hoverElevation == null || hoverElevation >= 0.0),\n        assert(highlightElevation == null || highlightElevation >= 0.0),\n        assert(disabledElevation == null || disabledElevation >= 0.0),\n        _floatingActionButtonType = mini ? _FloatingActionButtonType.small : _FloatingActionButtonType.regular,\n        _extendedLabel = null,\n        extendedIconLabelSpacing = null,\n        extendedPadding = null,\n        extendedTextStyle = null;\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          /*\n          1.\"圆形\"按钮，默认带有阴影和灰色背景。按下后，阴影会变大\n          */\n          FloatingActionButton(\n            onPressed: () {\n              print(\"FloatingActionButton Click\");\n            },\n            child: Text(\"01\"),\n          ),\n          FloatingActionButton.small(\n            onPressed: () {\n              print(\"FloatingActionButton.small Click\");\n            },\n            child: Text(\"02\"),\n          ),\n          FloatingActionButton.large(\n            onPressed: () {},\n            child: Text(\"03\"),\n          ),\n          // 全角\n          FloatingActionButton.extended(\n            onPressed: () {\n              print(\"FloatingActionButton.extended Click\");\n            },\n            label: Text(\"- 04 -\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![05](Flutter之基础Widget/05.png)\n\n### 漂浮按钮\n\n\"漂浮\"按钮，它默认带有阴影和灰色背景。按下后，阴影会变大。\n\n```dart\nclass ElevatedButton extends ButtonStyleButton {\n  const ElevatedButton({\n    super.key,                      //唯一标识\n    required super.onPressed,       // 点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    required super.child,           \n  });\n}\n```\n\n实列\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // “01” 按钮\n          ElevatedButton(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            child: Text(\"01\"),\n          ),\n          // “+ 02” 按钮\n          ElevatedButton.icon(\n            onPressed: () {\n              print(\"ElevatedButton Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![06](Flutter之基础Widget/06.png)\n\n### 全角按钮\n\n```dart\nclass FilledButton extends ButtonStyleButton {\n  const FilledButton({\n    super.key,                      // 唯一标识\n    required super.onPressed,       // 点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    required super.child,\n  }) : _variant = _FilledButtonVariant.filled;\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          FilledButton(\n            onPressed: () {\n              print(\"FilledButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          FilledButton.icon(\n            onPressed: () {\n              print(\"FilledButton.icon Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n          FilledButton.tonal(\n            onPressed: () {\n              print(\"FilledButton.tonal Click\");\n            },\n            child: Text(\"03\"),\n          ),\n          FilledButton.tonalIcon(\n            onPressed: () {\n              print(\"FilledButton.tonalIcon Click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"04\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![07](Flutter之基础Widget/07.png)\n\n### 边框按钮\n\n默认有一个边框，不带阴影切背景透明。按下后，边框颜色会变亮。同时出现背景和阴影（较弱）。\n\n```dart\nclass OutlinedButton extends ButtonStyleButton {\n    const OutlinedButton({\n      super.key,                      // 唯一标识\n      required super.onPressed,       // 点击事件\n      super.onLongPress,              // 长按事件\n      super.onHover,                  // 悬停事件\n      super.onFocusChange,            // 焦点改变事件\n      super.style,                    // 按钮样式\n      super.focusNode,                // 焦点节点\n      super.autofocus = false,        // 是否自动获取焦点\n      super.clipBehavior = Clip.none, // 边缘裁剪方式\n      super.statesController,         // 状态控制器\n      required super.child,\n    });\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          OutlinedButton(\n            onPressed: () {\n              print(\"OutlinedButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          OutlinedButton.icon(\n            onPressed: () {\n              print(\"OutlinedButton.icon click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"02\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`01` 按钮是点击后的样式。\n\n![08](Flutter之基础Widget/08.png)\n\n### 文本按钮\n\n```dart\nclass TextButton extends ButtonStyleButton {\n  const TextButton({\n    super.key,\n    required super.onPressed,       // 按钮点击事件\n    super.onLongPress,              // 长按事件\n    super.onHover,                  // 悬停事件\n    super.onFocusChange,            // 焦点改变事件\n    super.style,                    // 按钮样式\n    super.focusNode,                // 焦点节点\n    super.autofocus = false,        // 是否自动获取焦点\n    super.clipBehavior = Clip.none, // 边缘裁剪方式\n    super.statesController,         // 状态控制器\n    super.isSemanticButton,         // 语义化按钮\n    required Widget super.child,\n  });\n}\n```\n\n示例\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextButton(\n            onPressed: () {\n              print(\"TextButton click\");\n            },\n            child: Text(\"01\"),\n          ),\n          TextButton(\n            onPressed: () {\n              print(\"TextButton 02 click\");\n            },\n            child: Text(\"02\"),\n          ),\n          TextButton.icon(\n            onPressed: () {\n              print(\"TextButton.icon click\");\n            },\n            icon: Icon(Icons.add),\n            label: Text(\"03\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`02` 按钮是点击时的样式。\n\n![09](Flutter之基础Widget/09.png)\n\n### 图标按钮\n\n```dart\nclass IconButton extends StatelessWidget {\n  const IconButton({\n    super.key,\n    this.iconSize,           // 图标大小\n    this.visualDensity,      // 视觉密度\n    this.padding,            // 内边距\n    this.alignment,          // 对齐方式\n    this.splashRadius,       // 闪动半径\n    this.color,              // 颜色\n    this.focusColor,         // 焦点颜色\n    this.hoverColor,         // 悬停颜色\n    this.highlightColor,     // 高亮颜色\n    this.splashColor,        // 闪动颜色\n    this.disabledColor,      // 禁用颜色\n    required this.onPressed, // 按钮点击事件\n    this.mouseCursor,        //\n    this.focusNode,          // 焦点节点\n    this.autofocus = false,  // 是否自动获取焦点\n    this.tooltip,            // 提示文本\n    this.enableFeedback,     // 是否为反馈按钮\n    this.constraints,        //\n    this.style,              // 样式\n    this.isSelected,         // 是否选中\n    this.selectedIcon,       // 选中图标\n    required this.icon,\n  }) : assert(splashRadius == null || splashRadius > 0),\n        _variant = _IconButtonVariant.standard;\n}\n```\n\n<!-- 示例 -->\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          IconButton(\n            onPressed: () {\n              print(\"IconButton click\");\n            },\n            icon: Icon(Icons.add),\n          ),\n          IconButton.filled(\n            onPressed: () {\n              print(\"IconButton.filled click\");\n            },\n            icon: Icon(Icons.send),\n          ),\n          IconButton.filledTonal(\n            onPressed: () {\n              print(\"IconButton.filledTonal click\");\n            },\n            icon: Icon(Icons.search),\n          ),\n          IconButton.outlined(\n            onPressed: () {\n              print(\"IconButton.outlined click\");\n            },\n            icon: Icon(Icons.list),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n`+` 按钮是点击时的样式。\n\n![10](Flutter之基础Widget/10.png\n\n### 自定义按钮\n\n继承自 `ButtonStyleButton` 的按钮有\n\n1. `FloatingActionButton`\n2. `ElevatedButton`\n3. `FilledButton`\n4. `OutlinedButton`\n5. `TextButton`\n\n在 VSCode 中可以通过「右键」+「转到实现」也可以查看（选中 ButtonStyleButton 字段），在 Android Studio 中可以使用快捷键 `optino + command + b` 查看。\n\n![11](Flutter之基础Widget/11.png)\n\n```dart\nabstract class ButtonStyleButton extends StatefulWidget {\n  const ButtonStyleButton({\n    super.key,\n    required this.onPressed,     // 点击事件\n    required this.onLongPress,   // 长按事件\n    required this.onHover,       // 悬停事件\n    required this.onFocusChange, // 焦点事件\n    required this.style,         // 按钮样式\n    required this.focusNode,     // 焦点节点\n    required this.autofocus,     // 自动获取焦点\n    required this.clipBehavior,  // 裁剪行为\n    this.statesController,       // 状态控制器\n    this.isSemanticButton = true,// 语义按钮\n    required this.child,\n  });\n}\n```\n\n按钮样式:\n\n```dart\nclass ButtonStyle with Diagnosticable {\n  /// Create a [ButtonStyle].\n  const ButtonStyle({\n    this.textStyle,        // 文本样式\n    this.backgroundColor,  // 背景颜色\n    this.foregroundColor,  // 前景颜色\n    this.overlayColor,     // 覆盖颜色\n    this.shadowColor,      // 阴影颜色\n    this.surfaceTintColor, // 表面着色颜色\n    this.elevation,        // 阴影\n    this.padding,          // 内边距\n    this.minimumSize,      // 最小尺寸\n    this.fixedSize,        // 固定尺寸\n    this.maximumSize,      // 最大尺寸\n    this.iconColor,        // 图标颜色\n    this.iconSize,         // 图标尺寸\n    this.side,             // 边框\n    this.shape,            // 形状\n    this.mouseCursor,      // 鼠标光标\n    this.visualDensity,    // 视觉密度\n    this.tapTargetSize,    // 触摸目标尺寸\n    this.animationDuration,// 动画时长\n    this.enableFeedback,   // 反馈\n    this.alignment,        // 文本对齐方式\n    this.splashFactory,    // 溅射工厂\n  });\n}\n```\n\n自定义按钮：\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextButton(\n            child: Text(\n              \"自定义样式\",\n              style: TextStyle(color: Colors.red), // 字体颜色\n            ),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.lightGreen, // 背景色\n              shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(10)), // 设置圆角\n              elevation: 2, // 通过添加阴影，设置按钮漂浮高度\n            ),\n            onPressed: () {\n              print(\"FilledButton click\");\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![12](Flutter之基础Widget/12.png)\n\n## Image\n\n### 加载网络图片\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"图片\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Container(\n            width: 300,\n            height: 400,\n            decoration: BoxDecoration(\n              border: Border.all(color: Colors.red, width: 2),\n            ),\n            child: Image.network(\n              \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n              alignment: Alignment.center,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之基础Widget/13.png)\n\n### 加载本地图片\n\n加载本地图片，需要先将图片放到`assets`目录下，然后通过`Image.asset`加载。\n\n![16](Flutter之基础Widget/16.png)\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 300,\n        height: 400,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 2),\n        ),\n        child: Image.asset('assets/images/01.png'),\n      ),\n    );\n  }\n}\n```\n\n![13](Flutter之基础Widget/13.png)\n\n### 填充方式\n\n- `fill`：填充，图片会根据容器的尺寸进行拉伸\n- `contain`：包含，图片会保持宽高比，并缩放至完全适应容器\n- `cover`：覆盖，图片会保持宽高比，并缩放至完全覆盖容器\n- `fitWidth`：填充宽度，图片会保持宽高比，并缩放至容器宽度\n- `fitHeight`：填充高度，图片会保持宽高比，并缩放至容器高度\n- `none`：不填充，图片会保持原始大小，并居中显示\n\n#### fill\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Container(\n            width: 300,\n            height: 400,\n            decoration: BoxDecoration(\n              border: Border.all(color: Colors.red, width: 2),\n            ),\n            child: Image.network(\n              \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n              alignment: Alignment.center,\n              fit: BoxFit.fill,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![14](Flutter之基础Widget/14.png)\n\n#### contain\n\n默认填充方式\n\n```dart\nfit: BoxFit.contain,\n```\n\n![13](Flutter之基础Widget/13.png)\n\n#### cover\n\n```dart\nfit: BoxFit.cover,\n```\n\n![15](Flutter之基础Widget/15.png)\n\n#### fitWidth\n\n```dart\nfit: BoxFit.fitWidth,\n```\n\n![13](Flutter之基础Widget/13.png)\n\n#### fitHeight\n\n```dart\nfit: BoxFit.fitHeight,\n```\n\n![15](Flutter之基础Widget/15.png)\n\n### 头像\n\n#### 方式一：CircleAvatar\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 2),\n        ),\n        child: CircleAvatar(\n          radius: 100,\n          backgroundImage: AssetImage('assets/images/01.png'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![17](Flutter之基础Widget/17.png)\n\n`CircleAvatar` 的定义：\n\n```dart\nclass CircleAvatar extends StatelessWidget {\n  const CircleAvatar({\n    super.key,                   // 唯一标识\n    this.child,                  // 子控件\n    this.backgroundColor,        // 背景颜色\n    this.backgroundImage,        // 背景图片\n    this.foregroundImage,        // 前景图片\n    this.onBackgroundImageError, // 背景图片错误回调\n    this.onForegroundImageError, // 前景图片错误回调\n    this.foregroundColor,        // 前景颜色\n    this.radius,                 // 半径\n    this.minRadius,              // 最小半径\n    this.maxRadius,              // 最大半径\n  }) : assert(radius == null || (minRadius == null && maxRadius == null)),\n       assert(backgroundImage != null || onBackgroundImageError == null),\n       assert(foregroundImage != null || onForegroundImageError== null);\n}\n```\n\n#### 方式二：Container+BoxDecoration\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.red, width: 10),\n          borderRadius: BorderRadius.all(Radius.circular(100)),\n          image: DecorationImage(\n            image: AssetImage(\"assets/images/01.png\"),\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![18](Flutter之基础Widget/18.png)\n\n`DecorationImage` 的定义：\n\n```dart\nclass DecorationImage {\n  const DecorationImage({\n    required this.image,                    // 图片\n    this.onError,                           // 错误回调\n    this.colorFilter,                       // 颜色过滤器\n    this.fit,                               // 填充方式\n    this.alignment = Alignment.center,      // 位置\n    this.centerSlice,                       // 切片\n    this.repeat = ImageRepeat.noRepeat,     // 重复方式\n    this.matchTextDirection = false,        // 文本方向\n    this.scale = 1.0,                       // 缩放\n    this.opacity = 1.0,                     // 透明度\n    this.filterQuality = FilterQuality.low, // 过滤器\n    this.invertColors = false,              // 反色\n    this.isAntiAlias = false,               // 抗锯齿\n  });\n}\n```\n\n#### 方式三：ClipOval\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container\n      (\n        decoration: BoxDecoration(\n          border: Border.all(width: 2, color: Colors.red),\n        ),\n        child: ClipOval(\n          child: Image.network(\n            \"https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg\",\n            fit: BoxFit.cover,\n            width: 200,\n            height: 200,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n![19](Flutter之基础Widget/19.png)\n\n`ClipOval` 的定义：\n\n```dart\nclass ClipOval extends SingleChildRenderObjectWidget {\n  const ClipOval({\n    super.key,\n    this.clipper, // 裁剪\n    this.clipBehavior = Clip.antiAlias, // 边缘裁剪方式\n    super.child,\n  });\n}\n```\n\n### 圆角图片\n\n![20](Flutter之基础Widget/20.png)\n\n#### 方式一：Container+BoxDecoration\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        decoration: BoxDecoration(\n          border: Border.all(width: 2, color: Colors.red),\n          borderRadius: BorderRadius.circular(10),\n        ),\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(10),\n          child: Image.network(\n            'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg',\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n#### 方式二：ClipRRect\n\n```dart\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(20),\n          child: Image.network(\n            'https://pic4.zhimg.com/v2-cb75f239dfd0c1c42c23dfc9011965a3_b.jpg',\n            width: 200,\n            height: 200,\n            fit: BoxFit.cover,\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## TextField\n\n定义：\n\n```dart\nclass TextField extends StatefulWidget {\n  const TextField({\n    super.key,                                         // 唯一标识\n    this.controller,                                   // 控制器（👇）\n    this.focusNode,                                    // 焦点\n    this.undoController,                               // 撤销控制器\n    this.decoration = const InputDecoration(),         // 装饰器\n    TextInputType? keyboardType,                       // 键盘类型\n    this.textInputAction,                              // 文本输入动作\n    this.textCapitalization = TextCapitalization.none, // 文本大写\n    this.style,                                        // 样式\n    this.strutStyle,                                   // 结构样式\n    this.textAlign = TextAlign.start,                  // 文本对齐\n    this.textAlignVertical,                            // 文本垂直对齐\n    this.textDirection,                                // 文本方向\n    this.readOnly = false,                             // 只读\n    @Deprecated(\n      'Use `contextMenuBuilder` instead. '\n      'This feature was deprecated after v3.3.0-0.5.pre.',\n    )\n    this.toolbarOptions,              // 工具栏选项（长按或鼠标右击时出现的菜单，包括 copy、cut、paste 以及 selectAll。）\n    this.showCursor,                  // 显示光标\n    this.autofocus = false,           // 自动聚焦\n    this.obscuringCharacter = '•',    // 隐藏字符\n    this.obscureText = false,         // 隐藏文本\n    this.autocorrect = true,          // 自动更正\n    SmartDashesType? smartDashesType, // 智能断句\n    SmartQuotesType? smartQuotesType, // 智能引号\n    this.enableSuggestions = true,    // 启用建议\n    this.maxLines = 1,                // 最大行数\n    this.minLines,                    // 最小行数\n    this.expands = false,             // 扩展\n    this.maxLength,                   // 最大长度\n    this.maxLengthEnforcement,        // 当输入文本长度超过maxLength时如何处理，如截断、超出等。\n    this.onChanged,                   // 改变\n    this.onEditingComplete,           // 完成编辑\n    this.onSubmitted,                 // 提交\n    this.onAppPrivateCommand,\n    this.inputFormatters,             // 用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验\n    this.enabled,                     // 如果为false，则输入框会被禁用，禁用状态不能响应输入和事件，同时显示禁用态样式（在其decoration中定义）\n    this.cursorWidth = 2.0,           // 光标宽度\n    this.cursorHeight,                // 光标高度\n    this.cursorRadius,                // 光标半径\n    this.cursorOpacityAnimates,\n    this.cursorColor,                 // 光标颜色\n    this.selectionHeightStyle = ui.BoxHeightStyle.tight,\n    this.selectionWidthStyle = ui.BoxWidthStyle.tight,\n    this.keyboardAppearance,\n    this.scrollPadding = const EdgeInsets.all(20.0),\n    this.dragStartBehavior = DragStartBehavior.start,\n    bool? enableInteractiveSelection,\n    this.selectionControls,\n    this.onTap,\n    this.onTapOutside,\n    this.mouseCursor,\n    this.buildCounter,\n    this.scrollController,\n    this.scrollPhysics,\n    this.autofillHints = const <String>[],\n    this.contentInsertionConfiguration,\n    this.clipBehavior = Clip.hardEdge,\n    this.restorationId,\n    this.scribbleEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contextMenuBuilder = _defaultContextMenuBuilder,\n    this.canRequestFocus = true,\n    this.spellCheckConfiguration,\n    this.magnifierConfiguration,\n  }) : assert(obscuringCharacter.length == 1),\n       smartDashesType = smartDashesType ?? (obscureText ? SmartDashesType.disabled : SmartDashesType.enabled),\n       smartQuotesType = smartQuotesType ?? (obscureText ? SmartQuotesType.disabled : SmartQuotesType.enabled),\n       assert(maxLines == null || maxLines > 0),\n       assert(minLines == null || minLines > 0),\n       assert(\n         (maxLines == null) || (minLines == null) || (maxLines >= minLines),\n         \"minLines can't be greater than maxLines\",\n       ),\n       assert(\n         !expands || (maxLines == null && minLines == null),\n         'minLines and maxLines must be null when expands is true.',\n       ),\n       assert(!obscureText || maxLines == 1, 'Obscured fields cannot be multiline.'),\n       assert(maxLength == null || maxLength == TextField.noMaxLength || maxLength > 0),\n       // Assert the following instead of setting it directly to avoid surprising the user by silently changing the value they set.\n       assert(\n         !identical(textInputAction, TextInputAction.newline) ||\n         maxLines == 1 ||\n         !identical(keyboardType, TextInputType.text),\n         'Use keyboardType TextInputType.multiline when using TextInputAction.newline on a multiline TextField.',\n       ),\n       keyboardType = keyboardType ?? (maxLines == 1 ? TextInputType.text : TextInputType.multiline),\n       enableInteractiveSelection = enableInteractiveSelection ?? (!readOnly || !obscureText);\n}\n```\n\n### TextField 示例及监听\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"TextField\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          MyTextField(),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyTextField extends StatefulWidget {\n  @override\n  _MyTextFieldState createState() => _MyTextFieldState();\n}\n\nclass _MyTextFieldState extends State<MyTextField> {\n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      // 样式\n      decoration: InputDecoration(\n        icon: Icon(Icons.phone),  // 图标\n        labelText: \"手机号\",       // 标签\n        hintText: \"请输入手机号\",   // 输入框提示文字\n        border: InputBorder.none, // 边框\n        filled: true,             // 是否填充\n        fillColor: Colors.yellow, // 填充颜色\n      ),\n      // 监听-输入事件\n      onChanged: (value) {\n        print(\"onChange: $value\");\n      },\n      // 监听-提交事件（回车键）\n      onSubmitted: (value) {\n        print(\"onSubmitted: $value\");\n      },\n      cursorWidth: 1, // 光标宽度\n      cursorColor: Colors.red, // 光标颜色\n    );\n  }\n}\n```\n\n打印信息：\n\n```js\nflutter: onChange: 1\nflutter: onChange: 12\nflutter: onChange: 123\nflutter: onChange: 1234\nflutter: onChange: 12345\nflutter: onChange: 123456\nflutter: onSubmitted: 123456\n```\n\n![21](Flutter之基础Widget/21.png)\n\n### TextField的controller\n\n`TextField` 的 `controller` 属性，用于获取输入框的值，并控制输入框的值。包括设置/获取编辑框的内容，选择编辑内容，监听编辑文本的变化等。需要指定 `TextEditingController` 对象与文本框绑定，如果没有指定，则使用默认的 `TextEditingController`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"TextField\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          MyTextField(),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyTextField extends StatefulWidget {\n  @override\n  _MyTextFieldState createState() => _MyTextFieldState();\n}\n\nclass _MyTextFieldState extends State<MyTextField> {\n  // 1.创建监听器\n  final _textEditingController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    // 2.设置默认值\n    _textEditingController.text = \"Hello World\";\n    // 3.监听文本框\n    _textEditingController.addListener(() {\n      print(\n          \"TextEditingController.addListener: ${_textEditingController.text}\");\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      // 4.设置监听器\n      controller: _textEditingController,\n      decoration: InputDecoration(\n        icon: Icon(Icons.password),\n        labelText: \"密码\",\n        hintText: \"请输入密码\",\n        // border: InputBorder.none, // 边框\n        filled: true,\n        fillColor: Colors.yellow,\n      ),\n      onChanged: (value) {\n        print(value);\n      },\n      onSubmitted: (value) {\n        print(value);\n      },\n    );\n  }\n}\n```\n\n![22](Flutter之基础Widget/22.png)\n\n## Form表单\n\nForm 表单用于将多个输入控件封装起来，并且提供一些辅助功能，比如验证、自动补全、错误提示等。\n\n`TextField` 就是 `Form` 表单的一个子类，在验证过程中，`Form` 表单会自动调用 `TextField` 的 `validate()` 方法，如果 `validate()` 返回 `true`，则表示验证通过，否则表示验证失败。\n\n`Form` 表单可以清除所有输入框的值，也可以重置所有输入框的值。\n\n```dart\nclass Form extends StatefulWidget {\n  const Form({\n    super.key,                          // 唯一标识\n    required this.child,                // 子控件\n    this.onWillPop,                     // 返回键按下时触发\n    this.onChanged,                     // 输入框内容改变时触发\n    AutovalidateMode? autovalidateMode, // 自动验证模式\n  }) : autovalidateMode = autovalidateMode ?? AutovalidateMode.disabled; // 默认关闭自动验证\n}\n```\n\n### FormField\n\n```dart\nclass FormField<T> extends StatefulWidget {\n  const FormField({\n    super.key,                         // 唯一标识\n    required this.builder,             // 构建子控件\n    this.onSaved,                      // 保存回调\n    this.validator,                    // 验证回调\n    this.initialValue,                 // 初始值\n    this.enabled = true,               // 是否可用\n    AutovalidateMode? autovalidateMode,// 自动验证模式\n    this.restorationId,                // 恢复标识\n  }) : autovalidateMode = autovalidateMode ?? AutovalidateMode.disabled;\n}\n```\n\n`FormField` 是一个抽象类，它有两个子类：`TextFormField` 和 `DropdownButtonFormField`。\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"Form\"),\n        ),\n        body: MyBody(),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: MyForm(),\n    );\n  }\n}\n\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.person),\n              labelText: \"用户名或手机号\",\n            ),\n          ),\n          TextFormField(\n            obscureText: true,\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"密码\",\n            ),\n          ),\n          SizedBox(height: 20), // 输入框和按钮的间距\n          Container(            // 按钮\n            width: double.infinity,\n            height: 44,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![23](Flutter之基础Widget/23.png)\n\n### FormState\n\n`FormState` 是 `Form` 的内部类，它继承自 `State`，用于保存 `Form` 表单的状态。`FormState` 有一个字段 `_formKey`，它是 `GlobalKey<FormState>` 类型的，用于保存 Form 表单的标识。\n\n1. `FormState.save()` 会调用 `Form` 子孙控件的 `save()` 方法，保存表单。\n\n2. `FormState.reset()` 会调用 `Form` 子孙控件的 `reset()` 方法，重置表单。\n\n3. `FormState.validate()` 会调用 `Form` 子孙控件的 `validate()` 方法，验证表单。\n\n#### 保存表单 FormState.save()\n\n```dart\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  final registerFormKey = GlobalKey<FormState>(); // 1.创建标识\n  late String username, password;\n\n  void registerForm() {\n    registerFormKey.currentState?.save(); // 3.登录时，调用 save() 方法\n    print(\"username: $username, password: $password\");\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: registerFormKey, // 2.注册标识，用于获取FormState\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.person),\n              labelText: \"用户名或手机号\",\n            ),\n            onSaved: (value) {\n              print(\"username: $value\");\n              this.username = value ?? \"\"; // 5.保存用户名\n            },\n          ),\n          TextFormField(\n            obscureText: true,\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"密码\",\n            ),\n            onSaved: (value) {\n              print(\"onSaved: $value\");\n              this.password = value ?? \"\"; // 6.保存密码\n            },\n          ),\n          SizedBox(height: 20), // 输入框和按钮的间距\n          Container(\n            // 按钮\n            width: double.infinity,\n            height: 44,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n                this.registerForm();\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![24](Flutter之基础Widget/24.png)\n\n#### 验证表单 FormState.validate()\n\n```dart\nclass MyForm extends StatefulWidget {\n  @override\n  _MyFormState createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  // 1.创建 GlobalKey\n  final registerFormKey = GlobalKey<FormState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: registerFormKey, // 2.设置GlobalKey，用户获取FormState\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.people),\n              labelText: \"用户名或手机号\",\n            ),\n            validator: (value) {\n              return value?.length == 0 ? \"用户名不能为空\" : null; // 4.验证表单子控件\n            },\n          ),\n          TextFormField(\n            decoration: InputDecoration(\n              icon: Icon(Icons.lock),\n              labelText: \"请输入密码\",\n            ),\n            validator: (value) {\n              return (value?.length ?? 0) < 6 ? \"密码长度不能小于6位\" : null; // 4.验证表单子控件\n            },\n          ),\n          SizedBox(\n            height: 20,\n          ),\n          Container(\n            width: double.infinity,\n            height: 40,\n            child: ElevatedButton(\n              child: Text(\n                \"登 录\",\n                style: TextStyle(fontSize: 20, color: Colors.white),\n              ),\n              onPressed: () {\n                print(\"登录\");\n                registerFormKey.currentState?.validate(); // 3.验证表单\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![25](Flutter之基础Widget/25.png)\n\n## ProgressIndicator\n\nMaterial 中的进度指示器包括两种：\n\n- LinerProgressIndicator：线性进度指示器\n- CircularProgressIndicator：环形进度指示器\n\n### LinerProgressIndicator\n\n```dart\nclass LinearProgressIndicator extends ProgressIndicator {\n  const LinearProgressIndicator({\n    super.key,\n    super.value,                           // 0.0 ~ 1.0\n    super.backgroundColor,                 // 背景色\n    super.color,                           // 进度条颜色\n    super.valueColor,                      // 进度条颜色\n    this.minHeight,                        // 最小高度\n    super.semanticsLabel,                  // 语义标签\n    super.semanticsValue,                  // 语义值\n    this.borderRadius = BorderRadius.zero, // 圆角\n  }) : assert(minHeight == null || minHeight > 0);\n}\n```\n\n### CircularProgressIndicator\n\n```dart\nclass CircularProgressIndicator extends ProgressIndicator {\n  const CircularProgressIndicator({\n    super.key,\n    super.value,                          // 0.0 ~ 1.0\n    super.backgroundColor,                // 背景色\n    super.color,                          // 进度条颜色\n    super.valueColor,                     // 进度条颜色\n    this.strokeWidth = 4.0,               // 进度条宽度\n    this.strokeAlign = strokeAlignCenter, // 进度条对齐方式\n    super.semanticsLabel,                 // 语义标签\n    super.semanticsValue,                 // 语义值\n    this.strokeCap,                       // 进度条端点类型\n  }) : _indicatorType = _ActivityIndicatorType.material; // 进度条类型\n}\n```\n\n示例\n\n```dart\nimport 'package:flutter/material.dart';\n\nmain() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"Progress Indicator\"),\n        ),\n        body: Container(\n          padding: EdgeInsets.all(20),\n          child: MyBody(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MyBody extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MyProgressIndicator();\n  }\n}\n\nclass MyProgressIndicator extends StatefulWidget {\n  @override\n  _MyProgressIndicatorState createState() => _MyProgressIndicatorState();\n}\n\nclass _MyProgressIndicatorState extends State<MyProgressIndicator> {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // 1.条形进度条。执行一个动画，进度条在滚动\n          LinearProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n          ),\n          SizedBox(height: 50),\n          // 2.条形进度条。进度条显示50%\n          LinearProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n            value: .5,\n          ),\n          SizedBox(height: 50),\n          // 3.圆形进度条。执行动画，进度条在转动\n          CircularProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n          ),\n          SizedBox(height: 50),\n          // 4.圆形进度条\n          CircularProgressIndicator(\n            backgroundColor: Colors.grey[200],\n            valueColor: AlwaysStoppedAnimation(Colors.blue),\n            value: .5,\n          ),\n          SizedBox(height: 50),\n          // 5. 自定义尺寸-条形进度条\n          SizedBox(\n            height: 10,\n            child: LinearProgressIndicator(\n              backgroundColor: Colors.grey[200],\n              valueColor: AlwaysStoppedAnimation(Colors.blue),\n              value: .5,\n            ),\n          ),\n          SizedBox(height: 50),\n          // 6. 自定义尺寸-圆形进度条\n          SizedBox(\n            height: 88,\n            width: 100,\n            child: CircularProgressIndicator(\n                backgroundColor: Colors.grey[200],\n                valueColor: AlwaysStoppedAnimation(Colors.blue),\n                value: .7),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n![26](Flutter之基础Widget/26.png)\n","slug":"Flutter/Flutter之基础Widget","published":1,"updated":"2023-11-21T09:08:15.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv6002raq7k189ra6rb"},{"title":"block","date":"2020-05-31T08:02:28.000Z","_content":"\n思考：\n* block 的原理是怎样的？本质是什么？\n* `__block`的作用是什么？有什么使用注意点？\n* block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？\n* block 在修改 NSMutableArray，需不需要添加 `__block`？\n\n\n<!-- more -->\n\n# 基本认识\n\n## block\n```\n^{\n    NSLog(@\"this is a block\");\n};\n```\n\nblock 可以封装一块代码，在将来需要执行的地方通过“()”进行调用：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        ^{\n            NSLog(@\"this is a block\");\n        }();\n    }\n    return 0;\n}\n```\n\n或者\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = ^{\n            NSLog(@\"this is a block\");\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block\n```\n\n## block 的 C++ 代码\n查看 block 的 C++ 代码。找到 main.m 文件，在终端输入：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp\n```\n\nblock 的 C++ 代码（精简版）：\n```\nstruct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size; //占用内存大小\n}\n\nstruct __block_impl {\n    void *isa; //指向父类的指针（OC对象特征）\n    int Flags;\n    int Reserved;\n    void *FuncPtr; //函数地址，用于函数调用\n};\n\nstruct __main_block_impl_0 { //block 结构体\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a; //调用环境\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int a = 20;\n        void (^block)(void) = ^{\n            NSLog(@\"this is a block - %d\", a); //断点2\n        };\n        block(); //断点1\n    }\n    return 0;\n}\n```\n\n## __main_block_impl_0\n`__main_block_impl_0` 是 block 在 C++ 中的结构体实现。第一个参数 __block_impl 中有一个 isa 指针，具备 OC 对象特征，说明 block 本质上也是一个 OC 对象。  \n\n`__main_block_impl_0` 省略 `__block_impl` 和 `__main_block_desc_0` 后可以看成：\n```\nstruct __main_block_impl_0 {\n    void *isa; \n    int Flags;\n    int Reserved;\n    void *FuncPtr; \n    size_t reserved;\n    size_t Block_size;\n    int a; \n};\n```\n\n即：\n![block03](block/block03.png)\n\n## FuncPtr\nFuncPtr 是一个指针，指向 block 封装的代码块的函数地址。  \n\n在断点1处打印 FuncPtr 地址：  \n![block01](block/block01.png)\n\n```\nPrinting description of blockStruct->impl.FuncPtr:\n(void *) FuncPtr = 0x0000000100000f00\n```\n\n在断点2处，选择 Debug -> Debug Workflow -> Always Show Disassembly:\n![block02](block/block02.png)\n\n可以看到，block 里的开始地址值 100000f00 等于 FuncPtr 的地址值。说明 block 里的代码块的地址值被保存在了 `__block_impl` 里的 FuncPtr 中（函数调用），另外 `__main_block_impl_0` 里保存了外部变量 int a（调用环境），说明 block 是封装了函数调用以及函数调用环境的 OC 对象。\n\n\n\n# block 的本质\n\nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象，它内部也有个 isa 指针。\n\n## 定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n查看 block 的 C++ 代码：\n```\nstruct __block_impl {\n    void *isa; //指向父类\n    int Flags;\n    int Reserved;\n    void *FuncPtr; //指向 __main_block_func_0 函数地址的指针，用于函数调用\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl; //作为第一个变量，__block_impl 的内存地址就是 __main_block_impl_0 内存地址\n    struct __main_block_desc_0* Desc; //描述，是一个结构体变量 __main_block_desc_0_DATA\n    // 构造函数（类似于OC的init方法），返回结构体对象\n    // 参数 fp：block 执行逻辑的函数的地址，即 __main_block_func_0\n    // 参数 desc：描述，__main_block_desc_0 的结构体变量，即 __main_block_desc_0_DATA\n    // 参数 flags：默认可以不传，flags=0\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock; //指向父类。_NSConcreteStackBlock：block 的类型\n        impl.Flags = flags;\n        impl.FuncPtr = fp; //__main_block_func_0\n        Desc = desc; //__main_block_desc_0_DATA\n    }\n};\n\n// 封装了 block 执行逻辑的函数\n// 参数：block 结构体\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_880b47_mi_0); // NSLog(@\"this is a block\");\n}\n\n// 封装了 block 执行逻辑的函数\nstatic struct __main_block_desc_0 {\n  size_t reserved; // 0\n  size_t Block_size; // block 占用内存大小\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; //__main_block_desc_0 的结构体变量，参数 reserved：0，参数 Block_size：sizeof(struct __main_block_impl_0)\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        // 定义 block 变量，指向结构体 __main_block_impl_0 地址的指针\n        void (*block)(void) = ((void (*)())&__main_block_impl_0(\n                                                                (void *)__main_block_func_0, //block 执行逻辑的函数\n                                                                &__main_block_desc_0_DATA //__main_block_desc_0 的结构体变量\n                                                                ));\n        // 执行 block 内部的代码\n        // 因为在结构体 __main_block_impl_0 中，__block_impl 作为第一个变量，所以 __block_impl 的内存地址就是 __main_block_impl_0 内存地址\n        // 所以这里可以将 block 强转为 __block_impl 类型\n        // FuncPtr：函数 __main_block_func_0 地址\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block); //简化后：block->FuncPtr(block)\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n`__main_block_impl_0`、`__block_impl` 和 `__main_block_desc_0` 三者之间的关系：\n![block04](block/block04.png)\n\n## 有参数的 block\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(int, int) =  ^(int a, int b){\n            NSLog(@\"this is a block - %d, %d\", a, b);\n        };\n        block(10, 20);\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码，可以看到 `__main_block_func_0` 函数发生了变化：\n```\nstruct __block_impl {\n    void *isa; \n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数，增加了参数 a 和 b\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, int a, int b) {\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_f90d21_mi_0, a, b);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;\n        // 定义 block 变量，增加了参数 10 和 20\n        void (*block)(int, int) = ((void (*)(int, int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        ((void (*)(__block_impl *, int, int))((__block_impl *)block)->FuncPtr)((__block_impl *)block, 10, 20); //简化后：block->FuncPtr(block, 10, 20)\n    }\n    return 0;\n}\n```\n\n## 小结\n* block的原理是怎样的？本质是什么？  \nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象，它内部也有个 isa 指针。\n\n# 变量捕获（capture）\n\n为了保证 block 内部能够正常访问外部的变量，block 有个变量捕获机制。  \n变量捕获机制：block 内部会生成对应的成员变量或指针，存储被捕获变量的值或地址值。\n\n![block06](block/block06.png)\n\nps：局部变量还有一个 register 变量（定义 int age = 10，尽量使用寄存器寄存变量 age）。\n```\nregister int age = 10;\n```\n\n## 局部变量\n\n### auto 变量捕获\n* auto 变量的作用域在当前“{}”内，离开作用域就销毁。\n* auto 变量的捕获方式是值传递。  \n\n平时定义的局部变量 int age = 10 默认就是 auto 变量，auto 省略不写：\n```\nauto int age = 10; // int age = 10;\n```\n\n定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - %d\", age);\n        };\n        age = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block - 10\n```\n\n因为 auto 变量的捕获方式是值传递，即 block 捕获的是 age 的值（10），而不是 age 的地址值，所以在 block 捕获了 age 的值（10）后，再通过指针 age 修改指向的地址里的值（20），block 捕获到的值（10）不变。所以打印结果是 10。\n\n查看 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int age; //新增变量，用于捕获外部变量 age\n\n    //构造函数\n    //参数 _age：新增参数\n    //age(_age)方法：将参数 _age 赋值给 age，即 age(_age) 方法等于 age = _age;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int age = __cself->age; //取出 block 里的 age\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_de0112_mi_0, age); //NSLog(@\"this is a block - %d\", age);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        // 定义 block 变量，__main_block_impl_0 方法里捕获了 age\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age));\n        age = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block); //简化后：block->FuncPtr(block)\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n![block05](block/block05.png)\n\nblock 的结构体 __main_block_impl_0 内部新增了成员变量 age，就是用来捕获外部 auto 变量 age 用的。\n\n### static 变量捕获\n* static 变量会一直保存在内存里。\n* static 变量的捕获方式是指针传递。\n\nstatic 声明的局部变量只初始化一次，其内存分配在静态存储区（数据区域），在程序中只有一份内存，并且在整个程序执行期间都存在不会释放。虽然 static 变量的内存不会释放，但是其作用域并没有改变。\n\n定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        static int height = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n        };\n        age = 20;\n        height = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int age; //新增变量 age，用于捕获外部 auto 变量 age 的值\n    int *height; //新增指针 height，用于捕获外部的 static 变量 height 的地址值\n\n    //构造函数\n    //参数 *_height：static 变量的地址值\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int age = __cself->age; //获取 block 的 age\n    int *height = __cself->height; // 获取 block 的 height\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_ac9850_mi_0, age, (*height)); //NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        static int height = 10;\n        //调用 __main_block_impl_0 方法出入 age 和 &height（height 的地址）生成 block 指针\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age, &height));\n        age = 20;\n        height = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n因为 static 变量的捕获方式是指针传递，即 block 捕获的是 height 的地址值，所以在 block 捕获了 height 地址值后，再通过指针 height 修改地址里的值（20），block 捕获到的地址里的值就是 20 了，所以打印结果是 20。\n\n### 指针传递 & 值传递\n```\nvoid (^block)(void);\n\nvoid test()\n{\n    int age = 10;\n    static int height = 10;\n    block =  ^{\n        NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    };\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n因为 age 是 auto 变量，所以在 test() 执行后 age 就被被销毁了。因为 block 在执行时会访问 age，而 age 地址对应的内存已经被销毁不能被访问，所以 block 在捕获 age 时只能捕获 age 的值不能捕获 age 的地址值。因此 block 在捕获 auto 变量时采取的策略的是值传递。\n\n因为 height 是 static 变量，会一直保存在内存里，所以 block 在执行时依然能成功访问 height 的地址。因此 block 在捕获 static 变量时采取的策略的是指针传递。\n\n### self 的捕获方式\n定义 Person：\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n- (void)test {\n    void (^block)(void) = ^{\n        NSLog(@\"---- %p\", self);\n    };\n    block();\n}\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self test];\n    }\n    return self;\n}\n@end\n```\n\n查看 Person.m 的 C++ 实现：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person.m\n```\n\n-(void)test 方法的 C++ 代码：\n```\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n```\n\n-(void)test 方法的 C++ 实现时有两个默认参数，类对象 self 和 test 方法的指针 _cmd。因为参数都是局部变量，所以作为参数出入的 self 和 _cmd 是局部变量。\n\nblock 的 C++ 代码：\n```\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self 变量的地址值\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n    Person *self = __cself->self; //通过 block 获取 self\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_e5b707_mi_0, self);\n}\n```\n\n因为局部变量都会被 block 捕获，所以 self 以参数的形式传入后，block 结构体 __Person__test_block_impl_0 里新增了一个变量 Person *self 用来捕获 self 的地址值。\n\n#### 成员变量 _name 的捕获方式\n```\n- (void)test {\n    void (^block)(void) = ^{\n        NSLog(@\"---- %p\", _name); //等同于self->_name\n    };\n    block();\n}\n```\n\nblock 内部调用 _name 的方式等同于 self->_name，即 block 还是先捕获 self 再通过 self->_name 获取 _name。\n\n查看 C++ 代码：\n```\n//-(void)test\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n\n//block 结构体\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n  Person *self = __cself->self; //通过 block 获取 self\n    //self + OBJC_IVAR_$_Person$_name 调用 _name\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_6a1844_mi_0, (*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_Person$_name)));\n}\n```\n\n#### self.name 的捕获方式\n\nself.name 等同于 [self name]，在调用时通过向捕获的 self 发送“name”消息调用，objc_msgSend(self, sel_registerName(\"name\"))。\n```\n//-(void)test\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n\n//block 结构体\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n  Person *self = __cself->self; //通过 block 获取 self\n    //向 self 发送 “name” 消息\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_49af9b_mi_0, ((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"name\")));\n}\n```\n\n## 全局变量\n\n* 全局变量的内存存放在数据区域，在整个程序执行期间都存在不会释放。\n* 全局变量不会被 block 捕获，而是直接访问。\n\n定义 block：\n```\nint age_ = 10;\nstatic int height_ = 10;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - age = %d，height = %d\", age_, height_);\n        };\n        age_ = 20;\n        height_ = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block - age = 20，height = 20\n```\n\n查看 C++ 代码：\n```\nint age_ = 10; //全局变量 age_\nstatic int height_ = 10; //全局变量 height_\n\n//block 结构体，并没有捕获全局变量 age 和 height\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    //构造函数\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    //NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    //age_ 和 height_ 不是通过参数传进来的，而是直接调用\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_d9e2db_mi_0, age_, height_);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        // 定义 block 变量\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        age_ = 20;\n        height_ = 20;\n\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n全局变量不会被 block 捕获，因为全局变量的内存存放在全局（静态）存储区，任何函数都可以访问，所以在 __main_block_func_0 方法执行时，不需要通过 block 获取变量，而是直接访问。\n\n## block 捕获局部变量的原因\n局部变量之所以会被捕获，是因为局部变量的作用域的限制。为了防止在 block 调用时，局部变量因为超出作用域而无法访问了，block 会记住需要用到的局部变量，在调用 block 执行 __main_block_func_0 函数时，再从 block 取出局部变量：\n```\nvoid (^block)(void);\n\nvoid test()\n{\n    int age = 10;\n    static int height = 10;\n    block =  ^{\n        NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    };\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码：\n```\nvoid (*block)(void);\n\nstruct __test_block_impl_0 {\n    struct __block_impl impl;\n    struct __test_block_desc_0* Desc;\n    int age;\n    int *height;\n    __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//跨函数调用 age_ 和 height_\nstatic void __test_block_func_0(struct __test_block_impl_0 *__cself) {\n    int age = __cself->age; //获取 block 里捕获的 age\n    int *height = __cself->height; //获取 block 里捕获的 height\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_d42dac_mi_0, age, (*height));\n}\n\nstatic struct __test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __test_block_desc_0_DATA = { 0, sizeof(struct __test_block_impl_0)};\n\n//定义 age 和 height\nvoid test()\n{\n    int age = 10; \n    static int height = 10;\n    //调用 __test_block_impl_0 传入 age 和 height 生成 block\n    block = ((void (*)())&__test_block_impl_0((void *)__test_block_func_0, &__test_block_desc_0_DATA, age, &height));\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        test();\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n局部变量 age 和 height 的作用域是 test() 函数的“{}”内，而调用局部变量 age 和 height 是在 `__test_block_func_0` 函数里，为了实现跨函数调用局部变量，使用 block 捕获变量机制。在 `__test_block_func_0` 函数内可以通过 block 获取到被捕获的局部变量 age 的值和局部变量 height 的地址值。\n\n# block 的继承\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        NSLog(@\"%@\", [block class]);\n        NSLog(@\"%@\", [[block class] superclass]);\n        NSLog(@\"%@\", [[[block class] superclass] superclass]);\n        NSLog(@\"%@\", [[[[block class] superclass] superclass] superclass]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n__NSGlobalBlock\nNSBlock\nNSObject\n```\n\n从打印结果可以看出，block 的继承关系是：\n```\n__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject\n```\n\nblock 最终继承自 NSObject，block 里的 isa 指针来自 NSObject，也说明了 block 是一个 OC 对象。\n\n\n# block 的类型\nblock 有3种类型，可以通过调用 class 方法或者 isa 指针查看具体类型，最终都是继承自 NSBlock 类型。\n\n* \\_\\_NSGlobalBlock\\_\\_ （ _NSConcreteGlobalBlock ）\n* \\_\\_NSStackBlock\\_\\_ （ _NSConcreteStackBlock ）\n* \\_\\_NSMallocBlock\\_\\_ （ _NSConcreteMallocBlock ）\n\n## 查看 block 的类型\n（ARC 环境下）定义三种类型的 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block1)(void) =  ^{\n            NSLog(@\"this is a block1\"); //__NSGlobalBlock__\n        };\n        \n        int age = 10;\n        void (^block2)(void) = ^{\n            NSLog(@\"this is a block2, age = %d\", age); //__NSMallocBlock__\n        }; //ARC 环境下默认调用 copy\n       \n        NSLog(@\"%@ %@ %@\", [block1 class], [block2 class], [^{\n            NSLog(@\"this is block3, age = %d\", age); //__NSStackBlock__\n        } class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__\n```\n\n终端通过 clang 生成 C++ 代码（只贴 block 结构体）：\n```\n//block1\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//block2\nstruct __main_block_impl_1 {\n    struct __block_impl impl;\n    struct __main_block_desc_1* Desc;\n    int age;\n    __main_block_impl_1(void *fp, struct __main_block_desc_1 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//block3\nstruct __main_block_impl_2 {\n    struct __block_impl impl;\n    struct __main_block_desc_2* Desc;\n    int age;\n    __main_block_impl_2(void *fp, struct __main_block_desc_2 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n从上面👆 C++ 代码可以看到，三个 block 的 isa 都是指向 &_NSConcreteStackBlock，即三个 block 都是 `__NSStackBlock__` 类型的？！通过终端命令生成的编译文件，跟运行时打印的结果不一样？！\n\n原因：\n1. 因为运行时可能会在系统运行过程中修改一些内容，所以这里还是以运行时打印的结果为准。  \n2. 通过 clang 生成的 C++ 代码，有时不一定是编译生成的代码，大致一样，细节上有区别。\n\n## 三种 block 类型的内存分配\n\n应用程序的内存分配：\n* 编译时：  \n程序区域：用于存放编写的代码。  \n数据区域：用于存放全局变量。  \n\n* 运行时：  \n堆区域：用于存放动态分配的内存，如通过 [NSObject alloc] 或者 malloc() 等方式主动申请出的内存。同时也要管理这块内存的释放工作，如 release 或 free() 等。  \n栈区域：用于存放局部变量，系统会负责管理这部分内存的创建和释放工作。\n\n![block07](block/block07.png)\n\n如图，GlobalBlock 存放在数据区域，MallocBlock 存放在堆区域，StackBlock 存放在栈区。\n\n## 三种 block 类型的划分\n![block08](block/block08.png)\n\n为了保证打印结果的准确性，需要关闭 Xcode 的 ARC。build setting -> Automatic Reference Counting（NO）。\n\n### \\_\\_NSGlobalBlock\\_\\_\n#### 不访问变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 访问 static 变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        static int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 访问全局变量：\n```\nint age_ = 10;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age_ = %d\", age_);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 小结\nblock 在“没有访问变量”、“访问 static 变量”和“访问全局变量”的时候，都是 `__NSGlobalBlock__` 类型，放在数据区域。\n\n### \\_\\_NSStackBlock\\_\\_\n\n#### 访问 auto 变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSStackBlock__\n```\n\n上面👆的打印结果中可以看到，block 在访问 auto 变量的时候类型是 `__NSStackBlock__`，放在栈区。\n\n放在栈区的 block 会有内存销毁的问题：\n```\nvoid (^block)(void);\nvoid test()\n{\n    int age = 10;\n    block = ^{\n        NSLog(@\"this is a block, age = %d\", age);\n    };\n    NSLog(@\"类型：%@\", [block class]);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n类型：__NSStackBlock__\nthis is a block, age = -272632600\n```\n\n可以看到打印出来的 age 出现异常。因为 block 是 `__NSStackBlock__` 类型的，放在栈区，它的作用域是 void test 方法的“{}”内部。在调用 test() 方法时，会在栈区开辟一块空间（调用栈）给 test() 函数使用，调用完成后该空间（调用栈）会被回收，这时 block 内部的数据就变成垃圾数据了。\n\n#### 小结\n虽然 block 捕获了 auto 变量的值，但是 block 结构体的内存是在栈区的，在 test 函数调用完被销毁后，block 结构体在栈上的内存里的数据可能就变成了垃圾数据。\n\n### \\_\\_NSMallocBlock\\_\\_\n\n可以通过 copy 方法将 `__NSStackBlock__` 类型的 block 变成 `__NSMallocBlock__` 类型。\n\n`__NSStackBlock__` 类型的 block 在调用 copy 后，block 的类型就变成了 `__NSMallocBlock__` 类型。`__NSMallocBlock__` 类型的 block 的内存存放在堆区，由开发者手动管理内存的释放，保证了 block 内存的完整性。\n\n\n# block 的 copy\n\n## 三种 block 类型的 copy\n\n### \\_\\_NSGlobalBlock\\_\\_ 的 copy\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = [^{\n            NSLog(@\"this is a block\");\n        } copy];\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n`__NSGlobalBlock__` 类型的 block 调用 copy 后还是 `__NSGlobalBlock__` 类型。\n\n### \\_\\_NSStackBlock\\_\\_ 的 copy\n```\nvoid (^block)(void);\nvoid test()\n{\n    int age = 10;\n    block = [^{\n        NSLog(@\"this is a block, age = %d\", age);\n    } copy];\n    NSLog(@\"类型：%@\", [block class]);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n类型：__NSMallocBlock__\nthis is a block, age = 10\n```\n\n调用 copy 方法后，block 的类型从 `__NSStackBlock__` 类型变成了 `__NSMallocBlock__` 类型，block 的内存位置就从栈区拷贝到堆区，由开发者手动管理内存的释放。将 block 的内存 copy 到堆区保证了 block 内存的完整性。\n\n### \\_\\_NSMallocBlock\\_\\_ 的 copy\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [[[block copy] copy] class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSMallocBlock__\n```\n\n`__NSMallocBlock__` 类型的 block 调用 copy 后还是 `__NSMallocBlock__` 类型，引用计数+1。\n\n### 小结\n![block09](block/block09.png)\n\n从内存管理的角度分析不同类型的 block 调用 copy 的不同现象：\n1. 数据区域的 `__NSGlobalBlock__`，因为数据区域的内存在程序运行期间始终存在不会销毁，所以 `__NSGlobalBlock__` 的内存也没必要拷贝到堆区通过引用计数的方式管理内存。\n2. 堆区的 `__NSMallocBlock__` 是通过引用计数策略被开发者管理内存的，所以在调用 copy 时要遵循引用计数管理逻辑+1。\n3. 栈区的 `__NSStackBlock__` 是系统管理内存的，离开作用域就会销毁。通过 copy 将 `__NSStackBlock__` 类型的 block 的内存放到堆区，通过引用计数的方式管理内存，实现让开发者管理内存。\n\nps：类对象内存的存放位置\n```\nint age = 10;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int a = 10;\n        NSLog(@\"数据段：age %p\", &age);\n        NSLog(@\"栈：a %p\", &a);\n        NSLog(@\"堆：obj %p\", [[NSObject alloc] init]);\n        NSLog(@\"class %p\", [Person class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n数据段：age 0x100001310\n栈：a 0x7ffeefbff52c\n堆：obj 0x100606140\nclass 0x1000012c0\n```\n\nclass 的内存地址跟 age 很接近，推测类对象的内存地址存放在数据段。\n\n## ARC 环境下 block 的 copy\n\n在 ARC 环境下，编译器会根据情况自动将栈上的 block 复制到堆上，比如以下情况：\n\n### block 作为函数返回值\n\nMRC 环境下 block 作为返回值的报错：Returning block that lives on the local stack\n![block10](block/block10.png)\n\n因为 myBlock() 方法里定义的 block 访问了 auto 变量，所以该 block 是 `__NSStackBlock__` 类型的，内存在栈区，作用域是在 myBlock() 方法的“{}”内。在 MRC 环境下，当 myBlock() 方法调用完成后，该 block 的内存就会被销毁。\n\nARC 环境下 block 作为返回值会调用 copy：\n```\ntypedef void(^Block)(void);\n\nBlock myBlock()\n{\n    int age = 10;\n    return ^{\n        NSLog(@\"this is a block, age = %d\", age);\n    }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block = myBlock();\n        block();\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\nARC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSMallocBlock__\n```\n\n在 ARC 环境下，^{} 在返回时返回的是 [^{} copy]，将 block 的内存从栈区拷贝到了堆区，所以打印 block 类型的结果是 `__NSMallocBlock__`。\n\n### 将 block 赋值给 __strong 指针\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        Block block = ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n        block();\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\nARC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSMallocBlock__\n```\n\nMRC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSStackBlock__\n```\n\n因为 block 访问了 auto 变量，所以该 block 是 `__NSStackBlock__` 类型的，内存在栈区，作用域是在当前“{}”内。在 ARC 环境下，^{} 在赋值给 `__strong` 指针时，调用了 copy（[^{} copy]），将 block 的内存从栈区拷贝到了堆区，所以打印 block 类型的结果是 `__NSMallocBlock__`。\n\n反证：\n```\nNSLog(@\"%@\", [^{\n    NSLog(@\"this is a block, age = %d\", age);\n} class]);\n```\n\nARC 环境下打印结果：\n```\n__NSStackBlock__\n```\n\n从打印结果可以看到，block 在没有被 `__strong` 指针指向时，其类型还是 `__NSStackBlock__` 类型，内存依然在栈区，说明 block 在没有 __strong 指针指向的时候不会调用 copy。\n\n### block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数\n```\nNSArray *array = @[];\n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    \n}]; //[^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop){} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n```\n\n### block 作为 GCD API 的方法参数\nGCD API 里的 block 都是在堆上的：\n```\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    \n}); //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    \n}); //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n```\n\n## 小结\nMRC 下 block 属性的建议写法\n```\n@property (copy, nonatomic) void (^block)(void);\n```\n\nARC 下 block 属性的建议写法\n```\n@property (strong, nonatomic) void (^block)(void);\n@property (copy, nonatomic) void (^block)(void);\n```\n\n# 对象类型的 auto 变量\n\n## ARC 下的“对象类型的 auto 变量”\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n        } //离开大括号，销毁 person 对象\n\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n运行到断点处的打印结果：\n```\nPerson - dealloc\n```\n\nauto 变量 person 的作用域在当前“{}”内，在没有其它引用的情况下，离开作用域就会被销毁。\n\nblock 捕获 person 对象：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区），ARC 下日常 copy\n        } //销毁 person 对象\n        \n        NSLog(@\"-------\"); //断点1\n    } //销毁 block\n    return 0; //断点2\n}\n```\n\n运行到断点1处没有打印结果。\n\n运行到断点2处的打印结果：\n```\n-------\nPerson - dealloc\n```\n\n简化代码，查看 block 与 person 的关系：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.age = 10;\n        Block block = ^{\n            NSLog(@\"this is a block, person.age = %d\", person.age);\n        }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区），ARC 下日常 copy\n    }\n    return 0;\n}\n```\n\n查看 block 的 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *person; //ARC下是强指针\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *_person, int flags=0) : person(_person) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n可以看到 block 捕获了 person 对象。因为 person 对象是 auto 变量，所以 block 在捕获 person 对象时生成的也是 Person 类型的变量，即：  \n```\nauto int person; -> int person;  \nauto Person *person; -> Person *person;  \n\nstatic int person; -> int *person;  \nstatic Person *person; -> Person **person;\n```\n\n因为在 ARC 下 block 有 copy 操作，所以 block 在堆空间。堆空间的 block 在捕获 person 对象时生成的变量 Person *person 在 ARC 下是强指针，即 block 持有了 person 对象，所以在 block 销毁前，block 不会释放 person。\n\n## MRC 下的“对象类型的 auto 变量”\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"Person - dealloc\");\n}\n@end\n\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            }; //MRC 下没有 copy 操作，block 在栈空间\n            [person release]; // MRC 下的手动释放 person 对象\n        } //销毁 person 对象\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n运行到断点处的打印结果：\n```\nPerson - dealloc\n```\n\n因为在 MRC 下 block 没有 copy 操作，所以 block 在栈空间。在断点处 person 对象被销毁了，说明栈空间的 block 对外部变量 person 对象时弱引用。\n\n对 block 进行 copy 操作\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = [^{\n                //堆空间的 block 会对 person 对象进行 retain 操作 [person retain]\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            } copy]; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n            [person release]; // MRC 下的手动释放 person 对象\n        }\n        NSLog(@\"-------\"); //断点\n    } //销毁 block 前，block 会释放 person 对象（release）\n    return 0;\n}\n```\n\n运行到断点处没有打印结果。\n\n因为在 MRC 下对 block 进行 copy 操作后，block 的内存就从栈空间拷贝到了堆空间，堆空间的 block 会对 person 对象进行 retain 操作 [person retain]，即 block 持有了 person 对象，所以在 block 销毁前，block 不会释放 person。\n\n堆空间的 block 在销毁时会对 person 对象进行一次 release 操作 [person release]。\n\n\n# __weak\n\n在使用 clang 转换 OC 为 C++ 代码时，如果使用了 `__weak` 可能会遇到以下问题：cannot create \\_\\_weak reference in file using manual reference\n\n解决方案：支持 ARC、指定运行时系统版本  \n```\n-fobjc-arc -fobjc-runtime=ios-8.0.0\n```\n即\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n## __strong 修饰的“对象类型的 auto 变量”\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            };\n        }\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n断点处没有打印结果。  \n\n在 ARC 下，block 在赋值给 __strong 指针时会调用 copy，block 的内存从栈区被拷贝到堆区，同时会对不会的变量进行强引用（__strong），所以断点处 person 没有销毁。\n\n查看 c++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__strong person; //__strong 强引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__strong _person, int flags=0) : person(_person) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n## __weak 修饰的“对象类型的 auto 变量”\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n            __weak Person *weakPerson = person;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", weakPerson.age);\n            };\n        } //销毁 person\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n断点处的打印结果：\n```\nPerson - dealloc\n```\n\n`__weak` 修饰的 person 对象，不会被 block 强引用。\n\n查看 c++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__weak weakPerson; //__weak 弱引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n    }\n};\n```\n\n结合“MRC 下对'对象类型的 auto 变量'的引用”可以看出，不管 block 的 c++ 结构体里引用外部变量的是 `__weak`（弱引用） 还是 `__strong`（强引用），栈上的 block 对外部变量的引用都不是强引用。\n\n## copy 函数和 dispose 函数\n\n![block11](block/block11.png)\n\n以上面使用 __weak 修改变量的 c++ 代码为例：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__weak weakPerson; //__weak 弱引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    Person *__weak weakPerson = __cself->weakPerson; // bound by copy\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_52dcf5_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)weakPerson, sel_registerName(\"age\")));\n}\n\n//copy 函数，调用时机：栈上的 block 复制到堆时\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    //会根据 auto 变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用。方法内部有引用计数的管理。\n    _Block_object_assign((void*)&dst->weakPerson, (void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\n//dispose 函数，调用时机：堆上的 block 被废弃时\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n    //会自动释放引用的 auto 变量（release）\n    _Block_object_dispose((void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); //copy 函数\n    void (*dispose)(struct __main_block_impl_0*); //dispose 函数\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        Block block;\n        {\n            Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n            ((void (*)(id, SEL, int))(void *)objc_msgSend)((id)person, sel_registerName(\"setAge:\"), 10);\n            __attribute__((objc_ownership(weak))) Person *weakPerson = person;\n            block = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, weakPerson, 570425344));\n        }\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_52dcf5_mi_1);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n`__main_block_desc_0` 结构体多了两个函数指针 copy 和 dispose，分别对应着 `__main_block_copy_0` 方法和 `__main_block_dispose_0` 方法。\n\n## GCD 与“对象类型的 auto 变量”\n\n### GCD 与 __strong 修饰的“对象类型的 auto 变量”\n创建一个 iOS 项目测试：\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"Person: %@\", person);\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 10:19:58.941605+0800 block-test[4017:52615] touchesBegan:withEvent:\n2020-06-09 10:20:01.941715+0800 block-test[4017:52615] Person: <Person: 0x600001040370>\n2020-06-09 10:20:01.941879+0800 block-test[4017:52615] Person - dealloc\n```\n\n从打印结果可以看到，在触摸事件触发后3秒，GCD 的 block 代码块打印了 person 对象，几乎是同时，person 对象被销毁了，说明 GCD 的 block 与 person 对象之间是强引用关系（`__strong`）。这是因为 GCD 的 block 在 ARC 下回自动调用 copy，将内存从栈区拷贝到堆区，堆区的 block 又会调用 block 内部的 copy 函数对 person 对象根据引用类型（`__strong`）进行强引用（retain）。\n\n### GCD 与 __weak 修饰的“对象类型的 auto 变量”\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"Person: %@\", weakPerson);\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 10:31:06.313268+0800 block-test[4386:61611] touchesBegan:withEvent:\n2020-06-09 10:31:06.313352+0800 block-test[4386:61611] Person - dealloc\n2020-06-09 10:31:09.313416+0800 block-test[4386:61611] Person: (null)\n```\n\n从打印结果可以看到，在触摸事件触发时，person 对象就被销毁了，3秒后 block 内部打印的 person 对象等于（null），说明 GCD 的 block 与 person 对象之间是弱引用关系（`__weak`）。这是因为 GCD 的 block 在 ARC 下会自动调用 copy，将内存从栈区拷贝到堆区，堆区的 block 又会调用 block 内部的 copy 函数对 person 对象根据引用类型（`__weak`）进行弱引用。\n\n拓展：\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"time：1，Person: %@\", weakPerson); //__weak\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            NSLog(@\"time：2，Person: %@\", person); //__strong\n        });\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 13:41:54.571551+0800 block-test[9174:148566] touchesBegan:withEvent:\n2020-06-09 13:41:55.670345+0800 block-test[9174:148566] time：1，Person: <Person: 0x600002a90130>\n2020-06-09 13:41:57.842076+0800 block-test[9174:148566] time：2，Person: <Person: 0x600002a90130>\n2020-06-09 13:41:57.842202+0800 block-test[9174:148566] Person - dealloc\n```\n\n1秒的定时器对 person 对象时弱引用（`__weak`），2秒的定时器对 person 对象是强引用（`__strong`），所以 person 对象会在2秒的 GCD 定时器执行完成后，在 block 销毁前被释放。\n\n## 小结\n\n* 如果 block 是在栈上，将不会对 auto 变量产生强引用  \n不管是 ARC 下还是 MRC 下，栈空间的 block 是不会持有“对象类型的 auto 变量”的。堆空间的 block 在 ARC 下通过 `__strong`（强引用）持有“对象类型的 auto 变量”。在 MRC 下，当 block 手动调用 copy 从栈区拷贝到堆区，并通过 retain 持有“对象类型的 auto 变量”，通过 release 释放“对象类型的 auto 变量”。 \n\n* 如果 block 被拷贝到堆上，会调用 block 内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会根据 auto 变量的修饰符（`__strong`、`__weak`、`__unsafe_unretained`）做出相应的操作，形成强引用（retain）或者弱引用。\n\n* 如果 block 从堆上移除，会调用 block 内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放引用的 auto 变量（release）。\n\n# __block\n\n## __block 的本质\n\nblock 内部无法修改 auto 变量的值：\n![block12](block/block12.png)\n\nblock 内部可以修改全局变量、静态变量（static）。  \n全局变量：\n```\ntypedef void(^Block)(void);\n\nint age = 10;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n```\n\n静态变量（static）：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        static int age = 10;\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n```\n \n`__block` 可以用于解决 block 内部无法修改 auto 变量值的问题：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block int age = 10;\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n        NSLog(@\"%p\", &age);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n0x7ffeefbff578\n```\n\n编译器会将 `__block` 变量包装成一个对象，查看 c++ 代码：\n```\ntypedef void(*Block)(void);\n\n//__block 变量被包装成一个对象\nstruct __Block_byref_age_0 {\n  void *__isa; //具有 isa 指针，说明 __Block_byref_age_0 结构体是一个对象\n__Block_byref_age_0 *__forwarding; //指向 __Block_byref_age_0 结构体自身\n int __flags;\n int __size; //__Block_byref_age_0 结构体的大小\n int age; //auto 变量（10）\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_age_0 *age; //指向 __block 变量包装成的对象 \n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    __Block_byref_age_0 *age = __cself->age; //获取到 __Block_byref_age_0 对象\n    (age->__forwarding->age) = 20; //通过 age（__Block_byref_age_0）对象的 __forwarding 指针找到 age（__Block_byref_age_0）对象里的参数 int age\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_f95ea5_mi_0, (age->__forwarding->age));\n}\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->age, (void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        //对应的 OC 代码：__block int age = 10;\n        //简化后：__Block_byref_age_0 age = {0,&age, 0, sizeof(__Block_byref_age_0), 10};\n        __attribute__((__blocks__(byref))) __Block_byref_age_0 age = {(void*)0, //isa 指针\n                                                                      (__Block_byref_age_0 *)&age, //age（__Block_byref_age_0）对象的地址值\n                                                                      0, \n                                                                      sizeof(__Block_byref_age_0), //__Block_byref_age_0 结构体的大小\n                                                                      10}; //auto 变量 age 的值\n        Block block = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, \n                                                        &__main_block_desc_0_DATA, \n                                                        (__Block_byref_age_0 *)&age, \n                                                        570425344));\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n        //NSLog(@\"%p\", &age); 访问的是 __block 结构体里面的 age 变量\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_85d8e5_mi_1, &(age.__forwarding->age));\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n被 `__block` 修饰过的 auto 变量被包装成一个 `__Block_byref_age_0` 结构体。因为 `__Block_byref_age_0` 结构体内有 isa 指针，所以 `__Block_byref_age_0` 结构体是一个对象。`__Block_byref_age_0` 结构体的 `__forwarding` 指针指向自身，在 block 的执行代码里调用 `__Block_byref_age_0` 结构体内部参数 age 时，就是通过 `__forwarding` 指针调用的（age->\\_\\_forwarding->age）。\n\n外部再想访问 age 时，也会通过 `__block` 结构体访问 &(age.\\_\\_forwarding->age)，如：NSLog(@\"%p\", &age)：\n```\nNSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_85d8e5_mi_1, &(age.__forwarding->age));\n```\n\n![block14](block/block14.png)\n\n`__block` 修改“对象类型的 auto 变量”  \n```\nstruct __Block_byref_obj_0 {\n    void *__isa;\n    __Block_byref_obj_0 *__forwarding;\n    int __flags;\n    int __size;\n    void (*__Block_byref_id_object_copy)(void*, void*); //copy 函数（内存管理相关）\n    void (*__Block_byref_id_object_dispose)(void*); //dispose 函数（内存管理相关）\n    NSObject *obj; //auto 变量\n};\n```\n\n使用 `__bloclk` 修改“对象类型的 auto 变量” 同样会生成对应的 `__Block_byref_obj_0` 对象。相对于普通的 auto 变量，增加了 copy 函数和 dispose 函数用于内存管理。\n\n`__bloclk` 结构体内部用于保存 auto 变量 obj 的变量 NSObject *obj，同  auto 变量的类型保持一致。\n\n`__block` 不能修饰全局变量、静态变量（static）\n\n![block13](block/block13.png)\n\nblock 内部可以使用 array 指针，但是不可以修改 array 指针：  \n使用 array 指针：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableArray *array = [NSMutableArray array];\n        Block block =  ^{\n            [array addObject:@\"123\"];\n        };\n        block();\n    }\n    return 0;\n}\n```\n\nblock 内部可以使用 NSMutableArray 指针（如：[array addObject:@\"123\"]），不需要添加 `__block`。  \n\n修改 array 指针：\n![block15](block/block15.png)\n\nblock 内部不可以修改 NSMutableArray 的指针（如：array = nil），如果需要修改 NSMutableArray 指针的话，需要添加 `__block`。 \n\n## \\_\\_block 的内存管理\n\n当 block 在栈上时，并不会对 `__block` 变量产生强引用。  \n\n当 block 被 copy 到堆时，会调用 block 内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会对 `__block` 变量形成强引用（retain）。\n\n![block16](block/block16.png)\n\n\n当 block 从堆中移除时，会调用 block 内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放引用的 `__block` 变量（release）。\n\n![block17](block/block17.png)\n\n\n### 对象类型的 auto 变量、\\_\\_block 变量\n\n![block19](block/block19.png)\n\n当 block 在栈上时，对对象类型的 auto 变量、`__block` 变量都不会产生强引用.  \n\n当 block 拷贝到堆上时，都会通过 copy 函数来处理对象类型的 auto 变量、`__block` 变量。  \n当 block 从堆上移除时，都会通过 dispose 函数来释放对象类型的 auto 变量、`__block` 变量。  \n\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *personBlock = [[Person alloc] init];\n        Person *person = [[Person alloc] init];\n        Block block = ^{\n            NSLog(@\"%@, %@\", personBlock, person);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n查看 c++ 代码：\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    _Block_object_assign((void*)&dst->personBlock, (void*)src->personBlock, 8/*BLOCK_FIELD_IS_BYREF*/); //__block 变量\n    _Block_object_assign((void*)&dst->person, (void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/); //对象类型的 auto 变量\n}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n    _Block_object_dispose((void*)src->personBlock, 8/*BLOCK_FIELD_IS_BYREF*/); //__block 变量\n    _Block_object_dispose((void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/); //对象类型的 auto 变量\n}\n```\n\n### 被 \\_\\_block 修饰的对象类型\n\n#### ARC 下：\n\\_\\_block Person *person 的内存结构：\n![block21](block/block21.png)\n\n\\_\\_block \\_\\_weak Person *weakPerson 的内存结构：\n![block20](block/block20.png)\n\n#### MRC 下：\n查看支持 MRC、指定运行时系统版本的 c++ 代码：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fno-objc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n栈区的 block：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        Block block = ^{\n            NSLog(@\"%@\", person);\n        };\n        [person release];\n        block();\n        [block release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPerson - dealloc\n```\n\n堆区的 block：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        Block block = [^{\n            NSLog(@\"%@\", person);\n        } copy];\n        [person release];\n        block();\n        [block release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPerson - dealloc\n```\n\n栈区和堆区的 block 在执行代码时出现同样的错误：\n\n![block22](block/block22.png)\n\nMRC 下栈区和堆区的 block 都不会对指向的对象产生强引���（_Block_object_assign 没有 retain 操作），内存结构：\n![block23](block/block23.png)\n\n截图👆里 `__Block_byref_person_0` 结构体里的 Person \\*person 可能是省略了 `__weak`，即 Person \\*\\_\\_weak person;\n\n对比没有 `__block` 的对象类型的 auto 变量的内存结构：\n![block24](block/block24.png)\n\n\n#### 小结\n\n当 `__block` 变量在栈上时，不会对指向的对象产生强引用。  \n\n当 `__block` 变量被 copy 到堆时，会调用 `__block` 变量内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会根据所指向对象的修饰符（`__strong`、`__weak`、`__unsafe_unretained`）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于 ARC 时会 retain，MRC 时不会 retain）。\n\n当 `__block` 变量从堆上移除时，会调用 `__block` 变量内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放指向的对象（release）。\n\n## \\_\\_block 的 \\_\\_forwarding 指针\n\n![block18](block/block18.png)\n\nage.\\_\\_forwarding->age：`__Block_byref_obj_0` 结构体对应的 age 对象通过 `__forwarding` 指针找到被拷贝到堆里的 `__block` 结构体，再找到结构体里的 age 变量。\n\n\n## 循环引用\n\n常见循环引用问题：\n```\n@implementation Person\n- (void)test {\n    self.block = ^{\n        NSLog(@\"self.age = %d\", self.age);\n    };\n}\n@end\n```\n\n引用关系：self -> block -> self\n\n引用关系图解：\n![block25](block/block25.png)\n\n`__block` 变量的循环引用问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = ^{\n            NSLog(@\"%d\", person.age);\n        };\n    }\n    return 0;\n}\n```\n\n引用关系：person -> block -> __block person -> person\n\n引用关系图解：\n![block27](block/block27.png)\n\n### 解决循环引用问题 - ARC\n\n解决方案一：用 `__weak`、`__unsafe_unretained` 解决，去掉 block 对 对象的强引用关系：\n```\n//__weak \n- (void)test {\n    __weak typeof(self) weakSelf = self;\n    self.block = ^{\n        NSLog(@\"self.age = %d\", weakSelf.age);\n    };\n}\n\n//__unsafe_unretained\n- (void)test {\n    __unsafe_unretained typeof(self) weakSelf = self;\n    self.block = ^{\n        NSLog(@\"self.age = %d\", weakSelf.age);\n    };\n}\n```\n\n`__weak`：不会产生强引用，指向的对象销毁时，会自动让指针置为 nil。  \n`__unsafe_unretained`：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变。\n\n\n图解：\n![block26](block/block26.png)\n\n\n解决方案二：用 `__block` 解决（必须要调用 block），通过将捕获的变量置为 nil，去掉 `__block` 变量和对象之间的强引用关系：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = ^{\n            NSLog(@\"%d\", person.age);\n            person = nil;\n        };\n        person.block();\n    }\n    return 0;\n}\n```\n\n图解：\n![block28](block/block28.png)\n\n\n#### \\_\\_weak 安全问题\n```\n- (void)test {\n    __weak typeof(self) weakSelf = self;\n    self.block = ^{\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        NSLog(@\"self.age = %d\", strongSelf.age);\n    };\n}\n```\n\n被 `__weak` 修饰的变量随时可能被释放，block 内部有可能访问的 weakSelf 已经不存在了。通过 `__strong` 修饰后，可以保证在 block 执行完成前 strongSelf 一直在。\n\n### 解决循环引用问题 - MRC\n\n解决方案一：用 `__unsafe_unretained` 解决，声明后的 person 对象在 block 里不会被 retain：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __unsafe_unretained Person *person = [[Person alloc] init];\n        person.block = [^{\n            NSLog(@\"%d\", person.age);\n        } copy];\n        [person release];\n    }\n    return 0;\n}\n```\n\n解决方案二：用 `__block` 解决，MRC 下的 block 不会对 `__block` 变量进行 retain 操作：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = [^{\n            NSLog(@\"%d\", person.age);\n        } copy];\n        [person release];\n    }\n    return 0;\n}\n```\n\n\n# 总结\n* block 的原理是怎样的？本质是什么？  \nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象。\n\n* `__block`的作用是什么？有什么使用注意点？  \n作用：`__block` 可以用于解决 block 内部无法修改 auto 变量值的问题。  \n注意：在 MRC 下 `__block` 变量不会对指向的对象产生强引用。\n\n* block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？  \nblock 创建时内存是在栈上的，进行 copy 操作后，block 的内存就从栈上拷贝到了堆上。  \n堆上的 block 对捕获到的变量有强引用，需要注意 block 与被捕获的变量之间是否存在循环引用的问题。\n\n* block 在修改 NSMutableArray，需不需要添加 `__block`？  \nblock 内部可以使用 NSMutableArray 指针（如：[array addObject:@\"123\"]），不需要添加 `__block`。  \nblock 内部不可以修改 NSMutableArray 的指针（如：array = nil），如果需要修改 NSMutableArray 指针的话，需要添加 `__block`。 ","source":"_posts/OC底层原理/block.md","raw":"---\ntitle: block\ndate: 2020-05-31 16:02:28\ntags: OC底层原理\n---\n\n思考：\n* block 的原理是怎样的？本质是什么？\n* `__block`的作用是什么？有什么使用注意点？\n* block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？\n* block 在修改 NSMutableArray，需不需要添加 `__block`？\n\n\n<!-- more -->\n\n# 基本认识\n\n## block\n```\n^{\n    NSLog(@\"this is a block\");\n};\n```\n\nblock 可以封装一块代码，在将来需要执行的地方通过“()”进行调用：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        ^{\n            NSLog(@\"this is a block\");\n        }();\n    }\n    return 0;\n}\n```\n\n或者\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = ^{\n            NSLog(@\"this is a block\");\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block\n```\n\n## block 的 C++ 代码\n查看 block 的 C++ 代码。找到 main.m 文件，在终端输入：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp\n```\n\nblock 的 C++ 代码（精简版）：\n```\nstruct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size; //占用内存大小\n}\n\nstruct __block_impl {\n    void *isa; //指向父类的指针（OC对象特征）\n    int Flags;\n    int Reserved;\n    void *FuncPtr; //函数地址，用于函数调用\n};\n\nstruct __main_block_impl_0 { //block 结构体\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int a; //调用环境\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int a = 20;\n        void (^block)(void) = ^{\n            NSLog(@\"this is a block - %d\", a); //断点2\n        };\n        block(); //断点1\n    }\n    return 0;\n}\n```\n\n## __main_block_impl_0\n`__main_block_impl_0` 是 block 在 C++ 中的结构体实现。第一个参数 __block_impl 中有一个 isa 指针，具备 OC 对象特征，说明 block 本质上也是一个 OC 对象。  \n\n`__main_block_impl_0` 省略 `__block_impl` 和 `__main_block_desc_0` 后可以看成：\n```\nstruct __main_block_impl_0 {\n    void *isa; \n    int Flags;\n    int Reserved;\n    void *FuncPtr; \n    size_t reserved;\n    size_t Block_size;\n    int a; \n};\n```\n\n即：\n![block03](block/block03.png)\n\n## FuncPtr\nFuncPtr 是一个指针，指向 block 封装的代码块的函数地址。  \n\n在断点1处打印 FuncPtr 地址：  \n![block01](block/block01.png)\n\n```\nPrinting description of blockStruct->impl.FuncPtr:\n(void *) FuncPtr = 0x0000000100000f00\n```\n\n在断点2处，选择 Debug -> Debug Workflow -> Always Show Disassembly:\n![block02](block/block02.png)\n\n可以看到，block 里的开始地址值 100000f00 等于 FuncPtr 的地址值。说明 block 里的代码块的地址值被保存在了 `__block_impl` 里的 FuncPtr 中（函数调用），另外 `__main_block_impl_0` 里保存了外部变量 int a（调用环境），说明 block 是封装了函数调用以及函数调用环境的 OC 对象。\n\n\n\n# block 的本质\n\nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象，它内部也有个 isa 指针。\n\n## 定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n查看 block 的 C++ 代码：\n```\nstruct __block_impl {\n    void *isa; //指向父类\n    int Flags;\n    int Reserved;\n    void *FuncPtr; //指向 __main_block_func_0 函数地址的指针，用于函数调用\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl; //作为第一个变量，__block_impl 的内存地址就是 __main_block_impl_0 内存地址\n    struct __main_block_desc_0* Desc; //描述，是一个结构体变量 __main_block_desc_0_DATA\n    // 构造函数（类似于OC的init方法），返回结构体对象\n    // 参数 fp：block 执行逻辑的函数的地址，即 __main_block_func_0\n    // 参数 desc：描述，__main_block_desc_0 的结构体变量，即 __main_block_desc_0_DATA\n    // 参数 flags：默认可以不传，flags=0\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock; //指向父类。_NSConcreteStackBlock：block 的类型\n        impl.Flags = flags;\n        impl.FuncPtr = fp; //__main_block_func_0\n        Desc = desc; //__main_block_desc_0_DATA\n    }\n};\n\n// 封装了 block 执行逻辑的函数\n// 参数：block 结构体\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_880b47_mi_0); // NSLog(@\"this is a block\");\n}\n\n// 封装了 block 执行逻辑的函数\nstatic struct __main_block_desc_0 {\n  size_t reserved; // 0\n  size_t Block_size; // block 占用内存大小\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; //__main_block_desc_0 的结构体变量，参数 reserved：0，参数 Block_size：sizeof(struct __main_block_impl_0)\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        // 定义 block 变量，指向结构体 __main_block_impl_0 地址的指针\n        void (*block)(void) = ((void (*)())&__main_block_impl_0(\n                                                                (void *)__main_block_func_0, //block 执行逻辑的函数\n                                                                &__main_block_desc_0_DATA //__main_block_desc_0 的结构体变量\n                                                                ));\n        // 执行 block 内部的代码\n        // 因为在结构体 __main_block_impl_0 中，__block_impl 作为第一个变量，所以 __block_impl 的内存地址就是 __main_block_impl_0 内存地址\n        // 所以这里可以将 block 强转为 __block_impl 类型\n        // FuncPtr：函数 __main_block_func_0 地址\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block); //简化后：block->FuncPtr(block)\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n`__main_block_impl_0`、`__block_impl` 和 `__main_block_desc_0` 三者之间的关系：\n![block04](block/block04.png)\n\n## 有参数的 block\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(int, int) =  ^(int a, int b){\n            NSLog(@\"this is a block - %d, %d\", a, b);\n        };\n        block(10, 20);\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码，可以看到 `__main_block_func_0` 函数发生了变化：\n```\nstruct __block_impl {\n    void *isa; \n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数，增加了参数 a 和 b\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, int a, int b) {\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_f90d21_mi_0, a, b);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;\n        // 定义 block 变量，增加了参数 10 和 20\n        void (*block)(int, int) = ((void (*)(int, int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        ((void (*)(__block_impl *, int, int))((__block_impl *)block)->FuncPtr)((__block_impl *)block, 10, 20); //简化后：block->FuncPtr(block, 10, 20)\n    }\n    return 0;\n}\n```\n\n## 小结\n* block的原理是怎样的？本质是什么？  \nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象，它内部也有个 isa 指针。\n\n# 变量捕获（capture）\n\n为了保证 block 内部能够正常访问外部的变量，block 有个变量捕获机制。  \n变量捕获机制：block 内部会生成对应的成员变量或指针，存储被捕获变量的值或地址值。\n\n![block06](block/block06.png)\n\nps：局部变量还有一个 register 变量（定义 int age = 10，尽量使用寄存器寄存变量 age）。\n```\nregister int age = 10;\n```\n\n## 局部变量\n\n### auto 变量捕获\n* auto 变量的作用域在当前“{}”内，离开作用域就销毁。\n* auto 变量的捕获方式是值传递。  \n\n平时定义的局部变量 int age = 10 默认就是 auto 变量，auto 省略不写：\n```\nauto int age = 10; // int age = 10;\n```\n\n定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - %d\", age);\n        };\n        age = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block - 10\n```\n\n因为 auto 变量的捕获方式是值传递，即 block 捕获的是 age 的值（10），而不是 age 的地址值，所以在 block 捕获了 age 的值（10）后，再通过指针 age 修改指向的地址里的值（20），block 捕获到的值（10）不变。所以打印结果是 10。\n\n查看 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int age; //新增变量，用于捕获外部变量 age\n\n    //构造函数\n    //参数 _age：新增参数\n    //age(_age)方法：将参数 _age 赋值给 age，即 age(_age) 方法等于 age = _age;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int age = __cself->age; //取出 block 里的 age\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_de0112_mi_0, age); //NSLog(@\"this is a block - %d\", age);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        // 定义 block 变量，__main_block_impl_0 方法里捕获了 age\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age));\n        age = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block); //简化后：block->FuncPtr(block)\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n![block05](block/block05.png)\n\nblock 的结构体 __main_block_impl_0 内部新增了成员变量 age，就是用来捕获外部 auto 变量 age 用的。\n\n### static 变量捕获\n* static 变量会一直保存在内存里。\n* static 变量的捕获方式是指针传递。\n\nstatic 声明的局部变量只初始化一次，其内存分配在静态存储区（数据区域），在程序中只有一份内存，并且在整个程序执行期间都存在不会释放。虽然 static 变量的内存不会释放，但是其作用域并没有改变。\n\n定义 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        static int height = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n        };\n        age = 20;\n        height = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int age; //新增变量 age，用于捕获外部 auto 变量 age 的值\n    int *height; //新增指针 height，用于捕获外部的 static 变量 height 的地址值\n\n    //构造函数\n    //参数 *_height：static 变量的地址值\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int age = __cself->age; //获取 block 的 age\n    int *height = __cself->height; // 获取 block 的 height\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_ac9850_mi_0, age, (*height)); //NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        static int height = 10;\n        //调用 __main_block_impl_0 方法出入 age 和 &height（height 的地址）生成 block 指针\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age, &height));\n        age = 20;\n        height = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n因为 static 变量的捕获方式是指针传递，即 block 捕获的是 height 的地址值，所以在 block 捕获了 height 地址值后，再通过指针 height 修改地址里的值（20），block 捕获到的地址里的值就是 20 了，所以打印结果是 20。\n\n### 指针传递 & 值传递\n```\nvoid (^block)(void);\n\nvoid test()\n{\n    int age = 10;\n    static int height = 10;\n    block =  ^{\n        NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    };\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n因为 age 是 auto 变量，所以在 test() 执行后 age 就被被销毁了。因为 block 在执行时会访问 age，而 age 地址对应的内存已经被销毁不能被访问，所以 block 在捕获 age 时只能捕获 age 的值不能捕获 age 的地址值。因此 block 在捕获 auto 变量时采取的策略的是值传递。\n\n因为 height 是 static 变量，会一直保存在内存里，所以 block 在执行时依然能成功访问 height 的地址。因此 block 在捕获 static 变量时采取的策略的是指针传递。\n\n### self 的捕获方式\n定义 Person：\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n- (void)test {\n    void (^block)(void) = ^{\n        NSLog(@\"---- %p\", self);\n    };\n    block();\n}\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self test];\n    }\n    return self;\n}\n@end\n```\n\n查看 Person.m 的 C++ 实现：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person.m\n```\n\n-(void)test 方法的 C++ 代码：\n```\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n```\n\n-(void)test 方法的 C++ 实现时有两个默认参数，类对象 self 和 test 方法的指针 _cmd。因为参数都是局部变量，所以作为参数出入的 self 和 _cmd 是局部变量。\n\nblock 的 C++ 代码：\n```\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self 变量的地址值\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n    Person *self = __cself->self; //通过 block 获取 self\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_e5b707_mi_0, self);\n}\n```\n\n因为局部变量都会被 block 捕获，所以 self 以参数的形式传入后，block 结构体 __Person__test_block_impl_0 里新增了一个变量 Person *self 用来捕获 self 的地址值。\n\n#### 成员变量 _name 的捕获方式\n```\n- (void)test {\n    void (^block)(void) = ^{\n        NSLog(@\"---- %p\", _name); //等同于self->_name\n    };\n    block();\n}\n```\n\nblock 内部调用 _name 的方式等同于 self->_name，即 block 还是先捕获 self 再通过 self->_name 获取 _name。\n\n查看 C++ 代码：\n```\n//-(void)test\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n\n//block 结构体\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n  Person *self = __cself->self; //通过 block 获取 self\n    //self + OBJC_IVAR_$_Person$_name 调用 _name\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_6a1844_mi_0, (*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_Person$_name)));\n}\n```\n\n#### self.name 的捕获方式\n\nself.name 等同于 [self name]，在调用时通过向捕获的 self 发送“name”消息调用，objc_msgSend(self, sel_registerName(\"name\"))。\n```\n//-(void)test\nstatic void _I_Person_test(Person * self, SEL _cmd) {\n    //调用构造函数 __Person__test_block_impl_0 传入 self\n    void (*block)(void) = ((void (*)())&__Person__test_block_impl_0((void *)__Person__test_block_func_0, &__Person__test_block_desc_0_DATA, self, 570425344));\n    ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n}\n\n//block 结构体\nstruct __Person__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __Person__test_block_desc_0* Desc;\n    Person *self; //捕获 self\n    __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {\n  Person *self = __cself->self; //通过 block 获取 self\n    //向 self 发送 “name” 消息\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_Person_49af9b_mi_0, ((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"name\")));\n}\n```\n\n## 全局变量\n\n* 全局变量的内存存放在数据区域，在整个程序执行期间都存在不会释放。\n* 全局变量不会被 block 捕获，而是直接访问。\n\n定义 block：\n```\nint age_ = 10;\nstatic int height_ = 10;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block - age = %d，height = %d\", age_, height_);\n        };\n        age_ = 20;\n        height_ = 20;\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block - age = 20，height = 20\n```\n\n查看 C++ 代码：\n```\nint age_ = 10; //全局变量 age_\nstatic int height_ = 10; //全局变量 height_\n\n//block 结构体，并没有捕获全局变量 age 和 height\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    //构造函数\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// 封装了 block 执行逻辑的函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    //NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    //age_ 和 height_ 不是通过参数传进来的，而是直接调用\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_d9e2db_mi_0, age_, height_);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        // 定义 block 变量\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        age_ = 20;\n        height_ = 20;\n\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n全局变量不会被 block 捕获，因为全局变量的内存存放在全局（静态）存储区，任何函数都可以访问，所以在 __main_block_func_0 方法执行时，不需要通过 block 获取变量，而是直接访问。\n\n## block 捕获局部变量的原因\n局部变量之所以会被捕获，是因为局部变量的作用域的限制。为了防止在 block 调用时，局部变量因为超出作用域而无法访问了，block 会记住需要用到的局部变量，在调用 block 执行 __main_block_func_0 函数时，再从 block 取出局部变量：\n```\nvoid (^block)(void);\n\nvoid test()\n{\n    int age = 10;\n    static int height = 10;\n    block =  ^{\n        NSLog(@\"this is a block - age = %d，height = %d\", age, height);\n    };\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n查看 C++ 代码：\n```\nvoid (*block)(void);\n\nstruct __test_block_impl_0 {\n    struct __block_impl impl;\n    struct __test_block_desc_0* Desc;\n    int age;\n    int *height;\n    __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//跨函数调用 age_ 和 height_\nstatic void __test_block_func_0(struct __test_block_impl_0 *__cself) {\n    int age = __cself->age; //获取 block 里捕获的 age\n    int *height = __cself->height; //获取 block 里捕获的 height\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_d42dac_mi_0, age, (*height));\n}\n\nstatic struct __test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n} __test_block_desc_0_DATA = { 0, sizeof(struct __test_block_impl_0)};\n\n//定义 age 和 height\nvoid test()\n{\n    int age = 10; \n    static int height = 10;\n    //调用 __test_block_impl_0 传入 age 和 height 生成 block\n    block = ((void (*)())&__test_block_impl_0((void *)__test_block_func_0, &__test_block_desc_0_DATA, age, &height));\n    age = 20;\n    height = 20;\n}\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        test();\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n局部变量 age 和 height 的作用域是 test() 函数的“{}”内，而调用局部变量 age 和 height 是在 `__test_block_func_0` 函数里，为了实现跨函数调用局部变量，使用 block 捕获变量机制。在 `__test_block_func_0` 函数内可以通过 block 获取到被捕获的局部变量 age 的值和局部变量 height 的地址值。\n\n# block 的继承\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        NSLog(@\"%@\", [block class]);\n        NSLog(@\"%@\", [[block class] superclass]);\n        NSLog(@\"%@\", [[[block class] superclass] superclass]);\n        NSLog(@\"%@\", [[[[block class] superclass] superclass] superclass]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n__NSGlobalBlock\nNSBlock\nNSObject\n```\n\n从打印结果可以看出，block 的继承关系是：\n```\n__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject\n```\n\nblock 最终继承自 NSObject，block 里的 isa 指针来自 NSObject，也说明了 block 是一个 OC 对象。\n\n\n# block 的类型\nblock 有3种类型，可以通过调用 class 方法或者 isa 指针查看具体类型，最终都是继承自 NSBlock 类型。\n\n* \\_\\_NSGlobalBlock\\_\\_ （ _NSConcreteGlobalBlock ）\n* \\_\\_NSStackBlock\\_\\_ （ _NSConcreteStackBlock ）\n* \\_\\_NSMallocBlock\\_\\_ （ _NSConcreteMallocBlock ）\n\n## 查看 block 的类型\n（ARC 环境下）定义三种类型的 block：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block1)(void) =  ^{\n            NSLog(@\"this is a block1\"); //__NSGlobalBlock__\n        };\n        \n        int age = 10;\n        void (^block2)(void) = ^{\n            NSLog(@\"this is a block2, age = %d\", age); //__NSMallocBlock__\n        }; //ARC 环境下默认调用 copy\n       \n        NSLog(@\"%@ %@ %@\", [block1 class], [block2 class], [^{\n            NSLog(@\"this is block3, age = %d\", age); //__NSStackBlock__\n        } class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__\n```\n\n终端通过 clang 生成 C++ 代码（只贴 block 结构体）：\n```\n//block1\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//block2\nstruct __main_block_impl_1 {\n    struct __block_impl impl;\n    struct __main_block_desc_1* Desc;\n    int age;\n    __main_block_impl_1(void *fp, struct __main_block_desc_1 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n//block3\nstruct __main_block_impl_2 {\n    struct __block_impl impl;\n    struct __main_block_desc_2* Desc;\n    int age;\n    __main_block_impl_2(void *fp, struct __main_block_desc_2 *desc, int _age, int flags=0) : age(_age) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n从上面👆 C++ 代码可以看到，三个 block 的 isa 都是指向 &_NSConcreteStackBlock，即三个 block 都是 `__NSStackBlock__` 类型的？！通过终端命令生成的编译文件，跟运行时打印的结果不一样？！\n\n原因：\n1. 因为运行时可能会在系统运行过程中修改一些内容，所以这里还是以运行时打印的结果为准。  \n2. 通过 clang 生成的 C++ 代码，有时不一定是编译生成的代码，大致一样，细节上有区别。\n\n## 三种 block 类型的内存分配\n\n应用程序的内存分配：\n* 编译时：  \n程序区域：用于存放编写的代码。  \n数据区域：用于存放全局变量。  \n\n* 运行时：  \n堆区域：用于存放动态分配的内存，如通过 [NSObject alloc] 或者 malloc() 等方式主动申请出的内存。同时也要管理这块内存的释放工作，如 release 或 free() 等。  \n栈区域：用于存放局部变量，系统会负责管理这部分内存的创建和释放工作。\n\n![block07](block/block07.png)\n\n如图，GlobalBlock 存放在数据区域，MallocBlock 存放在堆区域，StackBlock 存放在栈区。\n\n## 三种 block 类型的划分\n![block08](block/block08.png)\n\n为了保证打印结果的准确性，需要关闭 Xcode 的 ARC。build setting -> Automatic Reference Counting（NO）。\n\n### \\_\\_NSGlobalBlock\\_\\_\n#### 不访问变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block\");\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 访问 static 变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        static int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 访问全局变量：\n```\nint age_ = 10;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age_ = %d\", age_);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n#### 小结\nblock 在“没有访问变量”、“访问 static 变量”和“访问全局变量”的时候，都是 `__NSGlobalBlock__` 类型，放在数据区域。\n\n### \\_\\_NSStackBlock\\_\\_\n\n#### 访问 auto 变量：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSStackBlock__\n```\n\n上面👆的打印结果中可以看到，block 在访问 auto 变量的时候类型是 `__NSStackBlock__`，放在栈区。\n\n放在栈区的 block 会有内存销毁的问题：\n```\nvoid (^block)(void);\nvoid test()\n{\n    int age = 10;\n    block = ^{\n        NSLog(@\"this is a block, age = %d\", age);\n    };\n    NSLog(@\"类型：%@\", [block class]);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n类型：__NSStackBlock__\nthis is a block, age = -272632600\n```\n\n可以看到打印出来的 age 出现异常。因为 block 是 `__NSStackBlock__` 类型的，放在栈区，它的作用域是 void test 方法的“{}”内部。在调用 test() 方法时，会在栈区开辟一块空间（调用栈）给 test() 函数使用，调用完成后该空间（调用栈）会被回收，这时 block 内部的数据就变成垃圾数据了。\n\n#### 小结\n虽然 block 捕获了 auto 变量的值，但是 block 结构体的内存是在栈区的，在 test 函数调用完被销毁后，block 结构体在栈上的内存里的数据可能就变成了垃圾数据。\n\n### \\_\\_NSMallocBlock\\_\\_\n\n可以通过 copy 方法将 `__NSStackBlock__` 类型的 block 变成 `__NSMallocBlock__` 类型。\n\n`__NSStackBlock__` 类型的 block 在调用 copy 后，block 的类型就变成了 `__NSMallocBlock__` 类型。`__NSMallocBlock__` 类型的 block 的内存存放在堆区，由开发者手动管理内存的释放，保证了 block 内存的完整性。\n\n\n# block 的 copy\n\n## 三种 block 类型的 copy\n\n### \\_\\_NSGlobalBlock\\_\\_ 的 copy\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = [^{\n            NSLog(@\"this is a block\");\n        } copy];\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSGlobalBlock__\n```\n\n`__NSGlobalBlock__` 类型的 block 调用 copy 后还是 `__NSGlobalBlock__` 类型。\n\n### \\_\\_NSStackBlock\\_\\_ 的 copy\n```\nvoid (^block)(void);\nvoid test()\n{\n    int age = 10;\n    block = [^{\n        NSLog(@\"this is a block, age = %d\", age);\n    } copy];\n    NSLog(@\"类型：%@\", [block class]);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n类型：__NSMallocBlock__\nthis is a block, age = 10\n```\n\n调用 copy 方法后，block 的类型从 `__NSStackBlock__` 类型变成了 `__NSMallocBlock__` 类型，block 的内存位置就从栈区拷贝到堆区，由开发者手动管理内存的释放。将 block 的内存 copy 到堆区保证了 block 内存的完整性。\n\n### \\_\\_NSMallocBlock\\_\\_ 的 copy\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        void (^block)(void) =  ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        NSLog(@\"%@\", [[[block copy] copy] class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSMallocBlock__\n```\n\n`__NSMallocBlock__` 类型的 block 调用 copy 后还是 `__NSMallocBlock__` 类型，引用计数+1。\n\n### 小结\n![block09](block/block09.png)\n\n从内存管理的角度分析不同类型的 block 调用 copy 的不同现象：\n1. 数据区域的 `__NSGlobalBlock__`，因为数据区域的内存在程序运行期间始终存在不会销毁，所以 `__NSGlobalBlock__` 的内存也没必要拷贝到堆区通过引用计数的方式管理内存。\n2. 堆区的 `__NSMallocBlock__` 是通过引用计数策略被开发者管理内存的，所以在调用 copy 时要遵循引用计数管理逻辑+1。\n3. 栈区的 `__NSStackBlock__` 是系统管理内存的，离开作用域就会销毁。通过 copy 将 `__NSStackBlock__` 类型的 block 的内存放到堆区，通过引用计数的方式管理内存，实现让开发者管理内存。\n\nps：类对象内存的存放位置\n```\nint age = 10;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int a = 10;\n        NSLog(@\"数据段：age %p\", &age);\n        NSLog(@\"栈：a %p\", &a);\n        NSLog(@\"堆：obj %p\", [[NSObject alloc] init]);\n        NSLog(@\"class %p\", [Person class]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n数据段：age 0x100001310\n栈：a 0x7ffeefbff52c\n堆：obj 0x100606140\nclass 0x1000012c0\n```\n\nclass 的内存地址跟 age 很接近，推测类对象的内存地址存放在数据段。\n\n## ARC 环境下 block 的 copy\n\n在 ARC 环境下，编译器会根据情况自动将栈上的 block 复制到堆上，比如以下情况：\n\n### block 作为函数返回值\n\nMRC 环境下 block 作为返回值的报错：Returning block that lives on the local stack\n![block10](block/block10.png)\n\n因为 myBlock() 方法里定义的 block 访问了 auto 变量，所以该 block 是 `__NSStackBlock__` 类型的，内存在栈区，作用域是在 myBlock() 方法的“{}”内。在 MRC 环境下，当 myBlock() 方法调用完成后，该 block 的内存就会被销毁。\n\nARC 环境下 block 作为返回值会调用 copy：\n```\ntypedef void(^Block)(void);\n\nBlock myBlock()\n{\n    int age = 10;\n    return ^{\n        NSLog(@\"this is a block, age = %d\", age);\n    }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block = myBlock();\n        block();\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\nARC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSMallocBlock__\n```\n\n在 ARC 环境下，^{} 在返回时返回的是 [^{} copy]，将 block 的内存从栈区拷贝到了堆区，所以打印 block 类型的结果是 `__NSMallocBlock__`。\n\n### 将 block 赋值给 __strong 指针\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int age = 10;\n        Block block = ^{\n            NSLog(@\"this is a block, age = %d\", age);\n        }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n        block();\n        NSLog(@\"%@\", [block class]);\n    }\n    return 0;\n}\n```\n\nARC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSMallocBlock__\n```\n\nMRC 环境下打印结果：\n```\nthis is a block, age = 10\n__NSStackBlock__\n```\n\n因为 block 访问了 auto 变量，所以该 block 是 `__NSStackBlock__` 类型的，内存在栈区，作用域是在当前“{}”内。在 ARC 环境下，^{} 在赋值给 `__strong` 指针时，调用了 copy（[^{} copy]），将 block 的内存从栈区拷贝到了堆区，所以打印 block 类型的结果是 `__NSMallocBlock__`。\n\n反证：\n```\nNSLog(@\"%@\", [^{\n    NSLog(@\"this is a block, age = %d\", age);\n} class]);\n```\n\nARC 环境下打印结果：\n```\n__NSStackBlock__\n```\n\n从打印结果可以看到，block 在没有被 `__strong` 指针指向时，其类型还是 `__NSStackBlock__` 类型，内存依然在栈区，说明 block 在没有 __strong 指针指向的时候不会调用 copy。\n\n### block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数\n```\nNSArray *array = @[];\n[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    \n}]; //[^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop){} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n```\n\n### block 作为 GCD API 的方法参数\nGCD API 里的 block 都是在堆上的：\n```\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    \n}); //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    \n}); //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n```\n\n## 小结\nMRC 下 block 属性的建议写法\n```\n@property (copy, nonatomic) void (^block)(void);\n```\n\nARC 下 block 属性的建议写法\n```\n@property (strong, nonatomic) void (^block)(void);\n@property (copy, nonatomic) void (^block)(void);\n```\n\n# 对象类型的 auto 变量\n\n## ARC 下的“对象类型的 auto 变量”\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n        } //离开大括号，销毁 person 对象\n\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n运行到断点处的打印结果：\n```\nPerson - dealloc\n```\n\nauto 变量 person 的作用域在当前“{}”内，在没有其它引用的情况下，离开作用域就会被销毁。\n\nblock 捕获 person 对象：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区），ARC 下日常 copy\n        } //销毁 person 对象\n        \n        NSLog(@\"-------\"); //断点1\n    } //销毁 block\n    return 0; //断点2\n}\n```\n\n运行到断点1处没有打印结果。\n\n运行到断点2处的打印结果：\n```\n-------\nPerson - dealloc\n```\n\n简化代码，查看 block 与 person 的关系：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.age = 10;\n        Block block = ^{\n            NSLog(@\"this is a block, person.age = %d\", person.age);\n        }; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区），ARC 下日常 copy\n    }\n    return 0;\n}\n```\n\n查看 block 的 C++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *person; //ARC下是强指针\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *_person, int flags=0) : person(_person) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n可以看到 block 捕获了 person 对象。因为 person 对象是 auto 变量，所以 block 在捕获 person 对象时生成的也是 Person 类型的变量，即：  \n```\nauto int person; -> int person;  \nauto Person *person; -> Person *person;  \n\nstatic int person; -> int *person;  \nstatic Person *person; -> Person **person;\n```\n\n因为在 ARC 下 block 有 copy 操作，所以 block 在堆空间。堆空间的 block 在捕获 person 对象时生成的变量 Person *person 在 ARC 下是强指针，即 block 持有了 person 对象，所以在 block 销毁前，block 不会释放 person。\n\n## MRC 下的“对象类型的 auto 变量”\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"Person - dealloc\");\n}\n@end\n\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            }; //MRC 下没有 copy 操作，block 在栈空间\n            [person release]; // MRC 下的手动释放 person 对象\n        } //销毁 person 对象\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n运行到断点处的打印结果：\n```\nPerson - dealloc\n```\n\n因为在 MRC 下 block 没有 copy 操作，所以 block 在栈空间。在断点处 person 对象被销毁了，说明栈空间的 block 对外部变量 person 对象时弱引用。\n\n对 block 进行 copy 操作\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = [^{\n                //堆空间的 block 会对 person 对象进行 retain 操作 [person retain]\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            } copy]; //[^{} copy]，__NSStackBlock__（栈区）-> __NSMallocBlock__（堆区）\n            [person release]; // MRC 下的手动释放 person 对象\n        }\n        NSLog(@\"-------\"); //断点\n    } //销毁 block 前，block 会释放 person 对象（release）\n    return 0;\n}\n```\n\n运行到断点处没有打印结果。\n\n因为在 MRC 下对 block 进行 copy 操作后，block 的内存就从栈空间拷贝到了堆空间，堆空间的 block 会对 person 对象进行 retain 操作 [person retain]，即 block 持有了 person 对象，所以在 block 销毁前，block 不会释放 person。\n\n堆空间的 block 在销毁时会对 person 对象进行一次 release 操作 [person release]。\n\n\n# __weak\n\n在使用 clang 转换 OC 为 C++ 代码时，如果使用了 `__weak` 可能会遇到以下问题：cannot create \\_\\_weak reference in file using manual reference\n\n解决方案：支持 ARC、指定运行时系统版本  \n```\n-fobjc-arc -fobjc-runtime=ios-8.0.0\n```\n即\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n## __strong 修饰的“对象类型的 auto 变量”\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n            person.age = 10;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", person.age);\n            };\n        }\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n断点处没有打印结果。  \n\n在 ARC 下，block 在赋值给 __strong 指针时会调用 copy，block 的内存从栈区被拷贝到堆区，同时会对不会的变量进行强引用（__strong），所以断点处 person 没有销毁。\n\n查看 c++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__strong person; //__strong 强引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__strong _person, int flags=0) : person(_person) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n## __weak 修饰的“对象类型的 auto 变量”\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block;\n        {\n            Person *person = [[Person alloc] init];\n            person.age = 10;\n            __weak Person *weakPerson = person;\n            block = ^{\n                NSLog(@\"this is a block, person.age = %d\", weakPerson.age);\n            };\n        } //销毁 person\n        NSLog(@\"-------\"); //断点\n    }\n    return 0;\n}\n```\n\n断点处的打印结果：\n```\nPerson - dealloc\n```\n\n`__weak` 修饰的 person 对象，不会被 block 强引用。\n\n查看 c++ 代码：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__weak weakPerson; //__weak 弱引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n    }\n};\n```\n\n结合“MRC 下对'对象类型的 auto 变量'的引用”可以看出，不管 block 的 c++ 结构体里引用外部变量的是 `__weak`（弱引用） 还是 `__strong`（强引用），栈上的 block 对外部变量的引用都不是强引用。\n\n## copy 函数和 dispose 函数\n\n![block11](block/block11.png)\n\n以上面使用 __weak 修改变量的 c++ 代码为例：\n```\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    Person *__weak weakPerson; //__weak 弱引用\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    Person *__weak weakPerson = __cself->weakPerson; // bound by copy\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_52dcf5_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)weakPerson, sel_registerName(\"age\")));\n}\n\n//copy 函数，调用时机：栈上的 block 复制到堆时\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    //会根据 auto 变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用。方法内部有引用计数的管理。\n    _Block_object_assign((void*)&dst->weakPerson, (void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\n//dispose 函数，调用时机：堆上的 block 被废弃时\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n    //会自动释放引用的 auto 变量（release）\n    _Block_object_dispose((void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\nstatic struct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); //copy 函数\n    void (*dispose)(struct __main_block_impl_0*); //dispose 函数\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        Block block;\n        {\n            Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n            ((void (*)(id, SEL, int))(void *)objc_msgSend)((id)person, sel_registerName(\"setAge:\"), 10);\n            __attribute__((objc_ownership(weak))) Person *weakPerson = person;\n            block = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, weakPerson, 570425344));\n        }\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_52dcf5_mi_1);\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n`__main_block_desc_0` 结构体多了两个函数指针 copy 和 dispose，分别对应着 `__main_block_copy_0` 方法和 `__main_block_dispose_0` 方法。\n\n## GCD 与“对象类型的 auto 变量”\n\n### GCD 与 __strong 修饰的“对象类型的 auto 变量”\n创建一个 iOS 项目测试：\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init]; //等同于 __strong Person *person = [[Person alloc] init];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"Person: %@\", person);\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 10:19:58.941605+0800 block-test[4017:52615] touchesBegan:withEvent:\n2020-06-09 10:20:01.941715+0800 block-test[4017:52615] Person: <Person: 0x600001040370>\n2020-06-09 10:20:01.941879+0800 block-test[4017:52615] Person - dealloc\n```\n\n从打印结果可以看到，在触摸事件触发后3秒，GCD 的 block 代码块打印了 person 对象，几乎是同时，person 对象被销毁了，说明 GCD 的 block 与 person 对象之间是强引用关系（`__strong`）。这是因为 GCD 的 block 在 ARC 下回自动调用 copy，将内存从栈区拷贝到堆区，堆区的 block 又会调用 block 内部的 copy 函数对 person 对象根据引用类型（`__strong`）进行强引用（retain）。\n\n### GCD 与 __weak 修饰的“对象类型的 auto 变量”\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"Person: %@\", weakPerson);\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 10:31:06.313268+0800 block-test[4386:61611] touchesBegan:withEvent:\n2020-06-09 10:31:06.313352+0800 block-test[4386:61611] Person - dealloc\n2020-06-09 10:31:09.313416+0800 block-test[4386:61611] Person: (null)\n```\n\n从打印结果可以看到，在触摸事件触发时，person 对象就被销毁了，3秒后 block 内部打印的 person 对象等于（null），说明 GCD 的 block 与 person 对象之间是弱引用关系（`__weak`）。这是因为 GCD 的 block 在 ARC 下会自动调用 copy，将内存从栈区拷贝到堆区，堆区的 block 又会调用 block 内部的 copy 函数对 person 对象根据引用类型（`__weak`）进行弱引用。\n\n拓展：\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event \n{\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        NSLog(@\"time：1，Person: %@\", weakPerson); //__weak\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            NSLog(@\"time：2，Person: %@\", person); //__strong\n        });\n    });\n    NSLog(@\"touchesBegan:withEvent:\");\n}\n@end\n\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"Person - dealloc\");\n}\n@end\n```\n\n打印结果：\n```\n2020-06-09 13:41:54.571551+0800 block-test[9174:148566] touchesBegan:withEvent:\n2020-06-09 13:41:55.670345+0800 block-test[9174:148566] time：1，Person: <Person: 0x600002a90130>\n2020-06-09 13:41:57.842076+0800 block-test[9174:148566] time：2，Person: <Person: 0x600002a90130>\n2020-06-09 13:41:57.842202+0800 block-test[9174:148566] Person - dealloc\n```\n\n1秒的定时器对 person 对象时弱引用（`__weak`），2秒的定时器对 person 对象是强引用（`__strong`），所以 person 对象会在2秒的 GCD 定时器执行完成后，在 block 销毁前被释放。\n\n## 小结\n\n* 如果 block 是在栈上，将不会对 auto 变量产生强引用  \n不管是 ARC 下还是 MRC 下，栈空间的 block 是不会持有“对象类型的 auto 变量”的。堆空间的 block 在 ARC 下通过 `__strong`（强引用）持有“对象类型的 auto 变量”。在 MRC 下，当 block 手动调用 copy 从栈区拷贝到堆区，并通过 retain 持有“对象类型的 auto 变量”，通过 release 释放“对象类型的 auto 变量”。 \n\n* 如果 block 被拷贝到堆上，会调用 block 内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会根据 auto 变量的修饰符（`__strong`、`__weak`、`__unsafe_unretained`）做出相应的操作，形成强引用（retain）或者弱引用。\n\n* 如果 block 从堆上移除，会调用 block 内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放引用的 auto 变量（release）。\n\n# __block\n\n## __block 的本质\n\nblock 内部无法修改 auto 变量的值：\n![block12](block/block12.png)\n\nblock 内部可以修改全局变量、静态变量（static）。  \n全局变量：\n```\ntypedef void(^Block)(void);\n\nint age = 10;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n```\n\n静态变量（static）：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        static int age = 10;\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n```\n \n`__block` 可以用于解决 block 内部无法修改 auto 变量值的问题：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block int age = 10;\n        Block block =  ^{\n            age = 20;\n            NSLog(@\"this is a block, age = %d\", age);\n        };\n        block();\n        NSLog(@\"%p\", &age);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nthis is a block, age = 20\n0x7ffeefbff578\n```\n\n编译器会将 `__block` 变量包装成一个对象，查看 c++ 代码：\n```\ntypedef void(*Block)(void);\n\n//__block 变量被包装成一个对象\nstruct __Block_byref_age_0 {\n  void *__isa; //具有 isa 指针，说明 __Block_byref_age_0 结构体是一个对象\n__Block_byref_age_0 *__forwarding; //指向 __Block_byref_age_0 结构体自身\n int __flags;\n int __size; //__Block_byref_age_0 结构体的大小\n int age; //auto 变量（10）\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_age_0 *age; //指向 __block 变量包装成的对象 \n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    __Block_byref_age_0 *age = __cself->age; //获取到 __Block_byref_age_0 对象\n    (age->__forwarding->age) = 20; //通过 age（__Block_byref_age_0）对象的 __forwarding 指针找到 age（__Block_byref_age_0）对象里的参数 int age\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_f95ea5_mi_0, (age->__forwarding->age));\n}\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->age, (void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        //对应的 OC 代码：__block int age = 10;\n        //简化后：__Block_byref_age_0 age = {0,&age, 0, sizeof(__Block_byref_age_0), 10};\n        __attribute__((__blocks__(byref))) __Block_byref_age_0 age = {(void*)0, //isa 指针\n                                                                      (__Block_byref_age_0 *)&age, //age（__Block_byref_age_0）对象的地址值\n                                                                      0, \n                                                                      sizeof(__Block_byref_age_0), //__Block_byref_age_0 结构体的大小\n                                                                      10}; //auto 变量 age 的值\n        Block block = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, \n                                                        &__main_block_desc_0_DATA, \n                                                        (__Block_byref_age_0 *)&age, \n                                                        570425344));\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n        //NSLog(@\"%p\", &age); 访问的是 __block 结构体里面的 age 变量\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_85d8e5_mi_1, &(age.__forwarding->age));\n    }\n    return 0;\n}\nstatic struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };\n```\n\n被 `__block` 修饰过的 auto 变量被包装成一个 `__Block_byref_age_0` 结构体。因为 `__Block_byref_age_0` 结构体内有 isa 指针，所以 `__Block_byref_age_0` 结构体是一个对象。`__Block_byref_age_0` 结构体的 `__forwarding` 指针指向自身，在 block 的执行代码里调用 `__Block_byref_age_0` 结构体内部参数 age 时，就是通过 `__forwarding` 指针调用的（age->\\_\\_forwarding->age）。\n\n外部再想访问 age 时，也会通过 `__block` 结构体访问 &(age.\\_\\_forwarding->age)，如：NSLog(@\"%p\", &age)：\n```\nNSLog((NSString *)&__NSConstantStringImpl__var_folders_rw_lcynwz_524g1qwsw4sclwtrw0000gn_T_main_85d8e5_mi_1, &(age.__forwarding->age));\n```\n\n![block14](block/block14.png)\n\n`__block` 修改“对象类型的 auto 变量”  \n```\nstruct __Block_byref_obj_0 {\n    void *__isa;\n    __Block_byref_obj_0 *__forwarding;\n    int __flags;\n    int __size;\n    void (*__Block_byref_id_object_copy)(void*, void*); //copy 函数（内存管理相关）\n    void (*__Block_byref_id_object_dispose)(void*); //dispose 函数（内存管理相关）\n    NSObject *obj; //auto 变量\n};\n```\n\n使用 `__bloclk` 修改“对象类型的 auto 变量” 同样会生成对应的 `__Block_byref_obj_0` 对象。相对于普通的 auto 变量，增加了 copy 函数和 dispose 函数用于内存管理。\n\n`__bloclk` 结构体内部用于保存 auto 变量 obj 的变量 NSObject *obj，同  auto 变量的类型保持一致。\n\n`__block` 不能修饰全局变量、静态变量（static）\n\n![block13](block/block13.png)\n\nblock 内部可以使用 array 指针，但是不可以修改 array 指针：  \n使用 array 指针：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableArray *array = [NSMutableArray array];\n        Block block =  ^{\n            [array addObject:@\"123\"];\n        };\n        block();\n    }\n    return 0;\n}\n```\n\nblock 内部可以使用 NSMutableArray 指针（如：[array addObject:@\"123\"]），不需要添加 `__block`。  \n\n修改 array 指针：\n![block15](block/block15.png)\n\nblock 内部不可以修改 NSMutableArray 的指针（如：array = nil），如果需要修改 NSMutableArray 指针的话，需要添加 `__block`。 \n\n## \\_\\_block 的内存管理\n\n当 block 在栈上时，并不会对 `__block` 变量产生强引用。  \n\n当 block 被 copy 到堆时，会调用 block 内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会对 `__block` 变量形成强引用（retain）。\n\n![block16](block/block16.png)\n\n\n当 block 从堆中移除时，会调用 block 内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放引用的 `__block` 变量（release）。\n\n![block17](block/block17.png)\n\n\n### 对象类型的 auto 变量、\\_\\_block 变量\n\n![block19](block/block19.png)\n\n当 block 在栈上时，对对象类型的 auto 变量、`__block` 变量都不会产生强引用.  \n\n当 block 拷贝到堆上时，都会通过 copy 函数来处理对象类型的 auto 变量、`__block` 变量。  \n当 block 从堆上移除时，都会通过 dispose 函数来释放对象类型的 auto 变量、`__block` 变量。  \n\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *personBlock = [[Person alloc] init];\n        Person *person = [[Person alloc] init];\n        Block block = ^{\n            NSLog(@\"%@, %@\", personBlock, person);\n        };\n        block();\n    }\n    return 0;\n}\n```\n\n查看 c++ 代码：\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    _Block_object_assign((void*)&dst->personBlock, (void*)src->personBlock, 8/*BLOCK_FIELD_IS_BYREF*/); //__block 变量\n    _Block_object_assign((void*)&dst->person, (void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/); //对象类型的 auto 变量\n}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n    _Block_object_dispose((void*)src->personBlock, 8/*BLOCK_FIELD_IS_BYREF*/); //__block 变量\n    _Block_object_dispose((void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/); //对象类型的 auto 变量\n}\n```\n\n### 被 \\_\\_block 修饰的对象类型\n\n#### ARC 下：\n\\_\\_block Person *person 的内存结构：\n![block21](block/block21.png)\n\n\\_\\_block \\_\\_weak Person *weakPerson 的内存结构：\n![block20](block/block20.png)\n\n#### MRC 下：\n查看支持 MRC、指定运行时系统版本的 c++ 代码：\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fno-objc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n栈区的 block：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        Block block = ^{\n            NSLog(@\"%@\", person);\n        };\n        [person release];\n        block();\n        [block release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPerson - dealloc\n```\n\n堆区的 block：\n```\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        Block block = [^{\n            NSLog(@\"%@\", person);\n        } copy];\n        [person release];\n        block();\n        [block release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nPerson - dealloc\n```\n\n栈区和堆区的 block 在执行代码时出现同样的错误：\n\n![block22](block/block22.png)\n\nMRC 下栈区和堆区的 block 都不会对指向的对象产生强引���（_Block_object_assign 没有 retain 操作），内存结构：\n![block23](block/block23.png)\n\n截图👆里 `__Block_byref_person_0` 结构体里的 Person \\*person 可能是省略了 `__weak`，即 Person \\*\\_\\_weak person;\n\n对比没有 `__block` 的对象类型的 auto 变量的内存结构：\n![block24](block/block24.png)\n\n\n#### 小结\n\n当 `__block` 变量在栈上时，不会对指向的对象产生强引用。  \n\n当 `__block` 变量被 copy 到堆时，会调用 `__block` 变量内部的 copy 函数，copy 函数内部会调用 _Block_object_assign 函数，_Block_object_assign 函数会根据所指向对象的修饰符（`__strong`、`__weak`、`__unsafe_unretained`）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于 ARC 时会 retain，MRC 时不会 retain）。\n\n当 `__block` 变量从堆上移除时，会调用 `__block` 变量内部的 dispose 函数，dispose 函数内部会调用 _Block_object_dispose 函数，_Block_object_dispose 函数会自动释放指向的对象（release）。\n\n## \\_\\_block 的 \\_\\_forwarding 指针\n\n![block18](block/block18.png)\n\nage.\\_\\_forwarding->age：`__Block_byref_obj_0` 结构体对应的 age 对象通过 `__forwarding` 指针找到被拷贝到堆里的 `__block` 结构体，再找到结构体里的 age 变量。\n\n\n## 循环引用\n\n常见循环引用问题：\n```\n@implementation Person\n- (void)test {\n    self.block = ^{\n        NSLog(@\"self.age = %d\", self.age);\n    };\n}\n@end\n```\n\n引用关系：self -> block -> self\n\n引用关系图解：\n![block25](block/block25.png)\n\n`__block` 变量的循环引用问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = ^{\n            NSLog(@\"%d\", person.age);\n        };\n    }\n    return 0;\n}\n```\n\n引用关系：person -> block -> __block person -> person\n\n引用关系图解：\n![block27](block/block27.png)\n\n### 解决循环引用问题 - ARC\n\n解决方案一：用 `__weak`、`__unsafe_unretained` 解决，去掉 block 对 对象的强引用关系：\n```\n//__weak \n- (void)test {\n    __weak typeof(self) weakSelf = self;\n    self.block = ^{\n        NSLog(@\"self.age = %d\", weakSelf.age);\n    };\n}\n\n//__unsafe_unretained\n- (void)test {\n    __unsafe_unretained typeof(self) weakSelf = self;\n    self.block = ^{\n        NSLog(@\"self.age = %d\", weakSelf.age);\n    };\n}\n```\n\n`__weak`：不会产生强引用，指向的对象销毁时，会自动让指针置为 nil。  \n`__unsafe_unretained`：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变。\n\n\n图解：\n![block26](block/block26.png)\n\n\n解决方案二：用 `__block` 解决（必须要调用 block），通过将捕获的变量置为 nil，去掉 `__block` 变量和对象之间的强引用关系：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = ^{\n            NSLog(@\"%d\", person.age);\n            person = nil;\n        };\n        person.block();\n    }\n    return 0;\n}\n```\n\n图解：\n![block28](block/block28.png)\n\n\n#### \\_\\_weak 安全问题\n```\n- (void)test {\n    __weak typeof(self) weakSelf = self;\n    self.block = ^{\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        NSLog(@\"self.age = %d\", strongSelf.age);\n    };\n}\n```\n\n被 `__weak` 修饰的变量随时可能被释放，block 内部有可能访问的 weakSelf 已经不存在了。通过 `__strong` 修饰后，可以保证在 block 执行完成前 strongSelf 一直在。\n\n### 解决循环引用问题 - MRC\n\n解决方案一：用 `__unsafe_unretained` 解决，声明后的 person 对象在 block 里不会被 retain：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __unsafe_unretained Person *person = [[Person alloc] init];\n        person.block = [^{\n            NSLog(@\"%d\", person.age);\n        } copy];\n        [person release];\n    }\n    return 0;\n}\n```\n\n解决方案二：用 `__block` 解决，MRC 下的 block 不会对 `__block` 变量进行 retain 操作：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        __block Person *person = [[Person alloc] init];\n        person.block = [^{\n            NSLog(@\"%d\", person.age);\n        } copy];\n        [person release];\n    }\n    return 0;\n}\n```\n\n\n# 总结\n* block 的原理是怎样的？本质是什么？  \nblock 本质上是封装了函数调用以及函数调用环境的 OC 对象。\n\n* `__block`的作用是什么？有什么使用注意点？  \n作用：`__block` 可以用于解决 block 内部无法修改 auto 变量值的问题。  \n注意：在 MRC 下 `__block` 变量不会对指向的对象产生强引用。\n\n* block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？  \nblock 创建时内存是在栈上的，进行 copy 操作后，block 的内存就从栈上拷贝到了堆上。  \n堆上的 block 对捕获到的变量有强引用，需要注意 block 与被捕获的变量之间是否存在循环引用的问题。\n\n* block 在修改 NSMutableArray，需不需要添加 `__block`？  \nblock 内部可以使用 NSMutableArray 指针（如：[array addObject:@\"123\"]），不需要添加 `__block`。  \nblock 内部不可以修改 NSMutableArray 的指针（如：array = nil），如果需要修改 NSMutableArray 指针的话，需要添加 `__block`。 ","slug":"OC底层原理/block","published":1,"updated":"2023-08-22T09:52:13.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv7002taq7kc4ti2wyp"},{"title":"内存管理","date":"2020-08-14T09:16:33.000Z","_content":"\n思考：\n* 使用 CADisplayLink、NSTimer 有什么注意点？\n* 介绍下内存的几大区域\n* 讲一下你对 iOS 内存管理的理解\n* ARC 都帮我们做了什么？(LLVM + Runtime)\n* weak 指针的实现原理\n* autorelease 对象在什么时机会被调用 release\n* 方法里有局部对象， 出了方法后会立即释放吗?\n<!-- more -->\n\n# CADisplayLink、NSTimer 定时器\nCADisplayLink、NSTimer 会对 target 产生强引用，如果 target 又对它们产生强引用，那么就会引发循环引用。\n\n## 循环引用问题\n\n### CADisplayLink\nCADisplayLink 保证调用 `-(void)timerTest` 方法的频率和屏幕的刷新帧频率一致，60FPS。实际的调用频率可能不太一样，根据任务的耗时情况会有减少。\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n......\n```\n\n从打印结果可以看到，进入 TimerViewController 控制器后返回，会发现 TimerViewController 没有释放，CADisplayLink 定时器还在继续运行。\n\n### NSTimer\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n......\n```\n\n从打印结果可以看到，进入 TimerViewController 控制器后返回，会发现 TimerViewController 没有释放，NSTimer 定时器还在继续运行。\n\n### 问题分析\n![内存管理01](内存管理/内存管理01.png)\n\n## 解决方案\n\n### 方案一：使用 block\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        [weakSelf timerTest];\n    }];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n在使用 NSTimer 的时候，使用 block 的方式传入 weakSelf 可以有效解决循环引用的问题。并且以 scheduled 开头的方法会自动将 timer 添加到当前的 runloop 中并使用 default mode。\n```\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n```\n\ntarget 传入 weakSelf 并不能解决循环引用个问题，因为 NSTimer 内部对传入的 target 也是强引用的，而且 weakSelf 只是用来解决 block 循环引用问题的方案。\n```\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n```\n\nCADisplayLink 没有 block 相关的 API。\n\n### 方案二：使用中间对象\n![内存管理02](内存管理/内存管理02.png)\n\n定义中间对象：\n```\n@interface YQProxy : NSObject\n+ (instancetype)proxyWithTarget:(id)target;\n@property (nonatomic, weak) id target;\n@end\n\n@implementation YQProxy\n+ (instancetype)proxyWithTarget:(id)target\n{\n    YQProxy *proxy = [[YQProxy alloc] init];\n    proxy.target = target;\n    return proxy;\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    return self.target;\n}\n@end\n```\n\n#### NSTimer\n```\n@interface TimerViewController ()\n//@property (nonatomic, strong) CADisplayLink *link;\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[YQProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n#### CADisplayLink\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.link = [CADisplayLink displayLinkWithTarget:[YQProxy proxyWithTarget:self] selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n@end\n```\n\n打印结果：\n```\n......\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n传给定时器的 target 是 YQProxy 对象，在 YQProxy 对象尝试调用 `-(void)timerTest` 方法时，发现没有实现后会调用 `- (id)forwardingTargetForSelector:(SEL)aSelector` 方法走消息转发的逻辑，在该方法内部返回已经实现了 `-(void)timerTest` 方法的对象，就可以正常实现 timer 定时器调用 `-(void)timerTest` 方法的逻辑了。 \n\n因为 YQProxy 对象没有实现 `-(void)timerTest` 方法，所以需要添加消息转发逻辑。如果 YQProxy 中没有添加消息转发的逻辑会出现如下报错：\n![内存管理03](内存管理/内存管理03.png) \n\nYQProxy 会在其类对象以及父类的类对象里查找 `-(void)timerTest` 方法，查找了一圈后发现找不到，就会抛出错误。\n\n## 使用代理对象（NSProxy）\n\n定义 YQTimerProxy 继承自 NSProxy：\n```\n@interface YQTimerProxy : NSProxy\n+ (instancetype)proxyWithTarget:(id)target;\n@property (nonatomic, weak) id target;\n@end\n\n@implementation YQTimerProxy\n+ (instancetype)proxyWithTarget:(id)target\n{\n    YQTimerProxy *proxy = [YQTimerProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel\n{\n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    [invocation invokeWithTarget:self.target];\n}\n@end\n```\n\nNSProxy 对象没有 `-(instancetype)init` 方法，直接 alloc 就可以了。\n\n### NSTimer\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0\n                                                  target:[YQTimerProxy proxyWithTarget:self]\n                                                selector:@selector(timerTest)\n                                                userInfo:nil\n                                                 repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n### CADisplayLink\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.link = [CADisplayLink displayLinkWithTarget:[YQTimerProxy proxyWithTarget:self] selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n\n@end\n```\n\n传给定时器的 target 是 YQTimerProxy 对象，YQTimerProxy 对象不会尝试调用 `-(void)timerTest` 方法，而是直接走消息转发逻辑，在对应的消息转发的方法里返回已经实现了 `-(void)timerTest` 方法的对象，就可以正常实现 timer 定时器调用 `-(void)timerTest` 方法的逻辑了。\n\n因为 YQTimerProxy 对象不会尝试调用 `-(void)timerTest` 方法，而是直接调用 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法，所以需要添加消息转发逻辑。如果 YQTimerProxy 中没有添加消息转发的逻辑会出现如下报错：\n![内存管理04](内存管理/内存管理04.png) \n\n可以看到 YQTimerProxy 没有去查找 `-(void)timerTest` 方法，而是直接查找的 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法。这一点可以通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看 NSProxy 的源码找到原因。NSProxy 内部的方法的实现都是直接调用的 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法，因此 NSProxy 作为代理对象效率更高。\n\n## NSProxy\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    YQProxy *proxy1 = [YQProxy proxyWithTarget:self];\n    YQTimerProxy *proxy2 = [YQTimerProxy proxyWithTarget:self];\n    NSLog(@\"%d %d\", [proxy1 isKindOfClass:[ViewController class]], [proxy2 isKindOfClass:[ViewController class]]);\n}\n@end\n```\n\n打印结果：\n```\n0 1\n```\n\n从打印结果可以看到，YQProxy 的实例对象和 YQTimerProxy 的实列对象在判断是否是 ViewController 的对象类型的时候结果不同。这是因为 YQTimerProxy 继承自 NSProxy，NSProxy 的 `-(BOOL) isKindOfClass:(Class)aClass` 方法的实现与普通的 OC 对象同。通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看 NSProxy 的源码：\n```\n- (BOOL)isKindOfClass:(Class)aClass\n{\n    NSMethodSignature\t*sig;\n    NSInvocation\t\t*inv;\n    BOOL\t\t\tret;\n\n    sig = [self methodSignatureForSelector: _cmd];\n    inv = [NSInvocation invocationWithMethodSignature: sig];\n    [inv setSelector: _cmd];\n    [inv setArgument: &aClass atIndex: 2];\n    [self forwardInvocation: inv];\n    [inv getReturnValue: &ret];\n    return ret;\n}\n```\n\n可以看到，NSProxy 的 `-(BOOL)isKindOfClass:(Class)aClass` 方法内部直接调用了 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法。\n\n普通 OC 对象的 `-(BOOL)isKindOfClass:(Class)aClass` 方法实现 [objc4-781](https://opensource.apple.com/tarballs/objc4/) ：\n```\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n# GCD 定时器\nCADisplayLink 和 NSTimer 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 CADisplayLink 和 NSTimer 不准时。GCD 的定时器会更加准时。\n\n## block 回调：\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@\"GCD timer\");\n    });\n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n@end\n```\n\n打印结果：\n```\n18:16:38.889349+0800 内存管理-定时器[15880:352867] -[ViewController viewDidLoad]\n18:16:40.889609+0800 内存管理-定时器[15880:352867] GCD timer\n18:16:41.889685+0800 内存管理-定时器[15880:352867] GCD timer\n18:16:42.889624+0800 内存管理-定时器[15880:352867] GCD timer\n......\n```\n\n## 函数回调：\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler_f(timer, timerFire);\n    \n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n\nvoid timerFire(void *param)\n{\n    NSLog(@\"GCD timer - %@\", [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n20:37:01.629410+0800 内存管理-定时器[1363:25276] -[ViewController viewDidLoad]\n20:37:03.629774+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n20:37:04.629784+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n20:37:05.629800+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n......\n```\n\n## 自定义队列\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 自定义队列\n    dispatch_queue_t queue = dispatch_queue_create(\"GCDTimer\", NULL);\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler_f(timer, timerFire);\n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n\nvoid timerFire(void *param)\n{\n    NSLog(@\"GCD timer - %@\", [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n20:39:58.857389+0800 内存管理-定时器[1460:28690] -[ViewController viewDidLoad]\n20:40:00.857845+0800 内存管理-定时器[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}\n20:40:01.857692+0800 内存管理-定时器[1460:28835] GCD timer - <NSThread: 0x6000021272c0>{number = 6, name = (null)}\n20:40:02.857792+0800 内存管理-定时器[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}\n......\n```\n\n## 封装 GCD\n\n```\n@interface YQGCDTimer : NSObject\n/**\nblock 回调\n*/\n+ (NSString *)execTask:(void(^)(void))task\n                 start:(NSTimeInterval)start\n              interval:(NSTimeInterval)interval\n               repeats:(BOOL)repeats\n                 async:(BOOL)async;\n/**\n函数回调\n*/\n+ (NSString *)execTaskWithTarget:(id)target\n                        selector:(SEL)selector\n                           start:(NSTimeInterval)start\n                        interval:(NSTimeInterval)interval\n                         repeats:(BOOL)repeats\n                           async:(BOOL)async;\n/**\n取消\n*/\n+ (void)cancelTask:(NSString *)name;\n@end\n\n\nNSInteger index_;\nstatic NSMutableDictionary *timers_;\ndispatch_semaphore_t semaphore_;\n\n@implementation YQGCDTimer\n\n+ (void)initialize\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        timers_ = [NSMutableDictionary dictionary];\n        semaphore_ = dispatch_semaphore_create(1);\n        index_ = 0;\n    });\n}\n\n+ (NSString *)execTask:(void (^)(void))task start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    if (!task || start < 0 || (interval <= 0 && repeats)) return nil;\n    // 队列（全局串行队列或主队列）\n    dispatch_queue_t queue = async ? dispatch_get_global_queue(0, 0) : dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler(timer, ^{\n        task();\n        // 不需要重复任务\n        if (!repeats) {\n            dispatch_source_cancel(timer);\n        }\n    });\n    // 加锁\n    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);\n    // 定时器唯一标识\n    NSString *identify = [NSString stringWithFormat:@\"%ld\", (long)index_++];\n    // 保存\n    timers_[identify] = timer;\n    // 解锁\n    dispatch_semaphore_signal(semaphore_);\n    // 启动定时器\n    dispatch_resume(timer);\n    return identify;\n}\n\n+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    return [self execTask:^{\n        if ([target respondsToSelector:selector]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n            [target performSelector:selector];\n#pragma clang diagnostic pop\n        }\n    } start:start interval:interval repeats:repeats async:async];\n}\n\n+ (void)cancelTask:(NSString *)name\n{\n    if (name.length == 0) return;\n    // 加锁\n    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);\n    dispatch_source_t timer = timers_[name];\n    if (timer) {\n        dispatch_source_cancel(timer);\n        [timers_ removeObjectForKey:name];\n    }\n    // 解锁\n    dispatch_semaphore_signal(semaphore_);\n}\n@end\n```\n\n调用 block 回调方法：\n```\n@interface TimerViewController ()\n@property (nonatomic, copy) NSString *task;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    self.task = [YQGCDTimer execTask:^{\n        NSLog(@\"GCD timer\");\n    } start:2 interval:1 repeats:YES async:NO];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [YQGCDTimer cancelTask:self.task];\n}\n@end\n```\n\n调用函数回调方法：\n```\n@interface TimerViewController ()\n@property (nonatomic, copy) NSString *task;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    self.task = [YQGCDTimer execTaskWithTarget:self selector:@selector(timerTest) start:2 interval:1 repeats:YES async:NO];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [YQGCDTimer cancelTask:self.task];\n}\n@end\n```\n\n打印结果：\n```\n21:18:01.050592+0800 内存管理-定时器[2321:52592] -[TimerViewController viewDidLoad]\n21:18:03.050800+0800 内存管理-定时器[2321:52592] GCD timer\n21:18:04.050986+0800 内存管理-定时器[2321:52592] GCD timer\n21:18:05.050943+0800 内存管理-定时器[2321:52592] GCD timer\n```\n\n去掉警告：\n```\n+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    return [self execTask:^{\n        if ([target respondsToSelector:selector]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n            [target performSelector:selector];\n#pragma clang diagnostic pop\n        }\n    } start:start interval:interval repeats:repeats async:async];\n}\n```\n\n`\"-Warc-performSelector-leaks\"` 可以在这里找到：\n![内存管理05](内存管理/内存管理05.png) \n\n# iOS程序的内存布局\n* 代码段：编译之后的代码\n* 数据段：字符串常量、已初始化数据和未初始化数据\n* 栈：函数调用开销，比如局部变量。（分配的内存空间地址越来越小）\n* 堆：通过 alloc、malloc、calloc 等动态分配的空间，分配的内存空间地址越来越大\n![内存管理06](内存管理/内存管理06.png) \n\n```\n// 已初始化的全局变量\nint a = 10;\n// 未初始化的全局变量\nint b;\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        // 已初始化的静态变量\n        static int c = 20;\n        // 未初始化的静态变量\n        static int d;\n        // 栈\n        int e;\n        int f = 20;\n        // 字符串常量\n        NSString *str = @\"123\";\n        // 堆\n        NSObject *obj = [[NSObject alloc] init];\n        \n        NSLog(@\"\\n&a=%p\\n&b=%p\\n&c=%p\\n&d=%p\\n&e=%p\\n&f=%p\\nstr=%p\\nobj1=%p\\nobj2=%p\\n\",\n              &a, &b, &c, &d, &e, &f, str, obj1, obj2);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n打印结果：\n```\n&a=0x105bbee38\n&b=0x105bbef04\n&c=0x105bbee3c\n&d=0x105bbef00\n&e=0x7ffeea042c2c\n&f=0x7ffeea042c28\nstr=0x105bbe070\nobj1=0x600002528110\nobj2=0x600002528120\n```\n\n打印结果解析（内地地址从小到大排序）：\n```\n// 字符串常量\nstr=0x105bbe070\n\n// 已初始化的全局变量、静态变量\n&a=0x105bbee38\n&c=0x105bbee3c\n\n// 未初始化的全局变量、静态变量\n&d=0x105bbef00\n&b=0x105bbef04\n\n// 堆\nobj1=0x600002528110\nobj2=0x600002528120\n\n// 栈\n&f=0x7ffeea042c28\n&e=0x7ffeea042c2c\n```\n\n内存地址大小比较：\n```\nstr < a < c < d < b < obj1 < obj2 < f < e \n```\n\n数据段：str < a < c < d < b，空间地址越来越大。   \n堆区：obj1 比 b 多了3位数，这3位数的空间都属于数据段。obj1 的内存地址首位数字为6，obj1 < obj2，分配的内存空间越来越大（越来越逼近栈区）。  \n栈区：e 的内存地址首位数字为7，f < e，分配的内存空间越来越小（越来越逼近堆区）。  \n\n# Tagged Pointer\n\n* 从64bit开始，iOS 引入了 Tagged Pointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储。\n* 在没有使用 Tagged Pointer 之前，NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 等对象的指针存储的是堆中 NSNumber 对象的地址值。\n* 使用 Tagged Pointer 之后，NSNumber 指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。\n* 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。\n* `objc_msgSend()` 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据，节省了以前的调用开销。\n* 如何判断一个指针是否为Tagged Pointer？  \n  iOS平台，最高有效位是1（第64bit）  \n  Mac平台，最低有效位是1  \n\n## NSNumber\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        \n        NSNumber *number1 = @4;\n        NSNumber *number2 = @5;\n        NSNumber *number3 = @(0xFFFFFFFFFFFFFFFF);\n        NSLog(@\"%p %p %p\", number1, number2, number3);\n        \n        int a = [number1 intValue];\n\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n0xb0d1e4bcdb858740 0xb0d1e4bcdb858750 0x600000b4c080\n```\n\n`0xb0d1e4bcdb858740` 和 `0xb0d1e4bcdb858750` 去掉前面相同的部分后是 `0x40` 和 `0x50`，可以看出数据直接存储在了指针中。当指针不够存储数据时，如 `@(0xFFFFFFFFFFFFFFFF)` 打印出来的内存地址是 `0x600000b4c080`（堆空间里 NSNumber 对象的地址值），是使用了动态分配内存的方式来存储数据。\n\n因为 `objc_msgSend()` 能识别 Tagged Pointer，所以在 number1 调用 `intValue` 方法时，`objc_msgSend()` 直接从指针提取数据。\n```\nint a = [number1 intValue];\n```\n\n可以看出 Tagged Pointer 技术不仅仅是内存空间的优化，也对使用过程进行了优化。\n\n## NSString\n\n### 例一：\n```\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            self.name = [NSString stringWithFormat:@\"abcdefghijk\"];\n        });\n    }\n}\n@end\n```\n\n运行后报错（坏内存访问）：\n![内存管理07](内存管理/内存管理07.png)\n\n因为 `name` 是非原子性（`nonatomic`）的，多条线程同时访问 `name` 的 set 方法时，如果有一条线程已经将 `_name` 释放了，其它线程再次对 `_name` 进行释放操作就会出现坏内存访问的错误：\n```\n- (void)setName:(NSString *)name\n{\n    if (_name != name) {\n        [_name release]; // 多条线程同时操作这一行，如果 `_name` 已经被释放了，其它线程再次对 `_name` 进行 release 操作，坏内存访问\n        _name = [name copy];\n    }\n}\n```\n\n#### 解决方案一：\n将 `name` 改成原子性的：\n```\n@property (atomic, copy) NSString *name;\n```\n\n程序运行正常。\n\n将 `name` 改成原子性后，`name` 的 set 方法就是线程安全的了，不会出现多条线程同时对 `name` 进行 release 操作。\n\n#### 解决方案二：\n将 `name` 改成原子性后，任何地方、任何时候调用 `name` 的 get 方法都是有锁的。因为 `name` 只需要在异步线程访问时加锁，如果在主线程的话没有必要加锁，所以不使用 `atomic` 而是选择手动加锁，哪里需要就在哪里加锁，尽可能的提升效率节省资源：\n```\n/// 加锁\n#define SemaphoreBegin \\\nstatic dispatch_semaphore_t semaphore; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    semaphore = dispatch_semaphore_create(1); \\\n}); \\\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n/// 解锁\n#define SemaphoreEnd \\\ndispatch_semaphore_signal(semaphore);\n\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            // 加锁\n            SemaphoreBegin;\n            self.name = [NSString stringWithFormat:@\"abcdefghijk\"];\n            // 解锁\n            SemaphoreEnd;\n        });\n    }\n}\n@end\n```\n\n程序运行正常。\n\n### 例二：  \n将 `@\"abcdefghijk\"` 改成 `@\"abc\"`：\n```\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            self.name = [NSString stringWithFormat:@\"abc\"];\n        });\n    }\n}\n@end\n```\n\n运行正常。  \n\n同样是多线程访问、没有加锁，但是将 `@\"abcdefghijk\"` 改成 `@\"abc\"` 后，就不会出现坏内存访问的错误，难道是没有调用 `name` 的 set 方法吗？是的。\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str1 = [NSString stringWithFormat:@\"abcdefghijk\"];\n    NSString *str2 = [NSString stringWithFormat:@\"abc\"];\n    NSLog(@\"%p %p\", str1, str2);\n    NSLog(@\"%@ %@\", [str1 class], [str2 class]);\n}\n@end\n```\n\n打印结果：\n```\n0x600002aefdc0 0x9cedd15798132057\n__NSCFString NSTaggedPointerString\n```\n\nstr1 是一个 `__NSCFString`，其内存地址是6开头的，说明 str1 是存储在堆空间里的。  \nstr2 是一个 `NSTaggedPointerString`，`@\"abc\"` 存储在 str2 指针里，不会调用 set 方法，取值时也不会调用 get 方法而是直接从指针里取值。\n\n## 判断是否是 Tagged Pointer\n\n[objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 objc-internal.h 文件里：\n\n`_OBJC_TAG_MASK` 定义：\n```\n#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__\n    // 64-bit Mac - tag bit is LSB\n#   define OBJC_MSB_TAGGED_POINTERS 0 // Mac\n#else\n    // Everything else - tag bit is MSB\n#   define OBJC_MSB_TAGGED_POINTERS 1 // iPhone（真机/模拟器）\n#endif\n\n#if OBJC_MSB_TAGGED_POINTERS\n#   define _OBJC_TAG_MASK (1UL<<63) \n#else\n#   define _OBJC_TAG_MASK 1UL \n#endif\n```\n\n判断是否是 tagged pointer：\n```\nstatic inline bool \n_objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\n```\n\n如果是 mac，`_OBJC_TAG_MASK` 等于1。如果不是 mac， `_OBJC_TAG_MASK` 等于 1UL<<63。`_OBJC_TAG_MASK` 和指针地址进行与运算，判断结果是否是 `_OBJC_TAG_MASK`，如果是的话，那这个指针就是 tagged pointer。  \n在 iOS 平台，如果指针转成2进制后它的最高位（64位）为1的话，那么这个指针就是 tagged pointer。  \n在 Mac 平台，如果指针转成2进制后它的最低位为1的话，那么这个指针就是 tagged pointer。\n\n# MRC\n* 在 iOS 中，使用引用计数来管理 OC 对象的内存。  \n* 一个新创建的 OC 对象引用计数默认是1，当引用计数减为0，OC 对象就会销毁，释放其占用的内存空间。  \n* 调用 retain 会让 OC 对象的引用计数+1，调用 release 会让 OC 对象的引用计数-1。  \n* 内存管理的经验总结：  \n  当调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。  \n  想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1。  \n* 可以通过以下私有函数来查看自动释放池的情况  \n  ```\n  extern void _objc_autoreleasePoolPrint(void);\n  ```\n\n👉 使用 MRC：Build Setting -> Objective-C Automatic Referencd Counting 设置为 YES。\n\n定义 Person 类：\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n## release\n\n创建 person 对象：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init]; // Person *person = [Person new];\n        NSLog(@\"%zd\", person.retainCount);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n 1\n```\n\n从打印结果可以看到，person 对象调用完 `alloc` 方法后引用计数是1，没有被释放。\n\n添加 release：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        \n        // 使用 person 对象\n        NSLog(@\"%zd\", person.retainCount);\n\n        [person release];\n        NSLog(@\"111\");\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n 1\n -[Person dealloc]\n 111\n```\n\n从打印结果可以看到，因为 person 对象调用完 `alloc` 方法后引用计数是1，调用完 `release` 方法后引用计数减1等于0，所以 person 对象在调用 `release` 的那一刻就被释放了。\n\nMRC 下 `alloc` 方法和 `release` 方法是一一对应的，每个对象使用完成后都要调用一下 `release` 方法，这样才能避免内存泄漏。另外，在使用 `release` 方法管理 person 对象时，要保证在调用 `release` 方法之前使用 person 对象。\n\n## autorelease\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[[Person alloc] init] autorelease];\n        NSLog(@\"%zd\", person.retainCount);\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n1\n111\n-[Person dealloc]\n222\n```\n\n从打印结果可以看到，因为 person 对象调用完 `alloc` 方法又调用了 `autorelease` 后引用计数是1，直到 `@autoreleasepool {}` 执行完那一刻才被释放。  \n\n在 `@autoreleasepool {}` 执行完那一刻，会对调用了 `autorelease` 方法的对象进行 `release` 操作：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n        NSLog(@\"111\");\n    } // [person release]、[person release]\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n-[Person dealloc]\n222\n```\n\n使用 `autorelease` 方法管理 person 对象的内存，只需要在调用 `alloc` 方法的同时调用一下 `autorelease` 方法，就可以放心的使用 person 对象了，当然是在 `@autoreleasepool {}` 内部使用。不用再关心 person 对象的释放问题，在 `@autoreleasepool {}` 执行完那一刻，person 对象会自动调用 `release` 方法。\n\n## retain\n\n错误演示：\n```\n// Dog\n@interface Dog : NSObject\n- (void)run;\n@end\n\n@implementation Dog\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n// Person\n@interface Person : NSObject\n{\n    Dog *_dog;\n}\n- (void)setDog:(Dog *)dog;\n- (Dog *)dog;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    _dog = dog;\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n\n// 调用\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // 引用计数：1\n        Person *person = [[Person alloc] init];\n        [person setDog:dog];\n        \n        [dog release]; // 引用计数：0\n        \n        [[person dog] run];\n        \n        [person release];\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印信息：\n```\n -[Dog dealloc]\n```\n\n`[[person dog] run]` 这个时候 dog 对象因为引用计数为0已经被释放了。\n![内存管理08](内存管理/内存管理08.png)\n\n`[person setDog:dog]` 方法表示 person 对象想要用于 dog 对象，那么 person 对象应该对 dog 的引用计数加1，只要 person 对象还在，dog 对象就不可以被释放。\n\n上面的写法有两个地方需要优化：  \n1、Person 类的 `- (void)setDog:(Dog *)dog` 方法在获取 dog 对象时，引用计数需要加1。  \n2、Person 类的 `- (void)dealloc` 方法需要对 dog 对象进行 `release` 操作。  \n\nPerson 类优化后：\n```\n@implementation Person\n- (void)dealloc\n{\n    [_dog release];\n    _dog = nil;\n    \n    [super dealloc]; // 父类的 dealloc 放到子类后\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    _dog = [dog retain];\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog run]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n创建两个 person 对象引用 dog 对象：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // dog 引用计数：1\n        \n        Person *person1 = [[Person alloc] init];\n        [person1 setDog:dog]; // dog 引用计数：2\n        \n        Person *person2 = [[Person alloc] init];\n        [person2 setDog:dog]; // dog 引用计数：3\n        \n        [dog release]; // dog 引用计数：2\n        \n        [person1 release]; // dog 引用计数：1\n        \n        [[person2 dog] run];\n        \n        [person2 release]; // dog 引用计数：0\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Person dealloc]\n-[Dog run]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n## set 方法\n\n上面 Person 类里的 set 方法还有问题，在 person 对象替换 dog 对象时会出现不释放的问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog1 = [[Dog alloc] init]; // dog1 : 1\n        Dog *dog2 = [[Dog alloc] init]; // dog2 : 1\n        Person *person = [[Person alloc] init];\n        \n        [person setDog:dog1]; // dog1 : 2\n        [person setDog:dog2]; // dog2 : 2\n        \n        [dog1 release]; // dog1 : 1\n        [dog2 release]; // dog2 : 1\n        [person release]; // dog0 : 0\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n从打印结果和注释可以看到，dog1 最后的引用计数是1，没有释放。这是因为 person 对象在拥有 dog1 时，将 `_dog` 指向了 dog1 并对其引用计数加1，后又将 `_dog` 指向了 dog2 并对其引用计数加1，所以 person 对象在调用 `[_dog release]` 时的 `_dog` 是 dog2 对象，dog1 对象因此少调用了一次 release 方法，最后的引用计数最后为1无法释放。\n\n优化 set 方法：在 person 对象引用新的 dog 对象时，需要先将之前的 dog 对象进行 release 操作。\n```\n@implementation Person\n- (void)dealloc\n{\n    [_dog release];\n    _dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    [_dog release];\n    _dog = [dog retain];\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n从打印结果可以看到，dog1 和 dog2 对象都被释放调用。但是优化后的 set 方法还不够完善，person 对象在重复设置同一个 dog 对象的时候还是有问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // dog1 : 1\n        Person *person = [[Person alloc] init];\n        \n        [person setDog:dog]; // dog1 : 2\n        \n        [dog release]; // dog1 : 1\n        \n        [person setDog:dog]; // dog1 : 0\n        \n        [person release];\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n错误信息：\n![内存管理09](内存管理/内存管理09.png)\n\n问题出在 Person 类的 set 方法：  \n第一次赋值，dog 对象的引用计数加一，此时 dog 对象的引用计数等于2。  \ndog 对象调用了一次 release 方法，此时 dog 对象的引用计数等于1。  \n第二次赋值，会先调用 `[_dog release]`, 此时 dog 对象的引用计数等于0，dog 对象被释放。再调用 `_dog = [dog retain]`，此时 dog 指向的内存已经被销毁了：\n```\n- (void)setDog:(Dog *)dog\n{\n    [_dog release]; // dog : 0\n    _dog = [dog retain]; // dog 指向的内存已经被销毁\n}\n```\n\n因此，在 set 方法里对 `_dog` 处理前，需要先判断一下 `_dog` 是否等于传入的 dog 对象。因为一个 person 对象在拥有一个 dog 对象时只需要对其 retain 一次，所以如果 `_dog == dog` 就不做处理。\n\n优化 Person 类里的 set 方法：\n```\n@implementation Person\n- (void)dealloc\n{\n    self.dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    if (_dog != dog) {\n        [_dog release];\n        _dog = [dog retain];\n    }\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n## property 属性\n\n在 .h 文件通过 property 声明的属性，编译器会自动生成成员变量和属性的 setter、getter 实现。\n\n## 基本数据类型\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n```\n\n编译器自动生成：\n```\n@implementation Person\n\n@synthesize age = _age;\n\n- (void)setAge:(int)age\n{\n    _age = age;\n}\n\n- (int)age\n{\n    return _age;\n}\n@end\n```\n\n## 对象类型\n```\n@interface Person : NSObject\n@property (nonatomic, retain) Dog *dog;\n@end\n```\n\n编译器自动生成：\n```\n@implementation Person\n\n@synthesize dog = _dog;\n\n- (void)setDog:(Dog *)dog\n{\n    if (_dog != dog) {\n        [_dog release];\n        _dog = [dog retain];\n    }\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n如果是在 MRC 环境下，这种情况下还需要在 delloc 方法里手动调用 _dog 的 release 方法：\n```\n@implementation Person\n- (void)dealloc\n{\n    self.dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n## 常用代码解析\n\n创建一个 iOS 项目，设置 MRC 环境。\n\n```\n@interface ViewController ()\n@property (nonatomic, retain) NSMutableArray *data;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableArray *data = [[NSMutableArray alloc] init];\n    self.data = data;\n    [data release];\n}\n\n- (void)dealloc\n{\n    self.data = nil;\n    \n    [super dealloc];\n}\n@end\n```\n\n简化：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [[NSMutableArray alloc] init];\n    [self.data release];\n}\n```\n\n`autorelease`：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [[[NSMutableArray alloc] init] autorelease];\n}\n```\n\n`+array`：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [NSMutableArray array];\n}\n```\n\n不是通过 `alloc` 方法初始化的，而是通过类方法初始化的，在类方法内部已经调用过 `autorelease` 了。类方法 `+array` 大概是这样：\n```\n@implementation NSMutableArray\n+ (instancetype)array\n{\n    return [[[NSMutableArray alloc] init] autorelease];\n}\n@end\n```\n\n## 工厂方法\n```\n@interface Person : NSObject\n+ (instancetype)person;\n@end\n\n@implementation Person\n+ (instancetype)person\n{\n    return [[[Person alloc] init] autorelease];\n}\n\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [Person person];\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n```\n\n# copy和mutableCopy\n\n* 拷贝的目的：产生一个副本对象，跟原对象互不影响  \n  修改了原对象，不会影响副本对象  \n  修改了副本对象，不会影响原对象  \n\n* iOS 提供了两个拷贝方法  \n  1、copy，不可变拷贝，产生不可变副本  \n  2、mutableCopy，可变拷贝，产生可变副本  \n\n## 拷贝\n### NSString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [NSString stringWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy]; // 返回的是 NSString\n        NSMutableString *str3 = [str1 mutableCopy]; // 返回的是 NSMutableString\n\n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%d %d %d\",\n              [str1 isKindOfClass:[NSMutableString class]],\n              [str2 isKindOfClass:[NSMutableString class]],\n              [str3 isKindOfClass:[NSMutableString class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0 0 1\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是 str1 和 str2 是不可变字符串，str3 是可变字符串。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\n### NSMutableString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableString *str1 = [NSMutableString stringWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy];\n        NSMutableString *str3 = [str1 mutableCopy];\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%d %d %d\",\n              [str1 isKindOfClass:[NSMutableString class]],\n              [str2 isKindOfClass:[NSMutableString class]],\n              [str3 isKindOfClass:[NSMutableString class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n1 0 1\n```\n\n不管是可变字符串还是不可变字符串，调用 `copy` 返回的都是不可变字符串，调用 `mutableCopy` 返回的都是可变字符串。\n\n### 内存管理\n在 MRC 环境下，调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2 = [str1 copy];\n        NSMutableString *str3 = [str1 mutableCopy];\n\n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n## 深拷贝和浅拷贝\n\n* 深拷贝：内容拷贝，产生新的对象\n* 浅拷贝：指针拷贝，没有产生新的对象\n\n### NSString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy]; // 浅拷贝：指针拷贝，没有产生新对象\n        NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝：内容拷贝，又产生新对象\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%p %p %p\", str1, str2, str3);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0x100001018 0x100001018 0x1007bb4e0\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是 str1 和 str2 指向的是同一个内存地址，str3 指向的是另一个内存地址。即 str1 通过 `copy` 方法拷贝出来的副本 str2 还是原对象（str1），而 str1 通过 `mutableCopy` 方法拷贝出来的副本 str3 是一个新的对象。\n![内存管理10](内存管理/内存管理10.png)\n\n👉 拷贝的目的：产生一个副本对象，跟原对象互不影响。  \nstr1 是一个不可变字符串对象，通过 `copy` 方法拷贝出来的副本也是不可变字符串对象。因为不可变字符串对象不可以被修改，不可以被修改就不会互相影响，所以 str1 和 str2 指向同一个对象满足拷贝的原则（互不影响）。而且将 str1 和 str2 指向同一个对象还节省了内存。  \nstr1 是一个不可变字符串对象，通过 `mutableCopy` 方法拷贝出来的副本是可变字符串对象。因为可变字符串对象可以被修改，所以 str3 指向的是一个新的对象，保证在修改 str3 时不会影响到 str1。  \n\n（总的来看，既要保证互不影响，也要做到节省资源）\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str3 = [str2 copy];\n        NSString *str4 = @\"test\";\n        NSMutableString *str5 = [str1 mutableCopy];\n        \n        NSLog(@\"%@ %@ %@ %@ %@ %@\", @\"test\", str1, str2, str3, str4, str5);\n        NSLog(@\"%p %p %p %p %p %p\", @\"test\", str1, str2, str3, str4, str5);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test test test test\n0x100002040 0x100002040 0x100002040 0x100002040 0x100002040 0x1006bd980\n```\n\nstr1、str2、str3 和 str4 都是 `@\"test\"` 对象。\n\n引用计数：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test111111111\"]; // str1 : 1\n        NSString *str2 = [str1 copy]; // str1 : 2\n        NSMutableString *str3 = [str1 mutableCopy];\n        \n        NSLog(@\"%zd\", str1.retainCount);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n2\n```\n\n从打印结果可以看到，str1 在调用 `copy` 方法后，引用计数加1，相当于调用了一次 `retain` 方法。\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test111111111\"];\n        NSString *str2 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str3 = [[NSString alloc] initWithString:@\"test\"];\n        \n        NSLog(@\"%@ %@ %@\", [str1 class], [str2 class], [str3 class]);\n        NSLog(@\"%zd %zd %zd\", str1.retainCount, str2.retainCount, str3.retainCount);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSCFString NSTaggedPointerString __NSCFConstantString\n1 -1 -1\n```\n\n使用 `initWithFormat:` 方法初始化字符串，字符串长度足够长，创建出来的是 `__NSCFString` 类型的字符串。`__NSCFString` 类型的字符串是通过引用计数管理内存的。  \n使用 `initWithFormat:` 方法初始化字符串，字符串长度不够长，创建出来的是 `NSTaggedPointerString` 类型的字符串。`NSTaggedPointerString` 类型的字符串不是通过引用计数管理内存的。  \n使用 `initWithString:` 方法初始化字符串，不管字符串长度，创建出来的是 `__NSCFConstantString` 类型的字符串。`__NSCFConstantString` 类型的字符串不是通过引用计数管理内存的。\n\nps：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = @\"test\";\n        NSString *str1_1 = @\"test\";\n        \n        NSString *str2 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2_1 = [[NSString alloc] initWithString:@\"test\"];\n        \n        NSString *str3 = [NSString stringWithString:@\"test\"];\n        NSString *str3_1 = [NSString stringWithString:@\"test\"];\n        \n        NSString *str4 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str4_1 = [[NSString alloc] initWithFormat:@\"test\"];\n        \n        NSString *str5 = [NSString stringWithFormat:@\"test\"];\n        NSString *str5_1 = [NSString stringWithFormat:@\"test\"];\n        \n        NSLog(@\"%p\", str1);\n        NSLog(@\"%p\", str1_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str2);\n        NSLog(@\"%p\", str2_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str3);\n        NSLog(@\"%p\", str3_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str4);\n        NSLog(@\"%p\", str4_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str5);\n        NSLog(@\"%p\", str5_1);\n        \n        [str1 release];\n        [str1_1 release];\n        [str2 release];\n        [str2_1 release];\n        [str3 release];\n        [str3_1 release];\n        [str4 release];\n        [str4_1 release];\n        [str5 release];\n        [str5_1 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x100002040\n0x100002040\n------------------\n0x100002040\n0x100002040\n------------------\n0x100002040\n0x100002040\n------------------\n0x1f9d08801e47ec0b\n0x1f9d08801e47ec0b\n------------------\n0x1f9d08801e47ec0b\n0x1f9d08801e47ec0b\n```\n\n通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看源码：  \n以 Format 结尾的方法最终调用的都是这个方法：\n```\n- (id)initWithFormat:(NSString*)format locale:(NSDictionary*)locale arguments:(va_list)argList;\n```\n\n以 String 结尾的方法最终调用的都是这个方法：\n```\n- (id)initWithString:(NSString*)string;\n```\n\n### NSMutableString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableString *str1 = [[NSMutableString alloc] initWithString:@\"test\"];\n        NSString *str2 = [str1 copy]; // 深拷贝\n        NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%p %p %p\", str1, str2, str3);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0x103aaab50 0x48301b1a78a3a9e5 0x103aab150\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是他们指向的都是不同的内存地址。即 str1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 str2 和 str3 都是一个新的对象。\n![内存管理11](内存管理/内存管理11.png)\n\n### NSArray\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 浅拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", arr1, arr2, arr3);\n        NSLog(@\"%p %p %p\", arr1, arr2, arr3);\n        NSLog(@\"%d %d %d\",\n              [arr1 isKindOfClass:[NSMutableArray class]],\n              [arr2 isKindOfClass:[NSMutableArray class]],\n              [arr3 isKindOfClass:[NSMutableArray class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n(\n    1,\n    2\n) (\n    1,\n    2\n) (\n    1,\n    2\n)\n0x1004bfc20 0x1004bfc20 0x1004c0100\n0 0 1\n```\n\narr1 和 arr2 是不可变数组，arr3 是可变数组。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\narr1、arr2 和 arr3 打印出来都是同样的内容，但是 arr1 和 arr2 指向的是同一个内存地址，arr3 指向的是另一个内存地址。即 arr1 通过 `copy` 方法拷贝出来的副本 arr2 还是原对象（arr1），而 arr1 通过 `mutableCopy` 方法拷贝出来的副本 arr3 是一个新的对象。\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 浅拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        NSLog(@\"%p %p %p %p\", @[@\"1\", @\"2\"], arr1, arr2, arr3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x100713270 0x100712d60 0x100712d60 0x100713240\n```\n\nNSArray 和 NSString 不同，`@[@\"1\", @\"2\"]`、arr1 和 arr2 虽然内容相同，但是它们是不同的对象（arr1 和 arr2 是同一个对象）。\n\n### NSMutableArray\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableArray *arr1 = [[NSMutableArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 深拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", arr1, arr2, arr3);\n        NSLog(@\"%p %p %p\", arr1, arr2, arr3);\n        NSLog(@\"%d %d %d\",\n              [arr1 isKindOfClass:[NSMutableArray class]],\n              [arr2 isKindOfClass:[NSMutableArray class]],\n              [arr3 isKindOfClass:[NSMutableArray class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n(\n    1,\n    2\n) (\n    1,\n    2\n) (\n    1,\n    2\n)\n0x100535780 0x1005358f0 0x100535910\n1 0 1\n```\n\narr1 和 arr3 是可变数组，arr2 是不可变数组。即：  \n[可变 copy] -> 不可变  \n[可变 mutableCopy] -> 可变  \n\narr1、arr2 和 arr3 打印出来都是同样的内容，但是他们指向的都是不同的内存地址。即 arr1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 arr2 和 arr3 都是一个新的对象。\n\n\n### NSDictionary\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSDictionary *dict1 = [NSDictionary dictionaryWithObjectsAndKeys:@\"value\", @\"key\", nil];\n        NSDictionary *dict2 = [dict1 copy]; // 浅拷贝\n        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", dict1, dict2, dict3);\n        NSLog(@\"%p %p %p\", dict1, dict2, dict3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{\n    key = value;\n} {\n    key = value;\n} {\n    key = value;\n}\n0x100491ff0 0x100491ff0 0x1004923f0\n```\n\ndict1 和 dict2 是不可变字典，dict3 是可变字典。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\ndict1、dict2 和 dict3 打印出来都是同样的内容，但是 dict1 和 dict2 指向的是同一个内存地址，dict3 指向的是另一个内存地址。即 dict1 通过 `copy` 方法拷贝出来的副本 dict2 还是原对象（dict1），而 dict1 通过 `mutableCopy` 方法拷贝出来的副本 dict3 是一个新的对象。\n\n### NSMutableDictionary\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableDictionary *dict1 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@\"value\", @\"key\", nil];\n        NSDictionary *dict2 = [dict1 copy]; // 深拷贝\n        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", dict1, dict2, dict3);\n        NSLog(@\"%p %p %p\", dict1, dict2, dict3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{\n    key = value;\n} {\n    key = value;\n} {\n    key = value;\n}\n0x100463300 0x100463900 0x100463920\n```\n\ndict1 和 dict3 是可变字典，dict2 是不可变字典。即：  \n[可变 copy] -> 不可变  \n[可变 mutableCopy] -> 可变  \n\ndict1、dict2 和 dict3 打印出来都是同样的内容，但是他们指向的都是不同的内存地址。即 dict1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 dict2 和 dict3 都是一个新的对象。\n\n### 小结\n\n|  | copy | mutableCopy |\n| :-- | :-- | :-- |\n| NSString | NSString<br><font color=#FF0000> 浅拷贝 </font> | NSMutableString<br>深拷贝 |\n| NSMutableString | NSString<br>深拷贝| NSMutableString<br>深拷贝 |\n| NSArray | NSArray<br><font color=#FF0000> 浅拷贝 </font>| NSMutableArray<br>深拷贝 |\n| NSMutableArray | NSArray<br>深拷贝| NSMutableArray<br>深拷贝 |\n| NSDictionary | NSDictionary<br><font color=#FF0000> 浅拷贝 </font>| NSMutableDictionary<br>深拷贝 |\n| NSMutableDictionary | NSDictionary<br>深拷贝| NSDictionary<br>深拷贝 |\n\n\n## copy策略的property\n\n定义 Person\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSMutableArray *data;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.data = [NSMutableArray array];\n        [person.data addObject:@\"123\"];\n    }\n    return 0;\n}\n```\n\n报错：\n![内存管理12](内存管理/内存管理12.png)\n\n`data` 是 Person 用 `copy` 策略定义的 `NSMutableArray`，`data` 的 set 方法是：\n```\n@implementation Person\n- (void)setData:(NSMutableArray *)data\n{\n    if (_data != data) {\n        [_data release];\n        _data = [data copy];\n    }\n}\n@end\n```\n\n在 `person.data = [NSMutableArray array]` 赋值的这一刻，虽然传入的是一个 `NSMutableArray`，但是因为是 `copy` 策略，所以在赋值时需要进行 `copy` 操作 `_data = [data copy]`，所以 `_data` 是一个 `NSArray` 类型的不可变数组。\n\n对于可变类型的变量，在声明时使用 `strong` 策略。  \n对于不可变类型的变量，在声明时使用 `copy` 策略。\n\n比如 `UITextField` 里的 text、attributedText 和 placeholder 等，都是使用的 copy 策略，保证不管传入的是可变类型还是不可变类型，`UITextField` 内部使用的都是不可变类型：\n```\n@interface UITextField : UIControl <UITextInput, NSCoding, UIContentSizeCategoryAdjusting>\n\n@property(nullable, nonatomic,copy)   NSString               *text;                 // default is nil\n@property(nullable, nonatomic,copy)   NSAttributedString     *attributedText API_AVAILABLE(ios(6.0)); // default is nil\n......\n@property(nullable, nonatomic,copy)   NSString               *placeholder;          // default is nil. string is drawn 70% gray\n@property(nullable, nonatomic,copy)   NSAttributedString     *attributedPlaceholder API_AVAILABLE(ios(6.0)); // default is nil\n```\n\n## copyWithZone:\n\n对象类型进行 `copy` 操作，首先要遵守 `<NSCopying>` 协议，然后实现 `- (id)copyWithZone:(struct _NSZone *)zone` 方法：\n```\n@interface Person : NSObject <NSCopying>\n@property (nonatomic, assign) int age;\n@property (nonatomic, assign) int weight;\n@end\n\n@implementation Person\n- (id)copyWithZone:(struct _NSZone *)zone\n{\n    Person *person = [Person allocWithZone:zone];\n    // 设置需要拷贝的属性\n    person.age = self.age;\n    person.weight = self.weight;\n    return person;\n}\n\n- (NSString *)description\n{\n    return [NSString stringWithFormat:@\"age = %d, weight = %d\", self.age, self.weight];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.age = 10;\n        person.weight = 20;\n        \n        Person *person2 = [person copy];\n        NSLog(@\"{%@} {%@}\", person, person2);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{age = 10, weight = 20} {age = 10, weight = 20}\n```\n\n# 引用计数的存储\n在 64bit 中，引用计数可以直接存储在优化过的 isa 指针中，也可能存储在 SideTable 类中。\n```\nstruct SideTable {\n    spinlock_t slock;\n    RefcountMap refcnts; // 一个存放着对象引用计数的散列表\n    weak_table_t weak_table; // 弱引用表\n    ......\n};\n```\n\n在 objc-weak.h 文件查看 `weak_table_t` 定义：\n```\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 数组地址（首元素地址）\n    size_t    num_entries; // 数组的数量\n    uintptr_t mask; // 数组下标最大值（weak_table_t的size-1）\n    uintptr_t max_hash_displacement; // 最大hash偏移量\n};\n```\n\n## retainCount\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件中查看 `retainCount`：  \n```\n- (NSUInteger)retainCount {\n    return _objc_rootRetainCount(self);\n}\n\n......\n\nuintptr_t\n_objc_rootRetainCount(id obj)\n{\n    ASSERT(obj);\n\n    return obj->rootRetainCount();\n}\n```\n\n在 objc-object.h 文件中查看 `rootRetainCount()` 方法：\n```\ninline uintptr_t \nobjc_object::rootRetainCount()\n{\n    if (isTaggedPointer()) return (uintptr_t)this;\n\n    sidetable_lock();\n    isa_t bits = LoadExclusive(&isa.bits);\n    ClearExclusive(&isa.bits);\n    if (bits.nonpointer) { // 非指针类型（优化过的isa指针）\n        uintptr_t rc = 1 + bits.extra_rc;\n        if (bits.has_sidetable_rc) { // 引用计数不是存储在isa中，而是存储在sidetable中\n            rc += sidetable_getExtraRC_nolock();\n        }\n        sidetable_unlock();\n        return rc;\n    }\n\n    sidetable_unlock();\n    return sidetable_retainCount();\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_getExtraRC_nolock()` 方法：\n```\nsize_t \nobjc_object::sidetable_getExtraRC_nolock()\n{\n    ASSERT(isa.nonpointer);\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this); //取出对象对应的散列表\n    if (it == table.refcnts.end()) return 0;\n    else return it->second >> SIDE_TABLE_RC_SHIFT;\n}\n```\n\n`has_sidetable_rc`：引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中。\n![内存管理17](内存管理/内存管理17.png)\n\n## release\n```\n- (oneway void)release {\n    _objc_rootRelease(self);\n}\n\n......\n\nNEVER_INLINE void\n_objc_rootRelease(id obj)\n{\n    ASSERT(obj);\n\n    obj->rootRelease();\n}\n```\n\n在 objc-object.h 文件中查看 `rootRelease()` 方法：\n```\nALWAYS_INLINE bool \nobjc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    bool sideTableLocked = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n retry:\n    do {\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n        if (slowpath(!newisa.nonpointer)) {\n            // 不是优化过的isa指针\n            ClearExclusive(&isa.bits);\n            if (rawISA()->isMetaClass()) return false;\n            if (sideTableLocked) sidetable_unlock();\n            return sidetable_release(performDealloc);\n        }\n        // don't check newisa.fast_rr; we already called any RR overrides\n        uintptr_t carry;\n        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--\n        // 相减后下溢出\n        if (slowpath(carry)) {\n            // don't ClearExclusive()\n            goto underflow;\n        }\n    } while (slowpath(!StoreReleaseExclusive(&isa.bits, \n                                             oldisa.bits, newisa.bits)));\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n    return false;\n\n underflow:\n    // newisa.extra_rc-- underflowed: borrow from side table or deallocate\n\n    // abandon newisa to undo the decrement\n    newisa = oldisa;\n\n    // 引用计数不是存储在isa中，而是存储在sidetable中 \n    if (slowpath(newisa.has_sidetable_rc)) {\n        if (!handleUnderflow) {\n            ClearExclusive(&isa.bits);\n            // 再执行 rootRelease 一次，处理下溢出\n            return rootRelease_underflow(performDealloc);\n        }\n\n        // Transfer retain count from side table to inline storage.\n\n        if (!sideTableLocked) {\n            ClearExclusive(&isa.bits);\n            sidetable_lock();\n            sideTableLocked = true;\n            // Need to start over to avoid a race against \n            // the nonpointer -> raw pointer transition.\n            goto retry;\n        }\n\n        // 下面是从 sideTable 借 RC_HALF 的引用计数放到 extra_rc 上, 借不到的情况，对象需要被销毁了\n        // Try to remove some retain counts from the side table.        \n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n\n        // To avoid races, has_sidetable_rc must remain set \n        // even if the side table count is now zero.\n\n        if (borrowed > 0) {\n            // Side table retain count decreased.\n            // Try to add them to the inline count.\n            newisa.extra_rc = borrowed - 1;  // redo the original decrement too\n            bool stored = StoreReleaseExclusive(&isa.bits, \n                                                oldisa.bits, newisa.bits);\n            if (!stored) {\n                // Inline update failed. \n                // Try it again right now. This prevents livelock on LL/SC \n                // architectures where the side table access itself may have \n                // dropped the reservation.\n                isa_t oldisa2 = LoadExclusive(&isa.bits);\n                isa_t newisa2 = oldisa2;\n                if (newisa2.nonpointer) {\n                    uintptr_t overflow;\n                    newisa2.bits = \n                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);\n                    if (!overflow) {\n                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, \n                                                       newisa2.bits);\n                    }\n                }\n            }\n\n            if (!stored) {\n                // Inline update failed.\n                // Put the retains back in the side table.\n                sidetable_addExtraRC_nolock(borrowed);\n                goto retry;\n            }\n\n            // Decrement successful after borrowing from side table.\n            // This decrement cannot be the deallocating decrement - the side \n            // table lock and has_sidetable_rc bit ensure that if everyone \n            // else tried to -release while we worked, the last one would block.\n            sidetable_unlock();\n            return false;\n        }\n        else {\n            // Side table is empty after all. Fall-through to the dealloc path.\n        }\n    }\n\n    // Really deallocate.\n\n    if (slowpath(newisa.deallocating)) {\n        ClearExclusive(&isa.bits);\n        if (sideTableLocked) sidetable_unlock();\n        return overrelease_error();\n        // does not actually return\n    }\n    newisa.deallocating = true;\n    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n\n    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n    if (performDealloc) {\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));\n    }\n    return true;\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_release()` 方法：\n```\n#define SIDE_TABLE_RC_ONE            (1UL<<2)  // MSB-ward of deallocating bit\n\n......\n\nuintptr_t\nobjc_object::sidetable_release(bool performDealloc)\n{\n#if SUPPORT_NONPOINTER_ISA\n    ASSERT(!isa.nonpointer);\n#endif\n    SideTable& table = SideTables()[this];\n\n    bool do_dealloc = false;\n    \n    //----- 对引用计数减操作 -----\n    table.lock();\n    auto it = table.refcnts.try_emplace(this, SIDE_TABLE_DEALLOCATING);\n    auto &refcnt = it.first->second;\n    if (it.second) {\n        do_dealloc = true;\n    } else if (refcnt < SIDE_TABLE_DEALLOCATING) {\n        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.\n        do_dealloc = true;\n        refcnt |= SIDE_TABLE_DEALLOCATING;\n    } else if (! (refcnt & SIDE_TABLE_RC_PINNED)) {\n        refcnt -= SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n    //----- 对引用计数减操作 end -----\n\n    // 是否要执行 dealloc\n    if (do_dealloc  &&  performDealloc) {\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));\n    }\n    return do_dealloc;\n}\n```\n\n## retain()\n在 objc-object.h 文件中查看 `retain()` 方法：\n```\ninline id \nobjc_object::retain()\n{\n    ASSERT(!isTaggedPointer());\n\n    if (fastpath(!ISA()->hasCustomRR())) {\n        return sidetable_retain();\n    }\n\n    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(retain));\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_retain()` 方法：\n```\nid\nobjc_object::sidetable_retain()\n{\n#if SUPPORT_NONPOINTER_ISA\n    ASSERT(!isa.nonpointer);\n#endif\n    SideTable& table = SideTables()[this];\n    \n    //----- 对引用计数加操作 -----\n    table.lock();\n    size_t& refcntStorage = table.refcnts[this];\n    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {\n        refcntStorage += SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n    //----- 对引用计数加操作 end -----\n\n    return (id)this;\n}\n```\n\n# weak指针的原理\n\n## 局部变量的内存管理\n创建局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n    }\n    NSLog(@\"222\");\n}\n@end\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n```\n\n### \\_\\_strong\n使用 `__strong` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __strong Person *strongPerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        strongPerson = person;\n    }\n    NSLog(@\"222\");\n    NSLog(@\"%@\", strongPerson);\n}\n@end\n```\n\n打印结果：\n```\n111\n222\n<Person: 0x60000177c310>\n-[Person dealloc]\n```\n\n### \\_\\_weak \n使用 `__weak` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak Person *weakPerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        weakPerson = person;\n    }\n    NSLog(@\"222\");\n    NSLog(@\"%@\", weakPerson);\n}\n@end\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n(null)\n```\n\n`weakPerson` 指针指向的内存地址被销毁后，`weakPerson` 指针会自动置为 nil。\n\n### \\_\\_unsafe_unretained\n使用 `__unsafe_unretained` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __unsafe_unretained Person *unsafePerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        unsafePerson = person;\n    }\n    NSLog(@\"222\");\n}\n@end\n```\n\n报错：\n![内存管理12](内存管理/内存管理12.png)\n\n报错的原因是指针 `unsafePerson` 还在，但是它指向的内存地址已经不存在了。这也是跟 `weakPerson` 指针相比不同也是不够安全的地方。\n\n## dealloc\n\n[objc4-781](https://opensource.apple.com/tarballs/objc4/) 查看源码：  \n\nNSObject.mm 文件：\n```\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\n......\n\nvoid\n_objc_rootDealloc(id obj)\n{\n    ASSERT(obj);\n\n    obj->rootDealloc();\n}\n```\n\n在 objc-object.h 文件查看 `rootDealloc()` 方法：\n```\ninline void\nobjc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;  // fixme necessary?\n\n    if (fastpath(isa.nonpointer  &&  \n                 !isa.weakly_referenced  &&  \n                 !isa.has_assoc  &&  \n                 !isa.has_cxx_dtor  &&  \n                 !isa.has_sidetable_rc))\n    {\n        assert(!sidetable_present());\n        free(this);\n    } \n    else {\n        object_dispose((id)this);\n    }\n}\n```\n\n* nonpointer  \n0，代表普通的指针，isa 只存储着 Class、Meta-Class 对象的内存地址  \n1，代表优化过，isa 使用位域存储更多的信息\n* has_assoc  \n是否有设置过关联对象，如果没有，释放时会更快\n* has_cxx_dtor  \n是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快\n* weakly_referenced  \n是否有被弱引用指向过，如果没有，释放时会更快\n* has_sidetable_rc  \n引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中\n\n如果条件不成立会走到 objc-runtime-new.mm 文件的 `object_dispose()` 方法：\n```\nid \nobject_dispose(id obj)\n{\n    if (!obj) return nil;\n\n    objc_destructInstance(obj);    \n    free(obj);\n\n    return nil;\n}\n\n......\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj); // 清除成员变量\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating(); // 将指向当前对象的弱指针置为nil\n    }\n\n    return obj;\n}\n```\n\n在 objc-object.h 文件查看 `clearDeallocating()` 方法：\n```\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) { // 是否是普通的isa指针\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) { // 是否有被弱引用指向过 || // 是否是优化过的isa指针\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```\n\n在 NSObject.mm 文件 查看 `clearDeallocating_slow()` 方法：\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this); // 清除弱应用\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this); // 清空引用计数\n    }\n    table.unlock();\n}\n```\n\n在 objc-weak.mm 文件查看 `weak_clear_no_lock()` 方法：\n```\nvoid \nweak_clear_no_lock(weak_table_t *weak_table, id referent_id) \n{\n    // 获取当前对象\n    objc_object *referent = (objc_object *)referent_id;\n\n    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); // 传入弱引用表和当前对象的地址值，找到对应的弱引用数组\n    if (entry == nil) {\n        return; // 如果没有表示当前对象没有弱引用，不用处理直接返回\n    }\n\n    // zero out references\n    weak_referrer_t *referrers;\n    size_t count;\n    \n    if (entry->out_of_line()) {\n        referrers = entry->referrers;\n        count = TABLE_SIZE(entry);\n    } \n    else {\n        referrers = entry->inline_referrers;\n        count = WEAK_INLINE_COUNT;\n    }\n    \n    for (size_t i = 0; i < count; ++i) {\n        objc_object **referrer = referrers[i];\n        if (referrer) {\n            if (*referrer == referent) {\n                *referrer = nil;\n            }\n            else if (*referrer) {\n                _objc_inform(\"__weak variable at %p holds %p instead of %p. \"\n                             \"This is probably incorrect use of \"\n                             \"objc_storeWeak() and objc_loadWeak(). \"\n                             \"Break on objc_weak_error to debug.\\n\", \n                             referrer, (void*)*referrer, (void*)referent);\n                objc_weak_error();\n            }\n        }\n    }\n    \n    weak_entry_remove(weak_table, entry);\n}\n\n......\n\nstatic weak_entry_t *\nweak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)\n{\n    ASSERT(referent);\n\n    weak_entry_t *weak_entries = weak_table->weak_entries; // 在weak_table中取出weak_entry_t数组\n\n    if (!weak_entries) return nil;\n\n    size_t begin = hash_pointer(referent) & weak_table->mask; // 通过hash实例对象的地址 & weak_table->mask得到begin(没有hash冲突的index)，因为是 & mask(2的n次方-1，类似00001111)，所以保证了begin在mask范围内(<=mask)\n    size_t index = begin;\n    size_t hash_displacement = 0;\n    while (weak_table->weak_entries[index].referent != referent) { // while循环检测hash冲突，如果有冲突,index+1，hash_displacement++（hash冲突偏移量）\n        index = (index+1) & weak_table->mask;\n        if (index == begin) bad_weak_table(weak_table->weak_entries);\n        hash_displacement++;\n        if (hash_displacement > weak_table->max_hash_displacement) {\n            return nil;\n        }\n    }\n    \n    return &weak_table->weak_entries[index];\n}\n```\n\n# 自动释放池\n自动释放池的主要底层数据结构是：`__AtAutoreleasePool`、`AutoreleasePoolPage`，调用了 `autorelease` 的对象最终都是通过 `AutoreleasePoolPage` 对象来管理的。\n\n## \\_\\_AtAutoreleasePool\n\n堆代码：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[[Person alloc] init] autorelease];\n    }\n    return 0;\n}\n```\n\n找到 main.m 所在文件，在终端输入：\n```\n$ xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc main.m\n```\n\n上面的代码转成 C++ 代码后就是这个样子：\n```\nint main(int argc, const char * argv[]) {\n    {\n        __AtAutoreleasePool __autoreleasepool; \n        Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    }\n    return 0;\n}\n```\n\n简化一下：\n```\nint main(int argc, const char * argv[]) {\n    {\n        __AtAutoreleasePool __autoreleasepool; \n        Person *person = [[[Person alloc] init] autorelease];\n    }\n    return 0;\n}\n```\n\n在生成的 main.mm 文件中搜索 `__AtAutoreleasePool`，`__AtAutoreleasePool` 是一个 C++ 结构体：\n```\nstruct __AtAutoreleasePool {\n    // 构造函数，在创建结构体的时候调用\n    __AtAutoreleasePool() {\n        atautoreleasepoolobj = objc_autoreleasePoolPush();\n    }\n    // 析构函数，在结构体销毁的时候调用\n    ~__AtAutoreleasePool() {\n        objc_autoreleasePoolPop(atautoreleasepoolobj);\n    }\n    void * atautoreleasepoolobj;\n};\n```\n\n认识了 `__AtAutoreleasePool` 结构体后，通过 clang 生成的 C++ 代码可以看做：\n```\nint main(int argc, const char * argv[]) {\n    atautoreleasepoolobj = objc_autoreleasePoolPush();\n \n    MJPerson *person = [[[MJPerson alloc] init] autorelease];\n \n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n    return 0;\n}\n```\n\n通过上面的摸索，`@autoreleasepool {}` 的第一个大括号其实是调用了 `objc_autoreleasePoolPush()` 方法，第二个大括号是调用 `objc_autoreleasePoolPop()` 方法，`objc_autoreleasePoolPop()` 方法的参数是 `objc_autoreleasePoolPush()` 方法生成的 `atautoreleasepoolobj`。\n\n如果有多个 `@autoreleasepool {}` 嵌套的话就是这样：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool { // objc_autoreleasePoolPush()\n        \n        @autoreleasepool { // objc_autoreleasePoolPush()\n            \n            @autoreleasepool { // objc_autoreleasePoolPush()\n               \n                Person *person = [[[Person alloc] init] autorelease];\n            \n            } // objc_autoreleasePoolPop()\n        \n        } // objc_autoreleasePoolPop()\n    \n    } // objc_autoreleasePoolPop()\n    return 0;\n}\n```\n\n查看 `objc_autoreleasePoolPush()` 源码：\n```\nvoid *\nobjc_autoreleasePoolPush(void)\n{\n    return AutoreleasePoolPage::push();\n}\n```\n\n查看 `objc_autoreleasePoolPop()` 源码：\n```\nNEVER_INLINE\nvoid\nobjc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n从源码可以看到，`objc_autoreleasePoolPush()` 和 `objc_autoreleasePoolPop()` 方法内部都是通过 `AutoreleasePoolPage` 实现的。\n\n## AutoreleasePoolPage\n\n### 定义\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject-internal.h 文件可以看到 AutoreleasePoolPage 的定义：\n```\nclass AutoreleasePoolPage;\nstruct AutoreleasePoolPageData\n{\n\tmagic_t const magic; // 用于校验内存是否损坏\n\t__unsafe_unretained id *next; // 指向了下一个能存放autorelease对象地址的区域\n\tpthread_t const thread; // 线程\n\tAutoreleasePoolPage * const parent; // 前驱结点，指向前一个page\n\tAutoreleasePoolPage *child; // 后继结点，指向下一个page\n\tuint32_t const depth;\n\tuint32_t hiwat;\n\n\tAutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)\n\t\t: magic(), next(_next), thread(_thread),\n\t\t  parent(_parent), child(nil),\n\t\t  depth(_depth), hiwat(_hiwat)\n\t{\n\t}\n};\n\nclass AutoreleasePoolPage : private AutoreleasePoolPageData\n{\n    ......\n}\n```\n\n`AutoreleasePoolPage` 结构体的 thread 存储的是其对应的线程，也表示一个 `AutoreleasePoolPage` 对应一个线程。\n\n### 结构\n每个 `AutoreleasePoolPage` 对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 `autorelease` 对象的地址，所有的 `AutoreleasePoolPage` 对象通过双向链表的形式连接在一起。\n\n假设 `AutoreleasePoolPage` 对象的内存地址从 `0x1000` 开始：\n![内存管理14](内存管理/内存管理14.png)\n从 `0x1000` 到 `0x2000` 共4096个字节（`0x1000`）。  \n从 `0x1000` 到 `0x1038` 共56个字节（`0x38`），即 `AutoreleasePoolPage` 结构体内部的成员变量大小之和。  \n从 `0x1038` 到 `0x2000` 共4040个字节，分别是 `begain()` 和 `end()` 方法调用的位置，这段内存用来保存调用了 `autorelease` 方法的对象的地址值。  \n\n查看 `begain()` 方法源码：\n```\nid * begin() {\n    return (id *) ((uint8_t *)this+sizeof(*this));\n}\n```\n\n可以看到 `begain()` 方法内部直接返回的是 `AutoreleasePoolPage` 内存地址开始位置加上其自身占用内存大小（`0x1000` + `0x38` = `0x1038`）。\n\n查看 `end()` 方法源码：\n```\nid * end() {\n    return (id *) ((uint8_t *)this+SIZE);\n}\n```\n\n可以看到 `end()` 方法内部直接返回的是 `AutoreleasePoolPage` 内存地址开始位置加上 `SIZE`：\n```\n#define I386_PGBYTES            4096            /* bytes per 80386 page */\n#define PAGE_SIZE               I386_PGBYTES\n#define PAGE_MAX_SIZE           PAGE_SIZE\n\nstatic size_t const SIZE =\n#if PROTECT_AUTORELEASEPOOL\n\t\tPAGE_MAX_SIZE;  // must be multiple of vm page size\n#else\n\t\tPAGE_MIN_SIZE;  // size and alignment, power of 2\n#endif\n```\n\n一个 `AutoreleasePoolPage` 结构体能够存放的 `autorelease` 对象的地址是有限的，如果超出存储最大值，会新创建一个 `AutoreleasePoolPage` 结构体用来存储剩下的部分。多个 `AutoreleasePoolPage` 结构体通过机构体中的 child 指向下一个 `AutoreleasePoolPage` 结构体，通过 parent 指向上一个 `AutoreleasePoolPage` 结构体，构成双向链表结构：\n![内存管理15](内存管理/内存管理15.png)\n\n* 👉 双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。\n* 👉 循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。\n\n### 原理\n调用 `push` 方法会将一个 `POOL_BOUNDARY` 入栈，并且返回其存放的内存地址。  \n调用 `pop` 方法时传入一个 `POOL_BOUNDARY` 的内存地址，会从最后一个入栈的对象开始发送 `release` 消息，直到遇到这个 `POOL_BOUNDARY`。  \n`id *next` 指向了下一个能存放 `autorelease` 对象地址的区域。    \n\n比如在 `@autoreleasepool {}` 内创建1000个 person 对象调用 `autorelease`。\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        for (int i=0; i<1000; i++) {\n            Person *person = [[[Person alloc] init] autorelease];\n        }\n    }\n    return 0;\n}\n```\n\n一个 person 对象的指针占8个字节，1000个 person 对象就是8000个字节。一个 `AutoreleasePoolPage` 对象可以保存4040个字节，所以会再创建一个 `AutoreleasePoolPage` 对象用来保存剩下的 person 对象的地址值。\n\n将 `@autoreleasepool {}` 转成 `__AtAutoreleasePool`：\n```\nint main(int argc, const char * argv[]) {\n    atautoreleasepoolobj = objc_autoreleasePoolPush(); // atautoreleasepoolobj = 0x1038\n    \n    for (int i=0; i<1000; i++) {\n        Person *person = [[[Person alloc] init] autorelease];\n    } // 8000个字节\n\n    objc_autoreleasePoolPop(atautoreleasepoolobj); // atautoreleasepoolobj = 0x1038\n    return 0;\n}\n```\n\n`objc_autoreleasePoolPush()` 会调用 `AutoreleasePoolPage` 对象的 `push()` 方法，将一个 `POOL_BOUNDARY` 入栈，并且返回其存放的内存地址（`0x1038`）：\n![内存管理18](内存管理/内存管理18.png)\n\n每个调用 `autorelease` 方法的 person 对象都会添加到 `AutoreleasePoolPage` 对象中：\n![内存管理19](内存管理/内存管理19.png)\n正如上面提到的一样，一个 `AutoreleasePoolPage` 对象可以保存4040个字节，所以会创建一个新的 `AutoreleasePoolPage` 对象用来保存剩下的 person 对象的地址值。\n\n`objc_autoreleasePoolPop(atautoreleasepoolobj)` 方法传入的 `atautoreleasepoolobj` 是 `objc_autoreleasePoolPush()` 方法返回的 `POOL_BOUNDARY` 的地址值（`0x1038`），即 `objc_autoreleasePoolPop(POOL_BOUNDARY)`。拿到 `POOL_BOUNDARY` 后，`objc_autoreleasePoolPop()` 方法内部会从最后一个加入到 `AutoreleasePoolPage` 里的对象开始，依次调用 `release` 方法，直到 `POOL_BOUNDARY` 完成释放工作。\n\n在整个过程中，`next` 指向 page 中下一个将要存放的对象的地址, 通过 `*next++ = obj` 来实现对象的存入并 `next` 指针的累加, 用 `id obj = *--page->next` 来取出要 `release` 的对象并实现 `next` 的递减。\n\n### 验证\n可以通过以下私有函数来查看自动释放池的情况：\n```\nextern void _objc_autoreleasePoolPrint(void);\n```\n\n`_objc_autoreleasePoolPrint()` 方法是定义在 Runtime 里的，所以是不开源的。但是可以通过 `extern` 关键字在 main.m 文件中声明，编译器就会自动去找到这个方法，从而实现调用。\n```\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        _objc_autoreleasePoolPrint(); // 位置0\n\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n        \n        //_objc_autoreleasePoolPrint(); // 位置1\n\n        @autoreleasepool {\n            Person *person3 = [[[Person alloc] init] autorelease];\n            Person *person4 = [[[Person alloc] init] autorelease];\n\n            //_objc_autoreleasePoolPrint(); // 位置2\n\n            @autoreleasepool {\n                Person *person5 = [[[Person alloc] init] autorelease];\n                Person *person6 = [[[Person alloc] init] autorelease];\n\n                //_objc_autoreleasePoolPrint(); // 位置3\n            }\n\n            //_objc_autoreleasePoolPrint(); // 位置4\n        }\n\n        //_objc_autoreleasePoolPrint(); // 位置5\n    }\n\n    //_objc_autoreleasePoolPrint(); // 位置6\n    return 0;\n}\n```\n\n位置0，打印结果：\n```\nobjc[13812]: ##############\nobjc[13812]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13812]: 0 releases pending.\nobjc[13812]: [0x1]  ................  PAGE (placeholder)\nobjc[13812]: [0x1]  ################  POOL (placeholder)\nobjc[13812]: ##############\nProgram ended with exit code: 0\n```\n\n位置1，打印结果：\n```\nobjc[13633]: ##############\nobjc[13633]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13633]: 3 releases pending.\nobjc[13633]: [0x10400a000]  ................  PAGE  (hot) (cold)\nobjc[13633]: [0x10400a038]  ################  POOL 0x10400a038\nobjc[13633]: [0x10400a040]       0x10293c6e0  Person\nobjc[13633]: [0x10400a048]       0x10293b7a0  Person\nobjc[13633]: ##############\nProgram ended with exit code: 0\n```\n\n位置2，打印结果：\n```\nobjc[13658]: ##############\nobjc[13658]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13658]: 6 releases pending.\nobjc[13658]: [0x10400a000]  ................  PAGE  (hot) (cold)\nobjc[13658]: [0x10400a038]  ################  POOL 0x10400a038\nobjc[13658]: [0x10400a040]       0x102974880  Person\nobjc[13658]: [0x10400a048]       0x102973940  Person\nobjc[13658]: [0x10400a050]  ################  POOL 0x10400a050\nobjc[13658]: [0x10400a058]       0x1029722e0  Person\nobjc[13658]: [0x10400a060]       0x102973800  Person\nobjc[13658]: ##############\nProgram ended with exit code: 0\n```\n\n位置3，打印结果：\n```\nobjc[13677]: ##############\nobjc[13677]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13677]: 9 releases pending.\nobjc[13677]: [0x10280d000]  ................  PAGE  (hot) (cold)\nobjc[13677]: [0x10280d038]  ################  POOL 0x10280d038\nobjc[13677]: [0x10280d040]       0x1006addd0  Person\nobjc[13677]: [0x10280d048]       0x1006ace90  Person\nobjc[13677]: [0x10280d050]  ################  POOL 0x10280d050\nobjc[13677]: [0x10280d058]       0x1006ab830  Person\nobjc[13677]: [0x10280d060]       0x1006acd50  Person\nobjc[13677]: [0x10280d068]  ################  POOL 0x10280d068\nobjc[13677]: [0x10280d070]       0x1006aba20  Person\nobjc[13677]: [0x10280d078]       0x1006ab4f0  Person\nobjc[13677]: ##############\nProgram ended with exit code: 0\n```\n\n位置4，打印结果：\n```\nobjc[13703]: ##############\nobjc[13703]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13703]: 6 releases pending.\nobjc[13703]: [0x10080d000]  ................  PAGE  (hot) (cold)\nobjc[13703]: [0x10080d038]  ################  POOL 0x10080d038\nobjc[13703]: [0x10080d040]       0x100437c20  Person\nobjc[13703]: [0x10080d048]       0x100436ce0  Person\nobjc[13703]: [0x10080d050]  ################  POOL 0x10080d050\nobjc[13703]: [0x10080d058]       0x100435680  Person\nobjc[13703]: [0x10080d060]       0x100436ba0  Person\nobjc[13703]: ##############\nProgram ended with exit code: 0\n```\n\n位置5，打印结果：\n```\nobjc[13735]: ##############\nobjc[13735]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13735]: 3 releases pending.\nobjc[13735]: [0x10480a000]  ................  PAGE  (hot) (cold)\nobjc[13735]: [0x10480a038]  ################  POOL 0x10480a038\nobjc[13735]: [0x10480a040]       0x10322c4d0  Person\nobjc[13735]: [0x10480a048]       0x10322b590  Person\nobjc[13735]: ##############\nProgram ended with exit code: 0\n```\n\n位置6，打印结果：\n```\nobjc[13751]: ##############\nobjc[13751]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13751]: 0 releases pending.\nobjc[13751]: [0x10300d000]  ................  PAGE  (hot) (cold)\nobjc[13751]: ##############\nProgram ended with exit code: 0\n```\n\n打印结果中的 `POOL` 代表的就是 `POOL_BOUNDARY`，person 代表的就是调用 `autorelease` 方法的对象。`releases pending` 表示当前自动释放池里的对象个数。 \n\n多个 `AutoreleasePoolPage` 对象的情况：\n```\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n\n        @autoreleasepool {\n            for (int i=0; i<600; i++) {\n                Person *person3 = [[[Person alloc] init] autorelease];\n            }\n\n            @autoreleasepool {\n                Person *person5 = [[[Person alloc] init] autorelease];\n                Person *person6 = [[[Person alloc] init] autorelease];\n\n                _objc_autoreleasePoolPrint();\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nobjc[13947]: ##############\nobjc[13947]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13947]: 607 releases pending.\nobjc[13947]: [0x10280c000]  ................  PAGE (full)  (cold)\nobjc[13947]: [0x10280c038]  ################  POOL 0x10280c038\nobjc[13947]: [0x10280c040]       0x10067bc20  Person\nobjc[13947]: [0x10280c048]       0x10067a1d0  Person\nobjc[13947]: [0x10280c050]  ################  POOL 0x10280c050\nobjc[13947]: [0x10280c058]       0x100679d60  Person\nobjc[13947]: [0x10280c060]       0x100678e20  Person\nobjc[13947]: [0x10280c068]       0x1006777c0  Person\nobjc[13947]: [0x10280c070]       0x100678ce0  Person\n...\nobjc[13947]: [0x10280cff8]       0x100681ba0  Person\nobjc[13947]: [0x10280a000]  ................  PAGE  (hot) \nobjc[13947]: [0x10280a038]       0x100681bb0  Person\n...\nobjc[13947]: [0x10280a348]       0x1006821d0  Person\nobjc[13947]: [0x10280a350]  ################  POOL 0x10280a350\nobjc[13947]: [0x10280a358]       0x1006821e0  Person\nobjc[13947]: [0x10280a360]       0x1006821f0  Person\n```\n\n从打印结果中可以看到，第一个 page 里有两个 `POOL_BOUNDARY`，由于对象太多超出了第一个 page 的存储范围，所以创建出了第二个 page。第二个 page 中存储了多出来的 person 对象，还有一个 `POOL_BOUNDARY`。  \n`PAGE  (hot) ` 表示该 page 为当前页，`PAGE (full)  (cold)` 中的 full 表示这一页已经满了，cold 表示该 page 不是当前页。\n\n### 源码分析\n\n`objc_autoreleasePoolPush()` 方法的实现原理是调用 `AutoreleasePoolPage` 对象的 `push()` 方法。  \n`objc_autoreleasePoolPop()` 方法的实现原理是调用 `AutoreleasePoolPage` 对象的 `pop()` 方法。  \n`autorelease` 方法的实现原理则是调用了 `AutoreleasePoolPage` 对象的 `autorelease()` 方法。\n\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 NSObject.mm 文件查看。\n\n#### objc_autoreleasePoolPush(void)\n```\nvoid *\nobjc_autoreleasePoolPush(void)\n{\n    return AutoreleasePoolPage::push();\n}\n```\n\n`push()` 方法：\n```\nstatic inline void *push() \n{\n    id *dest;\n    if (slowpath(DebugPoolAllocation)) {\n        dest = autoreleaseNewPage(POOL_BOUNDARY); // 传入 POOL_BOUNDARY 来新建一个 AutoreleasePoolPage 对象\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY); // AutoreleasePoolPage 对象已经存在就直接添加\n    }\n    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n\n如果 page 不存在就调用 `autoreleaseNewPage()` 方法传入 `POOL_BOUNDARY` 创建：\n```\nstatic __attribute__((noinline))\nid *autoreleaseNewPage(id obj)\n{\n    AutoreleasePoolPage *page = hotPage(); // 获取当前 page\n    if (page) return autoreleaseFullPage(obj, page);\n    else return autoreleaseNoPage(obj);\n}\n\nstatic inline AutoreleasePoolPage *hotPage() \n{\n    AutoreleasePoolPage *result = (AutoreleasePoolPage *)\n        tls_get_direct(key);\n    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;\n    if (result) result->fastcheck();\n    return result;\n}\n\nstatic __attribute__((noinline))\nid *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)\n{\n    // The hot page is full. \n    // Step to the next non-full page, adding a new page if necessary.\n    // Then add the object to that page.\n    ASSERT(page == hotPage());\n    ASSERT(page->full()  ||  DebugPoolAllocation);\n\n    do {\n        if (page->child) page = page->child;\n        else page = new AutoreleasePoolPage(page);\n    } while (page->full());\n\n    setHotPage(page);\n    return page->add(obj); // 入栈 POOL_BOUNDARY\n}\n```\n\n如果 `AutoreleasePoolPage` 对象已经存在就直接调用 `autoreleaseFast()` 方法添加 `POOL_BOUNDARY`：\n```\nstatic inline id *autoreleaseFast(id obj)\n{\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) { // page 存在 && page 没有满\n        return page->add(obj); // 添加 obj\n    } else if (page) { // page 存在 && page 满了\n        return autoreleaseFullPage(obj, page);\n    } else { // page 不存在\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n#### - (id)autorelease\n```\n- (id)autorelease {\n    return _objc_rootAutorelease(self);\n}\n\nNEVER_INLINE id\n_objc_rootAutorelease(id obj)\n{\n    ASSERT(obj);\n    return obj->rootAutorelease();\n}\n\n__attribute__((noinline,used))\nid \nobjc_object::rootAutorelease2()\n{\n    ASSERT(!isTaggedPointer());\n    return AutoreleasePoolPage::autorelease((id)this); // 将当前对象 this 加入 page\n}\n```\n\n`autorelease((id)this)` 方法：\n```\nstatic inline id autorelease(id obj)\n{\n    ASSERT(obj);\n    ASSERT(!obj->isTaggedPointer());\n    id *dest __unused = autoreleaseFast(obj); // 添加 obj\n    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);\n    return obj;\n}\n```\n\n调用 `autoreleaseFast()` 方法添加 obj：\n```\nstatic inline id *autoreleaseFast(id obj)\n{\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) { // page 存在 && page 没有满\n        return page->add(obj); // 添加 obj\n    } else if (page) { // page 存在 && page 满了\n        return autoreleaseFullPage(obj, page);\n    } else { // page 不存在\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n`autorelease` 方法最终是通过调用 `autoreleaseFast()` 方法，将调用了 `autorelease` 方法的对象保存到了 page 中。\n\n#### objc_autoreleasePoolPop(void *ctxt)\n```\nNEVER_INLINE\nvoid\nobjc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n`pop()` 方法：\n```\nstatic inline void\npop(void *token)\n{\n    AutoreleasePoolPage *page;\n    id *stop;\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        page = hotPage(); // 从当前的 page 开始 pop\n        if (!page) {\n            // Pool was never used. Clear the placeholder.\n            return setHotPage(nil);\n        }\n        // Pool was used. Pop its contents normally.\n        // Pool pages remain allocated for re-use as usual.\n        page = coldPage();\n        token = page->begin();\n    } else {\n        page = pageForPointer(token);\n    }\n\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {\n        return popPageDebug(token, page, stop);\n    }\n\n    return popPage<false>(token, page, stop); // 释放对象\n}\n```\n\n`popPageDebug()` 方法：\n```\n__attribute__((noinline, cold))\nstatic void\npopPageDebug(void *token, AutoreleasePoolPage *page, id *stop)\n{\n    popPage<true>(token, page, stop);\n}\n```\n\n`popPage()` 方法：\n```\ntemplate<bool allowDebug>\nstatic void\npopPage(void *token, AutoreleasePoolPage *page, id *stop)\n{\n    if (allowDebug && PrintPoolHiwat) printHiwat();\n\n    page->releaseUntil(stop); // 释放 page 里的所有对象，知道遇到 stop 才停止\n\n    // memory: delete empty children\n    if (allowDebug && DebugPoolAllocation  &&  page->empty()) {\n        // special case: delete everything during page-per-pool debugging\n        AutoreleasePoolPage *parent = page->parent;\n        page->kill();\n        setHotPage(parent);\n    } else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {\n        // special case: delete everything for pop(top)\n        // when debugging missing autorelease pools\n        page->kill();\n        setHotPage(nil);\n    } else if (page->child) {\n        // hysteresis: keep one empty child if page is more than half full\n        if (page->lessThanHalfFull()) {\n            page->child->kill();\n        }\n        else if (page->child->child) {\n            page->child->child->kill();\n        }\n    }\n}\n```\n\n`releaseUntil()` 方法：\n```\nvoid releaseUntil(id *stop) \n{\n    while (this->next != stop) {\n        AutoreleasePoolPage *page = hotPage(); // 取出当前 page\n\n        while (page->empty()) {\n            page = page->parent;\n            setHotPage(page);\n        }\n\n        page->unprotect();\n        id obj = *--page->next; // 取出最后面的一个 obj\n        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));\n        page->protect();\n\n        if (obj != POOL_BOUNDARY) {\n            objc_release(obj); // 调用obj的release方法\n        }\n    }\n\n    setHotPage(this);\n}\n```\n\n`pop()` 方法最终是通过调用 `releaseUntil()` 方法，将 page 里的对象依次调用 `objc_release(obj)` 方法释放掉了。\n\n## autorelease 释放时机\n创建一个 iOS 项目，选择 MRC 环境，修改 main.m 文件（当前XCode版本11.6）。\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n        return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n    }\n}\n```\n\n定义 Person 类，添加打印：\n```\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [super dealloc];\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[[Person alloc] init] autorelease];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController viewDidLoad]\n-[ViewController viewWillAppear:]\n-[Person dealloc]\n-[ViewController viewDidAppear:]\n```\n\n从打印结果可以看到，person 对象是在 `viewWillAppear` 方法执行完成后被释放的。\n\n### Runloop和Autorelease\niOS 在主线程的 Runloop 中注册了两个 Observer：  \n第一个 Observer 监听了 `kCFRunLoopEntry` 事件，会调用 `objc_autoreleasePoolPush()`。  \n第二个 Observer 监听了 `kCFRunLoopBeforeWaiting` 事件，会调用 `objc_autoreleasePoolPop()`、`objc_autoreleasePoolPush()`，监听了 `kCFRunLoopBeforeExit` 事件，会调用 `objc_autoreleasePoolPop()`。\n\n打印当前的 RunLoop，查看 Observers：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[[Person alloc] init] autorelease];\n    NSLog(@\"%s\", __func__);\n    \n    NSLog(@\"%@\", [NSRunLoop currentRunLoop]);\n}\n@end\n```\n\n打印结果里有很多内容，这里是摘出来的跟 Autorelease 相关的两个 Observe：\n```\nobservers = (\n    \"<CFRunLoopObserver 0x6000009fc1e0 [0x7fff8062d750]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7fdaef00a048>\\n)}}\",\n\n    \"<CFRunLoopObserver 0x6000009fc280 [0x7fff8062d750]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7fdaef00a048>\\n)}}\"\n),\n```\n\n`_wrapRunLoopWithAutoreleasePoolHandler` 是回调方法，在收到消息时用来处理 Autorelease 相关操作。\n\n第一个 observe 的 `activities` 是 `0x1`，第二个 observe 的 `activities` 是 `0xa0`。\n\n`activities` 对应的枚举：\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),          // 1（十进制）\n    kCFRunLoopBeforeTimers = (1UL << 1),   // 2\n    kCFRunLoopBeforeSources = (1UL << 2),  // 4\n    kCFRunLoopBeforeWaiting = (1UL << 5),  // 32\n    kCFRunLoopAfterWaiting = (1UL << 6),   // 64\n    kCFRunLoopExit = (1UL << 7),           // 128\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n因为：  \n`0x1`（十六进制）-> 1（十进制） \n`0xa0`（十六进制）-> 160（十进制）  \n所以：    \n```\n0x1：kCFRunLoopEntry\n0xa0：kCFRunLoopAfterWaiting | kCFRunLoopExit\n```\n\n所以第一个 observe 监听的状态就是 `kCFRunLoopEntry`，第二个 observe 监听的状态就是 `kCFRunLoopAfterWaiting` 和 `kCFRunLoopExit`。 \n\n![内存管理20](内存管理/内存管理20.png)\n* 第一次循环：  \n  01 状态是 `kCFRunLoopEntry`，RunLoop 会调用 `objc_autoreleasePoolPush()` 方法；  \n  07 状态是 `kCFRunLoopAfterWaiting`，RunLoop 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法； \n* 非第一次循环：\n  10-1 回到 02 继续循环至 07；  \n  07 状态是 `kCFRunLoopAfterWaiting`，RunLoop 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法； \n  10-1 回到 02 继续循环至 07；  \n* 结束循环：\n  10-2 退出 RunLoop；  \n  11 状态是 `kCFRunLoopExit`，RunLoop 会调用 `objc_autoreleasePoolPop()` 方法。\n\n因为 02 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法，所以 `push()` 和 `pop()` 实现了一一对应的关系。\n\n在看打印结果：\n```\n-[ViewController viewDidLoad]\n-[ViewController viewWillAppear:]\n-[Person dealloc]\n-[ViewController viewDidAppear:]\n```\n\n在 `viewWillAppear` 执行完成后，RunLoop 到了 02 的位置。此时 RunLoop 监听到了 `kCFRunLoopAfterWaiting` 状态，会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法。在调用 `objc_autoreleasePoolPop()` 方法时，Autorelease 中的 person 对象就被释放了。\n\n另外，打印结果也说明了 `viewDidLoad` 和 `viewWillAppear` 方法是在同一个循环中执行的。\n\n### ARC环境下的release\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[Person alloc] init];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController viewDidLoad]\n-[Person dealloc]\n-[ViewController viewWillAppear:]\n-[ViewController viewDidAppear:]\n```\n\n从打印结果可以看到，person 对象在 `viewDidLoad` 方法执行完就释放了。所以在 ARC 环境下，在方法最后结束前，对方法内部的局部变量调用了 release 方法：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[Person alloc] init];\n    NSLog(@\"%s\", __func__);\n    \n    // [person release];\n}\n```\n\n# 总结\n* 使用 CADisplayLink、NSTimer 有什么注意点？\n  CADisplayLink 和 NSTimer 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 CADisplayLink 和 NSTimer 不准时。  \n  CADisplayLink 和 NSTimer 有可能会造成循环引用问题，CADisplayLink 可以通过使用代理对象（NSProxy）解决，NSTimer 除了可以通过使用代理对象（NSProxy）解决外，还可以使用带有 block 回调的初始化方法。  \n\n* 介绍下内存的几大区域\n  代码段：编译之后的代码  \n  数据段：字符串常量、已初始化数据和未初始化数据  \n  栈：函数调用开销，比如局部变量。（分配的内存空间地址越来越小）  \n  堆：通过 alloc、malloc、calloc 等动态分配的空间，分配的内存空间地址越来越大\n\n* 讲一下你对 iOS 内存管理的理解\n  在 iOS 中，使用引用计数来管理 OC 对象的内存。  \n  一个新创建的 OC 对象引用计数默认是1，当引用计数减为0，OC 对象就会销毁，释放其占用的内存空间。  \n  调用 retain 会让 OC 对象的引用计数+1，调用 release 会让 OC 对象的引用计数-1。  \n  内存管理的经验总结：  \n  当调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。  \n  想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1。  \n\n* ARC 都帮我们做了什么？(LLVM + Runtime)\n  ARC 是 LLVM 编译器和 Runtime 协作协作实现的。ARC 利用 LLVM 编译器自动生成 release、retain 和 autorelease 等内存管理相关的代码，利用 Runtime 实现在运行时对弱引用的管理（添加和清除）。\n\n* weak 指针的实现原理\n  将弱引用存储在一个弱引用表（哈希表）里面，在对象要销毁时，就以对象的地址值 & mask 得到一个索引取出对应的弱引用表，并把弱引用表里存储的弱引用都清除掉。\n\n* autorelease 对象在什么时机会被调用 release？  \n  autorelease 对象在什么时候调用 release 是由 RunLoop 控制的，在 RunLoop 监听到 `kCFRunLoopAfterWaiting` 或 `kCFRunLoopExit` 状态时会调用 `objc_autoreleasePoolPop()` 方法，此时 autorelease 对象会调用 release。即在 RunLoop 进入休眠或者退出时调用 release。\n\n* 方法里有局部对象， 出了方法后会立即释放吗?\n  会。在方法结束前，runtime 会自动为方法内部的局部对象调用 release 方法进行释放。\n\n相关阅读：  \n[深入理解 Tagged Pointer](https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/)\n\n\n\n","source":"_posts/OC底层原理/内存管理.md","raw":"---\ntitle: 内存管理\ndate: 2020-08-14 17:16:33\ntags: OC底层原理\n---\n\n思考：\n* 使用 CADisplayLink、NSTimer 有什么注意点？\n* 介绍下内存的几大区域\n* 讲一下你对 iOS 内存管理的理解\n* ARC 都帮我们做了什么？(LLVM + Runtime)\n* weak 指针的实现原理\n* autorelease 对象在什么时机会被调用 release\n* 方法里有局部对象， 出了方法后会立即释放吗?\n<!-- more -->\n\n# CADisplayLink、NSTimer 定时器\nCADisplayLink、NSTimer 会对 target 产生强引用，如果 target 又对它们产生强引用，那么就会引发循环引用。\n\n## 循环引用问题\n\n### CADisplayLink\nCADisplayLink 保证调用 `-(void)timerTest` 方法的频率和屏幕的刷新帧频率一致，60FPS。实际的调用频率可能不太一样，根据任务的耗时情况会有减少。\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n......\n```\n\n从打印结果可以看到，进入 TimerViewController 控制器后返回，会发现 TimerViewController 没有释放，CADisplayLink 定时器还在继续运行。\n\n### NSTimer\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n......\n```\n\n从打印结果可以看到，进入 TimerViewController 控制器后返回，会发现 TimerViewController 没有释放，NSTimer 定时器还在继续运行。\n\n### 问题分析\n![内存管理01](内存管理/内存管理01.png)\n\n## 解决方案\n\n### 方案一：使用 block\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        [weakSelf timerTest];\n    }];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n在使用 NSTimer 的时候，使用 block 的方式传入 weakSelf 可以有效解决循环引用的问题。并且以 scheduled 开头的方法会自动将 timer 添加到当前的 runloop 中并使用 default mode。\n```\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n```\n\ntarget 传入 weakSelf 并不能解决循环引用个问题，因为 NSTimer 内部对传入的 target 也是强引用的，而且 weakSelf 只是用来解决 block 循环引用问题的方案。\n```\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n```\n\nCADisplayLink 没有 block 相关的 API。\n\n### 方案二：使用中间对象\n![内存管理02](内存管理/内存管理02.png)\n\n定义中间对象：\n```\n@interface YQProxy : NSObject\n+ (instancetype)proxyWithTarget:(id)target;\n@property (nonatomic, weak) id target;\n@end\n\n@implementation YQProxy\n+ (instancetype)proxyWithTarget:(id)target\n{\n    YQProxy *proxy = [[YQProxy alloc] init];\n    proxy.target = target;\n    return proxy;\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    return self.target;\n}\n@end\n```\n\n#### NSTimer\n```\n@interface TimerViewController ()\n//@property (nonatomic, strong) CADisplayLink *link;\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[YQProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n#### CADisplayLink\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.link = [CADisplayLink displayLinkWithTarget:[YQProxy proxyWithTarget:self] selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n@end\n```\n\n打印结果：\n```\n......\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n传给定时器的 target 是 YQProxy 对象，在 YQProxy 对象尝试调用 `-(void)timerTest` 方法时，发现没有实现后会调用 `- (id)forwardingTargetForSelector:(SEL)aSelector` 方法走消息转发的逻辑，在该方法内部返回已经实现了 `-(void)timerTest` 方法的对象，就可以正常实现 timer 定时器调用 `-(void)timerTest` 方法的逻辑了。 \n\n因为 YQProxy 对象没有实现 `-(void)timerTest` 方法，所以需要添加消息转发逻辑。如果 YQProxy 中没有添加消息转发的逻辑会出现如下报错：\n![内存管理03](内存管理/内存管理03.png) \n\nYQProxy 会在其类对象以及父类的类对象里查找 `-(void)timerTest` 方法，查找了一圈后发现找不到，就会抛出错误。\n\n## 使用代理对象（NSProxy）\n\n定义 YQTimerProxy 继承自 NSProxy：\n```\n@interface YQTimerProxy : NSProxy\n+ (instancetype)proxyWithTarget:(id)target;\n@property (nonatomic, weak) id target;\n@end\n\n@implementation YQTimerProxy\n+ (instancetype)proxyWithTarget:(id)target\n{\n    YQTimerProxy *proxy = [YQTimerProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel\n{\n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation\n{\n    [invocation invokeWithTarget:self.target];\n}\n@end\n```\n\nNSProxy 对象没有 `-(instancetype)init` 方法，直接 alloc 就可以了。\n\n### NSTimer\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0\n                                                  target:[YQTimerProxy proxyWithTarget:self]\n                                                selector:@selector(timerTest)\n                                                userInfo:nil\n                                                 repeats:YES];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.timer invalidate];\n}\n@end\n```\n\n打印结果：\n```\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController timerTest]\n-[TimerViewController dealloc]\n```\n\n### CADisplayLink\n```\n@interface TimerViewController ()\n@property (nonatomic, strong) CADisplayLink *link;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.link = [CADisplayLink displayLinkWithTarget:[YQTimerProxy proxyWithTarget:self] selector:@selector(timerTest)];\n    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [self.link invalidate];\n}\n\n@end\n```\n\n传给定时器的 target 是 YQTimerProxy 对象，YQTimerProxy 对象不会尝试调用 `-(void)timerTest` 方法，而是直接走消息转发逻辑，在对应的消息转发的方法里返回已经实现了 `-(void)timerTest` 方法的对象，就可以正常实现 timer 定时器调用 `-(void)timerTest` 方法的逻辑了。\n\n因为 YQTimerProxy 对象不会尝试调用 `-(void)timerTest` 方法，而是直接调用 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法，所以需要添加消息转发逻辑。如果 YQTimerProxy 中没有添加消息转发的逻辑会出现如下报错：\n![内存管理04](内存管理/内存管理04.png) \n\n可以看到 YQTimerProxy 没有去查找 `-(void)timerTest` 方法，而是直接查找的 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法。这一点可以通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看 NSProxy 的源码找到原因。NSProxy 内部的方法的实现都是直接调用的 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法，因此 NSProxy 作为代理对象效率更高。\n\n## NSProxy\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    YQProxy *proxy1 = [YQProxy proxyWithTarget:self];\n    YQTimerProxy *proxy2 = [YQTimerProxy proxyWithTarget:self];\n    NSLog(@\"%d %d\", [proxy1 isKindOfClass:[ViewController class]], [proxy2 isKindOfClass:[ViewController class]]);\n}\n@end\n```\n\n打印结果：\n```\n0 1\n```\n\n从打印结果可以看到，YQProxy 的实例对象和 YQTimerProxy 的实列对象在判断是否是 ViewController 的对象类型的时候结果不同。这是因为 YQTimerProxy 继承自 NSProxy，NSProxy 的 `-(BOOL) isKindOfClass:(Class)aClass` 方法的实现与普通的 OC 对象同。通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看 NSProxy 的源码：\n```\n- (BOOL)isKindOfClass:(Class)aClass\n{\n    NSMethodSignature\t*sig;\n    NSInvocation\t\t*inv;\n    BOOL\t\t\tret;\n\n    sig = [self methodSignatureForSelector: _cmd];\n    inv = [NSInvocation invocationWithMethodSignature: sig];\n    [inv setSelector: _cmd];\n    [inv setArgument: &aClass atIndex: 2];\n    [self forwardInvocation: inv];\n    [inv getReturnValue: &ret];\n    return ret;\n}\n```\n\n可以看到，NSProxy 的 `-(BOOL)isKindOfClass:(Class)aClass` 方法内部直接调用了 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel` 方法。\n\n普通 OC 对象的 `-(BOOL)isKindOfClass:(Class)aClass` 方法实现 [objc4-781](https://opensource.apple.com/tarballs/objc4/) ：\n```\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n# GCD 定时器\nCADisplayLink 和 NSTimer 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 CADisplayLink 和 NSTimer 不准时。GCD 的定时器会更加准时。\n\n## block 回调：\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@\"GCD timer\");\n    });\n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n@end\n```\n\n打印结果：\n```\n18:16:38.889349+0800 内存管理-定时器[15880:352867] -[ViewController viewDidLoad]\n18:16:40.889609+0800 内存管理-定时器[15880:352867] GCD timer\n18:16:41.889685+0800 内存管理-定时器[15880:352867] GCD timer\n18:16:42.889624+0800 内存管理-定时器[15880:352867] GCD timer\n......\n```\n\n## 函数回调：\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler_f(timer, timerFire);\n    \n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n\nvoid timerFire(void *param)\n{\n    NSLog(@\"GCD timer - %@\", [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n20:37:01.629410+0800 内存管理-定时器[1363:25276] -[ViewController viewDidLoad]\n20:37:03.629774+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n20:37:04.629784+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n20:37:05.629800+0800 内存管理-定时器[1363:25276] GCD timer - <NSThread: 0x600001b70d40>{number = 1, name = main}\n......\n```\n\n## 自定义队列\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    // 自定义队列\n    dispatch_queue_t queue = dispatch_queue_create(\"GCDTimer\", NULL);\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间（定时器，延迟执行时间，执行时间间隔，误差）\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler_f(timer, timerFire);\n    // 启动定时器\n    dispatch_resume(timer);\n    self.timer = timer;\n}\n\nvoid timerFire(void *param)\n{\n    NSLog(@\"GCD timer - %@\", [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n20:39:58.857389+0800 内存管理-定时器[1460:28690] -[ViewController viewDidLoad]\n20:40:00.857845+0800 内存管理-定时器[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}\n20:40:01.857692+0800 内存管理-定时器[1460:28835] GCD timer - <NSThread: 0x6000021272c0>{number = 6, name = (null)}\n20:40:02.857792+0800 内存管理-定时器[1460:28836] GCD timer - <NSThread: 0x600002119280>{number = 5, name = (null)}\n......\n```\n\n## 封装 GCD\n\n```\n@interface YQGCDTimer : NSObject\n/**\nblock 回调\n*/\n+ (NSString *)execTask:(void(^)(void))task\n                 start:(NSTimeInterval)start\n              interval:(NSTimeInterval)interval\n               repeats:(BOOL)repeats\n                 async:(BOOL)async;\n/**\n函数回调\n*/\n+ (NSString *)execTaskWithTarget:(id)target\n                        selector:(SEL)selector\n                           start:(NSTimeInterval)start\n                        interval:(NSTimeInterval)interval\n                         repeats:(BOOL)repeats\n                           async:(BOOL)async;\n/**\n取消\n*/\n+ (void)cancelTask:(NSString *)name;\n@end\n\n\nNSInteger index_;\nstatic NSMutableDictionary *timers_;\ndispatch_semaphore_t semaphore_;\n\n@implementation YQGCDTimer\n\n+ (void)initialize\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        timers_ = [NSMutableDictionary dictionary];\n        semaphore_ = dispatch_semaphore_create(1);\n        index_ = 0;\n    });\n}\n\n+ (NSString *)execTask:(void (^)(void))task start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    if (!task || start < 0 || (interval <= 0 && repeats)) return nil;\n    // 队列（全局串行队列或主队列）\n    dispatch_queue_t queue = async ? dispatch_get_global_queue(0, 0) : dispatch_get_main_queue();\n    // 创建定时器\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    // 设置时间\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);\n    // 回调\n    dispatch_source_set_event_handler(timer, ^{\n        task();\n        // 不需要重复任务\n        if (!repeats) {\n            dispatch_source_cancel(timer);\n        }\n    });\n    // 加锁\n    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);\n    // 定时器唯一标识\n    NSString *identify = [NSString stringWithFormat:@\"%ld\", (long)index_++];\n    // 保存\n    timers_[identify] = timer;\n    // 解锁\n    dispatch_semaphore_signal(semaphore_);\n    // 启动定时器\n    dispatch_resume(timer);\n    return identify;\n}\n\n+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    return [self execTask:^{\n        if ([target respondsToSelector:selector]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n            [target performSelector:selector];\n#pragma clang diagnostic pop\n        }\n    } start:start interval:interval repeats:repeats async:async];\n}\n\n+ (void)cancelTask:(NSString *)name\n{\n    if (name.length == 0) return;\n    // 加锁\n    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);\n    dispatch_source_t timer = timers_[name];\n    if (timer) {\n        dispatch_source_cancel(timer);\n        [timers_ removeObjectForKey:name];\n    }\n    // 解锁\n    dispatch_semaphore_signal(semaphore_);\n}\n@end\n```\n\n调用 block 回调方法：\n```\n@interface TimerViewController ()\n@property (nonatomic, copy) NSString *task;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    self.task = [YQGCDTimer execTask:^{\n        NSLog(@\"GCD timer\");\n    } start:2 interval:1 repeats:YES async:NO];\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [YQGCDTimer cancelTask:self.task];\n}\n@end\n```\n\n调用函数回调方法：\n```\n@interface TimerViewController ()\n@property (nonatomic, copy) NSString *task;\n@end\n\n@implementation TimerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%s\", __func__);\n    self.task = [YQGCDTimer execTaskWithTarget:self selector:@selector(timerTest) start:2 interval:1 repeats:YES async:NO];\n}\n\n- (void)timerTest\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    [YQGCDTimer cancelTask:self.task];\n}\n@end\n```\n\n打印结果：\n```\n21:18:01.050592+0800 内存管理-定时器[2321:52592] -[TimerViewController viewDidLoad]\n21:18:03.050800+0800 内存管理-定时器[2321:52592] GCD timer\n21:18:04.050986+0800 内存管理-定时器[2321:52592] GCD timer\n21:18:05.050943+0800 内存管理-定时器[2321:52592] GCD timer\n```\n\n去掉警告：\n```\n+ (NSString *)execTaskWithTarget:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async\n{\n    return [self execTask:^{\n        if ([target respondsToSelector:selector]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n            [target performSelector:selector];\n#pragma clang diagnostic pop\n        }\n    } start:start interval:interval repeats:repeats async:async];\n}\n```\n\n`\"-Warc-performSelector-leaks\"` 可以在这里找到：\n![内存管理05](内存管理/内存管理05.png) \n\n# iOS程序的内存布局\n* 代码段：编译之后的代码\n* 数据段：字符串常量、已初始化数据和未初始化数据\n* 栈：函数调用开销，比如局部变量。（分配的内存空间地址越来越小）\n* 堆：通过 alloc、malloc、calloc 等动态分配的空间，分配的内存空间地址越来越大\n![内存管理06](内存管理/内存管理06.png) \n\n```\n// 已初始化的全局变量\nint a = 10;\n// 未初始化的全局变量\nint b;\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        // 已初始化的静态变量\n        static int c = 20;\n        // 未初始化的静态变量\n        static int d;\n        // 栈\n        int e;\n        int f = 20;\n        // 字符串常量\n        NSString *str = @\"123\";\n        // 堆\n        NSObject *obj = [[NSObject alloc] init];\n        \n        NSLog(@\"\\n&a=%p\\n&b=%p\\n&c=%p\\n&d=%p\\n&e=%p\\n&f=%p\\nstr=%p\\nobj1=%p\\nobj2=%p\\n\",\n              &a, &b, &c, &d, &e, &f, str, obj1, obj2);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n打印结果：\n```\n&a=0x105bbee38\n&b=0x105bbef04\n&c=0x105bbee3c\n&d=0x105bbef00\n&e=0x7ffeea042c2c\n&f=0x7ffeea042c28\nstr=0x105bbe070\nobj1=0x600002528110\nobj2=0x600002528120\n```\n\n打印结果解析（内地地址从小到大排序）：\n```\n// 字符串常量\nstr=0x105bbe070\n\n// 已初始化的全局变量、静态变量\n&a=0x105bbee38\n&c=0x105bbee3c\n\n// 未初始化的全局变量、静态变量\n&d=0x105bbef00\n&b=0x105bbef04\n\n// 堆\nobj1=0x600002528110\nobj2=0x600002528120\n\n// 栈\n&f=0x7ffeea042c28\n&e=0x7ffeea042c2c\n```\n\n内存地址大小比较：\n```\nstr < a < c < d < b < obj1 < obj2 < f < e \n```\n\n数据段：str < a < c < d < b，空间地址越来越大。   \n堆区：obj1 比 b 多了3位数，这3位数的空间都属于数据段。obj1 的内存地址首位数字为6，obj1 < obj2，分配的内存空间越来越大（越来越逼近栈区）。  \n栈区：e 的内存地址首位数字为7，f < e，分配的内存空间越来越小（越来越逼近堆区）。  \n\n# Tagged Pointer\n\n* 从64bit开始，iOS 引入了 Tagged Pointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储。\n* 在没有使用 Tagged Pointer 之前，NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 等对象的指针存储的是堆中 NSNumber 对象的地址值。\n* 使用 Tagged Pointer 之后，NSNumber 指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。\n* 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。\n* `objc_msgSend()` 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据，节省了以前的调用开销。\n* 如何判断一个指针是否为Tagged Pointer？  \n  iOS平台，最高有效位是1（第64bit）  \n  Mac平台，最低有效位是1  \n\n## NSNumber\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        \n        NSNumber *number1 = @4;\n        NSNumber *number2 = @5;\n        NSNumber *number3 = @(0xFFFFFFFFFFFFFFFF);\n        NSLog(@\"%p %p %p\", number1, number2, number3);\n        \n        int a = [number1 intValue];\n\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n0xb0d1e4bcdb858740 0xb0d1e4bcdb858750 0x600000b4c080\n```\n\n`0xb0d1e4bcdb858740` 和 `0xb0d1e4bcdb858750` 去掉前面相同的部分后是 `0x40` 和 `0x50`，可以看出数据直接存储在了指针中。当指针不够存储数据时，如 `@(0xFFFFFFFFFFFFFFFF)` 打印出来的内存地址是 `0x600000b4c080`（堆空间里 NSNumber 对象的地址值），是使用了动态分配内存的方式来存储数据。\n\n因为 `objc_msgSend()` 能识别 Tagged Pointer，所以在 number1 调用 `intValue` 方法时，`objc_msgSend()` 直接从指针提取数据。\n```\nint a = [number1 intValue];\n```\n\n可以看出 Tagged Pointer 技术不仅仅是内存空间的优化，也对使用过程进行了优化。\n\n## NSString\n\n### 例一：\n```\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            self.name = [NSString stringWithFormat:@\"abcdefghijk\"];\n        });\n    }\n}\n@end\n```\n\n运行后报错（坏内存访问）：\n![内存管理07](内存管理/内存管理07.png)\n\n因为 `name` 是非原子性（`nonatomic`）的，多条线程同时访问 `name` 的 set 方法时，如果有一条线程已经将 `_name` 释放了，其它线程再次对 `_name` 进行释放操作就会出现坏内存访问的错误：\n```\n- (void)setName:(NSString *)name\n{\n    if (_name != name) {\n        [_name release]; // 多条线程同时操作这一行，如果 `_name` 已经被释放了，其它线程再次对 `_name` 进行 release 操作，坏内存访问\n        _name = [name copy];\n    }\n}\n```\n\n#### 解决方案一：\n将 `name` 改成原子性的：\n```\n@property (atomic, copy) NSString *name;\n```\n\n程序运行正常。\n\n将 `name` 改成原子性后，`name` 的 set 方法就是线程安全的了，不会出现多条线程同时对 `name` 进行 release 操作。\n\n#### 解决方案二：\n将 `name` 改成原子性后，任何地方、任何时候调用 `name` 的 get 方法都是有锁的。因为 `name` 只需要在异步线程访问时加锁，如果在主线程的话没有必要加锁，所以不使用 `atomic` 而是选择手动加锁，哪里需要就在哪里加锁，尽可能的提升效率节省资源：\n```\n/// 加锁\n#define SemaphoreBegin \\\nstatic dispatch_semaphore_t semaphore; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    semaphore = dispatch_semaphore_create(1); \\\n}); \\\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n/// 解锁\n#define SemaphoreEnd \\\ndispatch_semaphore_signal(semaphore);\n\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            // 加锁\n            SemaphoreBegin;\n            self.name = [NSString stringWithFormat:@\"abcdefghijk\"];\n            // 解锁\n            SemaphoreEnd;\n        });\n    }\n}\n@end\n```\n\n程序运行正常。\n\n### 例二：  \n将 `@\"abcdefghijk\"` 改成 `@\"abc\"`：\n```\n@interface ViewController ()\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    for (int i=0; i<1000; i++) {\n        dispatch_async(queue, ^{\n            self.name = [NSString stringWithFormat:@\"abc\"];\n        });\n    }\n}\n@end\n```\n\n运行正常。  \n\n同样是多线程访问、没有加锁，但是将 `@\"abcdefghijk\"` 改成 `@\"abc\"` 后，就不会出现坏内存访问的错误，难道是没有调用 `name` 的 set 方法吗？是的。\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str1 = [NSString stringWithFormat:@\"abcdefghijk\"];\n    NSString *str2 = [NSString stringWithFormat:@\"abc\"];\n    NSLog(@\"%p %p\", str1, str2);\n    NSLog(@\"%@ %@\", [str1 class], [str2 class]);\n}\n@end\n```\n\n打印结果：\n```\n0x600002aefdc0 0x9cedd15798132057\n__NSCFString NSTaggedPointerString\n```\n\nstr1 是一个 `__NSCFString`，其内存地址是6开头的，说明 str1 是存储在堆空间里的。  \nstr2 是一个 `NSTaggedPointerString`，`@\"abc\"` 存储在 str2 指针里，不会调用 set 方法，取值时也不会调用 get 方法而是直接从指针里取值。\n\n## 判断是否是 Tagged Pointer\n\n[objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 objc-internal.h 文件里：\n\n`_OBJC_TAG_MASK` 定义：\n```\n#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__\n    // 64-bit Mac - tag bit is LSB\n#   define OBJC_MSB_TAGGED_POINTERS 0 // Mac\n#else\n    // Everything else - tag bit is MSB\n#   define OBJC_MSB_TAGGED_POINTERS 1 // iPhone（真机/模拟器）\n#endif\n\n#if OBJC_MSB_TAGGED_POINTERS\n#   define _OBJC_TAG_MASK (1UL<<63) \n#else\n#   define _OBJC_TAG_MASK 1UL \n#endif\n```\n\n判断是否是 tagged pointer：\n```\nstatic inline bool \n_objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\n```\n\n如果是 mac，`_OBJC_TAG_MASK` 等于1。如果不是 mac， `_OBJC_TAG_MASK` 等于 1UL<<63。`_OBJC_TAG_MASK` 和指针地址进行与运算，判断结果是否是 `_OBJC_TAG_MASK`，如果是的话，那这个指针就是 tagged pointer。  \n在 iOS 平台，如果指针转成2进制后它的最高位（64位）为1的话，那么这个指针就是 tagged pointer。  \n在 Mac 平台，如果指针转成2进制后它的最低位为1的话，那么这个指针就是 tagged pointer。\n\n# MRC\n* 在 iOS 中，使用引用计数来管理 OC 对象的内存。  \n* 一个新创建的 OC 对象引用计数默认是1，当引用计数减为0，OC 对象就会销毁，释放其占用的内存空间。  \n* 调用 retain 会让 OC 对象的引用计数+1，调用 release 会让 OC 对象的引用计数-1。  \n* 内存管理的经验总结：  \n  当调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。  \n  想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1。  \n* 可以通过以下私有函数来查看自动释放池的情况  \n  ```\n  extern void _objc_autoreleasePoolPrint(void);\n  ```\n\n👉 使用 MRC：Build Setting -> Objective-C Automatic Referencd Counting 设置为 YES。\n\n定义 Person 类：\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n## release\n\n创建 person 对象：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init]; // Person *person = [Person new];\n        NSLog(@\"%zd\", person.retainCount);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n 1\n```\n\n从打印结果可以看到，person 对象调用完 `alloc` 方法后引用计数是1，没有被释放。\n\n添加 release：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        \n        // 使用 person 对象\n        NSLog(@\"%zd\", person.retainCount);\n\n        [person release];\n        NSLog(@\"111\");\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n 1\n -[Person dealloc]\n 111\n```\n\n从打印结果可以看到，因为 person 对象调用完 `alloc` 方法后引用计数是1，调用完 `release` 方法后引用计数减1等于0，所以 person 对象在调用 `release` 的那一刻就被释放了。\n\nMRC 下 `alloc` 方法和 `release` 方法是一一对应的，每个对象使用完成后都要调用一下 `release` 方法，这样才能避免内存泄漏。另外，在使用 `release` 方法管理 person 对象时，要保证在调用 `release` 方法之前使用 person 对象。\n\n## autorelease\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[[Person alloc] init] autorelease];\n        NSLog(@\"%zd\", person.retainCount);\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n1\n111\n-[Person dealloc]\n222\n```\n\n从打印结果可以看到，因为 person 对象调用完 `alloc` 方法又调用了 `autorelease` 后引用计数是1，直到 `@autoreleasepool {}` 执行完那一刻才被释放。  \n\n在 `@autoreleasepool {}` 执行完那一刻，会对调用了 `autorelease` 方法的对象进行 `release` 操作：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n        NSLog(@\"111\");\n    } // [person release]、[person release]\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n-[Person dealloc]\n222\n```\n\n使用 `autorelease` 方法管理 person 对象的内存，只需要在调用 `alloc` 方法的同时调用一下 `autorelease` 方法，就可以放心的使用 person 对象了，当然是在 `@autoreleasepool {}` 内部使用。不用再关心 person 对象的释放问题，在 `@autoreleasepool {}` 执行完那一刻，person 对象会自动调用 `release` 方法。\n\n## retain\n\n错误演示：\n```\n// Dog\n@interface Dog : NSObject\n- (void)run;\n@end\n\n@implementation Dog\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n// Person\n@interface Person : NSObject\n{\n    Dog *_dog;\n}\n- (void)setDog:(Dog *)dog;\n- (Dog *)dog;\n@end\n\n@implementation Person\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    _dog = dog;\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n\n// 调用\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // 引用计数：1\n        Person *person = [[Person alloc] init];\n        [person setDog:dog];\n        \n        [dog release]; // 引用计数：0\n        \n        [[person dog] run];\n        \n        [person release];\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印信息：\n```\n -[Dog dealloc]\n```\n\n`[[person dog] run]` 这个时候 dog 对象因为引用计数为0已经被释放了。\n![内存管理08](内存管理/内存管理08.png)\n\n`[person setDog:dog]` 方法表示 person 对象想要用于 dog 对象，那么 person 对象应该对 dog 的引用计数加1，只要 person 对象还在，dog 对象就不可以被释放。\n\n上面的写法有两个地方需要优化：  \n1、Person 类的 `- (void)setDog:(Dog *)dog` 方法在获取 dog 对象时，引用计数需要加1。  \n2、Person 类的 `- (void)dealloc` 方法需要对 dog 对象进行 `release` 操作。  \n\nPerson 类优化后：\n```\n@implementation Person\n- (void)dealloc\n{\n    [_dog release];\n    _dog = nil;\n    \n    [super dealloc]; // 父类的 dealloc 放到子类后\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    _dog = [dog retain];\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog run]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n创建两个 person 对象引用 dog 对象：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // dog 引用计数：1\n        \n        Person *person1 = [[Person alloc] init];\n        [person1 setDog:dog]; // dog 引用计数：2\n        \n        Person *person2 = [[Person alloc] init];\n        [person2 setDog:dog]; // dog 引用计数：3\n        \n        [dog release]; // dog 引用计数：2\n        \n        [person1 release]; // dog 引用计数：1\n        \n        [[person2 dog] run];\n        \n        [person2 release]; // dog 引用计数：0\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Person dealloc]\n-[Dog run]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n## set 方法\n\n上面 Person 类里的 set 方法还有问题，在 person 对象替换 dog 对象时会出现不释放的问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog1 = [[Dog alloc] init]; // dog1 : 1\n        Dog *dog2 = [[Dog alloc] init]; // dog2 : 1\n        Person *person = [[Person alloc] init];\n        \n        [person setDog:dog1]; // dog1 : 2\n        [person setDog:dog2]; // dog2 : 2\n        \n        [dog1 release]; // dog1 : 1\n        [dog2 release]; // dog2 : 1\n        [person release]; // dog0 : 0\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n从打印结果和注释可以看到，dog1 最后的引用计数是1，没有释放。这是因为 person 对象在拥有 dog1 时，将 `_dog` 指向了 dog1 并对其引用计数加1，后又将 `_dog` 指向了 dog2 并对其引用计数加1，所以 person 对象在调用 `[_dog release]` 时的 `_dog` 是 dog2 对象，dog1 对象因此少调用了一次 release 方法，最后的引用计数最后为1无法释放。\n\n优化 set 方法：在 person 对象引用新的 dog 对象时，需要先将之前的 dog 对象进行 release 操作。\n```\n@implementation Person\n- (void)dealloc\n{\n    [_dog release];\n    _dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    [_dog release];\n    _dog = [dog retain];\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n从打印结果可以看到，dog1 和 dog2 对象都被释放调用。但是优化后的 set 方法还不够完善，person 对象在重复设置同一个 dog 对象的时候还是有问题：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init]; // dog1 : 1\n        Person *person = [[Person alloc] init];\n        \n        [person setDog:dog]; // dog1 : 2\n        \n        [dog release]; // dog1 : 1\n        \n        [person setDog:dog]; // dog1 : 0\n        \n        [person release];\n        \n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n错误信息：\n![内存管理09](内存管理/内存管理09.png)\n\n问题出在 Person 类的 set 方法：  \n第一次赋值，dog 对象的引用计数加一，此时 dog 对象的引用计数等于2。  \ndog 对象调用了一次 release 方法，此时 dog 对象的引用计数等于1。  \n第二次赋值，会先调用 `[_dog release]`, 此时 dog 对象的引用计数等于0，dog 对象被释放。再调用 `_dog = [dog retain]`，此时 dog 指向的内存已经被销毁了：\n```\n- (void)setDog:(Dog *)dog\n{\n    [_dog release]; // dog : 0\n    _dog = [dog retain]; // dog 指向的内存已经被销毁\n}\n```\n\n因此，在 set 方法里对 `_dog` 处理前，需要先判断一下 `_dog` 是否等于传入的 dog 对象。因为一个 person 对象在拥有一个 dog 对象时只需要对其 retain 一次，所以如果 `_dog == dog` 就不做处理。\n\n优化 Person 类里的 set 方法：\n```\n@implementation Person\n- (void)dealloc\n{\n    self.dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)setDog:(Dog *)dog\n{\n    if (_dog != dog) {\n        [_dog release];\n        _dog = [dog retain];\n    }\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n打印结果：\n```\n-[Dog dealloc]\n-[Person dealloc]\n111\n222\n```\n\n## property 属性\n\n在 .h 文件通过 property 声明的属性，编译器会自动生成成员变量和属性的 setter、getter 实现。\n\n## 基本数据类型\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@end\n```\n\n编译器自动生成：\n```\n@implementation Person\n\n@synthesize age = _age;\n\n- (void)setAge:(int)age\n{\n    _age = age;\n}\n\n- (int)age\n{\n    return _age;\n}\n@end\n```\n\n## 对象类型\n```\n@interface Person : NSObject\n@property (nonatomic, retain) Dog *dog;\n@end\n```\n\n编译器自动生成：\n```\n@implementation Person\n\n@synthesize dog = _dog;\n\n- (void)setDog:(Dog *)dog\n{\n    if (_dog != dog) {\n        [_dog release];\n        _dog = [dog retain];\n    }\n}\n\n- (Dog *)dog\n{\n    return _dog;\n}\n@end\n```\n\n如果是在 MRC 环境下，这种情况下还需要在 delloc 方法里手动调用 _dog 的 release 方法：\n```\n@implementation Person\n- (void)dealloc\n{\n    self.dog = nil;\n    \n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n## 常用代码解析\n\n创建一个 iOS 项目，设置 MRC 环境。\n\n```\n@interface ViewController ()\n@property (nonatomic, retain) NSMutableArray *data;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableArray *data = [[NSMutableArray alloc] init];\n    self.data = data;\n    [data release];\n}\n\n- (void)dealloc\n{\n    self.data = nil;\n    \n    [super dealloc];\n}\n@end\n```\n\n简化：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [[NSMutableArray alloc] init];\n    [self.data release];\n}\n```\n\n`autorelease`：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [[[NSMutableArray alloc] init] autorelease];\n}\n```\n\n`+array`：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.data = [NSMutableArray array];\n}\n```\n\n不是通过 `alloc` 方法初始化的，而是通过类方法初始化的，在类方法内部已经调用过 `autorelease` 了。类方法 `+array` 大概是这样：\n```\n@implementation NSMutableArray\n+ (instancetype)array\n{\n    return [[[NSMutableArray alloc] init] autorelease];\n}\n@end\n```\n\n## 工厂方法\n```\n@interface Person : NSObject\n+ (instancetype)person;\n@end\n\n@implementation Person\n+ (instancetype)person\n{\n    return [[[Person alloc] init] autorelease];\n}\n\n- (void)dealloc\n{\n    [super dealloc];\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Person *person = [Person person];\n        NSLog(@\"111\");\n    }\n    NSLog(@\"222\");\n    return 0;\n}\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n```\n\n# copy和mutableCopy\n\n* 拷贝的目的：产生一个副本对象，跟原对象互不影响  \n  修改了原对象，不会影响副本对象  \n  修改了副本对象，不会影响原对象  \n\n* iOS 提供了两个拷贝方法  \n  1、copy，不可变拷贝，产生不可变副本  \n  2、mutableCopy，可变拷贝，产生可变副本  \n\n## 拷贝\n### NSString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [NSString stringWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy]; // 返回的是 NSString\n        NSMutableString *str3 = [str1 mutableCopy]; // 返回的是 NSMutableString\n\n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%d %d %d\",\n              [str1 isKindOfClass:[NSMutableString class]],\n              [str2 isKindOfClass:[NSMutableString class]],\n              [str3 isKindOfClass:[NSMutableString class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0 0 1\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是 str1 和 str2 是不可变字符串，str3 是可变字符串。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\n### NSMutableString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableString *str1 = [NSMutableString stringWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy];\n        NSMutableString *str3 = [str1 mutableCopy];\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%d %d %d\",\n              [str1 isKindOfClass:[NSMutableString class]],\n              [str2 isKindOfClass:[NSMutableString class]],\n              [str3 isKindOfClass:[NSMutableString class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n1 0 1\n```\n\n不管是可变字符串还是不可变字符串，调用 `copy` 返回的都是不可变字符串，调用 `mutableCopy` 返回的都是可变字符串。\n\n### 内存管理\n在 MRC 环境下，调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2 = [str1 copy];\n        NSMutableString *str3 = [str1 mutableCopy];\n\n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n## 深拷贝和浅拷贝\n\n* 深拷贝：内容拷贝，产生新的对象\n* 浅拷贝：指针拷贝，没有产生新的对象\n\n### NSString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str2 = [str1 copy]; // 浅拷贝：指针拷贝，没有产生新对象\n        NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝：内容拷贝，又产生新对象\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%p %p %p\", str1, str2, str3);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0x100001018 0x100001018 0x1007bb4e0\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是 str1 和 str2 指向的是同一个内存地址，str3 指向的是另一个内存地址。即 str1 通过 `copy` 方法拷贝出来的副本 str2 还是原对象（str1），而 str1 通过 `mutableCopy` 方法拷贝出来的副本 str3 是一个新的对象。\n![内存管理10](内存管理/内存管理10.png)\n\n👉 拷贝的目的：产生一个副本对象，跟原对象互不影响。  \nstr1 是一个不可变字符串对象，通过 `copy` 方法拷贝出来的副本也是不可变字符串对象。因为不可变字符串对象不可以被修改，不可以被修改就不会互相影响，所以 str1 和 str2 指向同一个对象满足拷贝的原则（互不影响）。而且将 str1 和 str2 指向同一个对象还节省了内存。  \nstr1 是一个不可变字符串对象，通过 `mutableCopy` 方法拷贝出来的副本是可变字符串对象。因为可变字符串对象可以被修改，所以 str3 指向的是一个新的对象，保证在修改 str3 时不会影响到 str1。  \n\n（总的来看，既要保证互不影响，也要做到节省资源）\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str3 = [str2 copy];\n        NSString *str4 = @\"test\";\n        NSMutableString *str5 = [str1 mutableCopy];\n        \n        NSLog(@\"%@ %@ %@ %@ %@ %@\", @\"test\", str1, str2, str3, str4, str5);\n        NSLog(@\"%p %p %p %p %p %p\", @\"test\", str1, str2, str3, str4, str5);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test test test test\n0x100002040 0x100002040 0x100002040 0x100002040 0x100002040 0x1006bd980\n```\n\nstr1、str2、str3 和 str4 都是 `@\"test\"` 对象。\n\n引用计数：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test111111111\"]; // str1 : 1\n        NSString *str2 = [str1 copy]; // str1 : 2\n        NSMutableString *str3 = [str1 mutableCopy];\n        \n        NSLog(@\"%zd\", str1.retainCount);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n2\n```\n\n从打印结果可以看到，str1 在调用 `copy` 方法后，引用计数加1，相当于调用了一次 `retain` 方法。\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = [[NSString alloc] initWithFormat:@\"test111111111\"];\n        NSString *str2 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str3 = [[NSString alloc] initWithString:@\"test\"];\n        \n        NSLog(@\"%@ %@ %@\", [str1 class], [str2 class], [str3 class]);\n        NSLog(@\"%zd %zd %zd\", str1.retainCount, str2.retainCount, str3.retainCount);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n__NSCFString NSTaggedPointerString __NSCFConstantString\n1 -1 -1\n```\n\n使用 `initWithFormat:` 方法初始化字符串，字符串长度足够长，创建出来的是 `__NSCFString` 类型的字符串。`__NSCFString` 类型的字符串是通过引用计数管理内存的。  \n使用 `initWithFormat:` 方法初始化字符串，字符串长度不够长，创建出来的是 `NSTaggedPointerString` 类型的字符串。`NSTaggedPointerString` 类型的字符串不是通过引用计数管理内存的。  \n使用 `initWithString:` 方法初始化字符串，不管字符串长度，创建出来的是 `__NSCFConstantString` 类型的字符串。`__NSCFConstantString` 类型的字符串不是通过引用计数管理内存的。\n\nps：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *str1 = @\"test\";\n        NSString *str1_1 = @\"test\";\n        \n        NSString *str2 = [[NSString alloc] initWithString:@\"test\"];\n        NSString *str2_1 = [[NSString alloc] initWithString:@\"test\"];\n        \n        NSString *str3 = [NSString stringWithString:@\"test\"];\n        NSString *str3_1 = [NSString stringWithString:@\"test\"];\n        \n        NSString *str4 = [[NSString alloc] initWithFormat:@\"test\"];\n        NSString *str4_1 = [[NSString alloc] initWithFormat:@\"test\"];\n        \n        NSString *str5 = [NSString stringWithFormat:@\"test\"];\n        NSString *str5_1 = [NSString stringWithFormat:@\"test\"];\n        \n        NSLog(@\"%p\", str1);\n        NSLog(@\"%p\", str1_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str2);\n        NSLog(@\"%p\", str2_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str3);\n        NSLog(@\"%p\", str3_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str4);\n        NSLog(@\"%p\", str4_1);\n        NSLog(@\"------------------\");\n        NSLog(@\"%p\", str5);\n        NSLog(@\"%p\", str5_1);\n        \n        [str1 release];\n        [str1_1 release];\n        [str2 release];\n        [str2_1 release];\n        [str3 release];\n        [str3_1 release];\n        [str4 release];\n        [str4_1 release];\n        [str5 release];\n        [str5_1 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x100002040\n0x100002040\n------------------\n0x100002040\n0x100002040\n------------------\n0x100002040\n0x100002040\n------------------\n0x1f9d08801e47ec0b\n0x1f9d08801e47ec0b\n------------------\n0x1f9d08801e47ec0b\n0x1f9d08801e47ec0b\n```\n\n通过 [GNUStep](http://www.gnustep.org/resources/downloads.php) 查看源码：  \n以 Format 结尾的方法最终调用的都是这个方法：\n```\n- (id)initWithFormat:(NSString*)format locale:(NSDictionary*)locale arguments:(va_list)argList;\n```\n\n以 String 结尾的方法最终调用的都是这个方法：\n```\n- (id)initWithString:(NSString*)string;\n```\n\n### NSMutableString\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableString *str1 = [[NSMutableString alloc] initWithString:@\"test\"];\n        NSString *str2 = [str1 copy]; // 深拷贝\n        NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", str1, str2, str3);\n        NSLog(@\"%p %p %p\", str1, str2, str3);\n        \n        [str1 release];\n        [str2 release];\n        [str3 release];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntest test test\n0x103aaab50 0x48301b1a78a3a9e5 0x103aab150\n```\n\nstr1、str2 和 str3 打印出来都是 test，但是他们指向的都是不同的内存地址。即 str1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 str2 和 str3 都是一个新的对象。\n![内存管理11](内存管理/内存管理11.png)\n\n### NSArray\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 浅拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", arr1, arr2, arr3);\n        NSLog(@\"%p %p %p\", arr1, arr2, arr3);\n        NSLog(@\"%d %d %d\",\n              [arr1 isKindOfClass:[NSMutableArray class]],\n              [arr2 isKindOfClass:[NSMutableArray class]],\n              [arr3 isKindOfClass:[NSMutableArray class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n(\n    1,\n    2\n) (\n    1,\n    2\n) (\n    1,\n    2\n)\n0x1004bfc20 0x1004bfc20 0x1004c0100\n0 0 1\n```\n\narr1 和 arr2 是不可变数组，arr3 是可变数组。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\narr1、arr2 和 arr3 打印出来都是同样的内容，但是 arr1 和 arr2 指向的是同一个内存地址，arr3 指向的是另一个内存地址。即 arr1 通过 `copy` 方法拷贝出来的副本 arr2 还是原对象（arr1），而 arr1 通过 `mutableCopy` 方法拷贝出来的副本 arr3 是一个新的对象。\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSArray *arr1 = [[NSArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 浅拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        NSLog(@\"%p %p %p %p\", @[@\"1\", @\"2\"], arr1, arr2, arr3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x100713270 0x100712d60 0x100712d60 0x100713240\n```\n\nNSArray 和 NSString 不同，`@[@\"1\", @\"2\"]`、arr1 和 arr2 虽然内容相同，但是它们是不同的对象（arr1 和 arr2 是同一个对象）。\n\n### NSMutableArray\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableArray *arr1 = [[NSMutableArray alloc] initWithArray:@[@\"1\", @\"2\"]];\n        NSArray *arr2 = [arr1 copy]; // 深拷贝\n        NSMutableArray *arr3 = [arr1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", arr1, arr2, arr3);\n        NSLog(@\"%p %p %p\", arr1, arr2, arr3);\n        NSLog(@\"%d %d %d\",\n              [arr1 isKindOfClass:[NSMutableArray class]],\n              [arr2 isKindOfClass:[NSMutableArray class]],\n              [arr3 isKindOfClass:[NSMutableArray class]]);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n(\n    1,\n    2\n) (\n    1,\n    2\n) (\n    1,\n    2\n)\n0x100535780 0x1005358f0 0x100535910\n1 0 1\n```\n\narr1 和 arr3 是可变数组，arr2 是不可变数组。即：  \n[可变 copy] -> 不可变  \n[可变 mutableCopy] -> 可变  \n\narr1、arr2 和 arr3 打印出来都是同样的内容，但是他们指向的都是不同的内存地址。即 arr1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 arr2 和 arr3 都是一个新的对象。\n\n\n### NSDictionary\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSDictionary *dict1 = [NSDictionary dictionaryWithObjectsAndKeys:@\"value\", @\"key\", nil];\n        NSDictionary *dict2 = [dict1 copy]; // 浅拷贝\n        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", dict1, dict2, dict3);\n        NSLog(@\"%p %p %p\", dict1, dict2, dict3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{\n    key = value;\n} {\n    key = value;\n} {\n    key = value;\n}\n0x100491ff0 0x100491ff0 0x1004923f0\n```\n\ndict1 和 dict2 是不可变字典，dict3 是可变字典。即：  \n[不可变 copy] -> 不可变  \n[不可变 mutableCopy] -> 可变  \n\ndict1、dict2 和 dict3 打印出来都是同样的内容，但是 dict1 和 dict2 指向的是同一个内存地址，dict3 指向的是另一个内存地址。即 dict1 通过 `copy` 方法拷贝出来的副本 dict2 还是原对象（dict1），而 dict1 通过 `mutableCopy` 方法拷贝出来的副本 dict3 是一个新的对象。\n\n### NSMutableDictionary\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSMutableDictionary *dict1 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@\"value\", @\"key\", nil];\n        NSDictionary *dict2 = [dict1 copy]; // 深拷贝\n        NSMutableDictionary *dict3 = [dict1 mutableCopy]; // 深拷贝\n        \n        NSLog(@\"%@ %@ %@\", dict1, dict2, dict3);\n        NSLog(@\"%p %p %p\", dict1, dict2, dict3);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{\n    key = value;\n} {\n    key = value;\n} {\n    key = value;\n}\n0x100463300 0x100463900 0x100463920\n```\n\ndict1 和 dict3 是可变字典，dict2 是不可变字典。即：  \n[可变 copy] -> 不可变  \n[可变 mutableCopy] -> 可变  \n\ndict1、dict2 和 dict3 打印出来都是同样的内容，但是他们指向的都是不同的内存地址。即 dict1 通过 `copy` 和 `mutableCopy` 方法拷贝出来的副本 dict2 和 dict3 都是一个新的对象。\n\n### 小结\n\n|  | copy | mutableCopy |\n| :-- | :-- | :-- |\n| NSString | NSString<br><font color=#FF0000> 浅拷贝 </font> | NSMutableString<br>深拷贝 |\n| NSMutableString | NSString<br>深拷贝| NSMutableString<br>深拷贝 |\n| NSArray | NSArray<br><font color=#FF0000> 浅拷贝 </font>| NSMutableArray<br>深拷贝 |\n| NSMutableArray | NSArray<br>深拷贝| NSMutableArray<br>深拷贝 |\n| NSDictionary | NSDictionary<br><font color=#FF0000> 浅拷贝 </font>| NSMutableDictionary<br>深拷贝 |\n| NSMutableDictionary | NSDictionary<br>深拷贝| NSDictionary<br>深拷贝 |\n\n\n## copy策略的property\n\n定义 Person\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSMutableArray *data;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.data = [NSMutableArray array];\n        [person.data addObject:@\"123\"];\n    }\n    return 0;\n}\n```\n\n报错：\n![内存管理12](内存管理/内存管理12.png)\n\n`data` 是 Person 用 `copy` 策略定义的 `NSMutableArray`，`data` 的 set 方法是：\n```\n@implementation Person\n- (void)setData:(NSMutableArray *)data\n{\n    if (_data != data) {\n        [_data release];\n        _data = [data copy];\n    }\n}\n@end\n```\n\n在 `person.data = [NSMutableArray array]` 赋值的这一刻，虽然传入的是一个 `NSMutableArray`，但是因为是 `copy` 策略，所以在赋值时需要进行 `copy` 操作 `_data = [data copy]`，所以 `_data` 是一个 `NSArray` 类型的不可变数组。\n\n对于可变类型的变量，在声明时使用 `strong` 策略。  \n对于不可变类型的变量，在声明时使用 `copy` 策略。\n\n比如 `UITextField` 里的 text、attributedText 和 placeholder 等，都是使用的 copy 策略，保证不管传入的是可变类型还是不可变类型，`UITextField` 内部使用的都是不可变类型：\n```\n@interface UITextField : UIControl <UITextInput, NSCoding, UIContentSizeCategoryAdjusting>\n\n@property(nullable, nonatomic,copy)   NSString               *text;                 // default is nil\n@property(nullable, nonatomic,copy)   NSAttributedString     *attributedText API_AVAILABLE(ios(6.0)); // default is nil\n......\n@property(nullable, nonatomic,copy)   NSString               *placeholder;          // default is nil. string is drawn 70% gray\n@property(nullable, nonatomic,copy)   NSAttributedString     *attributedPlaceholder API_AVAILABLE(ios(6.0)); // default is nil\n```\n\n## copyWithZone:\n\n对象类型进行 `copy` 操作，首先要遵守 `<NSCopying>` 协议，然后实现 `- (id)copyWithZone:(struct _NSZone *)zone` 方法：\n```\n@interface Person : NSObject <NSCopying>\n@property (nonatomic, assign) int age;\n@property (nonatomic, assign) int weight;\n@end\n\n@implementation Person\n- (id)copyWithZone:(struct _NSZone *)zone\n{\n    Person *person = [Person allocWithZone:zone];\n    // 设置需要拷贝的属性\n    person.age = self.age;\n    person.weight = self.weight;\n    return person;\n}\n\n- (NSString *)description\n{\n    return [NSString stringWithFormat:@\"age = %d, weight = %d\", self.age, self.weight];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.age = 10;\n        person.weight = 20;\n        \n        Person *person2 = [person copy];\n        NSLog(@\"{%@} {%@}\", person, person2);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n{age = 10, weight = 20} {age = 10, weight = 20}\n```\n\n# 引用计数的存储\n在 64bit 中，引用计数可以直接存储在优化过的 isa 指针中，也可能存储在 SideTable 类中。\n```\nstruct SideTable {\n    spinlock_t slock;\n    RefcountMap refcnts; // 一个存放着对象引用计数的散列表\n    weak_table_t weak_table; // 弱引用表\n    ......\n};\n```\n\n在 objc-weak.h 文件查看 `weak_table_t` 定义：\n```\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 数组地址（首元素地址）\n    size_t    num_entries; // 数组的数量\n    uintptr_t mask; // 数组下标最大值（weak_table_t的size-1）\n    uintptr_t max_hash_displacement; // 最大hash偏移量\n};\n```\n\n## retainCount\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件中查看 `retainCount`：  \n```\n- (NSUInteger)retainCount {\n    return _objc_rootRetainCount(self);\n}\n\n......\n\nuintptr_t\n_objc_rootRetainCount(id obj)\n{\n    ASSERT(obj);\n\n    return obj->rootRetainCount();\n}\n```\n\n在 objc-object.h 文件中查看 `rootRetainCount()` 方法：\n```\ninline uintptr_t \nobjc_object::rootRetainCount()\n{\n    if (isTaggedPointer()) return (uintptr_t)this;\n\n    sidetable_lock();\n    isa_t bits = LoadExclusive(&isa.bits);\n    ClearExclusive(&isa.bits);\n    if (bits.nonpointer) { // 非指针类型（优化过的isa指针）\n        uintptr_t rc = 1 + bits.extra_rc;\n        if (bits.has_sidetable_rc) { // 引用计数不是存储在isa中，而是存储在sidetable中\n            rc += sidetable_getExtraRC_nolock();\n        }\n        sidetable_unlock();\n        return rc;\n    }\n\n    sidetable_unlock();\n    return sidetable_retainCount();\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_getExtraRC_nolock()` 方法：\n```\nsize_t \nobjc_object::sidetable_getExtraRC_nolock()\n{\n    ASSERT(isa.nonpointer);\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this); //取出对象对应的散列表\n    if (it == table.refcnts.end()) return 0;\n    else return it->second >> SIDE_TABLE_RC_SHIFT;\n}\n```\n\n`has_sidetable_rc`：引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中。\n![内存管理17](内存管理/内存管理17.png)\n\n## release\n```\n- (oneway void)release {\n    _objc_rootRelease(self);\n}\n\n......\n\nNEVER_INLINE void\n_objc_rootRelease(id obj)\n{\n    ASSERT(obj);\n\n    obj->rootRelease();\n}\n```\n\n在 objc-object.h 文件中查看 `rootRelease()` 方法：\n```\nALWAYS_INLINE bool \nobjc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    bool sideTableLocked = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n retry:\n    do {\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n        if (slowpath(!newisa.nonpointer)) {\n            // 不是优化过的isa指针\n            ClearExclusive(&isa.bits);\n            if (rawISA()->isMetaClass()) return false;\n            if (sideTableLocked) sidetable_unlock();\n            return sidetable_release(performDealloc);\n        }\n        // don't check newisa.fast_rr; we already called any RR overrides\n        uintptr_t carry;\n        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--\n        // 相减后下溢出\n        if (slowpath(carry)) {\n            // don't ClearExclusive()\n            goto underflow;\n        }\n    } while (slowpath(!StoreReleaseExclusive(&isa.bits, \n                                             oldisa.bits, newisa.bits)));\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n    return false;\n\n underflow:\n    // newisa.extra_rc-- underflowed: borrow from side table or deallocate\n\n    // abandon newisa to undo the decrement\n    newisa = oldisa;\n\n    // 引用计数不是存储在isa中，而是存储在sidetable中 \n    if (slowpath(newisa.has_sidetable_rc)) {\n        if (!handleUnderflow) {\n            ClearExclusive(&isa.bits);\n            // 再执行 rootRelease 一次，处理下溢出\n            return rootRelease_underflow(performDealloc);\n        }\n\n        // Transfer retain count from side table to inline storage.\n\n        if (!sideTableLocked) {\n            ClearExclusive(&isa.bits);\n            sidetable_lock();\n            sideTableLocked = true;\n            // Need to start over to avoid a race against \n            // the nonpointer -> raw pointer transition.\n            goto retry;\n        }\n\n        // 下面是从 sideTable 借 RC_HALF 的引用计数放到 extra_rc 上, 借不到的情况，对象需要被销毁了\n        // Try to remove some retain counts from the side table.        \n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n\n        // To avoid races, has_sidetable_rc must remain set \n        // even if the side table count is now zero.\n\n        if (borrowed > 0) {\n            // Side table retain count decreased.\n            // Try to add them to the inline count.\n            newisa.extra_rc = borrowed - 1;  // redo the original decrement too\n            bool stored = StoreReleaseExclusive(&isa.bits, \n                                                oldisa.bits, newisa.bits);\n            if (!stored) {\n                // Inline update failed. \n                // Try it again right now. This prevents livelock on LL/SC \n                // architectures where the side table access itself may have \n                // dropped the reservation.\n                isa_t oldisa2 = LoadExclusive(&isa.bits);\n                isa_t newisa2 = oldisa2;\n                if (newisa2.nonpointer) {\n                    uintptr_t overflow;\n                    newisa2.bits = \n                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);\n                    if (!overflow) {\n                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, \n                                                       newisa2.bits);\n                    }\n                }\n            }\n\n            if (!stored) {\n                // Inline update failed.\n                // Put the retains back in the side table.\n                sidetable_addExtraRC_nolock(borrowed);\n                goto retry;\n            }\n\n            // Decrement successful after borrowing from side table.\n            // This decrement cannot be the deallocating decrement - the side \n            // table lock and has_sidetable_rc bit ensure that if everyone \n            // else tried to -release while we worked, the last one would block.\n            sidetable_unlock();\n            return false;\n        }\n        else {\n            // Side table is empty after all. Fall-through to the dealloc path.\n        }\n    }\n\n    // Really deallocate.\n\n    if (slowpath(newisa.deallocating)) {\n        ClearExclusive(&isa.bits);\n        if (sideTableLocked) sidetable_unlock();\n        return overrelease_error();\n        // does not actually return\n    }\n    newisa.deallocating = true;\n    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n\n    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n    if (performDealloc) {\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));\n    }\n    return true;\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_release()` 方法：\n```\n#define SIDE_TABLE_RC_ONE            (1UL<<2)  // MSB-ward of deallocating bit\n\n......\n\nuintptr_t\nobjc_object::sidetable_release(bool performDealloc)\n{\n#if SUPPORT_NONPOINTER_ISA\n    ASSERT(!isa.nonpointer);\n#endif\n    SideTable& table = SideTables()[this];\n\n    bool do_dealloc = false;\n    \n    //----- 对引用计数减操作 -----\n    table.lock();\n    auto it = table.refcnts.try_emplace(this, SIDE_TABLE_DEALLOCATING);\n    auto &refcnt = it.first->second;\n    if (it.second) {\n        do_dealloc = true;\n    } else if (refcnt < SIDE_TABLE_DEALLOCATING) {\n        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.\n        do_dealloc = true;\n        refcnt |= SIDE_TABLE_DEALLOCATING;\n    } else if (! (refcnt & SIDE_TABLE_RC_PINNED)) {\n        refcnt -= SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n    //----- 对引用计数减操作 end -----\n\n    // 是否要执行 dealloc\n    if (do_dealloc  &&  performDealloc) {\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));\n    }\n    return do_dealloc;\n}\n```\n\n## retain()\n在 objc-object.h 文件中查看 `retain()` 方法：\n```\ninline id \nobjc_object::retain()\n{\n    ASSERT(!isTaggedPointer());\n\n    if (fastpath(!ISA()->hasCustomRR())) {\n        return sidetable_retain();\n    }\n\n    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(retain));\n}\n```\n\n在 NSObject.mm 文件中查看 `sidetable_retain()` 方法：\n```\nid\nobjc_object::sidetable_retain()\n{\n#if SUPPORT_NONPOINTER_ISA\n    ASSERT(!isa.nonpointer);\n#endif\n    SideTable& table = SideTables()[this];\n    \n    //----- 对引用计数加操作 -----\n    table.lock();\n    size_t& refcntStorage = table.refcnts[this];\n    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {\n        refcntStorage += SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n    //----- 对引用计数加操作 end -----\n\n    return (id)this;\n}\n```\n\n# weak指针的原理\n\n## 局部变量的内存管理\n创建局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n    }\n    NSLog(@\"222\");\n}\n@end\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n```\n\n### \\_\\_strong\n使用 `__strong` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __strong Person *strongPerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        strongPerson = person;\n    }\n    NSLog(@\"222\");\n    NSLog(@\"%@\", strongPerson);\n}\n@end\n```\n\n打印结果：\n```\n111\n222\n<Person: 0x60000177c310>\n-[Person dealloc]\n```\n\n### \\_\\_weak \n使用 `__weak` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __weak Person *weakPerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        weakPerson = person;\n    }\n    NSLog(@\"222\");\n    NSLog(@\"%@\", weakPerson);\n}\n@end\n```\n\n打印结果：\n```\n111\n-[Person dealloc]\n222\n(null)\n```\n\n`weakPerson` 指针指向的内存地址被销毁后，`weakPerson` 指针会自动置为 nil。\n\n### \\_\\_unsafe_unretained\n使用 `__unsafe_unretained` 修饰的局部变量 person：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    __unsafe_unretained Person *unsafePerson;\n    NSLog(@\"111\");\n    {\n        Person *person = [[Person alloc] init];\n        unsafePerson = person;\n    }\n    NSLog(@\"222\");\n}\n@end\n```\n\n报错：\n![内存管理12](内存管理/内存管理12.png)\n\n报错的原因是指针 `unsafePerson` 还在，但是它指向的内存地址已经不存在了。这也是跟 `weakPerson` 指针相比不同也是不够安全的地方。\n\n## dealloc\n\n[objc4-781](https://opensource.apple.com/tarballs/objc4/) 查看源码：  \n\nNSObject.mm 文件：\n```\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\n......\n\nvoid\n_objc_rootDealloc(id obj)\n{\n    ASSERT(obj);\n\n    obj->rootDealloc();\n}\n```\n\n在 objc-object.h 文件查看 `rootDealloc()` 方法：\n```\ninline void\nobjc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;  // fixme necessary?\n\n    if (fastpath(isa.nonpointer  &&  \n                 !isa.weakly_referenced  &&  \n                 !isa.has_assoc  &&  \n                 !isa.has_cxx_dtor  &&  \n                 !isa.has_sidetable_rc))\n    {\n        assert(!sidetable_present());\n        free(this);\n    } \n    else {\n        object_dispose((id)this);\n    }\n}\n```\n\n* nonpointer  \n0，代表普通的指针，isa 只存储着 Class、Meta-Class 对象的内存地址  \n1，代表优化过，isa 使用位域存储更多的信息\n* has_assoc  \n是否有设置过关联对象，如果没有，释放时会更快\n* has_cxx_dtor  \n是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快\n* weakly_referenced  \n是否有被弱引用指向过，如果没有，释放时会更快\n* has_sidetable_rc  \n引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中\n\n如果条件不成立会走到 objc-runtime-new.mm 文件的 `object_dispose()` 方法：\n```\nid \nobject_dispose(id obj)\n{\n    if (!obj) return nil;\n\n    objc_destructInstance(obj);    \n    free(obj);\n\n    return nil;\n}\n\n......\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj); // 清除成员变量\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating(); // 将指向当前对象的弱指针置为nil\n    }\n\n    return obj;\n}\n```\n\n在 objc-object.h 文件查看 `clearDeallocating()` 方法：\n```\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) { // 是否是普通的isa指针\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) { // 是否有被弱引用指向过 || // 是否是优化过的isa指针\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```\n\n在 NSObject.mm 文件 查看 `clearDeallocating_slow()` 方法：\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this); // 清除弱应用\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this); // 清空引用计数\n    }\n    table.unlock();\n}\n```\n\n在 objc-weak.mm 文件查看 `weak_clear_no_lock()` 方法：\n```\nvoid \nweak_clear_no_lock(weak_table_t *weak_table, id referent_id) \n{\n    // 获取当前对象\n    objc_object *referent = (objc_object *)referent_id;\n\n    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); // 传入弱引用表和当前对象的地址值，找到对应的弱引用数组\n    if (entry == nil) {\n        return; // 如果没有表示当前对象没有弱引用，不用处理直接返回\n    }\n\n    // zero out references\n    weak_referrer_t *referrers;\n    size_t count;\n    \n    if (entry->out_of_line()) {\n        referrers = entry->referrers;\n        count = TABLE_SIZE(entry);\n    } \n    else {\n        referrers = entry->inline_referrers;\n        count = WEAK_INLINE_COUNT;\n    }\n    \n    for (size_t i = 0; i < count; ++i) {\n        objc_object **referrer = referrers[i];\n        if (referrer) {\n            if (*referrer == referent) {\n                *referrer = nil;\n            }\n            else if (*referrer) {\n                _objc_inform(\"__weak variable at %p holds %p instead of %p. \"\n                             \"This is probably incorrect use of \"\n                             \"objc_storeWeak() and objc_loadWeak(). \"\n                             \"Break on objc_weak_error to debug.\\n\", \n                             referrer, (void*)*referrer, (void*)referent);\n                objc_weak_error();\n            }\n        }\n    }\n    \n    weak_entry_remove(weak_table, entry);\n}\n\n......\n\nstatic weak_entry_t *\nweak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)\n{\n    ASSERT(referent);\n\n    weak_entry_t *weak_entries = weak_table->weak_entries; // 在weak_table中取出weak_entry_t数组\n\n    if (!weak_entries) return nil;\n\n    size_t begin = hash_pointer(referent) & weak_table->mask; // 通过hash实例对象的地址 & weak_table->mask得到begin(没有hash冲突的index)，因为是 & mask(2的n次方-1，类似00001111)，所以保证了begin在mask范围内(<=mask)\n    size_t index = begin;\n    size_t hash_displacement = 0;\n    while (weak_table->weak_entries[index].referent != referent) { // while循环检测hash冲突，如果有冲突,index+1，hash_displacement++（hash冲突偏移量）\n        index = (index+1) & weak_table->mask;\n        if (index == begin) bad_weak_table(weak_table->weak_entries);\n        hash_displacement++;\n        if (hash_displacement > weak_table->max_hash_displacement) {\n            return nil;\n        }\n    }\n    \n    return &weak_table->weak_entries[index];\n}\n```\n\n# 自动释放池\n自动释放池的主要底层数据结构是：`__AtAutoreleasePool`、`AutoreleasePoolPage`，调用了 `autorelease` 的对象最终都是通过 `AutoreleasePoolPage` 对象来管理的。\n\n## \\_\\_AtAutoreleasePool\n\n堆代码：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[[Person alloc] init] autorelease];\n    }\n    return 0;\n}\n```\n\n找到 main.m 所在文件，在终端输入：\n```\n$ xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc main.m\n```\n\n上面的代码转成 C++ 代码后就是这个样子：\n```\nint main(int argc, const char * argv[]) {\n    {\n        __AtAutoreleasePool __autoreleasepool; \n        Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    }\n    return 0;\n}\n```\n\n简化一下：\n```\nint main(int argc, const char * argv[]) {\n    {\n        __AtAutoreleasePool __autoreleasepool; \n        Person *person = [[[Person alloc] init] autorelease];\n    }\n    return 0;\n}\n```\n\n在生成的 main.mm 文件中搜索 `__AtAutoreleasePool`，`__AtAutoreleasePool` 是一个 C++ 结构体：\n```\nstruct __AtAutoreleasePool {\n    // 构造函数，在创建结构体的时候调用\n    __AtAutoreleasePool() {\n        atautoreleasepoolobj = objc_autoreleasePoolPush();\n    }\n    // 析构函数，在结构体销毁的时候调用\n    ~__AtAutoreleasePool() {\n        objc_autoreleasePoolPop(atautoreleasepoolobj);\n    }\n    void * atautoreleasepoolobj;\n};\n```\n\n认识了 `__AtAutoreleasePool` 结构体后，通过 clang 生成的 C++ 代码可以看做：\n```\nint main(int argc, const char * argv[]) {\n    atautoreleasepoolobj = objc_autoreleasePoolPush();\n \n    MJPerson *person = [[[MJPerson alloc] init] autorelease];\n \n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n    return 0;\n}\n```\n\n通过上面的摸索，`@autoreleasepool {}` 的第一个大括号其实是调用了 `objc_autoreleasePoolPush()` 方法，第二个大括号是调用 `objc_autoreleasePoolPop()` 方法，`objc_autoreleasePoolPop()` 方法的参数是 `objc_autoreleasePoolPush()` 方法生成的 `atautoreleasepoolobj`。\n\n如果有多个 `@autoreleasepool {}` 嵌套的话就是这样：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool { // objc_autoreleasePoolPush()\n        \n        @autoreleasepool { // objc_autoreleasePoolPush()\n            \n            @autoreleasepool { // objc_autoreleasePoolPush()\n               \n                Person *person = [[[Person alloc] init] autorelease];\n            \n            } // objc_autoreleasePoolPop()\n        \n        } // objc_autoreleasePoolPop()\n    \n    } // objc_autoreleasePoolPop()\n    return 0;\n}\n```\n\n查看 `objc_autoreleasePoolPush()` 源码：\n```\nvoid *\nobjc_autoreleasePoolPush(void)\n{\n    return AutoreleasePoolPage::push();\n}\n```\n\n查看 `objc_autoreleasePoolPop()` 源码：\n```\nNEVER_INLINE\nvoid\nobjc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n从源码可以看到，`objc_autoreleasePoolPush()` 和 `objc_autoreleasePoolPop()` 方法内部都是通过 `AutoreleasePoolPage` 实现的。\n\n## AutoreleasePoolPage\n\n### 定义\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject-internal.h 文件可以看到 AutoreleasePoolPage 的定义：\n```\nclass AutoreleasePoolPage;\nstruct AutoreleasePoolPageData\n{\n\tmagic_t const magic; // 用于校验内存是否损坏\n\t__unsafe_unretained id *next; // 指向了下一个能存放autorelease对象地址的区域\n\tpthread_t const thread; // 线程\n\tAutoreleasePoolPage * const parent; // 前驱结点，指向前一个page\n\tAutoreleasePoolPage *child; // 后继结点，指向下一个page\n\tuint32_t const depth;\n\tuint32_t hiwat;\n\n\tAutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)\n\t\t: magic(), next(_next), thread(_thread),\n\t\t  parent(_parent), child(nil),\n\t\t  depth(_depth), hiwat(_hiwat)\n\t{\n\t}\n};\n\nclass AutoreleasePoolPage : private AutoreleasePoolPageData\n{\n    ......\n}\n```\n\n`AutoreleasePoolPage` 结构体的 thread 存储的是其对应的线程，也表示一个 `AutoreleasePoolPage` 对应一个线程。\n\n### 结构\n每个 `AutoreleasePoolPage` 对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 `autorelease` 对象的地址，所有的 `AutoreleasePoolPage` 对象通过双向链表的形式连接在一起。\n\n假设 `AutoreleasePoolPage` 对象的内存地址从 `0x1000` 开始：\n![内存管理14](内存管理/内存管理14.png)\n从 `0x1000` 到 `0x2000` 共4096个字节（`0x1000`）。  \n从 `0x1000` 到 `0x1038` 共56个字节（`0x38`），即 `AutoreleasePoolPage` 结构体内部的成员变量大小之和。  \n从 `0x1038` 到 `0x2000` 共4040个字节，分别是 `begain()` 和 `end()` 方法调用的位置，这段内存用来保存调用了 `autorelease` 方法的对象的地址值。  \n\n查看 `begain()` 方法源码：\n```\nid * begin() {\n    return (id *) ((uint8_t *)this+sizeof(*this));\n}\n```\n\n可以看到 `begain()` 方法内部直接返回的是 `AutoreleasePoolPage` 内存地址开始位置加上其自身占用内存大小（`0x1000` + `0x38` = `0x1038`）。\n\n查看 `end()` 方法源码：\n```\nid * end() {\n    return (id *) ((uint8_t *)this+SIZE);\n}\n```\n\n可以看到 `end()` 方法内部直接返回的是 `AutoreleasePoolPage` 内存地址开始位置加上 `SIZE`：\n```\n#define I386_PGBYTES            4096            /* bytes per 80386 page */\n#define PAGE_SIZE               I386_PGBYTES\n#define PAGE_MAX_SIZE           PAGE_SIZE\n\nstatic size_t const SIZE =\n#if PROTECT_AUTORELEASEPOOL\n\t\tPAGE_MAX_SIZE;  // must be multiple of vm page size\n#else\n\t\tPAGE_MIN_SIZE;  // size and alignment, power of 2\n#endif\n```\n\n一个 `AutoreleasePoolPage` 结构体能够存放的 `autorelease` 对象的地址是有限的，如果超出存储最大值，会新创建一个 `AutoreleasePoolPage` 结构体用来存储剩下的部分。多个 `AutoreleasePoolPage` 结构体通过机构体中的 child 指向下一个 `AutoreleasePoolPage` 结构体，通过 parent 指向上一个 `AutoreleasePoolPage` 结构体，构成双向链表结构：\n![内存管理15](内存管理/内存管理15.png)\n\n* 👉 双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。\n* 👉 循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。\n\n### 原理\n调用 `push` 方法会将一个 `POOL_BOUNDARY` 入栈，并且返回其存放的内存地址。  \n调用 `pop` 方法时传入一个 `POOL_BOUNDARY` 的内存地址，会从最后一个入栈的对象开始发送 `release` 消息，直到遇到这个 `POOL_BOUNDARY`。  \n`id *next` 指向了下一个能存放 `autorelease` 对象地址的区域。    \n\n比如在 `@autoreleasepool {}` 内创建1000个 person 对象调用 `autorelease`。\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        for (int i=0; i<1000; i++) {\n            Person *person = [[[Person alloc] init] autorelease];\n        }\n    }\n    return 0;\n}\n```\n\n一个 person 对象的指针占8个字节，1000个 person 对象就是8000个字节。一个 `AutoreleasePoolPage` 对象可以保存4040个字节，所以会再创建一个 `AutoreleasePoolPage` 对象用来保存剩下的 person 对象的地址值。\n\n将 `@autoreleasepool {}` 转成 `__AtAutoreleasePool`：\n```\nint main(int argc, const char * argv[]) {\n    atautoreleasepoolobj = objc_autoreleasePoolPush(); // atautoreleasepoolobj = 0x1038\n    \n    for (int i=0; i<1000; i++) {\n        Person *person = [[[Person alloc] init] autorelease];\n    } // 8000个字节\n\n    objc_autoreleasePoolPop(atautoreleasepoolobj); // atautoreleasepoolobj = 0x1038\n    return 0;\n}\n```\n\n`objc_autoreleasePoolPush()` 会调用 `AutoreleasePoolPage` 对象的 `push()` 方法，将一个 `POOL_BOUNDARY` 入栈，并且返回其存放的内存地址（`0x1038`）：\n![内存管理18](内存管理/内存管理18.png)\n\n每个调用 `autorelease` 方法的 person 对象都会添加到 `AutoreleasePoolPage` 对象中：\n![内存管理19](内存管理/内存管理19.png)\n正如上面提到的一样，一个 `AutoreleasePoolPage` 对象可以保存4040个字节，所以会创建一个新的 `AutoreleasePoolPage` 对象用来保存剩下的 person 对象的地址值。\n\n`objc_autoreleasePoolPop(atautoreleasepoolobj)` 方法传入的 `atautoreleasepoolobj` 是 `objc_autoreleasePoolPush()` 方法返回的 `POOL_BOUNDARY` 的地址值（`0x1038`），即 `objc_autoreleasePoolPop(POOL_BOUNDARY)`。拿到 `POOL_BOUNDARY` 后，`objc_autoreleasePoolPop()` 方法内部会从最后一个加入到 `AutoreleasePoolPage` 里的对象开始，依次调用 `release` 方法，直到 `POOL_BOUNDARY` 完成释放工作。\n\n在整个过程中，`next` 指向 page 中下一个将要存放的对象的地址, 通过 `*next++ = obj` 来实现对象的存入并 `next` 指针的累加, 用 `id obj = *--page->next` 来取出要 `release` 的对象并实现 `next` 的递减。\n\n### 验证\n可以通过以下私有函数来查看自动释放池的情况：\n```\nextern void _objc_autoreleasePoolPrint(void);\n```\n\n`_objc_autoreleasePoolPrint()` 方法是定义在 Runtime 里的，所以是不开源的。但是可以通过 `extern` 关键字在 main.m 文件中声明，编译器就会自动去找到这个方法，从而实现调用。\n```\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        _objc_autoreleasePoolPrint(); // 位置0\n\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n        \n        //_objc_autoreleasePoolPrint(); // 位置1\n\n        @autoreleasepool {\n            Person *person3 = [[[Person alloc] init] autorelease];\n            Person *person4 = [[[Person alloc] init] autorelease];\n\n            //_objc_autoreleasePoolPrint(); // 位置2\n\n            @autoreleasepool {\n                Person *person5 = [[[Person alloc] init] autorelease];\n                Person *person6 = [[[Person alloc] init] autorelease];\n\n                //_objc_autoreleasePoolPrint(); // 位置3\n            }\n\n            //_objc_autoreleasePoolPrint(); // 位置4\n        }\n\n        //_objc_autoreleasePoolPrint(); // 位置5\n    }\n\n    //_objc_autoreleasePoolPrint(); // 位置6\n    return 0;\n}\n```\n\n位置0，打印结果：\n```\nobjc[13812]: ##############\nobjc[13812]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13812]: 0 releases pending.\nobjc[13812]: [0x1]  ................  PAGE (placeholder)\nobjc[13812]: [0x1]  ################  POOL (placeholder)\nobjc[13812]: ##############\nProgram ended with exit code: 0\n```\n\n位置1，打印结果：\n```\nobjc[13633]: ##############\nobjc[13633]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13633]: 3 releases pending.\nobjc[13633]: [0x10400a000]  ................  PAGE  (hot) (cold)\nobjc[13633]: [0x10400a038]  ################  POOL 0x10400a038\nobjc[13633]: [0x10400a040]       0x10293c6e0  Person\nobjc[13633]: [0x10400a048]       0x10293b7a0  Person\nobjc[13633]: ##############\nProgram ended with exit code: 0\n```\n\n位置2，打印结果：\n```\nobjc[13658]: ##############\nobjc[13658]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13658]: 6 releases pending.\nobjc[13658]: [0x10400a000]  ................  PAGE  (hot) (cold)\nobjc[13658]: [0x10400a038]  ################  POOL 0x10400a038\nobjc[13658]: [0x10400a040]       0x102974880  Person\nobjc[13658]: [0x10400a048]       0x102973940  Person\nobjc[13658]: [0x10400a050]  ################  POOL 0x10400a050\nobjc[13658]: [0x10400a058]       0x1029722e0  Person\nobjc[13658]: [0x10400a060]       0x102973800  Person\nobjc[13658]: ##############\nProgram ended with exit code: 0\n```\n\n位置3，打印结果：\n```\nobjc[13677]: ##############\nobjc[13677]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13677]: 9 releases pending.\nobjc[13677]: [0x10280d000]  ................  PAGE  (hot) (cold)\nobjc[13677]: [0x10280d038]  ################  POOL 0x10280d038\nobjc[13677]: [0x10280d040]       0x1006addd0  Person\nobjc[13677]: [0x10280d048]       0x1006ace90  Person\nobjc[13677]: [0x10280d050]  ################  POOL 0x10280d050\nobjc[13677]: [0x10280d058]       0x1006ab830  Person\nobjc[13677]: [0x10280d060]       0x1006acd50  Person\nobjc[13677]: [0x10280d068]  ################  POOL 0x10280d068\nobjc[13677]: [0x10280d070]       0x1006aba20  Person\nobjc[13677]: [0x10280d078]       0x1006ab4f0  Person\nobjc[13677]: ##############\nProgram ended with exit code: 0\n```\n\n位置4，打印结果：\n```\nobjc[13703]: ##############\nobjc[13703]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13703]: 6 releases pending.\nobjc[13703]: [0x10080d000]  ................  PAGE  (hot) (cold)\nobjc[13703]: [0x10080d038]  ################  POOL 0x10080d038\nobjc[13703]: [0x10080d040]       0x100437c20  Person\nobjc[13703]: [0x10080d048]       0x100436ce0  Person\nobjc[13703]: [0x10080d050]  ################  POOL 0x10080d050\nobjc[13703]: [0x10080d058]       0x100435680  Person\nobjc[13703]: [0x10080d060]       0x100436ba0  Person\nobjc[13703]: ##############\nProgram ended with exit code: 0\n```\n\n位置5，打印结果：\n```\nobjc[13735]: ##############\nobjc[13735]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13735]: 3 releases pending.\nobjc[13735]: [0x10480a000]  ................  PAGE  (hot) (cold)\nobjc[13735]: [0x10480a038]  ################  POOL 0x10480a038\nobjc[13735]: [0x10480a040]       0x10322c4d0  Person\nobjc[13735]: [0x10480a048]       0x10322b590  Person\nobjc[13735]: ##############\nProgram ended with exit code: 0\n```\n\n位置6，打印结果：\n```\nobjc[13751]: ##############\nobjc[13751]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13751]: 0 releases pending.\nobjc[13751]: [0x10300d000]  ................  PAGE  (hot) (cold)\nobjc[13751]: ##############\nProgram ended with exit code: 0\n```\n\n打印结果中的 `POOL` 代表的就是 `POOL_BOUNDARY`，person 代表的就是调用 `autorelease` 方法的对象。`releases pending` 表示当前自动释放池里的对象个数。 \n\n多个 `AutoreleasePoolPage` 对象的情况：\n```\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person1 = [[[Person alloc] init] autorelease];\n        Person *person2 = [[[Person alloc] init] autorelease];\n\n        @autoreleasepool {\n            for (int i=0; i<600; i++) {\n                Person *person3 = [[[Person alloc] init] autorelease];\n            }\n\n            @autoreleasepool {\n                Person *person5 = [[[Person alloc] init] autorelease];\n                Person *person6 = [[[Person alloc] init] autorelease];\n\n                _objc_autoreleasePoolPrint();\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nobjc[13947]: ##############\nobjc[13947]: AUTORELEASE POOLS for thread 0x1000d3dc0\nobjc[13947]: 607 releases pending.\nobjc[13947]: [0x10280c000]  ................  PAGE (full)  (cold)\nobjc[13947]: [0x10280c038]  ################  POOL 0x10280c038\nobjc[13947]: [0x10280c040]       0x10067bc20  Person\nobjc[13947]: [0x10280c048]       0x10067a1d0  Person\nobjc[13947]: [0x10280c050]  ################  POOL 0x10280c050\nobjc[13947]: [0x10280c058]       0x100679d60  Person\nobjc[13947]: [0x10280c060]       0x100678e20  Person\nobjc[13947]: [0x10280c068]       0x1006777c0  Person\nobjc[13947]: [0x10280c070]       0x100678ce0  Person\n...\nobjc[13947]: [0x10280cff8]       0x100681ba0  Person\nobjc[13947]: [0x10280a000]  ................  PAGE  (hot) \nobjc[13947]: [0x10280a038]       0x100681bb0  Person\n...\nobjc[13947]: [0x10280a348]       0x1006821d0  Person\nobjc[13947]: [0x10280a350]  ################  POOL 0x10280a350\nobjc[13947]: [0x10280a358]       0x1006821e0  Person\nobjc[13947]: [0x10280a360]       0x1006821f0  Person\n```\n\n从打印结果中可以看到，第一个 page 里有两个 `POOL_BOUNDARY`，由于对象太多超出了第一个 page 的存储范围，所以创建出了第二个 page。第二个 page 中存储了多出来的 person 对象，还有一个 `POOL_BOUNDARY`。  \n`PAGE  (hot) ` 表示该 page 为当前页，`PAGE (full)  (cold)` 中的 full 表示这一页已经满了，cold 表示该 page 不是当前页。\n\n### 源码分析\n\n`objc_autoreleasePoolPush()` 方法的实现原理是调用 `AutoreleasePoolPage` 对象的 `push()` 方法。  \n`objc_autoreleasePoolPop()` 方法的实现原理是调用 `AutoreleasePoolPage` 对象的 `pop()` 方法。  \n`autorelease` 方法的实现原理则是调用了 `AutoreleasePoolPage` 对象的 `autorelease()` 方法。\n\n在 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 NSObject.mm 文件查看。\n\n#### objc_autoreleasePoolPush(void)\n```\nvoid *\nobjc_autoreleasePoolPush(void)\n{\n    return AutoreleasePoolPage::push();\n}\n```\n\n`push()` 方法：\n```\nstatic inline void *push() \n{\n    id *dest;\n    if (slowpath(DebugPoolAllocation)) {\n        dest = autoreleaseNewPage(POOL_BOUNDARY); // 传入 POOL_BOUNDARY 来新建一个 AutoreleasePoolPage 对象\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY); // AutoreleasePoolPage 对象已经存在就直接添加\n    }\n    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n\n如果 page 不存在就调用 `autoreleaseNewPage()` 方法传入 `POOL_BOUNDARY` 创建：\n```\nstatic __attribute__((noinline))\nid *autoreleaseNewPage(id obj)\n{\n    AutoreleasePoolPage *page = hotPage(); // 获取当前 page\n    if (page) return autoreleaseFullPage(obj, page);\n    else return autoreleaseNoPage(obj);\n}\n\nstatic inline AutoreleasePoolPage *hotPage() \n{\n    AutoreleasePoolPage *result = (AutoreleasePoolPage *)\n        tls_get_direct(key);\n    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;\n    if (result) result->fastcheck();\n    return result;\n}\n\nstatic __attribute__((noinline))\nid *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)\n{\n    // The hot page is full. \n    // Step to the next non-full page, adding a new page if necessary.\n    // Then add the object to that page.\n    ASSERT(page == hotPage());\n    ASSERT(page->full()  ||  DebugPoolAllocation);\n\n    do {\n        if (page->child) page = page->child;\n        else page = new AutoreleasePoolPage(page);\n    } while (page->full());\n\n    setHotPage(page);\n    return page->add(obj); // 入栈 POOL_BOUNDARY\n}\n```\n\n如果 `AutoreleasePoolPage` 对象已经存在就直接调用 `autoreleaseFast()` 方法添加 `POOL_BOUNDARY`：\n```\nstatic inline id *autoreleaseFast(id obj)\n{\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) { // page 存在 && page 没有满\n        return page->add(obj); // 添加 obj\n    } else if (page) { // page 存在 && page 满了\n        return autoreleaseFullPage(obj, page);\n    } else { // page 不存在\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n#### - (id)autorelease\n```\n- (id)autorelease {\n    return _objc_rootAutorelease(self);\n}\n\nNEVER_INLINE id\n_objc_rootAutorelease(id obj)\n{\n    ASSERT(obj);\n    return obj->rootAutorelease();\n}\n\n__attribute__((noinline,used))\nid \nobjc_object::rootAutorelease2()\n{\n    ASSERT(!isTaggedPointer());\n    return AutoreleasePoolPage::autorelease((id)this); // 将当前对象 this 加入 page\n}\n```\n\n`autorelease((id)this)` 方法：\n```\nstatic inline id autorelease(id obj)\n{\n    ASSERT(obj);\n    ASSERT(!obj->isTaggedPointer());\n    id *dest __unused = autoreleaseFast(obj); // 添加 obj\n    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);\n    return obj;\n}\n```\n\n调用 `autoreleaseFast()` 方法添加 obj：\n```\nstatic inline id *autoreleaseFast(id obj)\n{\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) { // page 存在 && page 没有满\n        return page->add(obj); // 添加 obj\n    } else if (page) { // page 存在 && page 满了\n        return autoreleaseFullPage(obj, page);\n    } else { // page 不存在\n        return autoreleaseNoPage(obj);\n    }\n}\n```\n\n`autorelease` 方法最终是通过调用 `autoreleaseFast()` 方法，将调用了 `autorelease` 方法的对象保存到了 page 中。\n\n#### objc_autoreleasePoolPop(void *ctxt)\n```\nNEVER_INLINE\nvoid\nobjc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n`pop()` 方法：\n```\nstatic inline void\npop(void *token)\n{\n    AutoreleasePoolPage *page;\n    id *stop;\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        page = hotPage(); // 从当前的 page 开始 pop\n        if (!page) {\n            // Pool was never used. Clear the placeholder.\n            return setHotPage(nil);\n        }\n        // Pool was used. Pop its contents normally.\n        // Pool pages remain allocated for re-use as usual.\n        page = coldPage();\n        token = page->begin();\n    } else {\n        page = pageForPointer(token);\n    }\n\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {\n        return popPageDebug(token, page, stop);\n    }\n\n    return popPage<false>(token, page, stop); // 释放对象\n}\n```\n\n`popPageDebug()` 方法：\n```\n__attribute__((noinline, cold))\nstatic void\npopPageDebug(void *token, AutoreleasePoolPage *page, id *stop)\n{\n    popPage<true>(token, page, stop);\n}\n```\n\n`popPage()` 方法：\n```\ntemplate<bool allowDebug>\nstatic void\npopPage(void *token, AutoreleasePoolPage *page, id *stop)\n{\n    if (allowDebug && PrintPoolHiwat) printHiwat();\n\n    page->releaseUntil(stop); // 释放 page 里的所有对象，知道遇到 stop 才停止\n\n    // memory: delete empty children\n    if (allowDebug && DebugPoolAllocation  &&  page->empty()) {\n        // special case: delete everything during page-per-pool debugging\n        AutoreleasePoolPage *parent = page->parent;\n        page->kill();\n        setHotPage(parent);\n    } else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {\n        // special case: delete everything for pop(top)\n        // when debugging missing autorelease pools\n        page->kill();\n        setHotPage(nil);\n    } else if (page->child) {\n        // hysteresis: keep one empty child if page is more than half full\n        if (page->lessThanHalfFull()) {\n            page->child->kill();\n        }\n        else if (page->child->child) {\n            page->child->child->kill();\n        }\n    }\n}\n```\n\n`releaseUntil()` 方法：\n```\nvoid releaseUntil(id *stop) \n{\n    while (this->next != stop) {\n        AutoreleasePoolPage *page = hotPage(); // 取出当前 page\n\n        while (page->empty()) {\n            page = page->parent;\n            setHotPage(page);\n        }\n\n        page->unprotect();\n        id obj = *--page->next; // 取出最后面的一个 obj\n        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));\n        page->protect();\n\n        if (obj != POOL_BOUNDARY) {\n            objc_release(obj); // 调用obj的release方法\n        }\n    }\n\n    setHotPage(this);\n}\n```\n\n`pop()` 方法最终是通过调用 `releaseUntil()` 方法，将 page 里的对象依次调用 `objc_release(obj)` 方法释放掉了。\n\n## autorelease 释放时机\n创建一个 iOS 项目，选择 MRC 环境，修改 main.m 文件（当前XCode版本11.6）。\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n        return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n    }\n}\n```\n\n定义 Person 类，添加打印：\n```\n@implementation Person\n- (void)dealloc\n{\n    NSLog(@\"%s\", __func__);\n    [super dealloc];\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[[Person alloc] init] autorelease];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController viewDidLoad]\n-[ViewController viewWillAppear:]\n-[Person dealloc]\n-[ViewController viewDidAppear:]\n```\n\n从打印结果可以看到，person 对象是在 `viewWillAppear` 方法执行完成后被释放的。\n\n### Runloop和Autorelease\niOS 在主线程的 Runloop 中注册了两个 Observer：  \n第一个 Observer 监听了 `kCFRunLoopEntry` 事件，会调用 `objc_autoreleasePoolPush()`。  \n第二个 Observer 监听了 `kCFRunLoopBeforeWaiting` 事件，会调用 `objc_autoreleasePoolPop()`、`objc_autoreleasePoolPush()`，监听了 `kCFRunLoopBeforeExit` 事件，会调用 `objc_autoreleasePoolPop()`。\n\n打印当前的 RunLoop，查看 Observers：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[[Person alloc] init] autorelease];\n    NSLog(@\"%s\", __func__);\n    \n    NSLog(@\"%@\", [NSRunLoop currentRunLoop]);\n}\n@end\n```\n\n打印结果里有很多内容，这里是摘出来的跟 Autorelease 相关的两个 Observe：\n```\nobservers = (\n    \"<CFRunLoopObserver 0x6000009fc1e0 [0x7fff8062d750]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7fdaef00a048>\\n)}}\",\n\n    \"<CFRunLoopObserver 0x6000009fc280 [0x7fff8062d750]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4931eaa4), context = <CFArray 0x60000368ce70 [0x7fff8062d750]>{type = mutable-small, count = 1, values = (\\n\\t0 : <0x7fdaef00a048>\\n)}}\"\n),\n```\n\n`_wrapRunLoopWithAutoreleasePoolHandler` 是回调方法，在收到消息时用来处理 Autorelease 相关操作。\n\n第一个 observe 的 `activities` 是 `0x1`，第二个 observe 的 `activities` 是 `0xa0`。\n\n`activities` 对应的枚举：\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),          // 1（十进制）\n    kCFRunLoopBeforeTimers = (1UL << 1),   // 2\n    kCFRunLoopBeforeSources = (1UL << 2),  // 4\n    kCFRunLoopBeforeWaiting = (1UL << 5),  // 32\n    kCFRunLoopAfterWaiting = (1UL << 6),   // 64\n    kCFRunLoopExit = (1UL << 7),           // 128\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n因为：  \n`0x1`（十六进制）-> 1（十进制） \n`0xa0`（十六进制）-> 160（十进制）  \n所以：    \n```\n0x1：kCFRunLoopEntry\n0xa0：kCFRunLoopAfterWaiting | kCFRunLoopExit\n```\n\n所以第一个 observe 监听的状态就是 `kCFRunLoopEntry`，第二个 observe 监听的状态就是 `kCFRunLoopAfterWaiting` 和 `kCFRunLoopExit`。 \n\n![内存管理20](内存管理/内存管理20.png)\n* 第一次循环：  \n  01 状态是 `kCFRunLoopEntry`，RunLoop 会调用 `objc_autoreleasePoolPush()` 方法；  \n  07 状态是 `kCFRunLoopAfterWaiting`，RunLoop 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法； \n* 非第一次循环：\n  10-1 回到 02 继续循环至 07；  \n  07 状态是 `kCFRunLoopAfterWaiting`，RunLoop 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法； \n  10-1 回到 02 继续循环至 07；  \n* 结束循环：\n  10-2 退出 RunLoop；  \n  11 状态是 `kCFRunLoopExit`，RunLoop 会调用 `objc_autoreleasePoolPop()` 方法。\n\n因为 02 会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法，所以 `push()` 和 `pop()` 实现了一一对应的关系。\n\n在看打印结果：\n```\n-[ViewController viewDidLoad]\n-[ViewController viewWillAppear:]\n-[Person dealloc]\n-[ViewController viewDidAppear:]\n```\n\n在 `viewWillAppear` 执行完成后，RunLoop 到了 02 的位置。此时 RunLoop 监听到了 `kCFRunLoopAfterWaiting` 状态，会先调用 `objc_autoreleasePoolPop()` 方法，然后调用 `objc_autoreleasePoolPush()` 方法。在调用 `objc_autoreleasePoolPop()` 方法时，Autorelease 中的 person 对象就被释放了。\n\n另外，打印结果也说明了 `viewDidLoad` 和 `viewWillAppear` 方法是在同一个循环中执行的。\n\n### ARC环境下的release\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[Person alloc] init];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController viewDidLoad]\n-[Person dealloc]\n-[ViewController viewWillAppear:]\n-[ViewController viewDidAppear:]\n```\n\n从打印结果可以看到，person 对象在 `viewDidLoad` 方法执行完就释放了。所以在 ARC 环境下，在方法最后结束前，对方法内部的局部变量调用了 release 方法：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *person = [[Person alloc] init];\n    NSLog(@\"%s\", __func__);\n    \n    // [person release];\n}\n```\n\n# 总结\n* 使用 CADisplayLink、NSTimer 有什么注意点？\n  CADisplayLink 和 NSTimer 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 CADisplayLink 和 NSTimer 不准时。  \n  CADisplayLink 和 NSTimer 有可能会造成循环引用问题，CADisplayLink 可以通过使用代理对象（NSProxy）解决，NSTimer 除了可以通过使用代理对象（NSProxy）解决外，还可以使用带有 block 回调的初始化方法。  \n\n* 介绍下内存的几大区域\n  代码段：编译之后的代码  \n  数据段：字符串常量、已初始化数据和未初始化数据  \n  栈：函数调用开销，比如局部变量。（分配的内存空间地址越来越小）  \n  堆：通过 alloc、malloc、calloc 等动态分配的空间，分配的内存空间地址越来越大\n\n* 讲一下你对 iOS 内存管理的理解\n  在 iOS 中，使用引用计数来管理 OC 对象的内存。  \n  一个新创建的 OC 对象引用计数默认是1，当引用计数减为0，OC 对象就会销毁，释放其占用的内存空间。  \n  调用 retain 会让 OC 对象的引用计数+1，调用 release 会让 OC 对象的引用计数-1。  \n  内存管理的经验总结：  \n  当调用 alloc、new、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放它。  \n  想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1。  \n\n* ARC 都帮我们做了什么？(LLVM + Runtime)\n  ARC 是 LLVM 编译器和 Runtime 协作协作实现的。ARC 利用 LLVM 编译器自动生成 release、retain 和 autorelease 等内存管理相关的代码，利用 Runtime 实现在运行时对弱引用的管理（添加和清除）。\n\n* weak 指针的实现原理\n  将弱引用存储在一个弱引用表（哈希表）里面，在对象要销毁时，就以对象的地址值 & mask 得到一个索引取出对应的弱引用表，并把弱引用表里存储的弱引用都清除掉。\n\n* autorelease 对象在什么时机会被调用 release？  \n  autorelease 对象在什么时候调用 release 是由 RunLoop 控制的，在 RunLoop 监听到 `kCFRunLoopAfterWaiting` 或 `kCFRunLoopExit` 状态时会调用 `objc_autoreleasePoolPop()` 方法，此时 autorelease 对象会调用 release。即在 RunLoop 进入休眠或者退出时调用 release。\n\n* 方法里有局部对象， 出了方法后会立即释放吗?\n  会。在方法结束前，runtime 会自动为方法内部的局部对象调用 release 方法进行释放。\n\n相关阅读：  \n[深入理解 Tagged Pointer](https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/)\n\n\n\n","slug":"OC底层原理/内存管理","published":1,"updated":"2023-08-22T09:52:13.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgv8002vaq7kamrvukbn"},{"title":"多线程","date":"2020-07-14T08:31:01.000Z","_content":"\n思考：\n* 你理解的多线程？\n* iOS的多线程方案有哪几种？你更倾向于哪一种？\n* 你在项目中用过 GCD 吗？\n* GCD 的队列类型\n* 说一下 OperationQueue 和 GCD 的区别，以及各自的优势\n* 线程安全的处理手段有哪些？\n* OC你了解的锁有哪些？在你回答基础上进行二次提问；  \n追问一：自旋和互斥对比？  \n追问二：使用以上锁需要注意哪些？  \n追问三：用C/OC/C++，任选其一，实现自旋或互斥？\n<!-- more -->\n* 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n\n- (void)test\n{\n    NSLog(@\"2\");\n}\n@end\n```\n\n* 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)test\n{\n    NSLog(@\"2\");\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSThread *thread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"1\");\n    }];\n    [thread start];\n    \n    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n# GCD\n\n👉 [GCD源码](https://github.com/apple/swift-corelibs-libdispatch)\n\n## iOS中的常见多线程方案\n\n<!-- <style>\ntable th:nth-of-type(1){\n    width: 20%;\n}\ntable th:nth-of-type(2){\n    width: 25%;\n}\ntable th:nth-of-type(3){\n    width: 20%;\n}\ntable th:nth-of-type(4){\n    width: 20%;\n}\ntable th:nth-of-type(5){\n    width: 15%;\n}\n</style> -->\n\n| 技术方案 | 简介 | 语言 | 线程生命周期 | 使用频率 |\n| :--: | :-------- | :--: | :--: | :--: |\n| phread | 1.一套通用的多线程API；<br>2.适用于Unix\\Linux\\Windows等系统；<br>3.跨平台\\可移植；<br>4.使用难度大；| C | 开发者管理 | 几乎不用 |\n| NSThread | 1.使用更加面向对象；<br>2.简单易用，可直接操作线程对象； | OC | 开发者管理 | 偶尔使用 |\n| GCD | 1.旨在替代NSThread等多线程技术； | C | 自动管理 | 经常使用 |\n| NSOperation | 1.基于GCD（底层是GCD）；<br>2.比GCD多了一些更简单使用的功能；<br>3.使用更加面向对象； | OC | 自动管理 | 经常使用 |\n\nphread 在实际开发中几乎不会用到，一般只会在加锁解锁的地方用到。另外，NSThead、GCD 和 NSOperation 底层都会用到 phread，比如创建线程等。NSThread 就是对 phread 的包装。\n\n## GCD的常用函数\n\nGCD 中有2个用来执行任务的函数：\n* 用同步的方式执行任务（queue：队列；block：任务）  \n```\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n* 用异步的方式执行任务  \n```\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n队列相关函数：\n* 获取主队列\n```\ndispatch_queue_t queue = dispatch_get_main_queue();\n```\n\n* 获取全局并发队列\n```\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n```\n\n* 手动创建并发队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n* 手动创建串行队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"mySerialQueue\", DISPATCH_QUEUE_SERIAL);\n```\n\n* 手动创建队列组\n```\ndispatch_group_t group = dispatch_group_create();\n```\n\n## GCD的队列\n\nGCD的队列可以分为2大类型\n* 并发队列（Concurrent Dispatch Queue）  \n可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）；  \n并发功能只有在异步（dispatch_async）函数下才有效；\n\n* 串行队列（Serial Dispatch Queue）  \n让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）；\n\n## 容易混淆的术语\n\n有4个术语比较容易混淆：同步、异步、并发、串行\n* 同步和异步主要影响：能不能开启新的线程  \n同步：在当前线程中执行任务，不具备开启新线程的能力；  \n异步：在新的线程中执行任务，具备开启新线程的能力；\n\n* 并发和串行主要影响：任务的执行方式  \n并发：多个任务并发（同时）执行；  \n串行：一个任务执行完毕后，再执行下一个任务；\n\n## 各种队列的执行效果\n\n| &nbsp; | 并发队列 | 手动穿件的串行队列 | 主队列 |\n| :--: | :--: | :--: | :--: |\n| 同步（sync） | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |\n| 异步（async） | 有开启新线程<br>并发执行任务 | 有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |\n\n使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）。\n\n主队列是一个特殊的串行队列，async 方法在主队列中添加任务不会开启新线程，并且是串行执行任务。\n\n### 并发队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n\n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600003595140>{number = 1, name = main}\n任务4 - <NSThread: 0x600003595140>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n任务5 - <NSThread: 0x600000434d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：并发，创建新线程。\n![多线程03](多线程/多线程03.png)\n\n### 并发队列 & 同步执行（sync）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    /// 任务2\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n任务4 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n任务5 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程04](多线程/多线程04.png)\n\n### 串行队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n任务4 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n任务5 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，创建新线程。\n![多线程05](多线程/多线程05.png)\n\n### 串行队列 & 同步执行（sync）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\n    /// 任务2\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n任务4 - <NSThread: 0x600001438d40>{number = 1, name = main}\n任务5 - <NSThread: 0x600001438d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程06](多线程/多线程06.png)\n\n### 主队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600002408d80>{number = 1, name = main}\n任务4 - <NSThread: 0x600002408d80>{number = 1, name = main}\n任务5 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程07](多线程/多线程07.png)\n\n### 主队列 & 同步执行（sync）-> 死锁\n\n死锁一：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）：\n![多线程01](多线程/多线程01.png)\n\n问题分析：\n![多线程02](多线程/多线程02.png)\n\n`sync` 函数在这里的作用有两个，第一个是添加任务2，第二个是执行任务2。因为主队列是串行队列，所以遵循先进先出原则，只有在第一个任务 `viewDidLoad` 执行完成后才能执行任务2。但是第一个任务 `viewDidLoad` 要想执行完就必须执行完 `sync` 函数，而 `sync` 函数要想执行完就必须执行完任务2，而任务2要想执行完就必须执行完 `viewDidLoad` ... ... 产生死锁。\n\n死锁二：\n![多线程08](多线程/多线程08.png)\n\n问题分析：\n![多线程09](多线程/多线程09.png)\n\n## performSelector:withObject:afterDelay:\n\n在子线程里调用 `performSelector:withObject:afterDelay:` 方法：\n```\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n```\n\n打印结果：\n```\n1\n3\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法并没有起作用。这是因为 `performSelector:withObject:afterDelay:` 方法内部使用了 timer，而子线程默认没有 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 TImer 无法调用。1和3可以打印是因为 `NSLog()` 方法是普通的代码，不需要 RunLoop。\n\n解决方案 👉 手动添加 RunLoop：\n```\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n        \n        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n    });\n}\n```\n\n打印结果：\n```\n1\n执行任务2 - <NSThread: 0x600001ad0cc0>{number = 6, name = (null)} - (null)\n3\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法可以正常调用了。这是因为手动为子线程添加了 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 timer 可以正常运行了。\n\n猜想：`performSelector:withObject:afterDelay:` 方法的本质是往 RunLoop 中添加定时器：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:\n                NSLog(@\"kCFRunLoopEntry\");\n                break;\n            case kCFRunLoopBeforeTimers:\n                NSLog(@\"kCFRunLoopBeforeTimers\");\n                break;\n            case kCFRunLoopBeforeSources:\n                NSLog(@\"kCFRunLoopBeforeSources\");\n                break;\n            case kCFRunLoopBeforeWaiting:\n                NSLog(@\"kCFRunLoopBeforeWaiting\");\n                break;\n            case kCFRunLoopAfterWaiting:\n                NSLog(@\"kCFRunLoopAfterWaiting\");\n                break;\n            case kCFRunLoopExit:\n                NSLog(@\"kCFRunLoopExit\");\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"1\");\n    [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n    NSLog(@\"3\");\n}\n```\n\n打印结果：\n```\nkCFRunLoopAfterWaiting\nkCFRunLoopBeforeTimers\nkCFRunLoopBeforeSources\n1\n3\nkCFRunLoopBeforeTimers\nkCFRunLoopBeforeSources\n执行任务2 - <NSThread: 0x600000b5cd40>{number = 1, name = main} - <NSOperationQueue: 0x7fb3f0006020>{name = 'NSOperationQueue Main Queue'}\n... ...\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法的调用是一个 timers 事件：RunLoop 先处理了 Sources0 事件，再处理的 Timers。\n\n### GNUstep\n\nGNUstep 是 GNU 计划的项目之一，它将 Cocoa 的 OC 库重新开源实现了一遍。虽然 GNUstep 不是苹果官方源码，但还是具有一定的参考价值。👉 [源码地址](http://www.gnustep.org/resources/downloads.php)\n\n找到 NSRunLoop.m 文件查看 `performSelector:withObject:afterDelay:` 方法源码：\n```\n- (void) performSelector: (SEL)aSelector\n\t      withObject: (id)argument\n\t      afterDelay: (NSTimeInterval)seconds\n{\n  NSRunLoop\t\t*loop = [NSRunLoop currentRunLoop];\n  GSTimedPerformer\t*item;\n\n  //根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。\n  item = [[GSTimedPerformer alloc] initWithSelector: aSelector\n\t\t\t\t\t     target: self\n\t\t\t\t\t   argument: argument\n\t\t\t\t\t      delay: seconds];\n  [[loop _timedPerformers] addObject: item];\n  RELEASE(item);\n  [loop addTimer: item->timer forMode: NSDefaultRunLoopMode];\n}\n```\n\n通过源码可以得出结论：`performSelector:withObject:afterDelay:` 方法内部根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。\n\n### performSelector:withObject:\n\n`performSelector:withObject:` 方法跟 `performSelector:withObject:afterDelay:` 方法的实现原理不同，`performSelector:withObject:afterDelay:` 是定义在 RunLoop.h 文件里的 API，内部实现的本质是往 RunLoop 中添加定时器。而 `performSelector:withObject:` 方法的本质是调用 objc_msgSend() 方法。可以在 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 里看到具体实现，找到 NSObjec.m 文件：\n```\n- (id)performSelector:(SEL)sel withObject:(id)obj {\n    if (!sel) [self doesNotRecognizeSelector:sel];\n    return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);\n}\n```\n\n## 队列组的使用\n\n异步并发执行任务1、任务2，在任务1、任务2都执行完毕后，再回到主线程执行任务3：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_group_t group = dispatch_group_create();\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_async(group, queue, ^{\n        sleep(1);\n        NSLog(@\"任务1\");\n    });\n    dispatch_group_async(group, queue, ^{\n        NSLog(@\"任务2\");\n    });\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        NSLog(@\"任务3\");\n    });\n}\n```\n\n打印结果：\n```\n任务2\n任务1\n任务3\n```\n\n任务3会等到任务1和任务2都执行完成之后再执行。\n\n# GCD源码分析\n\n## dispatch_async()\n\n在 queue.h 文件找到 `dispatch_async()` 方法的定义\n```\nAPI_AVAILABLE(macos(10.6), ios(4.0))\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n在 queue.c 文件找到 `dispatch_async()` 方法的实现：\n```\nvoid\ndispatch_async(dispatch_queue_t dq, dispatch_block_t work)\n{\n    //将任务 work 打包成 dispatch_continuation_t 类型\n\tdispatch_continuation_t dc = _dispatch_continuation_alloc(); \n    //设置标志位\n\tuintptr_t dc_flags = DC_FLAG_CONSUME;\n\tdispatch_qos_t qos;\n\n    //进行block初始化\n\tqos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);\n\t_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);\n}\n```\n\n在 inline_internal.h 文件找到 `_dispatch_continuation_async()` 方法的实现：\n```\nDISPATCH_ALWAYS_INLINE\nstatic inline void\n_dispatch_continuation_async(dispatch_queue_class_t dqu,\n\t\tdispatch_continuation_t dc, dispatch_qos_t qos, uintptr_t dc_flags)\n{\n#if DISPATCH_INTROSPECTION\n\tif (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {\n\t\t_dispatch_trace_item_push(dqu, dc); //将任务添加到队列中\n\t}\n#else\n\t(void)dc_flags;\n#endif\n\treturn dx_push(dqu._dq, dc, qos);\n}\n```\n\n在 trace.h 文件找到 `_dispatch_trace_item_push` 方法的实现：\n```\n#define _dispatch_trace_item_push(dq, dou) \\\n\t\tdo { (void)(dq); (void)(dou); } while(0)\n```\n\n## dispatch_sync()\n\n# 多线程的安全隐患\n\n资源共享：1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件。\n\n当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。\n\n## 多线程安全隐患示例\n\n### 卖票\n```\n@interface ViewController ()\n@property (assign, nonatomic) int ticketsCount;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    [self ticketTest];\n}\n\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n             [self saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self saleTicket];\n        }\n    });\n}\n\n//卖1张票\n- (void)saleTicket\n{\n    int oldTicketsCount = self.ticketsCount;\n    sleep(.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    \n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n还剩14张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩14张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩14张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩13张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩12张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩11张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩10张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩9张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩9张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩8张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩7张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩6张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩5张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩4张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩3张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n```\n\n可以看到，刚开始三个线程都卖了1张票，结果还是下14张票。在三个线程走完后总共卖了15张票，但是最后还剩3张票。无论是在卖票过程中，还是最后剩余的票数都出现了异常。\n\n![多线程10](多线程/多线程10.png)\n总共15张票，两个线程同时卖票，每个线程都是拿15减1，得到的手势14张票。不同的线程拿到同一个变量进行修改，就会出现问题。\n\n### 存钱取钱\n```\n@interface ViewController ()\n@property (assign, nonatomic) int money;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self moneyTest];\n}\n\n- (void)moneyTest\n{\n    self.money = 100;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self saveMoney];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self drawMoney];\n        }\n    });\n}\n\n/// 存钱\n- (void)saveMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney += 50;\n    self.money = oldMoney;\n    \n    NSLog(@\"存50，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n/// 取钱\n- (void)drawMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney -= 20;\n    self.money = oldMoney;\n    \n    NSLog(@\"取20，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n存50，还剩150元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩80元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n取20，还剩110元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩130元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩90元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩140元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩120元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩170元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩150元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩200元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩180元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩230元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩210元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩260元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩240元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩290元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩270元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩320元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩300元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩350元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n```\n\n从打印结果可以看到，最后还剩350。代码中，原本有100，存了500，取了200，所以结果应该是400。\n\n![多线程11](多线程/多线程11.png)\n总共100元，两个线程同时拿到100元，第一个线程存了50元后余额还剩150元，第二个线程去了20元余额还剩80元。不同的线程拿到同一个变量进行修改，就会出现问题。\n\n## 多线程安全隐患分析\n\n线程A先取到变量的值17，线程B后取到变量的值17。线程A对取到的值加一（17+1=18），线程B对取到的值加一（17+1=18）。线程A将处理后的值赋值给变量（18），线程B也将处理后的值赋值给变量（18）。虽然修改了两次变量（+1），但是结果都是18：\n![多线程12](多线程/多线程12.png)\n\n## 多线程安全隐患的解决方案\n解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）。  \n常见的线程同步技术是：加锁。\n![多线程13](多线程/多线程13.png)\n\n# iOS中的线程同步方案\n\n| 同步方案 | 简介 |\n| :-- | :-- |\n| OSSpinLock | 自旋锁 |\n| os_unfair_lock | 用于取代不安全的OSSpinLock |\n| pthread_mutex | 互斥锁 |\n| dispatch_semaphore | 信号量 |\n| dispatch_queue(DISPATCH_QUEUE_SERIAL) | 串行队列 |\n| NSLock | 对mutex普通锁的封装 |\n| NSRecursiveLock | 对mutex递归锁的封装，API跟NSLock基本一致 |\n| NSCondition | 对mutex和cond的封装 |\n| NSConditionLock | 对NSCondition的进一步封装，可以设置具体的条件值 |\n| @synchronized | 对mutex递归锁的封装 |\n\n将卖票和存钱取钱测试代码封装起来：\n```\n@interface BaseLockDemo : NSObject\n/// 存钱取钱\n- (void)moneyTest;\n/// 卖票\n- (void)ticketTest;\n#pragma mark - 暴露给子类去使用\n- (void)__saveMoney;\n- (void)__drawMoney;\n- (void)__saleTicket;\n@end\n\n@interface BaseLockDemo()\n@property (assign, nonatomic) int money;\n@property (assign, nonatomic) int ticketsCount;\n@end\n\n@implementation BaseLockDemo\n///------ 存钱、取钱 ------\n- (void)moneyTest\n{\n    self.money = 100;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self __saveMoney];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self __drawMoney];\n        }\n    });\n}\n\n/// 存钱\n- (void)__saveMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney += 50;\n    self.money = oldMoney;\n    \n    NSLog(@\"存50，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney -= 20;\n    self.money = oldMoney;\n    \n    NSLog(@\"取20，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n///------ 卖票 ------\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n}\n\n/// 卖1张票\n- (void)__saleTicket\n{\n    int oldTicketsCount = self.ticketsCount;\n    sleep(.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n@end\n```\n\n## OSSpinLock\n`OSSpinLock` 叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源。目前已经不再安全，可能会出现优先级反转问题（如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁）。需要导入头文件 `#import <libkern/OSAtomic.h>`。\n\n忙等状态可以理解为一个 do-while 循环，不停的监测着是否解锁，这个状态下的线程会一直占用着CPU资源。正因为是处于忙等状态，所以 `OSSpinLock` 的效率要比其它锁都高，一旦解锁立刻就能监测到并继续执行。不再安全的原因是优先级较高的线程在等待锁时（忙等），CPU不再分配资源给其它线程，那么上锁的线程负责解锁，由于CPU没有分配资源也无法解锁，导致优先级较高的线程一直在这里等待。\n\n* 线程调度\n计算机通常只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配CPU的使用权。\n* 时间片轮转调度\n时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。\n\n### 常用API\n```\n/// 初始化\nOSSpinLock lock = OS_SPINLOCK_INIT;\n/// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）\nbool result = OSSpinLockTry(&lock);\n/// 加锁\nOSSpinLockLock(&lock);\n/// 解锁\nOSSpinLockUnlock(&lock);\n```\n\n### 解决卖票和存钱取钱问题\n定义 OSSpinLockDemo 继承自 LockBaseDemo。\n```\n#import <libkern/OSAtomic.h>\n\n@interface OSSpinLockDemo()\n@property (assign, nonatomic) OSSpinLock moneyLock;\n@property (assign, nonatomic) OSSpinLock ticketLock;\n@end\n\n@implementation OSSpinLockDemo\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        self.moneyLock = OS_SPINLOCK_INIT;\n        self.ticketLock = OS_SPINLOCK_INIT;\n    }\n    return self;\n}\n/// 取钱\n- (void)__drawMoney\n{\n    OSSpinLockLock(&_moneyLock);\n    \n    [super __drawMoney];\n    \n    OSSpinLockUnlock(&_moneyLock);\n}\n/// 存钱\n- (void)__saveMoney\n{\n    OSSpinLockLock(&_moneyLock);\n    \n    [super __saveMoney];\n    \n    OSSpinLockUnlock(&_moneyLock);\n}\n/// 卖票\n- (void)__saleTicket\n{\n    OSSpinLockLock(&_ticketLock);\n    \n    [super __saleTicket];\n    \n    OSSpinLockUnlock(&_ticketLock);\n}\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    BaseLockDemo *demo = [[OSSpinLockDemo alloc] init];\n    [demo ticketTest];\n    [demo moneyTest];\n}\n@end\n```\n\n调用 `-(void)moneyTest` 打印结果：\n```\n存50，还剩150元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩200元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩250元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩300元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩350元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩400元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩450元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩500元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩550元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩600元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n取20，还剩580元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩560元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩540元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩520元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩500元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩480元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩460元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩440元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩420元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩400元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n```\n\n调用 `-(void)ticketTest` 打印结果：\n```\n还剩14张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩13张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩12张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩11张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩10张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩9张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩8张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩7张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩6张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩5张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩4张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩3张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩2张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩1张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩0张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n```\n\n因为要修改的有两个变量，一个是存钱取钱里的余额，一个是卖票里的剩余票数，所以要有两把锁分别对应这两个变量。一旦有线程对 OSSpinLock 上锁后，其它线程再遇到 OSSpinLock 时会阻塞住，等待 OSSpinLock 解锁在继续向下执行。\n\n上面👆的例子是将 OSSpinLock 锁对象放到了实例对象里，也可以将 OSSpinLock 锁对象放到类对象里：\n```\nstatic OSSpinLock moneyLock_;\n+ (void)initialize\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        moneyLock_ = 0;\n    });\n}\n```\n\n类方法 `+ (void)initialize` 只会被系统调用一次，但是允许被开发者调用，所以使用 `dispatch_once` 保证类对象的 `moneyLock_` 锁只初始化一次。\n\n或者：\n```\n- (void)__saleTicket\n{\n    static OSSpinLock ticketLock = OS_SPINLOCK_INIT;\n    \n    OSSpinLockLock(&ticketLock);\n    \n    [super __saleTicket];\n    \n    OSSpinLockUnlock(&ticketLock);\n}\n```\n\n使用 static 关键字，将 `ticketLock` 锁保存在全局区，保证只初始化一次。\n\n### OSSpinLock 汇编分析\n\n* 相关汇编代码：  \n  jne：j 是 jump，ne 是条件。  \n  callq：函数调用。  \n  syscall：系统调用。\n\n* lldb 指令： \n  setp：执行一行OC代码。  \n  stepi：stepinstruction 的简写，执行一行汇编代码，也可以简写为 si。（如果敲的过快可能会出现异常）  \n  next：执行一行OC代码。\n  nexti：执行一行汇编代码。\n  stepi 和 nexti 的区别：在遇到函数调用是，stepi 会进入调用的函数，nexti 不会进入。  \n  c：continue 的简写，继续执行。  \n\n（重复敲回车会执行上一个 lldb 指令）  \n\n### 查看汇编代码方法\n👉 修改 LockBaseDemo 类里的 `- (void)__saleTicket` 方法，设置睡眠时间为 60s，这样可以有足够的时间查看第二次加锁时的汇编代码。修改 `- (void)ticketTest` 方法，创建十条线程调用 `- (void)__saleTicket` 方法：\n```\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    for (int i=0; i<10; i++) {\n        [[[NSThread alloc] initWithTarget:self selector:@selector(__saleTicket) object:nil] start]; \n    }\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    int oldTicketsCount = self.ticketsCount; //断点\n    sleep(60.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n```\n\n第一次加锁后，在第二次尝试加锁时，就可以有足够多的时间查看其汇编代码，在断点处查看 Debug -> Debug Workflow -> Always Show Disassembly。\n\n### 查看 OSSpinLock 汇编代码\n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 9 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 10，因为此时的自旋锁处于上锁状态，所以 Thread 10 处于等待锁的状态。重复执行 si 指令，到第11行时会调用 OSSpinLocklock 函数：\n![多线程15](多线程/多线程15.png)\n使用 si 指令进入到调用函数：\n![多线程16](多线程/多线程16.png)\n重复执行 si 指令，在第6行通过 jne 跳转到 `_OSSpinLockLockSlow` 函数：\n![多线程17](多线程/多线程17.png)\n`_OSSpinLockLockSlow` 函数是自旋锁的核心代码，从第6行到第19行是一个 while 循环（🔎自旋锁标志）。因为 Thread 9 已经加过锁并且还没有解锁，所以这里会一直循环执行，等待 Thread 9 解锁。可以看到第14行和第16行是跳出 while 循环的判断：\n![多线程18](多线程/多线程18.png)\n\n\n## os_unfair_lock\n`OSSpinLock` 在以前是性能最高的一种锁，但是由于不再安全（优先级反转问题），苹果已经不建议使用了，从 iOS10 开始推出了替代它的 `os_unfair_lock`。需要导入头文件 `#import <os/lock.h>`。\n\n### 常用API\n```\n/// 初始化\nos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n/// 尝试加锁\nos_unfair_lock_trylock(&lock);\n/// 加锁\nos_unfair_lock_lock(&lock);\n/// 解锁\nos_unfair_lock_unlock(&lock);\n```\n\n### 解决卖票和存钱取钱问题\n定义 OSUnfairLockDemo 继承自 LockBaseDemo。\n```\n#import <libkern/OSAtomic.h>\n\n@interface OSUnfairLockDemo()\n@property (nonatomic, assign) os_unfair_lock moneyLock;\n@property (nonatomic, assign) os_unfair_lock ticketLock;\n@end\n\n@implementation OSUnfairLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyLock = OS_UNFAIR_LOCK_INIT;\n        self.ticketLock = OS_UNFAIR_LOCK_INIT;\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    os_unfair_lock_lock(&_moneyLock);\n    \n    [super __drawMoney];\n    \n    os_unfair_lock_unlock(&_moneyLock);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    os_unfair_lock_lock(&_moneyLock);\n    \n    [super __saveManey];\n    \n    os_unfair_lock_unlock(&_moneyLock);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    os_unfair_lock_lock(&_ticketLock);\n    \n    [super __saleTicket];\n    \n    os_unfair_lock_unlock(&_ticketLock);\n}\n```\n\n打印结果同 OSSpinLock。\n\n* 死锁  \n如果加锁后没有解锁，其它线程就会进入等待，永远无法往下继续执行。这种由于没有解锁造成的其它线程的等待叫做死锁。\n\n### os_unfair_lock 汇编分析\n\n根据“查看汇编代码方法”查看 `os_unfair_lock` 第二次尝试加锁的汇编代码。  \n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 8 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 15，因为此时的自旋锁处于上锁状态，所以 Thread 15 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `os_unfair_lock_lock` 函数：\n![多线程26](多线程/多线程26.png)\n使用 `si` 指令进入到 `os_unfair_lock_lock` 函数：\n![多线程27](多线程/多线程27.png)\n重复使用 `si` 指令，进入 `_os_unfair_lock_lock_slow` 函数：\n![多线程28](多线程/多线程28.png)\n使用 `si` 指令，第56行会调用 `__ulock_wait` 函数：\n![多线程29](多线程/多线程29.png)\n使用 `si` 指令，进入 `__ulock_wait`：\n![多线程30](多线程/多线程30.png)\n第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎 互斥锁标志）：\n![多线程31](多线程/多线程31.png)\n\n从上面👆对 `os_unfair_lock` 的汇编分析，可以看出 `os_unfair_lock` 是一个互斥锁。在 `os_unfair_lock` 的头文件 lock.h 里的注释可以看到一个单词 Low-level（低级锁），低级锁的特点就是休眠。自旋锁 OSSpinLock 是一个高级锁。\n\n## pthread_mutex\n\nmutex 叫做”互斥锁”，等待锁的线程会处于休眠状态。需要导入头文件 `#import <pthread.h>`。\n\n### 常用API\n```\n/// 初始化锁的属性\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);\n/// 初始化锁\npthread_mutex_t mutex;\npthread_mutex_init(&mutex, &attr);\n/// 尝试加锁\npthread_mutex_trylock(&mutex);\n/// 加锁\npthread_mutex_lock(&mutex);\n/// 解锁\npthread_mutex_unlock(&mutex);\n/// 销毁相关资源\npthread_mutexattr_destroy(&attr);\npthread_mutex_destroy(&mutex);\n```\n\n锁定类型：\n```\n#define PTHREAD_MUTEX_NORMAL\t\t0\n#define PTHREAD_MUTEX_ERRORCHECK\t1\n#define PTHREAD_MUTEX_RECURSIVE\t\t2\n#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL\n```\n\n### PTHREAD_MUTEX_INITIALIZER\n```\n/*\n * Mutex variables\n */\n#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}\n```\n\n可以看到，`PTHREAD_MUTEX_INITIALIZER` 是一个结构体，在使用 `PTHREAD_MUTEX_INITIALIZER` 初始化锁时，由于结构体语法的问题，需要进行静态初始化：\n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n    }\n    return self;\n}\n```\n\n如果使用 `PTHREAD_MUTEX_INITIALIZER` 动态初始化 `pthread_mutex_t` 会报错：\n![多线程14](多线程/多线程14.png)\n\n### pthread_mutexattr_t\n初始化 `pthread_mutex` 锁： \n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        /// 初始化属性\n        pthread_mutexattr_t attr;\n        pthread_mutexattr_init(&attr);\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n        /// 初始化锁\n        pthread_mutex_init(&_moneyMutex, &attr);\n        /// 销毁属性\n        pthread_mutexattr_destroy(&attr);\n    }\n    return self;\n}\n```\n\n上面👆初始化锁的代码比较繁琐，一般使用 `pthread_mutex_init(&_moneyMutex, NULL)` 方法进行初始化。`pthread_mutex_init()` 方法的第二参数传 `NULL`，就相当于设置了 `PTHREAD_MUTEX_DEFAULT` 类型的 `pthread_mutexattr_t` 属性。\n\n### 解决卖票和存钱取钱问题\n定义 PthreadMutexDemo 继承自 LockBaseDemo。\n```\n#import <pthread.h>\n\n@interface PthreadMutexDemo()\n@property (nonatomic, assign) pthread_mutex_t moneyMutex;\n@property (nonatomic, assign) pthread_mutex_t ticketMutex;\n@end\n\n@implementation PthreadMutexDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_moneyMutex, NULL);\n        pthread_mutex_init(&_ticketMutex, NULL);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    pthread_mutex_lock(&_moneyMutex);\n    \n    [super __drawMoney];\n    \n    pthread_mutex_unlock(&_moneyMutex);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    pthread_mutex_lock(&_moneyMutex);\n    \n    [super __saveManey];\n    \n    pthread_mutex_unlock(&_moneyMutex);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    pthread_mutex_lock(&_ticketMutex);\n    \n    [super __saleTicket];\n    \n    pthread_mutex_unlock(&_ticketMutex);\n}\n\n/// 销毁锁\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_moneyMutex);\n    pthread_mutex_destroy(&_ticketMutex);\n}\n\n@end\n```\n\n打印结果同 OSSpinLock。\n\n相对于 `OSSpinLock` 和 `os_unfair_lock`，`pthread_mutex` 的 API 里提供了销毁方法 `pthread_mutex_destroy()`，所以需要在 `-(void)dealloc` 方法里对锁进行销毁。\n\n### pthread_mutex 汇编分析\n\n根据“查看汇编代码方法”查看 `pthread_mutex` 第二次尝试加锁的汇编代码。  \n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 10 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 14，因为此时的自旋锁处于上锁状态，所以 Thread 14 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `phread_mutex_lock` 函数：\n![多线程19](多线程/多线程19.png)\n使用 `si` 指令进入到 `phread_mutex_lock` 函数：\n![多线程20](多线程/多线程20.png)\n重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_slow` 函数：\n![多线程21](多线程/多线程21.png)\n重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_wait` 函数：\n![多线程22](多线程/多线程22.png)\n重复使用 `si` 指令，调用 `__psynch_mutexwait`：\n![多线程23](多线程/多线程23.png)\n使用 `si` 指令，进入 `__psynch_mutexwait` 函数：\n![多线程23](多线程/多线程24.png)\n第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎互斥锁标志）：\n![多线程23](多线程/多线程25.png)\n\n从上面👆对 `pthread_mutex` 的汇编分析，可以看出 `pthread_mutex` 是一个互斥锁，也是一个低级锁。\n\n## pthread_mutex – 递归锁\n初始化 pthread_mutex 递归锁：\n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        /// 初始化属性\n        pthread_mutexattr_t attr;\n        pthread_mutexattr_init(&attr);\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n        /// 初始化锁\n        pthread_mutex_init(&_moneyMutex, &attr);\n        /// 销毁属性\n        pthread_mutexattr_destroy(&attr);\n    }\n    return self;\n}\n```\n\n用 `PTHREAD_MUTEX_RECURSIVE` 类型定义的属性创建出来的 `pthread_mutex` 锁就是 `pthread_mutex` 递归锁。\n\n### 死锁\n在使用锁时如果出现了递归调用，或者在加锁后调用了一个使用同一把锁的方法，就会出现死锁的情况。与上面👆提到过的死锁的概念相同。\n\n定义 PthreadMutexRecursiveDemo：\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)recursiveMutexTest\n{\n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n......\n```\n\n#### 死锁情况一：递归调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_mutex, NULL);\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n```\n\n可以看到打印结果里只有一条打印信息，这是因为加锁后再次调用 `-(void)recursiveMutexTest` 方法，会发现 `_mutex` 已经上锁了，进入休眠等待解锁。\n\n#### 死锁情况二：函数间互相调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_mutex, NULL);\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest2];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)recursiveMutexTest2\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n```\n\n可以看到打印结果里只有一条打印信息，这是因为两个方法使用的是同一把锁，在 `- (void)recursiveMutexTest` 方法加锁后再去调用 `- (void)recursiveMutexTest2` 方法时，会发现 _mutex 已经上锁了，进入休眠等待解锁。\n\n### 递归锁\n\n因为递归锁允许在同一个线程里重复加锁，所以递归锁可以解决上面出现的死锁情况。\n\n#### 解决死锁情况一：递归调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)initMutex:(pthread_mutex_t *)mutex\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex];\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n......\n```\n\n#### 解决死锁情况二：函数间互相调用 \n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)initMutex:(pthread_mutex_t *)mutex\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex];\n    }\n    return self;\n}\n\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest2];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)recursiveMutexTest2\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest2]\n```\n\n使用递归锁后，死锁的问题不存在了。但是，加了递归锁后的打印结果跟没加锁一样，这样被加锁的代码块还安全吗？其实，递归锁只可以在当前线程重复加锁。也就是说，当前线程加锁后，在当前线程再次调用 `- (void)recursiveMutexTest` 方法还可以重复加锁，而其它线程在此时调用 `- (void)recursiveMutexTest` 方法时判断到已经加过锁了就不再加锁了，会进入休眠等待解锁。\n\n## pthread_mutex – 条件\n\n### 相关API\n```\n/// 初始化锁\n pthread_mutex_t mutex;\n /// NULL代表使用默认属性\n pthread_mutex_init(&mutex, NULL);\n /// 初始化条件\n pthread_cond_t condition;\n pthread_cond_init(&condition, NULL);\n /// 等待条件（进入休眠，放开mutex；被唤醒后，会再次对mutex加锁）\n pthread_cond_wait(&condition, &mutex);\n /// 激活一个等待该条件的线程\n pthread_cond_signal(&condition);\n /// 激活所有等待该条件的线程\n pthread_cond_broadcast(&condition);\n /// 销毁资源\n pthread_mutex_destroy(&mutex);\n pthread_cond_destroy(&condition);\n```\n\n### 应用场景\n```\n#import <pthread.h>\n\n@interface PthreadMutexCondDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@property (nonatomic, assign) pthread_cond_t cond;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation PthreadMutexCondDemo\n\n- (void)initMutex:(pthread_mutex_t *)mutex cond:(pthread_cond_t *)cond\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n    /// 初始化条件\n    pthread_cond_init(cond, NULL);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex cond:&_cond];\n        \n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(remove) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(add) object:nil] start];\n}\n\n/// 线程1\n- (void)remove\n{\n    pthread_mutex_lock(&_mutex);\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    if (self.data.count == 0) {\n        NSLog(@\"%s, 等待信号\", __func__);\n        pthread_cond_wait(&_cond, &_mutex);\n        NSLog(@\"%s, 收到信号\", __func__);\n    }\n    \n    [self.data removeLastObject];\n    NSLog(@\"%s, 删除\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n/// 线程2\n- (void)add\n{\n    pthread_mutex_lock(&_mutex);\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    [self.data addObject:@\"test\"];\n    NSLog(@\"%s, 添加\", __func__);\n    \n    pthread_cond_signal(&_cond);\n    NSLog(@\"%s, 发送信号\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n    pthread_cond_destroy(&_cond);\n}\n\n@end\n```\n\n打印结果：\n```\n00:35:21.182042+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 上锁\n00:35:21.182158+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 等待信号\n00:35:23.182238+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 上锁\n00:35:23.182447+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 添加\n00:35:23.182614+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 发送信号\n00:35:23.182700+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 解锁\n00:35:23.182709+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 收到信号\n00:35:23.182772+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 删除\n00:35:23.182835+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 解锁\n```\n\n在 `pthread_cond_wait()` 方法调用后，线程1会解锁并进入等待消息状态（休眠）。线程2监听到 `pthread_mutex_t` 锁已经解锁开始正常执行，添加完数据后发送消息。线程1在收到消息后会判断 pthread_mutex_t 锁是否已经上锁，如果已经上锁了就继续等待其解锁（休眠），一旦解锁了（线程2）就立即向下执行下面的代码。\n\n因为应用场景是不同线程的调用，所以初始化属性时传入的第二个的参数 `PTHREAD_MUTEX_RECURSIVE` 也可以是 `PTHREAD_MUTEX_NORMAL`。\n\n`pthread_mutex` 条件锁的应用场景比较少见，就算遇到了类似的场景，估计也不会选择用这种方式解决。它主要是解决优先及问题，上面👆代码中为了不对空数组进行删除操作，给锁添加了条件，保证了数组的删除操作在添加完数据后执行。\n\n## NSLock\n\nNSLock 是对 mutex 普通锁的封装。\n\n### 相关API\n```\n/// 初始化锁\nNSLock *lock = [[NSLock alloc] init];\n/// 加锁\n[lock lock];\n/// 解锁\n[lock unlock];\n```\n\n### 应用\n```\n@interface NSLockDemo()\n@property (nonatomic, strong) NSLock *moneyLock;\n@property (nonatomic, strong) NSLock *ticketLock;\n@end\n\n@implementation NSLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyLock = [[NSLock alloc] init];\n        self.ticketLock = [[NSLock alloc] init];\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    [self.moneyLock lock];\n    \n    [super __drawMoney];\n    \n    [self.moneyLock unlock];\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    [self.moneyLock lock];\n    \n    [super __saveManey];\n    \n    [self.moneyLock unlock];\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    [self.ticketLock lock];\n    \n    [super __saleTicket];\n    \n    [self.ticketLock unlock];\n}\n\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### NSLock 实现原理\n\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSLock 的具体实现：\n```\n......\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 尝试加锁，返回YES表示加锁成功\n- (BOOL)tryLock;\n/// 尝试加锁，返回YES表示加锁成功，在终止时间（limt）前处于加锁状态，到了时间后，会自动解锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n  static BOOL\tbeenHere = NO;\n\n    if (beenHere == NO)\n    {\n        beenHere = YES;\n\n        pthread_mutexattr_init(&attr_normal);\n        pthread_mutexattr_settype(&attr_normal, PTHREAD_MUTEX_NORMAL);\n        pthread_mutexattr_init(&attr_reporting);\n        pthread_mutexattr_settype(&attr_reporting, PTHREAD_MUTEX_ERRORCHECK);\n        pthread_mutexattr_init(&attr_recursive);\n        pthread_mutexattr_settype(&attr_recursive, PTHREAD_MUTEX_RECURSIVE);\n\n        pthread_mutex_init(&deadlock, &attr_normal);\n        pthread_mutex_lock(&deadlock);\n\n        baseConditionClass = [NSCondition class];\n        baseConditionLockClass = [NSConditionLock class];\n        baseLockClass = [NSLock class];\n        baseRecursiveLockClass = [NSRecursiveLock class];\n\n        tracedConditionClass = [GSTracedCondition class];\n        tracedConditionLockClass = [GSTracedConditionLock class];\n        tracedLockClass = [GSTracedLock class];\n        tracedRecursiveLockClass = [GSTracedRecursiveLock class];\n\n        untracedConditionClass = [GSUntracedCondition class];\n        untracedConditionLockClass = [GSUntracedConditionLock class];\n        untracedLockClass = [GSUntracedLock class];\n        untracedRecursiveLockClass = [GSUntracedRecursiveLock class];\n    }\n}\n\nMDEALLOC\nMDESCRIPTION\nMFINALIZE\n\n/* Use an error-checking lock.  This is marginally slower, but lets us throw\n * exceptions when incorrect locking occurs.\n */\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_mutex_init(&_mutex, &attr_reporting))\n        {\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\n......\n```\n\n## NSRecursiveLock\n\nNSRecursiveLock 是对 mutex 递归锁的封装，API 跟 NSLock 基本一致。\n\n### 常用API\n```\n/// 初始化\nNSRecursiveLock *lock = [[NSRecursiveLock alloc] init];\n/// 加锁\n[lock lock];\n/// 解锁\n[lock unlock];\n```\n\n### 应用 - 递归调用\n```\n@interface NSRecursiveLockDemo()\n@property (nonatomic, strong) NSRecursiveLock *lock;\n@end\n\n@implementation NSRecursiveLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lock = [[NSRecursiveLock alloc] init];\n    }\n    return self;\n}\n\n- (void)test\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n    [self test];\n    \n    [self.lock unlock];\n}\n@end\n```\n\n打印结果：\n```\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n......\n```\n\n### 应用 - 方法间调用\n```\n@interface NSRecursiveLockDemo()\n@property (nonatomic, strong) NSRecursiveLock *lock;\n@end\n\n@implementation NSRecursiveLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lock = [[NSRecursiveLock alloc] init];\n    }\n    return self;\n}\n\n- (void)test\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n    [self test2];\n    \n    [self.lock unlock];\n}\n\n- (void)test2\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n   [self.lock unlock];\n}\n@end\n```\n\n打印结果：\n```\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test2]\n```\n\n### NSRecursiveLock 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSRecursiveLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSRecursiveLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 尝试加锁，返回YES表示加锁成功\n- (BOOL)tryLock;\n/// 尝试加锁，返�������������������������YES表示加锁成功，在终止时间（limt）前处于加锁状态，到了终止时间会自动解锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\nstatic pthread_mutexattr_t attr_recursive;\n\n@implementation NSRecursiveLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseRecursiveLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedRecursiveLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\nMDEALLOC\nMDESCRIPTION\nMFINALIZE\n\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_mutex_init(&_mutex, &attr_recursive))\n        {\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\nMISLOCKED\nMLOCK\nMLOCKBEFOREDATE\nMNAME\nMSTACK\nMTRYLOCK\nMUNLOCK\n@end\n```\n\n因为 NSRecursiveLock 是在 lock.m 文件定义的，所以 `- (id)init` 方法里的 attr_recursive 属性是在 `+ (void)initialize` 方法👆里创建好的：\n```\npthread_mutexattr_init(&attr_recursive);\npthread_mutexattr_settype(&attr_recursive, PTHREAD_MUTEX_RECURSIVE);\n```\n\n## NSCondition\nNSCondition 是对 mutex 和 cond 的封装。\n\n### 相关API\n```\n/// 初始化\nNSCondition *condition = [[NSCondition alloc] init];\n/// 加锁\n[condition lock];\n/// 解锁\n[condition unlock];\n/// 等待\n[condition wait];\n/// 发信号\n[condition signal];\n```\n\n### 应用\n```\n@interface NSConditionDemo()\n@property (nonatomic, strong) NSCondition *condition;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation NSConditionDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.condition = [[NSCondition alloc] init];\n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(remove) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(add) object:nil] start];\n}\n\n- (void)remove\n{\n    [self.condition lock];\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    if (self.data.count == 0) {\n        NSLog(@\"%s, 等待信号\", __func__);\n        [self.condition wait];\n        NSLog(@\"%s, 收到信号\", __func__);\n    }\n    \n    [self.data removeLastObject];\n    NSLog(@\"%s, 删除\", __func__);\n    \n    [self.condition unlock];\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n- (void)add\n{\n    [self.condition lock];\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    [self.data addObject:@\"test\"];\n    NSLog(@\"%s, 添加\", __func__);\n    \n    [self.condition signal];\n    NSLog(@\"%s, 发送信号\", __func__);\n    \n    [self.condition unlock];\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n@end\n```\n\n打印结果：\n```\n14:30:32.001876+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 上锁\n14:30:32.002080+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 等待信号\n14:30:34.002046+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 上锁\n14:30:34.002227+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 添加\n14:30:34.002313+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 发送信号\n14:30:34.002384+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 解锁\n14:30:34.002395+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 收到信号\n14:30:34.002470+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 删除\n14:30:34.002556+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 解锁\n```\n\n### NSCondition 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSRecursiveLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSCondition : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n/// 添加等待，收到了 signal 就会唤醒线程\n- (void)wait;\n/// 等待条件（进入休眠，解锁；被唤醒后，加锁）。在终止时间（limt）前收到了 signal 就会唤醒线程。当到达终止时间的时候，即使没有收到 signal，也会直接唤醒线程\n- (BOOL)waitUntilDate:(NSDate *)limit;\n/// 激活一个等待该条件的线程\n- (void)signal;\n/// 激活所有等待该条件的线程\n- (void)broadcast;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSCondition\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseConditionClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedConditionClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\n- (void) broadcast\n{\n    pthread_cond_broadcast(&_condition);\n}\n\nMDEALLOC\nMDESCRIPTION\n\n- (void) finalize\n{\n    pthread_cond_destroy(&_condition);\n    pthread_mutex_destroy(&_mutex);\n}\n\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_cond_init(&_condition, NULL))\n        {\n            DESTROY(self);\n        }\n        else if (0 != pthread_mutex_init(&_mutex, &attr_reporting))\n        {\n            pthread_cond_destroy(&_condition);\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\nMISLOCKED\nMLOCK\nMLOCKBEFOREDATE\nMNAME\n\n- (void) signal\n{\n    pthread_cond_signal(&_condition);\n}\n\nMSTACK\nMTRYLOCK\nMUNLOCK\n\n- (void) wait\n{\n    pthread_cond_wait(&_condition, &_mutex);\n}\n\n- (BOOL) waitUntilDate: (NSDate*)limit\n{\n    NSTimeInterval ti = [limit timeIntervalSince1970];\n    double secs, subsecs;\n    struct timespec timeout;\n    int retVal = 0;\n\n    // Split the float into seconds and fractions of a second\n    subsecs = modf(ti, &secs);\n    timeout.tv_sec = secs;\n    // Convert fractions of a second to nanoseconds\n    timeout.tv_nsec = subsecs * 1e9;\n\n    /* NB. On timeout the lock is still held even through condition is not met\n    */\n\n    retVal = pthread_cond_timedwait(&_condition, &_mutex, &timeout);\n    if (retVal == 0)\n    {\n        return YES;\n    }\n    if (retVal == ETIMEDOUT)\n    {\n        return NO;\n    }\n    if (retVal == EINVAL)\n    {\n        NSLog(@\"Invalid arguments to pthread_cond_timedwait\");\n    }\n    return NO;\n}\n\n@end\n```\n\n## NSConditionLock\n\nNSConditionLock 是对 NSCondition 的进一步封装，可以设置具体的条件值。\n\n### 相关API\n```\n/// 初始化锁，设置锁的条件1\nNSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:1];\n/// 如果条件为1就加锁\n[conditionLock lockWhenCondition:1];\n/// 解锁，并设置条件为2\n[conditionLock unlockWithCondition:2];\n```\n\n### 应用\n```\n@interface NSConditionLockDemo()\n@property (nonatomic, strong) NSConditionLock *conditionLock;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation NSConditionLockDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.conditionLock = [[NSConditionLock alloc] initWithCondition:1];\n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(one) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(two) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(three) object:nil] start];\n}\n\n- (void)one\n{\n    /// 如果条件等于1，继续往下执行\n    [self.conditionLock lockWhenCondition:1];\n    \n    NSLog(@\"1\");\n    \n    /// 解锁，设置条件为2\n    [self.conditionLock unlockWithCondition:2];\n}\n\n- (void)two\n{\n    /// 如果条件等于2，继续往下执行\n    [self.conditionLock lockWhenCondition:2];\n    \n    NSLog(@\"2\");\n    \n    /// 解锁，设置条件为3\n    [self.conditionLock unlockWithCondition:3];\n}\n\n- (void)three\n{\n    /// 如果条件等于3，继续往下执行\n    [self.conditionLock lockWhenCondition:3];\n    \n    NSLog(@\"3\");\n    \n    /// 解锁，设置条件为4\n    [self.conditionLock unlockWithCondition:4];\n}\n@end\n```\n\n打印结果：\n```\n16:04:40.425810+0800 多线程安全隐患[28831:334816] 1\n16:04:42.426001+0800 多线程安全隐患[28831:334904] 2\n16:04:44.426143+0800 多线程安全隐患[28831:334908] 3\n```\n\n可以看到 NSConditionLock 可以给线程之间设置优先级。\n\n如果使用 `-(void)lock` 方法只会判断锁是否处于加锁状态，如果不是就直接加锁，不会判断条件。\n\n### NSConditionLock 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSConditionLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@interface NSConditionLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 初始化\n- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;\n/// 条件\n@property (readonly) NSInteger condition;\n/// 如果条件成立就加锁\n- (void)lockWhenCondition:(NSInteger)condition;\n/// 尝试加锁，成功返回YES\n- (BOOL)tryLock;\n/// 如果条件成立就尝试加锁，成功返回YES\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n/// 解锁并设置条件\n- (void)unlockWithCondition:(NSInteger)condition;\n/// 在终止时间前加锁，成功返回YES\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n/// 在终止时间前，如果条件成立就加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSConditionLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseConditionLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedConditionLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\n- (NSInteger) condition\n{\n    return _condition_value;\n}\n\n- (void) dealloc\n{\n    [_name release];\n    [_condition release];\n    [super dealloc];\n}\n\n- (id) init\n{\n    return [self initWithCondition: 0];\n}\n\n- (id) initWithCondition: (NSInteger)value\n{\n    if (nil != (self = [super init]))\n    {\n        if (nil == (_condition = [NSCondition new]))\n        {\n            DESTROY(self);\n        }\n        else\n        {\n            _condition_value = value;\n            [_condition setName:[NSString stringWithFormat: @\"condition-for-lock-%p\", self]];\n        }\n    }\n    return self;\n}\n\n- (BOOL) isLockedByCurrentThread\n{\n    return [_condition isLockedByCurrentThread];\n}\n\n- (void) lock\n{\n    [_condition lock];\n}\n\n- (BOOL) lockBeforeDate: (NSDate*)limit\n{\n    return [_condition lockBeforeDate: limit];\n}\n\n- (void) lockWhenCondition: (NSInteger)value\n{\n    [_condition lock];\n    while (value != _condition_value)\n    {\n        [_condition wait];\n    }\n}\n\n- (BOOL) lockWhenCondition: (NSInteger)condition_to_meet\n                beforeDate: (NSDate*)limitDate\n{\n    if (NO == [_condition lockBeforeDate: limitDate])\n    {\n        return NO;        // Not locked\n    }\n    if (condition_to_meet == _condition_value)\n    {\n        return YES;       // Keeping the lock\n    }\n    while ([_condition waitUntilDate: limitDate])\n    {\n        if (condition_to_meet == _condition_value)\n        {\n            return YES;   // Keeping the lock\n        }\n    }\n    [_condition unlock];\n    return NO;            // Not locked\n}\n\nMNAME\nMSTACK\n\n- (BOOL) tryLock\n{\n    return [_condition tryLock];\n}\n\n- (BOOL) tryLockWhenCondition: (NSInteger)condition_to_meet\n{\n    if ([_condition tryLock])\n    {\n        if (condition_to_meet == _condition_value)\n        {\n            return YES; // KEEP THE LOCK\n        }\n        else\n        {\n            [_condition unlock];\n        }\n    }\n    return NO;\n}\n\n- (void) unlock\n{\n    [_condition unlock];\n}\n\n- (void) unlockWithCondition: (NSInteger)value\n{\n    _condition_value = value;\n    [_condition broadcast];\n    [_condition unlock];\n}\n\n@end\n```\n\n## dispatch_semaphore\n\nsemaphore 叫做“信号量”。信号量的初始值，可以用来控制线程并发访问的最大数量。信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步。\n\n### 相关API\n```\n/// 初始化\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(5);\n/// 如果信号量的值 >= 0，就让信号量的值减1，然后继续往下执行代码\n/// 如果信号量的值 <= 0，就会休眠等待；当信号量的值变成 >0 时，就让信号量的值减1，然后继续往下执行代码\n/// DISPATCH_TIME_FOREVER 表示一直在这里等待信号量变成 >0；DISPATCH_TIME_NOW 判断完后不管信号量的值是否 >0 都继续往下执行\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n/// 让信号量的值+1\ndispatch_semaphore_signal(semaphore);\n```\n\n### 应用 - 控制最大并发数量\n```\n@interface SemaphoreDemo()\n@property (nonatomic, strong) dispatch_semaphore_t semaphore;\n@end\n\n@implementation SemaphoreDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.semaphore = dispatch_semaphore_create(5);\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    for (int i=0; i < 20; i++) {\n        [[[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil] start];\n    }\n}\n\n- (void)test\n{\n    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n    \n    sleep(2);\n    NSLog(@\"test - %@\", [NSThread currentThread]);\n    \n    dispatch_semaphore_signal(self.semaphore);\n}\n@end\n```\n\n打印结果：\n```\n10:16:19.552038+0800 多线程安全隐患[10797:47431] test - <NSThread: 0x600002deb640>{number = 6, name = (null)}\n10:16:19.552041+0800 多线程安全隐患[10797:47434] test - <NSThread: 0x600002deb880>{number = 9, name = (null)}\n10:16:19.552076+0800 多线程安全隐患[10797:47441] test - <NSThread: 0x600002deba40>{number = 16, name = (null)}\n10:16:19.552043+0800 多线程安全隐患[10797:47433] test - <NSThread: 0x600002deb600>{number = 8, name = (null)}\n10:16:19.552082+0800 多线程安全隐患[10797:47435] test - <NSThread: 0x600002deb8c0>{number = 10, name = (null)}\n10:16:21.552319+0800 多线程安全隐患[10797:47445] test - <NSThread: 0x600002debb40>{number = 20, name = (null)}\n10:16:21.552317+0800 多线程安全隐患[10797:47432] test - <NSThread: 0x600002deb800>{number = 7, name = (null)}\n10:16:21.552447+0800 多线程安全隐患[10797:47439] test - <NSThread: 0x600002deb9c0>{number = 14, name = (null)}\n10:16:21.552460+0800 多线程安全隐患[10797:47438] test - <NSThread: 0x600002deb980>{number = 13, name = (null)}\n10:16:21.552463+0800 多线程安全隐患[10797:47449] test - <NSThread: 0x600002df16c0>{number = 24, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47436] test - <NSThread: 0x600002deb900>{number = 11, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47443] test - <NSThread: 0x600002debac0>{number = 18, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47444] test - <NSThread: 0x600002debb00>{number = 19, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47450] test - <NSThread: 0x600002da8380>{number = 25, name = (null)}\n10:16:24.476004+0800 多线程安全隐患[10797:47446] test - <NSThread: 0x600002debb80>{number = 21, name = (null)}\n10:16:26.476651+0800 多线程安全隐患[10797:47437] test - <NSThread: 0x600002deb940>{number = 12, name = (null)}\n10:16:26.476652+0800 多线程安全隐患[10797:47448] test - <NSThread: 0x600002debc00>{number = 23, name = (null)}\n10:16:26.476658+0800 多线程安全隐患[10797:47447] test - <NSThread: 0x600002debbc0>{number = 22, name = (null)}\n10:16:26.476660+0800 多线程安全隐患[10797:47442] test - <NSThread: 0x600002deba80>{number = 17, name = (null)}\n10:16:26.476658+0800 多线程安全隐患[10797:47440] test - <NSThread: 0x600002deba00>{number = 15, name = (null)}\n```\n\n从打印结果可以看到，一共执行了4次，每次5条线程。这是因为初始化 semaphore 的条件是5，每调用一次 `dispatch_semaphore_wait` 会减1，减5次等于0后就不在执行其它线程了。每调用一次 `dispatch_semaphore_signal` 会加1，就会有新的线程开始调用 `dispatch_semaphore_wait` 对条件减1。 \n\n### 应用 - 解决卖票和存钱取钱问题\n```\n@interface SemaphoreDemo()\n@property (nonatomic, strong) dispatch_semaphore_t moneySemaphore;\n@property (nonatomic, strong) dispatch_semaphore_t ticketSemaphore;\n@end\n\n@implementation SemaphoreDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneySemaphore = dispatch_semaphore_create(1);\n        self.ticketSemaphore = dispatch_semaphore_create(1);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __drawMoney];\n    \n    dispatch_semaphore_signal(self.moneySemaphore);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __saveManey];\n    \n    dispatch_semaphore_signal(self.moneySemaphore);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    dispatch_semaphore_wait(self.ticketSemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __saleTicket];\n    \n    dispatch_semaphore_signal(self.ticketSemaphore);\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### dispatch_semaphore 汇编分析\n\n查看方式与 “OSSpinLock 汇编分析” 相同。可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 9 对信号量减1。第二次调用 `- (void)__saleTicket` 方法是在 Thread 11，因为此时的信号量等于0，所以 Thread 15 处于等待信号量变成 >0 的状态。重复执行 `si` 指令，到第16行时会调用 `dispatch_semaphore_wait` 函数：\n![多线程33](多线程/多线程33.png)\n执行 `si` 指令，进入 `dispatch_semaphore_wait` 函数：\n![多线程34](多线程/多线程34.png)\n执行 `si` 指令，进入 `dispatch_semaphore_wait_slow` 函数：\n![多线程35](多线程/多线程35.png)\n重复执行 `si` 指令，在第35行，进入 `_dispatch_sema4_wait` 函数：\n![多线程36](多线程/多线程36.png)\n重复执行 `si` 指令，在第8行，调用 `semaphore_wait` 函数：\n![多线程37](多线程/多线程37.png)\n执行 `si` 指令，进入 `semaphore_wait` 函数：\n![多线程38](多线程/多线程38.png)\n执行 `si` 指令，进入 `semaphore_wait_trap` 函数：\n![多线程39](多线程/多线程39.png)\n重复执行 `si` 指令，在第4行，调用 `syscall` 函数。`syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎 互斥锁标志）：\n![多线程40](多线程/多线程40.png)\n\n## dispatch_queue\n\n直接使用 GCD 的串行队列，也是可以实现线程同步的。因为线程同步的本质就是保证多条线程按顺序执行任务，所以串行队列可以通过控制执行顺序来实现线程同步。\n\n解决卖票和存钱取钱问题：\n```\n@interface SerialQueueDemo()\n@property (nonatomic, strong) dispatch_queue_t moneyQueue;\n@property (nonatomic, strong) dispatch_queue_t ticketQueue;\n@end\n\n@implementation SerialQueueDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyQueue = dispatch_queue_create(\"moneyQueue\", nil);\n        self.ticketQueue = dispatch_queue_create(\"ticketQueue\", nil);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    dispatch_sync(self.moneyQueue, ^{\n       [super __drawMoney];\n    });\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    dispatch_sync(self.moneyQueue, ^{\n       [super __saveManey];\n    });\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    dispatch_sync(self.ticketQueue, ^{\n       [super __saleTicket];\n    });\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n## @synchronized\n`@synchronized` 是对 mutex 递归锁的封装，`@synchronized(obj)` 内部会生成 obj 对应的递归锁，然后进行加锁、解锁操作。源码查看：[objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 objc-sync.mm 文件。\n\n### 解决卖票和存钱取钱问题\n\n为了解决不同对象调用的问题，存钱取钱的 `@synchronized()` 传入的是类对象 `[self class]`，卖票传入的是一个全局唯一的 NSObject 对象：\n```\n@implementation SynchronizeDemo\n\n///取钱\n- (void)__drawMoney\n{\n    @synchronized ([self class]) {\n        [super __drawMoney];\n    }\n}\n\n///存钱\n- (void)__saveManey\n{\n    @synchronized ([self class]) { /// 断点1\n        [super __saveManey];\n    }\n}\n\n///卖票\n- (void)__saleTicket\n{\n    static NSObject *object;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        object = [[NSObject alloc] init];\n    });\n    @synchronized (object) {\n        [super __saleTicket];\n    }\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### @synchronized 实现原理\n\n在断点1处查看汇编代码 Debug -> Debug Workflow -> Always Show Disassembly：\n![多线程32](多线程/多线程32.png)\n\n可以看到 `@synchronized()` 在开始和结束分别调用了 `objc_sync_enter()` 和 `objc_sync_exit()`，即：\n```\n///存钱\n- (void)__saveManey\n{\n    @synchronized ([self class]) { /// objc_sync_enter()\n        [super __saveManey];\n    } /// objc_sync_exit()\n}\n```\n\n源码查看：[objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 objc-sync.mm 文件\n```\n/// 加锁\nint objc_sync_enter(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE); /// 以 obj 为key，从哈希表里获取到对应的 spinlock_t\n        ASSERT(data);\n        data->mutex.lock(); /// 调用 mutex 上锁\n    } else {\n        // @synchronized(nil) does nothing\n        if (DebugNilSync) {\n            _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\");\n        }\n        objc_sync_nil();\n    }\n\n    return result;\n}\n\n/// 尝试加锁\nBOOL objc_sync_try_enter(id obj)\n{\n    BOOL result = YES;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE);\n        ASSERT(data);\n        result = data->mutex.tryLock();\n    } else {\n        // @synchronized(nil) does nothing\n        if (DebugNilSync) {\n            _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\");\n        }\n        objc_sync_nil();\n    }\n\n    return result;\n}\n\n/// 解锁\nint objc_sync_exit(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n    \n    if (obj) {\n        SyncData* data = id2data(obj, RELEASE); \n        if (!data) {\n            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n        } else {\n            bool okay = data->mutex.tryUnlock(); /// 调用 mutex 解锁\n            if (!okay) {\n                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n            }\n        }\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\n    return result;\n}\n```\n\n`SyncData` 实现：\n```\ntypedef struct alignas(CacheLineSize) SyncData {\n    struct SyncData* nextData;\n    DisguisedPtr<objc_object> object;\n    int32_t threadCount;  // number of THREADS using this block\n    recursive_mutex_t mutex; /// 对 os_unfair_recursive_lock 锁的封装👇\n} SyncData;\n\n#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock\n#define LIST_FOR_OBJ(obj) sDataLists[obj].data\n\nstatic SyncData* id2data(id object, enum usage why)\n{\n    spinlock_t *lockp = &LOCK_FOR_OBJ(object);\n    SyncData **listp = &LIST_FOR_OBJ(object);\n    SyncData* result = NULL;\n\n    ......\n}\n```\n\n`recursive_mutex_tt` 实现：\n```\nclass recursive_mutex_tt : nocopy_t {\n    os_unfair_recursive_lock mLock;\n\n  public:\n    constexpr recursive_mutex_tt() : mLock(OS_UNFAIR_RECURSIVE_LOCK_INIT) { /// 静态初始化方法，递归锁\n        lockdebug_remember_recursive_mutex(this);\n    }\n\n    constexpr recursive_mutex_tt(const fork_unsafe_lock_t unsafe)\n        : mLock(OS_UNFAIR_RECURSIVE_LOCK_INIT)\n    { }\n\n    void lock()\n    {\n        lockdebug_recursive_mutex_lock(this);\n        os_unfair_recursive_lock_lock(&mLock);\n    }\n\n    void unlock()\n    {\n        lockdebug_recursive_mutex_unlock(this);\n\n        os_unfair_recursive_lock_unlock(&mLock);\n    }\n\n    void forceReset()\n    {\n        lockdebug_recursive_mutex_unlock(this);\n\n        bzero(&mLock, sizeof(mLock));\n        mLock = os_unfair_recursive_lock OS_UNFAIR_RECURSIVE_LOCK_INIT;\n    }\n\n    bool tryLock()\n    {\n        if (os_unfair_recursive_lock_trylock(&mLock)) {\n            lockdebug_recursive_mutex_lock(this);\n            return true;\n        }\n        return false;\n    }\n\n    bool tryUnlock()\n    {\n        if (os_unfair_recursive_lock_tryunlock4objc(&mLock)) {\n            lockdebug_recursive_mutex_unlock(this);\n            return true;\n        }\n        return false;\n    }\n\n    void assertLocked() {\n        lockdebug_recursive_mutex_assert_locked(this);\n    }\n\n    void assertUnlocked() {\n        lockdebug_recursive_mutex_assert_unlocked(this);\n    }\n};\n```\n\n因为从源码中看到锁在初始化时传入的是 `OS_UNFAIR_RECURSIVE_LOCK_INIT`，所以 `@synchronized()` 其实就是一个递归锁。\n\n验证：\n```\n- (void)otherTest\n{\n    @synchronized (self) {\n        NSLog(@\"%s\", __func__);\n        [self otherTest];\n    }\n}\n```\n\n打印结果：\n```\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n......\n```\n\n# iOS线程同步方案性能比较\n\n性能从高到低排序\n* os_unfair_lock\n* OSSpinLock\n* dispatch_semaphore\n* pthread_mutex\n* dispatch_queue(DISPATCH_QUEUE_SERIAL)\n* NSLock\n* NSCondition\n* pthread_mutex(recursive)\n* NSRecursiveLock\n* NSConditionLock\n* @synchronized\n\n推荐使用\n* dispatch_semaphore\n* pthread_mutex\n\n## dispatch_semaphore\n不同方法使用 `dispatch_semaphore` 实现线程同步，每个方法都需要一把属于自己的锁，可以这样实现：\n```\n/// 加锁\n#define SemaphoreBegin \\\nstatic dispatch_semaphore_t semaphore; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    semaphore = dispatch_semaphore_create(1); \\\n}); \\\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n/// 解锁\n#define SemaphoreEnd \\\ndispatch_semaphore_signal(semaphore);\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n\n- (void)test2 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n\n- (void)test3 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController test1]\n-[ViewController test2]\n-[ViewController test3]\n```\n\n## pthread_mutex\n```\n#define PthreadMutexBegain \\\nstatic pthread_mutex_t mutex; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    pthread_mutex_init(&mutex, NULL); \\\n}); \\\npthread_mutex_lock(&mutex);\n\n#define PthreadMutexEnd \\\npthread_mutex_unlock(&mutex);\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n\n- (void)test2 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n\n- (void)test3 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController test1]\n-[ViewController test2]\n-[ViewController test3]\n```\n\n## 自旋锁、互斥锁比较\n\n* 什么情况使用自旋锁比较划算？  \n预计线程等待锁的时间很短；（线程1加锁后处理的事情很少，线程2不需要等太多时间，就没必要去休眠，只通过一个while循环稍微等一下就好）  \n加锁的代码（临界区）经常被调用，但竞争情况很少发生；（对于多条线程同时调用临界区的情况很少，而且临界区的调用比较频繁，使用自旋锁效率会更高）  \nCPU资源不紧张；（自旋锁的优点是效率高，缺点是一直占用CPU资源，如果CPU资源不紧张，比如多核，就可以忽略自旋锁的缺点）  \n多核处理器；\n\n* 什么情况使用互斥锁比较划算？  \n预计线程等待锁的时间较长；（线程1加锁后处理的事情很多，比如需要耗时2~3秒，此时自旋锁效率高的优点也没啥用了，不如让线程2去休眠，这样也减少了CPU资源的占用）  \n单核处理器；（这种情况以节省CPU资源为主，尽量不去占用CPU资源）  \n临界区有IO操作；（因为IO操作是比较占用CPU资源的，所以这种情况以节省CPU资源为主）  \n临界区代码复杂或者循环量大；（因为这种情况比较耗时，所以忽略效率比较高的自旋锁，选择节省CPU资源的互斥锁）  \n临界区竞争非常激烈；（很多线程会同事调用临界区的代码，为了节省CPU资源，选择互斥锁）\n\n## atomic\natom：原子，不可再分割的单位。atomic：原子性，用于保证属性 setter、getter 的原子性操作，相当于在 getter 和 setter 内部加了线程同步的锁。\n\n打开源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 objc-accessors.mm 文件，查看 setter 和 getter 方法 的实现：\n```\n/// setter 方法\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        /// 非原子性的不加锁\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        /// 原子性的要加锁\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n\n/// getter 方法\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    id *slot = (id*) ((char*)self + offset);\n    /// 非原子性的不加锁\n    if (!atomic) return *slot;\n        \n    /// 原子性的要加锁\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();\n    id value = objc_retain(*slot);\n    slotlock.unlock();\n    \n    return objc_autoreleaseReturnValue(value);\n}\n```\n\naotmic 并不能保证使用属性的过程是线程安全的：\n```\n@interface ViewController ()\n@property (atomic, copy) NSMutableArray *data;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.data = [NSMutableArray array];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    [self.data addObject:@\"test1\"];\n}\n\n- (void)test2 {\n    [self.data addObject:@\"test2\"];\n}\n\n- (void)test3 {\n    [self.data addObject:@\"test3\"];\n}\n```\n\n上面这段代码中 data 是原子性的，所以 `self.data` 是线程安全的，但是 `addObject` 不是线程安全的，需要单独加锁：\n```\n- (void)test1 {\n    /// 加锁\n    [self.data addObject:@\"test1\"];\n    /// 解锁\n}\n\n- (void)test2 {\n    /// 加锁\n    [self.data addObject:@\"test2\"];\n    /// 解锁\n}\n\n- (void)test3 {\n    /// 加锁\n    [self.data addObject:@\"test3\"];\n    /// 解锁\n}\n```\n\n# iOS中的读写安全方案\n\n* 思考如何实现以下场景  \n  同一时间，只能有1个线程进行写的操作；  \n  同一时间，允许有多个线程进行读的操作；  \n  同一时间，不允许既有写的操作，又有读的操作；  \n\n上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有 `pthread_rwlock`（读写锁）和 `dispatch_barrier_async`（异步栅栏调用）。\n\n## pthread_rwlock\n\n### 相关API：\n```\n/// 初始化\npthread_rwlock_t lock;\npthread_rwlock_init(&lock, NULL);\n/// 读-加锁\npthread_rwlock_rdlock(&lock);\n/// 读-尝试加锁\npthread_rwlock_tryrdlock(&lock);\n/// 写-加锁\npthread_rwlock_wrlock(&lock);\n/// 写-尝试加锁\npthread_rwlock_trywrlock(&lock);\n/// 解锁\npthread_rwlock_unlock(&lock);\n/// 销毁\npthread_rwlock_destroy(&lock);\n```\n\n ### 应用\n ```\n@interface ViewController ()\n@property (nonatomic, assign) pthread_rwlock_t lock;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    /// 初始化\n    pthread_rwlock_init(&_lock, NULL);\n    \n    for (int i=0; i < 5; i++) {\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            [self read];\n        });\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            [self write];\n        });\n    }\n}\n\n- (void)read\n{\n    pthread_rwlock_rdlock(&_lock);\n    \n    NSLog(@\"%s\", __func__);\n    sleep(2);\n    \n    pthread_rwlock_unlock(&_lock);\n}\n\n- (void)write\n{\n    pthread_rwlock_wrlock(&_lock);\n    \n    NSLog(@\"%s\", __func__);\n    sleep(2);\n    \n    pthread_rwlock_unlock(&_lock);\n}\n\n- (void)dealloc\n{\n    pthread_rwlock_destroy(&_lock);\n}\n@end\n ```\n\n 打印结果：\n ```\n10:57:24.915613+0800 多线程安全隐患[3171:66309] -[ViewController read]\n10:57:24.915613+0800 多线程安全隐患[3171:66290] -[ViewController read]\n10:57:26.918756+0800 多线程安全隐患[3171:66295] -[ViewController write]\n10:57:28.921411+0800 多线程安全隐患[3171:66308] -[ViewController write]\n10:57:30.924043+0800 多线程安全隐患[3171:66299] -[ViewController read]\n10:57:32.927292+0800 多线程安全隐患[3171:66291] -[ViewController write]\n10:57:34.927716+0800 多线程安全隐患[3171:66327] -[ViewController read]\n10:57:36.930458+0800 多线程安全隐患[3171:66328] -[ViewController write]\n10:57:38.934914+0800 多线程安全隐患[3171:66329] -[ViewController read]\n10:57:40.940214+0800 多线程安全隐患[3171:66330] -[ViewController write]\n ```\n\n 从打印结果可以看到，read 和 read 操作之间存在同时被打印的情况，但是 read 和 write 操作、write 和 write 操作之间不存在同时被打印的情况。\n\n ## dispatch_barrier_async\n\n这个函数传入的并发队列必须是自己通过 `dispatch_queue_cretate` 创建的，如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于 `dispatch_async` 函数的效果。\n\n`dispatch_barrier_async` 方法能够保证当前只有这一个临界区在执行，就可以实现在写的时候，没有其它写操作和读操作。\n\n ### 相关API\n ```\n/// 初始化队列\ndispatch_queue_t queue = dispatch_queue_create(\"rw_queue\", DISPATCH_QUEUE_CONCURRENT);\n\n/// 读\ndispatch_async(queue, ^{\n    \n});\n\n/// 写\ndispatch_barrier_async(queue, ^{\n    \n});\n ```\n\n ### 应用\n ```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_queue_t queue;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.queue = dispatch_queue_create(\"rw_queue\", DISPATCH_QUEUE_CONCURRENT);\n    for (int i=0; i<5; i++) {\n        [self read];\n        [self read];\n        [self read];\n        [self write];\n        [self write];\n        [self write];\n    }\n}\n\n- (void)read\n{\n    dispatch_async(self.queue, ^{\n        NSLog(@\"read\");\n        sleep(2);\n    });\n}\n\n- (void)write\n{\n    dispatch_barrier_async(self.queue, ^{\n        NSLog(@\"write\");\n        sleep(2);\n    });\n}\n@end\n ```\n\n 打印结果：\n ```\n11:29:28.216697+0800 多线程安全隐患[3903:86003] read\n11:29:28.216708+0800 多线程安全隐患[3903:85991] read\n11:29:28.216724+0800 多线程安全隐患[3903:85989] read\n11:29:30.218087+0800 多线程安全隐患[3903:86003] write\n11:29:32.222250+0800 多线程安全隐患[3903:86003] write\n11:29:34.226490+0800 多线程安全隐患[3903:86003] write\n11:29:36.231180+0800 多线程安全隐患[3903:86003] read\n11:29:36.231210+0800 多线程安全隐患[3903:85983] read\n11:29:36.231265+0800 多线程安全隐患[3903:86132] read\n11:29:38.232286+0800 多线程安全隐患[3903:86003] write\n11:29:40.232572+0800 多线程安全隐患[3903:86003] write\n11:29:42.232894+0800 多线程安全隐患[3903:86003] write\n......\n ```\n\n 从打印结果可以看到，read 操作是可以同时进行的，write 操作只能一个一个执行。\n\n# 总结\n\n## 你理解的多线程？  \n  通过多线程可以处理耗时任务，减少主线程的压力。  \n  通过多线程可以处理一个复杂任务的不同部分，充分利用CPU资源，提升效率。  \n  多线程意味着你能够在同一个应用程序中运行多个线程，多线程应用程序就像是具有多个 CPU 在同时执行应用程序的代码。其实这是一种假象，线程数量并不等于 CPU 数量，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行。\n  ![多线程41](多线程/多线程41.png)\n\n## iOS的多线程方案有哪几种？你更倾向于哪一种？  \n\n### 性能从高到低排序\nos_unfair_lock  \nOSSpinLock  \ndispatch_semaphore  \npthread_mutex  \ndispatch_queue(DISPATCH_QUEUE_SERIAL)  \nNSLock  \nNSCondition  \npthread_mutex(recursive)  \nNSRecursiveLock  \nNSConditionLock  \n@synchronized\n\n### 推荐使用  \ndispatch_semaphore  \npthread_mutex\n\n## 你在项目中用过 GCD 吗？  \n### 回到主线程\n```\n- (void)action\n{\n    if (![NSThread isMainThread]) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self action];\n            return;\n        });\n    }\n}\n```\n\n### 等所有的网络请求结束后，再刷新UI\n```\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\ndispatch_queue_t queue = dispatch_queue_create(\"myRequestQueue\", NULL);\ndispatch_async(queue, ^{\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    /// 请求全部完成\n    dispatch_async(dispatch_get_main_queue(), ^{\n        /// 回到主线程刷新UI\n    });\n});\n\n/// 网络请求1\n[self.server request1Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n\n/// 网络请求2\n[self.server request2Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n\n/// 网络请求3\n[self.server request3Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n```\n\n### 延时执行\n```\n/// 延时5秒执行\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    /// 回到主线程执行 \n});\n```\n\n### 定时器\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n\n- (void)startTimer {\n\n    __weak typeof(self) weakSelf = self;\n    /// 初始化\n    _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n    /// 5秒后开始执行\n    dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));\n    /// 5秒执行一次\n    dispatch_source_set_timer(_timer, delayTime, 5.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n    dispatch_source_set_event_handler(_timer, ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf cancelTimer];\n        });\n    });\n    dispatch_resume(_timer);\n}\n\n- (void)cancelTimer {\n    if (_timer) {\n        dispatch_source_cancel(_timer);\n        _timer = nil;\n    }\n}\n@end\n```\n\n## GCD 的队列类型\nGCD的队列可以分为2大类型\n* 并发队列（Concurrent Dispatch Queue）  \n可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）；  \n并发功能只有在异步（dispatch_async）函数下才有效；\n\n* 串行队列（Serial Dispatch Queue）  \n让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）；\n\n主队列是一个特殊的串行队列，async 方法在主队列中添加任务不会开启新线程，并且是串行执行任务。\n\n## 说一下 OperationQueue 和 GCD 的区别，以及各自的优势\nOperationQueue 是对 GCD 的封装，更加面向对象。  \nGCD 相对于 OperationQueue 更加底层，效率更高。\n\n## 线程安全的处理手段有哪些？\n线程安全的处理是使用线程同步技术，包括加锁、信号量和串行队列。\n\n## OC你了解的锁有哪些？在你回答基础上进行二次提问；  \n\n性能从高到低排序：  \nos_unfair_lock  \nOSSpinLock  \ndispatch_semaphore  \npthread_mutex   \nNSLock  \nNSCondition  \npthread_mutex(recursive)  \nNSRecursiveLock  \nNSConditionLock  \n@synchronized\n\n### 追问一：自旋和互斥对比？\n* 什么情况使用自旋锁比较划算？  \n预计线程等待锁的时间很短；（线程1加锁后处理的事情很少，线程2不需要等太多时间，就没必要去休眠，只通过一个while循环稍微等一下就好）  \n加锁的代码（临界区）经常被调用，但竞争情况很少发生；（对于多条线程同时调用临界区的情况很少，而且临界区的调用比较频繁，使用自旋锁效率会更高）  \nCPU资源不紧张；（自旋锁的优点是效率高，缺点是一直占用CPU资源，如果CPU资源不紧张，比如多核，就可以忽略自旋锁的缺点）  \n多核处理器；\n\n* 什么情况使用互斥锁比较划算？  \n预计线程等待锁的时间较长；（线程1加锁后处理的事情很多，比如需要耗时2~3秒，此时自旋锁效率高的优点也没啥用了，不如让线程2去休眠，这样也减少了CPU资源的占用）  \n单核处理器；（这种情况以节省CPU资源为主，尽量不去占用CPU资源）  \n临界区有IO操作；（因为IO操作是比较占用CPU资源的，所以这种情况以节省CPU资源为主）  \n临界区代码复杂或者循环量大；（因为这种情况比较耗时，所以忽略效率比较高的自旋锁，选择节省CPU资源的互斥锁）  \n临界区竞争非常激烈；（很多线程会同事调用临界区的代码，为了节省CPU资源，选择互斥锁）\n\n### 追问二：使用以上锁需要注意哪些？  \n加锁后一定要解锁；  \n一个变量对应一个锁；  \n使用 `@synchronized(obj)` 传入的 obj 对象就相当于一个锁，如果有不同的对象调用临界区，可以使用类对象 `@synchronized([self class])`；  \n在使用 pthread_mutex_t、pthread_mutex_t 递归锁、pthread_mutex_t 条件 和 pthread_rwlock_t 锁时需要手动释放。\n\n### 追问三：用C/OC/C++，任选其一，实现自旋或互斥？\n参考上面的内容。\n\n## 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n\n- (void)test\n{\n    NSLog(@\"2\");\n}\n@end\n```\n\n上面有详解👆。\n\n## 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)test\n{\n    NSLog(@\"2\");\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSThread *thread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"1\");\n    }];\n    [thread start];\n    \n    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n上面有详解👆。\n\n\n[2w字 + 40张图带你参透并发编程！](https://juejin.im/post/6862464169158344717)\n\n","source":"_posts/OC底层原理/多线程.md","raw":"---\ntitle: 多线程\ndate: 2020-07-14 16:31:01\ntags: OC底层原理\n---\n\n思考：\n* 你理解的多线程？\n* iOS的多线程方案有哪几种？你更倾向于哪一种？\n* 你在项目中用过 GCD 吗？\n* GCD 的队列类型\n* 说一下 OperationQueue 和 GCD 的区别，以及各自的优势\n* 线程安全的处理手段有哪些？\n* OC你了解的锁有哪些？在你回答基础上进行二次提问；  \n追问一：自旋和互斥对比？  \n追问二：使用以上锁需要注意哪些？  \n追问三：用C/OC/C++，任选其一，实现自旋或互斥？\n<!-- more -->\n* 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n\n- (void)test\n{\n    NSLog(@\"2\");\n}\n@end\n```\n\n* 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)test\n{\n    NSLog(@\"2\");\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSThread *thread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"1\");\n    }];\n    [thread start];\n    \n    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n# GCD\n\n👉 [GCD源码](https://github.com/apple/swift-corelibs-libdispatch)\n\n## iOS中的常见多线程方案\n\n<!-- <style>\ntable th:nth-of-type(1){\n    width: 20%;\n}\ntable th:nth-of-type(2){\n    width: 25%;\n}\ntable th:nth-of-type(3){\n    width: 20%;\n}\ntable th:nth-of-type(4){\n    width: 20%;\n}\ntable th:nth-of-type(5){\n    width: 15%;\n}\n</style> -->\n\n| 技术方案 | 简介 | 语言 | 线程生命周期 | 使用频率 |\n| :--: | :-------- | :--: | :--: | :--: |\n| phread | 1.一套通用的多线程API；<br>2.适用于Unix\\Linux\\Windows等系统；<br>3.跨平台\\可移植；<br>4.使用难度大；| C | 开发者管理 | 几乎不用 |\n| NSThread | 1.使用更加面向对象；<br>2.简单易用，可直接操作线程对象； | OC | 开发者管理 | 偶尔使用 |\n| GCD | 1.旨在替代NSThread等多线程技术； | C | 自动管理 | 经常使用 |\n| NSOperation | 1.基于GCD（底层是GCD）；<br>2.比GCD多了一些更简单使用的功能；<br>3.使用更加面向对象； | OC | 自动管理 | 经常使用 |\n\nphread 在实际开发中几乎不会用到，一般只会在加锁解锁的地方用到。另外，NSThead、GCD 和 NSOperation 底层都会用到 phread，比如创建线程等。NSThread 就是对 phread 的包装。\n\n## GCD的常用函数\n\nGCD 中有2个用来执行任务的函数：\n* 用同步的方式执行任务（queue：队列；block：任务）  \n```\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n* 用异步的方式执行任务  \n```\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n队列相关函数：\n* 获取主队列\n```\ndispatch_queue_t queue = dispatch_get_main_queue();\n```\n\n* 获取全局并发队列\n```\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n```\n\n* 手动创建并发队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n* 手动创建串行队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"mySerialQueue\", DISPATCH_QUEUE_SERIAL);\n```\n\n* 手动创建队列组\n```\ndispatch_group_t group = dispatch_group_create();\n```\n\n## GCD的队列\n\nGCD的队列可以分为2大类型\n* 并发队列（Concurrent Dispatch Queue）  \n可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）；  \n并发功能只有在异步（dispatch_async）函数下才有效；\n\n* 串行队列（Serial Dispatch Queue）  \n让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）；\n\n## 容易混淆的术语\n\n有4个术语比较容易混淆：同步、异步、并发、串行\n* 同步和异步主要影响：能不能开启新的线程  \n同步：在当前线程中执行任务，不具备开启新线程的能力；  \n异步：在新的线程中执行任务，具备开启新线程的能力；\n\n* 并发和串行主要影响：任务的执行方式  \n并发：多个任务并发（同时）执行；  \n串行：一个任务执行完毕后，再执行下一个任务；\n\n## 各种队列的执行效果\n\n| &nbsp; | 并发队列 | 手动穿件的串行队列 | 主队列 |\n| :--: | :--: | :--: | :--: |\n| 同步（sync） | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |\n| 异步（async） | 有开启新线程<br>并发执行任务 | 有开启新线程<br>串行执行任务 | 没有开启新线程<br>串行执行任务 |\n\n使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）。\n\n主队列是一个特殊的串行队列，async 方法在主队列中添加任务不会开启新线程，并且是串行执行任务。\n\n### 并发队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n\n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600003595140>{number = 1, name = main}\n任务4 - <NSThread: 0x600003595140>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n执行任务3 - <NSThread: 0x6000035c1ec0>{number = 3, name = (null)}\n执行任务2 - <NSThread: 0x600003588f00>{number = 4, name = (null)}\n任务5 - <NSThread: 0x600000434d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：并发，创建新线程。\n![多线程03](多线程/多线程03.png)\n\n### 并发队列 & 同步执行（sync）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    /// 任务2\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n任务4 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n任务5 - <NSThread: 0x600002fa4d80>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程04](多线程/多线程04.png)\n\n### 串行队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n任务4 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务2 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n执行任务3 - <NSThread: 0x6000004dc740>{number = 5, name = (null)}\n任务5 - <NSThread: 0x6000004b0d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，创建新线程。\n![多线程05](多线程/多线程05.png)\n\n### 串行队列 & 同步执行（sync）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_SERIAL);\n    /// 任务2\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_sync(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600001438d40>{number = 1, name = main}\n任务4 - <NSThread: 0x600001438d40>{number = 1, name = main}\n任务5 - <NSThread: 0x600001438d40>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程06](多线程/多线程06.png)\n\n### 主队列 & 异步执行（async）\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"任务1 - %@\", [NSThread currentThread]);\n    \n    /// 手动创建并发队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    /// 任务2\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务2 - %@\", [NSThread currentThread]);\n        }\n    });\n    /// 任务3\n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            NSLog(@\"执行任务3 - %@\", [NSThread currentThread]);\n        }\n    });\n    \n    NSLog(@\"任务4 - %@\", [NSThread currentThread]);\n    /// 主线程睡1秒\n    sleep(1);\n    NSLog(@\"任务5 - %@\", [NSThread currentThread]);\n}\n```\n\n打印结果：\n```\n任务1 - <NSThread: 0x600002408d80>{number = 1, name = main}\n任务4 - <NSThread: 0x600002408d80>{number = 1, name = main}\n任务5 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务2 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n执行任务3 - <NSThread: 0x600002408d80>{number = 1, name = main}\n```\n\n从打印结果可以看到，队列里任务的执行方式为：串行，主线程。\n![多线程07](多线程/多线程07.png)\n\n### 主队列 & 同步执行（sync）-> 死锁\n\n死锁一：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）：\n![多线程01](多线程/多线程01.png)\n\n问题分析：\n![多线程02](多线程/多线程02.png)\n\n`sync` 函数在这里的作用有两个，第一个是添加任务2，第二个是执行任务2。因为主队列是串行队列，所以遵循先进先出原则，只有在第一个任务 `viewDidLoad` 执行完成后才能执行任务2。但是第一个任务 `viewDidLoad` 要想执行完就必须执行完 `sync` 函数，而 `sync` 函数要想执行完就必须执行完任务2，而任务2要想执行完就必须执行完 `viewDidLoad` ... ... 产生死锁。\n\n死锁二：\n![多线程08](多线程/多线程08.png)\n\n问题分析：\n![多线程09](多线程/多线程09.png)\n\n## performSelector:withObject:afterDelay:\n\n在子线程里调用 `performSelector:withObject:afterDelay:` 方法：\n```\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n```\n\n打印结果：\n```\n1\n3\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法并没有起作用。这是因为 `performSelector:withObject:afterDelay:` 方法内部使用了 timer，而子线程默认没有 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 TImer 无法调用。1和3可以打印是因为 `NSLog()` 方法是普通的代码，不需要 RunLoop。\n\n解决方案 👉 手动添加 RunLoop：\n```\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n        \n        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n    });\n}\n```\n\n打印结果：\n```\n1\n执行任务2 - <NSThread: 0x600001ad0cc0>{number = 6, name = (null)} - (null)\n3\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法可以正常调用了。这是因为手动为子线程添加了 RunLoop，所以 `performSelector:withObject:afterDelay:` 方法内部的 timer 可以正常运行了。\n\n猜想：`performSelector:withObject:afterDelay:` 方法的本质是往 RunLoop 中添加定时器：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        switch (activity) {\n            case kCFRunLoopEntry:\n                NSLog(@\"kCFRunLoopEntry\");\n                break;\n            case kCFRunLoopBeforeTimers:\n                NSLog(@\"kCFRunLoopBeforeTimers\");\n                break;\n            case kCFRunLoopBeforeSources:\n                NSLog(@\"kCFRunLoopBeforeSources\");\n                break;\n            case kCFRunLoopBeforeWaiting:\n                NSLog(@\"kCFRunLoopBeforeWaiting\");\n                break;\n            case kCFRunLoopAfterWaiting:\n                NSLog(@\"kCFRunLoopAfterWaiting\");\n                break;\n            case kCFRunLoopExit:\n                NSLog(@\"kCFRunLoopExit\");\n                break;\n            default:\n                break;\n        }\n    });\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);\n    CFRelease(observer);\n}\n\n- (void)test\n{\n    NSLog(@\"执行任务2 - %@ - %@\", [NSThread currentThread], [NSOperationQueue currentQueue]);\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@\"1\");\n    [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n    NSLog(@\"3\");\n}\n```\n\n打印结果：\n```\nkCFRunLoopAfterWaiting\nkCFRunLoopBeforeTimers\nkCFRunLoopBeforeSources\n1\n3\nkCFRunLoopBeforeTimers\nkCFRunLoopBeforeSources\n执行任务2 - <NSThread: 0x600000b5cd40>{number = 1, name = main} - <NSOperationQueue: 0x7fb3f0006020>{name = 'NSOperationQueue Main Queue'}\n... ...\n```\n\n从打印结果可以看到，`performSelector:withObject:afterDelay:` 方法的调用是一个 timers 事件：RunLoop 先处理了 Sources0 事件，再处理的 Timers。\n\n### GNUstep\n\nGNUstep 是 GNU 计划的项目之一，它将 Cocoa 的 OC 库重新开源实现了一遍。虽然 GNUstep 不是苹果官方源码，但还是具有一定的参考价值。👉 [源码地址](http://www.gnustep.org/resources/downloads.php)\n\n找到 NSRunLoop.m 文件查看 `performSelector:withObject:afterDelay:` 方法源码：\n```\n- (void) performSelector: (SEL)aSelector\n\t      withObject: (id)argument\n\t      afterDelay: (NSTimeInterval)seconds\n{\n  NSRunLoop\t\t*loop = [NSRunLoop currentRunLoop];\n  GSTimedPerformer\t*item;\n\n  //根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。\n  item = [[GSTimedPerformer alloc] initWithSelector: aSelector\n\t\t\t\t\t     target: self\n\t\t\t\t\t   argument: argument\n\t\t\t\t\t      delay: seconds];\n  [[loop _timedPerformers] addObject: item];\n  RELEASE(item);\n  [loop addTimer: item->timer forMode: NSDefaultRunLoopMode];\n}\n```\n\n通过源码可以得出结论：`performSelector:withObject:afterDelay:` 方法内部根据传入参数生成一个 GSTimedPerformer 对象（内含 NSTimer 定时器），作为 Timers 事件添加到 RunLoop 中。\n\n### performSelector:withObject:\n\n`performSelector:withObject:` 方法跟 `performSelector:withObject:afterDelay:` 方法的实现原理不同，`performSelector:withObject:afterDelay:` 是定义在 RunLoop.h 文件里的 API，内部实现的本质是往 RunLoop 中添加定时器。而 `performSelector:withObject:` 方法的本质是调用 objc_msgSend() 方法。可以在 runtime 源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 里看到具体实现，找到 NSObjec.m 文件：\n```\n- (id)performSelector:(SEL)sel withObject:(id)obj {\n    if (!sel) [self doesNotRecognizeSelector:sel];\n    return ((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj);\n}\n```\n\n## 队列组的使用\n\n异步并发执行任务1、任务2，在任务1、任务2都执行完毕后，再回到主线程执行任务3：\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_group_t group = dispatch_group_create();\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_async(group, queue, ^{\n        sleep(1);\n        NSLog(@\"任务1\");\n    });\n    dispatch_group_async(group, queue, ^{\n        NSLog(@\"任务2\");\n    });\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        NSLog(@\"任务3\");\n    });\n}\n```\n\n打印结果：\n```\n任务2\n任务1\n任务3\n```\n\n任务3会等到任务1和任务2都执行完成之后再执行。\n\n# GCD源码分析\n\n## dispatch_async()\n\n在 queue.h 文件找到 `dispatch_async()` 方法的定义\n```\nAPI_AVAILABLE(macos(10.6), ios(4.0))\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n```\n\n在 queue.c 文件找到 `dispatch_async()` 方法的实现：\n```\nvoid\ndispatch_async(dispatch_queue_t dq, dispatch_block_t work)\n{\n    //将任务 work 打包成 dispatch_continuation_t 类型\n\tdispatch_continuation_t dc = _dispatch_continuation_alloc(); \n    //设置标志位\n\tuintptr_t dc_flags = DC_FLAG_CONSUME;\n\tdispatch_qos_t qos;\n\n    //进行block初始化\n\tqos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);\n\t_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);\n}\n```\n\n在 inline_internal.h 文件找到 `_dispatch_continuation_async()` 方法的实现：\n```\nDISPATCH_ALWAYS_INLINE\nstatic inline void\n_dispatch_continuation_async(dispatch_queue_class_t dqu,\n\t\tdispatch_continuation_t dc, dispatch_qos_t qos, uintptr_t dc_flags)\n{\n#if DISPATCH_INTROSPECTION\n\tif (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {\n\t\t_dispatch_trace_item_push(dqu, dc); //将任务添加到队列中\n\t}\n#else\n\t(void)dc_flags;\n#endif\n\treturn dx_push(dqu._dq, dc, qos);\n}\n```\n\n在 trace.h 文件找到 `_dispatch_trace_item_push` 方法的实现：\n```\n#define _dispatch_trace_item_push(dq, dou) \\\n\t\tdo { (void)(dq); (void)(dou); } while(0)\n```\n\n## dispatch_sync()\n\n# 多线程的安全隐患\n\n资源共享：1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件。\n\n当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。\n\n## 多线程安全隐患示例\n\n### 卖票\n```\n@interface ViewController ()\n@property (assign, nonatomic) int ticketsCount;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    [self ticketTest];\n}\n\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n             [self saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self saleTicket];\n        }\n    });\n}\n\n//卖1张票\n- (void)saleTicket\n{\n    int oldTicketsCount = self.ticketsCount;\n    sleep(.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    \n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n还剩14张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩14张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩14张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩13张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩12张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩11张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩10张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩9张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩9张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩8张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩7张票 - <NSThread: 0x600000da81c0>{number = 4, name = (null)}\n还剩6张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩5张票 - <NSThread: 0x600000d91a80>{number = 6, name = (null)}\n还剩4张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n还剩3张票 - <NSThread: 0x600000db4040>{number = 5, name = (null)}\n```\n\n可以看到，刚开始三个线程都卖了1张票，结果还是下14张票。在三个线程走完后总共卖了15张票，但是最后还剩3张票。无论是在卖票过程中，还是最后剩余的票数都出现了异常。\n\n![多线程10](多线程/多线程10.png)\n总共15张票，两个线程同时卖票，每个线程都是拿15减1，得到的手势14张票。不同的线程拿到同一个变量进行修改，就会出现问题。\n\n### 存钱取钱\n```\n@interface ViewController ()\n@property (assign, nonatomic) int money;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self moneyTest];\n}\n\n- (void)moneyTest\n{\n    self.money = 100;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self saveMoney];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self drawMoney];\n        }\n    });\n}\n\n/// 存钱\n- (void)saveMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney += 50;\n    self.money = oldMoney;\n    \n    NSLog(@\"存50，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n/// 取钱\n- (void)drawMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney -= 20;\n    self.money = oldMoney;\n    \n    NSLog(@\"取20，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n@end\n```\n\n打印结果：\n```\n存50，还剩150元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩80元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n取20，还剩110元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩130元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩90元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩140元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩120元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩170元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩150元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩200元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩180元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩230元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩210元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩260元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩240元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩290元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩270元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩320元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n取20，还剩300元 - <NSThread: 0x600000928a80>{number = 3, name = (null)}\n存50，还剩350元 - <NSThread: 0x60000094bf40>{number = 5, name = (null)}\n```\n\n从打印结果可以看到，最后还剩350。代码中，原本有100，存了500，取了200，所以结果应该是400。\n\n![多线程11](多线程/多线程11.png)\n总共100元，两个线程同时拿到100元，第一个线程存了50元后余额还剩150元，第二个线程去了20元余额还剩80元。不同的线程拿到同一个变量进行修改，就会出现问题。\n\n## 多线程安全隐患分析\n\n线程A先取到变量的值17，线程B后取到变量的值17。线程A对取到的值加一（17+1=18），线程B对取到的值加一（17+1=18）。线程A将处理后的值赋值给变量（18），线程B也将处理后的值赋值给变量（18）。虽然修改了两次变量（+1），但是结果都是18：\n![多线程12](多线程/多线程12.png)\n\n## 多线程安全隐患的解决方案\n解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）。  \n常见的线程同步技术是：加锁。\n![多线程13](多线程/多线程13.png)\n\n# iOS中的线程同步方案\n\n| 同步方案 | 简介 |\n| :-- | :-- |\n| OSSpinLock | 自旋锁 |\n| os_unfair_lock | 用于取代不安全的OSSpinLock |\n| pthread_mutex | 互斥锁 |\n| dispatch_semaphore | 信号量 |\n| dispatch_queue(DISPATCH_QUEUE_SERIAL) | 串行队列 |\n| NSLock | 对mutex普通锁的封装 |\n| NSRecursiveLock | 对mutex递归锁的封装，API跟NSLock基本一致 |\n| NSCondition | 对mutex和cond的封装 |\n| NSConditionLock | 对NSCondition的进一步封装，可以设置具体的条件值 |\n| @synchronized | 对mutex递归锁的封装 |\n\n将卖票和存钱取钱测试代码封装起来：\n```\n@interface BaseLockDemo : NSObject\n/// 存钱取钱\n- (void)moneyTest;\n/// 卖票\n- (void)ticketTest;\n#pragma mark - 暴露给子类去使用\n- (void)__saveMoney;\n- (void)__drawMoney;\n- (void)__saleTicket;\n@end\n\n@interface BaseLockDemo()\n@property (assign, nonatomic) int money;\n@property (assign, nonatomic) int ticketsCount;\n@end\n\n@implementation BaseLockDemo\n///------ 存钱、取钱 ------\n- (void)moneyTest\n{\n    self.money = 100;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self __saveMoney];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 10; i++) {\n            [self __drawMoney];\n        }\n    });\n}\n\n/// 存钱\n- (void)__saveMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney += 50;\n    self.money = oldMoney;\n    \n    NSLog(@\"存50，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    int oldMoney = self.money;\n    sleep(.2);\n    oldMoney -= 20;\n    self.money = oldMoney;\n    \n    NSLog(@\"取20，还剩%d元 - %@\", oldMoney, [NSThread currentThread]);\n}\n\n///------ 卖票 ------\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n        for (int i = 0; i < 5; i++) {\n            [self __saleTicket];\n        }\n    });\n}\n\n/// 卖1张票\n- (void)__saleTicket\n{\n    int oldTicketsCount = self.ticketsCount;\n    sleep(.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n@end\n```\n\n## OSSpinLock\n`OSSpinLock` 叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源。目前已经不再安全，可能会出现优先级反转问题（如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁）。需要导入头文件 `#import <libkern/OSAtomic.h>`。\n\n忙等状态可以理解为一个 do-while 循环，不停的监测着是否解锁，这个状态下的线程会一直占用着CPU资源。正因为是处于忙等状态，所以 `OSSpinLock` 的效率要比其它锁都高，一旦解锁立刻就能监测到并继续执行。不再安全的原因是优先级较高的线程在等待锁时（忙等），CPU不再分配资源给其它线程，那么上锁的线程负责解锁，由于CPU没有分配资源也无法解锁，导致优先级较高的线程一直在这里等待。\n\n* 线程调度\n计算机通常只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配CPU的使用权。\n* 时间片轮转调度\n时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。\n\n### 常用API\n```\n/// 初始化\nOSSpinLock lock = OS_SPINLOCK_INIT;\n/// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）\nbool result = OSSpinLockTry(&lock);\n/// 加锁\nOSSpinLockLock(&lock);\n/// 解锁\nOSSpinLockUnlock(&lock);\n```\n\n### 解决卖票和存钱取钱问题\n定义 OSSpinLockDemo 继承自 LockBaseDemo。\n```\n#import <libkern/OSAtomic.h>\n\n@interface OSSpinLockDemo()\n@property (assign, nonatomic) OSSpinLock moneyLock;\n@property (assign, nonatomic) OSSpinLock ticketLock;\n@end\n\n@implementation OSSpinLockDemo\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        self.moneyLock = OS_SPINLOCK_INIT;\n        self.ticketLock = OS_SPINLOCK_INIT;\n    }\n    return self;\n}\n/// 取钱\n- (void)__drawMoney\n{\n    OSSpinLockLock(&_moneyLock);\n    \n    [super __drawMoney];\n    \n    OSSpinLockUnlock(&_moneyLock);\n}\n/// 存钱\n- (void)__saveMoney\n{\n    OSSpinLockLock(&_moneyLock);\n    \n    [super __saveMoney];\n    \n    OSSpinLockUnlock(&_moneyLock);\n}\n/// 卖票\n- (void)__saleTicket\n{\n    OSSpinLockLock(&_ticketLock);\n    \n    [super __saleTicket];\n    \n    OSSpinLockUnlock(&_ticketLock);\n}\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    BaseLockDemo *demo = [[OSSpinLockDemo alloc] init];\n    [demo ticketTest];\n    [demo moneyTest];\n}\n@end\n```\n\n调用 `-(void)moneyTest` 打印结果：\n```\n存50，还剩150元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩200元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩250元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩300元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩350元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩400元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩450元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩500元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩550元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n存50，还剩600元 - <NSThread: 0x600000471080>{number = 4, name = (null)}\n取20，还剩580元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩560元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩540元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩520元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩500元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩480元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩460元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩440元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩420元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n取20，还剩400元 - <NSThread: 0x600000463ec0>{number = 3, name = (null)}\n```\n\n调用 `-(void)ticketTest` 打印结果：\n```\n还剩14张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩13张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩12张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩11张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩10张票 - <NSThread: 0x600003a39ec0>{number = 3, name = (null)}\n还剩9张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩8张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩7张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩6张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩5张票 - <NSThread: 0x600003a6c2c0>{number = 6, name = (null)}\n还剩4张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩3张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩2张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩1张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n还剩0张票 - <NSThread: 0x600003a4a700>{number = 5, name = (null)}\n```\n\n因为要修改的有两个变量，一个是存钱取钱里的余额，一个是卖票里的剩余票数，所以要有两把锁分别对应这两个变量。一旦有线程对 OSSpinLock 上锁后，其它线程再遇到 OSSpinLock 时会阻塞住，等待 OSSpinLock 解锁在继续向下执行。\n\n上面👆的例子是将 OSSpinLock 锁对象放到了实例对象里，也可以将 OSSpinLock 锁对象放到类对象里：\n```\nstatic OSSpinLock moneyLock_;\n+ (void)initialize\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        moneyLock_ = 0;\n    });\n}\n```\n\n类方法 `+ (void)initialize` 只会被系统调用一次，但是允许被开发者调用，所以使用 `dispatch_once` 保证类对象的 `moneyLock_` 锁只初始化一次。\n\n或者：\n```\n- (void)__saleTicket\n{\n    static OSSpinLock ticketLock = OS_SPINLOCK_INIT;\n    \n    OSSpinLockLock(&ticketLock);\n    \n    [super __saleTicket];\n    \n    OSSpinLockUnlock(&ticketLock);\n}\n```\n\n使用 static 关键字，将 `ticketLock` 锁保存在全局区，保证只初始化一次。\n\n### OSSpinLock 汇编分析\n\n* 相关汇编代码：  \n  jne：j 是 jump，ne 是条件。  \n  callq：函数调用。  \n  syscall：系统调用。\n\n* lldb 指令： \n  setp：执行一行OC代码。  \n  stepi：stepinstruction 的简写，执行一行汇编代码，也可以简写为 si。（如果敲的过快可能会出现异常）  \n  next：执行一行OC代码。\n  nexti：执行一行汇编代码。\n  stepi 和 nexti 的区别：在遇到函数调用是，stepi 会进入调用的函数，nexti 不会进入。  \n  c：continue 的简写，继续执行。  \n\n（重复敲回车会执行上一个 lldb 指令）  \n\n### 查看汇编代码方法\n👉 修改 LockBaseDemo 类里的 `- (void)__saleTicket` 方法，设置睡眠时间为 60s，这样可以有足够的时间查看第二次加锁时的汇编代码。修改 `- (void)ticketTest` 方法，创建十条线程调用 `- (void)__saleTicket` 方法：\n```\n- (void)ticketTest\n{\n    self.ticketsCount = 15;\n    \n    for (int i=0; i<10; i++) {\n        [[[NSThread alloc] initWithTarget:self selector:@selector(__saleTicket) object:nil] start]; \n    }\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    int oldTicketsCount = self.ticketsCount; //断点\n    sleep(60.2);\n    oldTicketsCount--;\n    self.ticketsCount = oldTicketsCount;\n    NSLog(@\"还剩%d张票 - %@\", oldTicketsCount, [NSThread currentThread]);\n}\n```\n\n第一次加锁后，在第二次尝试加锁时，就可以有足够多的时间查看其汇编代码，在断点处查看 Debug -> Debug Workflow -> Always Show Disassembly。\n\n### 查看 OSSpinLock 汇编代码\n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 9 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 10，因为此时的自旋锁处于上锁状态，所以 Thread 10 处于等待锁的状态。重复执行 si 指令，到第11行时会调用 OSSpinLocklock 函数：\n![多线程15](多线程/多线程15.png)\n使用 si 指令进入到调用函数：\n![多线程16](多线程/多线程16.png)\n重复执行 si 指令，在第6行通过 jne 跳转到 `_OSSpinLockLockSlow` 函数：\n![多线程17](多线程/多线程17.png)\n`_OSSpinLockLockSlow` 函数是自旋锁的核心代码，从第6行到第19行是一个 while 循环（🔎自旋锁标志）。因为 Thread 9 已经加过锁并且还没有解锁，所以这里会一直循环执行，等待 Thread 9 解锁。可以看到第14行和第16行是跳出 while 循环的判断：\n![多线程18](多线程/多线程18.png)\n\n\n## os_unfair_lock\n`OSSpinLock` 在以前是性能最高的一种锁，但是由于不再安全（优先级反转问题），苹果已经不建议使用了，从 iOS10 开始推出了替代它的 `os_unfair_lock`。需要导入头文件 `#import <os/lock.h>`。\n\n### 常用API\n```\n/// 初始化\nos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n/// 尝试加锁\nos_unfair_lock_trylock(&lock);\n/// 加锁\nos_unfair_lock_lock(&lock);\n/// 解锁\nos_unfair_lock_unlock(&lock);\n```\n\n### 解决卖票和存钱取钱问题\n定义 OSUnfairLockDemo 继承自 LockBaseDemo。\n```\n#import <libkern/OSAtomic.h>\n\n@interface OSUnfairLockDemo()\n@property (nonatomic, assign) os_unfair_lock moneyLock;\n@property (nonatomic, assign) os_unfair_lock ticketLock;\n@end\n\n@implementation OSUnfairLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyLock = OS_UNFAIR_LOCK_INIT;\n        self.ticketLock = OS_UNFAIR_LOCK_INIT;\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    os_unfair_lock_lock(&_moneyLock);\n    \n    [super __drawMoney];\n    \n    os_unfair_lock_unlock(&_moneyLock);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    os_unfair_lock_lock(&_moneyLock);\n    \n    [super __saveManey];\n    \n    os_unfair_lock_unlock(&_moneyLock);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    os_unfair_lock_lock(&_ticketLock);\n    \n    [super __saleTicket];\n    \n    os_unfair_lock_unlock(&_ticketLock);\n}\n```\n\n打印结果同 OSSpinLock。\n\n* 死锁  \n如果加锁后没有解锁，其它线程就会进入等待，永远无法往下继续执行。这种由于没有解锁造成的其它线程的等待叫做死锁。\n\n### os_unfair_lock 汇编分析\n\n根据“查看汇编代码方法”查看 `os_unfair_lock` 第二次尝试加锁的汇编代码。  \n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 8 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 15，因为此时的自旋锁处于上锁状态，所以 Thread 15 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `os_unfair_lock_lock` 函数：\n![多线程26](多线程/多线程26.png)\n使用 `si` 指令进入到 `os_unfair_lock_lock` 函数：\n![多线程27](多线程/多线程27.png)\n重复使用 `si` 指令，进入 `_os_unfair_lock_lock_slow` 函数：\n![多线程28](多线程/多线程28.png)\n使用 `si` 指令，第56行会调用 `__ulock_wait` 函数：\n![多线程29](多线程/多线程29.png)\n使用 `si` 指令，进入 `__ulock_wait`：\n![多线程30](多线程/多线程30.png)\n第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎 互斥锁标志）：\n![多线程31](多线程/多线程31.png)\n\n从上面👆对 `os_unfair_lock` 的汇编分析，可以看出 `os_unfair_lock` 是一个互斥锁。在 `os_unfair_lock` 的头文件 lock.h 里的注释可以看到一个单词 Low-level（低级锁），低级锁的特点就是休眠。自旋锁 OSSpinLock 是一个高级锁。\n\n## pthread_mutex\n\nmutex 叫做”互斥锁”，等待锁的线程会处于休眠状态。需要导入头文件 `#import <pthread.h>`。\n\n### 常用API\n```\n/// 初始化锁的属性\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);\n/// 初始化锁\npthread_mutex_t mutex;\npthread_mutex_init(&mutex, &attr);\n/// 尝试加锁\npthread_mutex_trylock(&mutex);\n/// 加锁\npthread_mutex_lock(&mutex);\n/// 解锁\npthread_mutex_unlock(&mutex);\n/// 销毁相关资源\npthread_mutexattr_destroy(&attr);\npthread_mutex_destroy(&mutex);\n```\n\n锁定类型：\n```\n#define PTHREAD_MUTEX_NORMAL\t\t0\n#define PTHREAD_MUTEX_ERRORCHECK\t1\n#define PTHREAD_MUTEX_RECURSIVE\t\t2\n#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL\n```\n\n### PTHREAD_MUTEX_INITIALIZER\n```\n/*\n * Mutex variables\n */\n#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}\n```\n\n可以看到，`PTHREAD_MUTEX_INITIALIZER` 是一个结构体，在使用 `PTHREAD_MUTEX_INITIALIZER` 初始化锁时，由于结构体语法的问题，需要进行静态初始化：\n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n    }\n    return self;\n}\n```\n\n如果使用 `PTHREAD_MUTEX_INITIALIZER` 动态初始化 `pthread_mutex_t` 会报错：\n![多线程14](多线程/多线程14.png)\n\n### pthread_mutexattr_t\n初始化 `pthread_mutex` 锁： \n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        /// 初始化属性\n        pthread_mutexattr_t attr;\n        pthread_mutexattr_init(&attr);\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n        /// 初始化锁\n        pthread_mutex_init(&_moneyMutex, &attr);\n        /// 销毁属性\n        pthread_mutexattr_destroy(&attr);\n    }\n    return self;\n}\n```\n\n上面👆初始化锁的代码比较繁琐，一般使用 `pthread_mutex_init(&_moneyMutex, NULL)` 方法进行初始化。`pthread_mutex_init()` 方法的第二参数传 `NULL`，就相当于设置了 `PTHREAD_MUTEX_DEFAULT` 类型的 `pthread_mutexattr_t` 属性。\n\n### 解决卖票和存钱取钱问题\n定义 PthreadMutexDemo 继承自 LockBaseDemo。\n```\n#import <pthread.h>\n\n@interface PthreadMutexDemo()\n@property (nonatomic, assign) pthread_mutex_t moneyMutex;\n@property (nonatomic, assign) pthread_mutex_t ticketMutex;\n@end\n\n@implementation PthreadMutexDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_moneyMutex, NULL);\n        pthread_mutex_init(&_ticketMutex, NULL);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    pthread_mutex_lock(&_moneyMutex);\n    \n    [super __drawMoney];\n    \n    pthread_mutex_unlock(&_moneyMutex);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    pthread_mutex_lock(&_moneyMutex);\n    \n    [super __saveManey];\n    \n    pthread_mutex_unlock(&_moneyMutex);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    pthread_mutex_lock(&_ticketMutex);\n    \n    [super __saleTicket];\n    \n    pthread_mutex_unlock(&_ticketMutex);\n}\n\n/// 销毁锁\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_moneyMutex);\n    pthread_mutex_destroy(&_ticketMutex);\n}\n\n@end\n```\n\n打印结果同 OSSpinLock。\n\n相对于 `OSSpinLock` 和 `os_unfair_lock`，`pthread_mutex` 的 API 里提供了销毁方法 `pthread_mutex_destroy()`，所以需要在 `-(void)dealloc` 方法里对锁进行销毁。\n\n### pthread_mutex 汇编分析\n\n根据“查看汇编代码方法”查看 `pthread_mutex` 第二次尝试加锁的汇编代码。  \n\n可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 10 并加锁。第二次调用 `- (void)__saleTicket` 方法是在 Thread 14，因为此时的自旋锁处于上锁状态，所以 Thread 14 处于等待锁的状态。重复执行 `si` 指令，到第11行时会调用 `phread_mutex_lock` 函数：\n![多线程19](多线程/多线程19.png)\n使用 `si` 指令进入到 `phread_mutex_lock` 函数：\n![多线程20](多线程/多线程20.png)\n重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_slow` 函数：\n![多线程21](多线程/多线程21.png)\n重复使用 `si` 指令，进入 `_pthread_mutex_firstfit_lock_wait` 函数：\n![多线程22](多线程/多线程22.png)\n重复使用 `si` 指令，调用 `__psynch_mutexwait`：\n![多线程23](多线程/多线程23.png)\n使用 `si` 指令，进入 `__psynch_mutexwait` 函数：\n![多线程23](多线程/多线程24.png)\n第4行 `syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎互斥锁标志）：\n![多线程23](多线程/多线程25.png)\n\n从上面👆对 `pthread_mutex` 的汇编分析，可以看出 `pthread_mutex` 是一个互斥锁，也是一个低级锁。\n\n## pthread_mutex – 递归锁\n初始化 pthread_mutex 递归锁：\n```\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        /// 初始化属性\n        pthread_mutexattr_t attr;\n        pthread_mutexattr_init(&attr);\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n        /// 初始化锁\n        pthread_mutex_init(&_moneyMutex, &attr);\n        /// 销毁属性\n        pthread_mutexattr_destroy(&attr);\n    }\n    return self;\n}\n```\n\n用 `PTHREAD_MUTEX_RECURSIVE` 类型定义的属性创建出来的 `pthread_mutex` 锁就是 `pthread_mutex` 递归锁。\n\n### 死锁\n在使用锁时如果出现了递归调用，或者在加锁后调用了一个使用同一把锁的方法，就会出现死锁的情况。与上面👆提到过的死锁的概念相同。\n\n定义 PthreadMutexRecursiveDemo：\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)recursiveMutexTest\n{\n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n......\n```\n\n#### 死锁情况一：递归调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_mutex, NULL);\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n```\n\n可以看到打印结果里只有一条打印信息，这是因为加锁后再次调用 `-(void)recursiveMutexTest` 方法，会发现 `_mutex` 已经上锁了，进入休眠等待解锁。\n\n#### 死锁情况二：函数间互相调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        pthread_mutex_init(&_mutex, NULL);\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest2];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)recursiveMutexTest2\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n```\n\n可以看到打印结果里只有一条打印信息，这是因为两个方法使用的是同一把锁，在 `- (void)recursiveMutexTest` 方法加锁后再去调用 `- (void)recursiveMutexTest2` 方法时，会发现 _mutex 已经上锁了，进入休眠等待解锁。\n\n### 递归锁\n\n因为递归锁允许在同一个线程里重复加锁，所以递归锁可以解决上面出现的死锁情况。\n\n#### 解决死锁情况一：递归调用\n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)initMutex:(pthread_mutex_t *)mutex\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex];\n    }\n    return self;\n}\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n......\n```\n\n#### 解决死锁情况二：函数间互相调用 \n```\n@interface PthreadMutexRecursiveDemo : LockBaseDemo\n- (void)recursiveMutexTest;\n@end\n\n@interface PthreadMutexRecursiveDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@end\n\n@implementation PthreadMutexRecursiveDemo\n- (void)initMutex:(pthread_mutex_t *)mutex\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex];\n    }\n    return self;\n}\n\n\n- (void)recursiveMutexTest\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    /// 递归调用\n    [self recursiveMutexTest2];\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)recursiveMutexTest2\n{\n    pthread_mutex_lock(&_mutex);\n    \n    NSLog(@\"%s\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n}\n@end\n```\n\n打印结果：\n```\n-[PthreadMutexRecursiveDemo recursiveMutexTest]\n-[PthreadMutexRecursiveDemo recursiveMutexTest2]\n```\n\n使用递归锁后，死锁的问题不存在了。但是，加了递归锁后的打印结果跟没加锁一样，这样被加锁的代码块还安全吗？其实，递归锁只可以在当前线程重复加锁。也就是说，当前线程加锁后，在当前线程再次调用 `- (void)recursiveMutexTest` 方法还可以重复加锁，而其它线程在此时调用 `- (void)recursiveMutexTest` 方法时判断到已经加过锁了就不再加锁了，会进入休眠等待解锁。\n\n## pthread_mutex – 条件\n\n### 相关API\n```\n/// 初始化锁\n pthread_mutex_t mutex;\n /// NULL代表使用默认属性\n pthread_mutex_init(&mutex, NULL);\n /// 初始化条件\n pthread_cond_t condition;\n pthread_cond_init(&condition, NULL);\n /// 等待条件（进入休眠，放开mutex；被唤醒后，会再次对mutex加锁）\n pthread_cond_wait(&condition, &mutex);\n /// 激活一个等待该条件的线程\n pthread_cond_signal(&condition);\n /// 激活所有等待该条件的线程\n pthread_cond_broadcast(&condition);\n /// 销毁资源\n pthread_mutex_destroy(&mutex);\n pthread_cond_destroy(&condition);\n```\n\n### 应用场景\n```\n#import <pthread.h>\n\n@interface PthreadMutexCondDemo()\n@property (nonatomic, assign) pthread_mutex_t mutex;\n@property (nonatomic, assign) pthread_cond_t cond;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation PthreadMutexCondDemo\n\n- (void)initMutex:(pthread_mutex_t *)mutex cond:(pthread_cond_t *)cond\n{\n    /// 初始化属性\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    /// 初始化锁\n    pthread_mutex_init(mutex, &attr);\n    /// 销毁属性\n    pthread_mutexattr_destroy(&attr);\n    /// 初始化条件\n    pthread_cond_init(cond, NULL);\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self initMutex:&_mutex cond:&_cond];\n        \n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(remove) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(add) object:nil] start];\n}\n\n/// 线程1\n- (void)remove\n{\n    pthread_mutex_lock(&_mutex);\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    if (self.data.count == 0) {\n        NSLog(@\"%s, 等待信号\", __func__);\n        pthread_cond_wait(&_cond, &_mutex);\n        NSLog(@\"%s, 收到信号\", __func__);\n    }\n    \n    [self.data removeLastObject];\n    NSLog(@\"%s, 删除\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n/// 线程2\n- (void)add\n{\n    pthread_mutex_lock(&_mutex);\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    [self.data addObject:@\"test\"];\n    NSLog(@\"%s, 添加\", __func__);\n    \n    pthread_cond_signal(&_cond);\n    NSLog(@\"%s, 发送信号\", __func__);\n    \n    pthread_mutex_unlock(&_mutex);\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n- (void)dealloc\n{\n    pthread_mutex_destroy(&_mutex);\n    pthread_cond_destroy(&_cond);\n}\n\n@end\n```\n\n打印结果：\n```\n00:35:21.182042+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 上锁\n00:35:21.182158+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 等待信号\n00:35:23.182238+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 上锁\n00:35:23.182447+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 添加\n00:35:23.182614+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 发送信号\n00:35:23.182700+0800 多线程安全隐患[7160:142386] -[PthreadMutexCondDemo add], 解锁\n00:35:23.182709+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 收到信号\n00:35:23.182772+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 删除\n00:35:23.182835+0800 多线程安全隐患[7160:142356] -[PthreadMutexCondDemo remove], 解锁\n```\n\n在 `pthread_cond_wait()` 方法调用后，线程1会解锁并进入等待消息状态（休眠）。线程2监听到 `pthread_mutex_t` 锁已经解锁开始正常执行，添加完数据后发送消息。线程1在收到消息后会判断 pthread_mutex_t 锁是否已经上锁，如果已经上锁了就继续等待其解锁（休眠），一旦解锁了（线程2）就立即向下执行下面的代码。\n\n因为应用场景是不同线程的调用，所以初始化属性时传入的第二个的参数 `PTHREAD_MUTEX_RECURSIVE` 也可以是 `PTHREAD_MUTEX_NORMAL`。\n\n`pthread_mutex` 条件锁的应用场景比较少见，就算遇到了类似的场景，估计也不会选择用这种方式解决。它主要是解决优先及问题，上面👆代码中为了不对空数组进行删除操作，给锁添加了条件，保证了数组的删除操作在添加完数据后执行。\n\n## NSLock\n\nNSLock 是对 mutex 普通锁的封装。\n\n### 相关API\n```\n/// 初始化锁\nNSLock *lock = [[NSLock alloc] init];\n/// 加锁\n[lock lock];\n/// 解锁\n[lock unlock];\n```\n\n### 应用\n```\n@interface NSLockDemo()\n@property (nonatomic, strong) NSLock *moneyLock;\n@property (nonatomic, strong) NSLock *ticketLock;\n@end\n\n@implementation NSLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyLock = [[NSLock alloc] init];\n        self.ticketLock = [[NSLock alloc] init];\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    [self.moneyLock lock];\n    \n    [super __drawMoney];\n    \n    [self.moneyLock unlock];\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    [self.moneyLock lock];\n    \n    [super __saveManey];\n    \n    [self.moneyLock unlock];\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    [self.ticketLock lock];\n    \n    [super __saleTicket];\n    \n    [self.ticketLock unlock];\n}\n\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### NSLock 实现原理\n\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSLock 的具体实现：\n```\n......\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 尝试加锁，返回YES表示加锁成功\n- (BOOL)tryLock;\n/// 尝试加锁，返回YES表示加锁成功，在终止时间（limt）前处于加锁状态，到了时间后，会自动解锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n  static BOOL\tbeenHere = NO;\n\n    if (beenHere == NO)\n    {\n        beenHere = YES;\n\n        pthread_mutexattr_init(&attr_normal);\n        pthread_mutexattr_settype(&attr_normal, PTHREAD_MUTEX_NORMAL);\n        pthread_mutexattr_init(&attr_reporting);\n        pthread_mutexattr_settype(&attr_reporting, PTHREAD_MUTEX_ERRORCHECK);\n        pthread_mutexattr_init(&attr_recursive);\n        pthread_mutexattr_settype(&attr_recursive, PTHREAD_MUTEX_RECURSIVE);\n\n        pthread_mutex_init(&deadlock, &attr_normal);\n        pthread_mutex_lock(&deadlock);\n\n        baseConditionClass = [NSCondition class];\n        baseConditionLockClass = [NSConditionLock class];\n        baseLockClass = [NSLock class];\n        baseRecursiveLockClass = [NSRecursiveLock class];\n\n        tracedConditionClass = [GSTracedCondition class];\n        tracedConditionLockClass = [GSTracedConditionLock class];\n        tracedLockClass = [GSTracedLock class];\n        tracedRecursiveLockClass = [GSTracedRecursiveLock class];\n\n        untracedConditionClass = [GSUntracedCondition class];\n        untracedConditionLockClass = [GSUntracedConditionLock class];\n        untracedLockClass = [GSUntracedLock class];\n        untracedRecursiveLockClass = [GSUntracedRecursiveLock class];\n    }\n}\n\nMDEALLOC\nMDESCRIPTION\nMFINALIZE\n\n/* Use an error-checking lock.  This is marginally slower, but lets us throw\n * exceptions when incorrect locking occurs.\n */\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_mutex_init(&_mutex, &attr_reporting))\n        {\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\n......\n```\n\n## NSRecursiveLock\n\nNSRecursiveLock 是对 mutex 递归锁的封装，API 跟 NSLock 基本一致。\n\n### 常用API\n```\n/// 初始化\nNSRecursiveLock *lock = [[NSRecursiveLock alloc] init];\n/// 加锁\n[lock lock];\n/// 解锁\n[lock unlock];\n```\n\n### 应用 - 递归调用\n```\n@interface NSRecursiveLockDemo()\n@property (nonatomic, strong) NSRecursiveLock *lock;\n@end\n\n@implementation NSRecursiveLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lock = [[NSRecursiveLock alloc] init];\n    }\n    return self;\n}\n\n- (void)test\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n    [self test];\n    \n    [self.lock unlock];\n}\n@end\n```\n\n打印结果：\n```\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test]\n......\n```\n\n### 应用 - 方法间调用\n```\n@interface NSRecursiveLockDemo()\n@property (nonatomic, strong) NSRecursiveLock *lock;\n@end\n\n@implementation NSRecursiveLockDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lock = [[NSRecursiveLock alloc] init];\n    }\n    return self;\n}\n\n- (void)test\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n    [self test2];\n    \n    [self.lock unlock];\n}\n\n- (void)test2\n{\n    [self.lock lock];\n    \n    NSLog(@\"%s\", __func__);\n    \n   [self.lock unlock];\n}\n@end\n```\n\n打印结果：\n```\n-[NSRecursiveLockDemo test]\n-[NSRecursiveLockDemo test2]\n```\n\n### NSRecursiveLock 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSRecursiveLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSRecursiveLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 尝试加锁，返回YES表示加锁成功\n- (BOOL)tryLock;\n/// 尝试加锁，返�������������������������YES表示加锁成功，在终止时间（limt）前处于加锁状态，到了终止时间会自动解锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\nstatic pthread_mutexattr_t attr_recursive;\n\n@implementation NSRecursiveLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseRecursiveLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedRecursiveLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\nMDEALLOC\nMDESCRIPTION\nMFINALIZE\n\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_mutex_init(&_mutex, &attr_recursive))\n        {\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\nMISLOCKED\nMLOCK\nMLOCKBEFOREDATE\nMNAME\nMSTACK\nMTRYLOCK\nMUNLOCK\n@end\n```\n\n因为 NSRecursiveLock 是在 lock.m 文件定义的，所以 `- (id)init` 方法里的 attr_recursive 属性是在 `+ (void)initialize` 方法👆里创建好的：\n```\npthread_mutexattr_init(&attr_recursive);\npthread_mutexattr_settype(&attr_recursive, PTHREAD_MUTEX_RECURSIVE);\n```\n\n## NSCondition\nNSCondition 是对 mutex 和 cond 的封装。\n\n### 相关API\n```\n/// 初始化\nNSCondition *condition = [[NSCondition alloc] init];\n/// 加锁\n[condition lock];\n/// 解锁\n[condition unlock];\n/// 等待\n[condition wait];\n/// 发信号\n[condition signal];\n```\n\n### 应用\n```\n@interface NSConditionDemo()\n@property (nonatomic, strong) NSCondition *condition;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation NSConditionDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.condition = [[NSCondition alloc] init];\n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(remove) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(add) object:nil] start];\n}\n\n- (void)remove\n{\n    [self.condition lock];\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    if (self.data.count == 0) {\n        NSLog(@\"%s, 等待信号\", __func__);\n        [self.condition wait];\n        NSLog(@\"%s, 收到信号\", __func__);\n    }\n    \n    [self.data removeLastObject];\n    NSLog(@\"%s, 删除\", __func__);\n    \n    [self.condition unlock];\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n- (void)add\n{\n    [self.condition lock];\n    NSLog(@\"%s, 上锁\", __func__);\n    \n    [self.data addObject:@\"test\"];\n    NSLog(@\"%s, 添加\", __func__);\n    \n    [self.condition signal];\n    NSLog(@\"%s, 发送信号\", __func__);\n    \n    [self.condition unlock];\n    NSLog(@\"%s, 解锁\", __func__);\n}\n\n@end\n```\n\n打印结果：\n```\n14:30:32.001876+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 上锁\n14:30:32.002080+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 等待信号\n14:30:34.002046+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 上锁\n14:30:34.002227+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 添加\n14:30:34.002313+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 发送信号\n14:30:34.002384+0800 多线程安全隐患[26696:271974] -[NSConditionDemo add], 解锁\n14:30:34.002395+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 收到信号\n14:30:34.002470+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 删除\n14:30:34.002556+0800 多线程安全隐患[26696:271952] -[NSConditionDemo remove], 解锁\n```\n\n### NSCondition 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSRecursiveLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSCondition : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n/// 添加等待，收到了 signal 就会唤醒线程\n- (void)wait;\n/// 等待条件（进入休眠，解锁；被唤醒后，加锁）。在终止时间（limt）前收到了 signal 就会唤醒线程。当到达终止时间的时候，即使没有收到 signal，也会直接唤醒线程\n- (BOOL)waitUntilDate:(NSDate *)limit;\n/// 激活一个等待该条件的线程\n- (void)signal;\n/// 激活所有等待该条件的线程\n- (void)broadcast;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSCondition\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseConditionClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedConditionClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\n- (void) broadcast\n{\n    pthread_cond_broadcast(&_condition);\n}\n\nMDEALLOC\nMDESCRIPTION\n\n- (void) finalize\n{\n    pthread_cond_destroy(&_condition);\n    pthread_mutex_destroy(&_mutex);\n}\n\n- (id) init\n{\n    if (nil != (self = [super init]))\n    {\n        if (0 != pthread_cond_init(&_condition, NULL))\n        {\n            DESTROY(self);\n        }\n        else if (0 != pthread_mutex_init(&_mutex, &attr_reporting))\n        {\n            pthread_cond_destroy(&_condition);\n            DESTROY(self);\n        }\n    }\n    return self;\n}\n\nMISLOCKED\nMLOCK\nMLOCKBEFOREDATE\nMNAME\n\n- (void) signal\n{\n    pthread_cond_signal(&_condition);\n}\n\nMSTACK\nMTRYLOCK\nMUNLOCK\n\n- (void) wait\n{\n    pthread_cond_wait(&_condition, &_mutex);\n}\n\n- (BOOL) waitUntilDate: (NSDate*)limit\n{\n    NSTimeInterval ti = [limit timeIntervalSince1970];\n    double secs, subsecs;\n    struct timespec timeout;\n    int retVal = 0;\n\n    // Split the float into seconds and fractions of a second\n    subsecs = modf(ti, &secs);\n    timeout.tv_sec = secs;\n    // Convert fractions of a second to nanoseconds\n    timeout.tv_nsec = subsecs * 1e9;\n\n    /* NB. On timeout the lock is still held even through condition is not met\n    */\n\n    retVal = pthread_cond_timedwait(&_condition, &_mutex, &timeout);\n    if (retVal == 0)\n    {\n        return YES;\n    }\n    if (retVal == ETIMEDOUT)\n    {\n        return NO;\n    }\n    if (retVal == EINVAL)\n    {\n        NSLog(@\"Invalid arguments to pthread_cond_timedwait\");\n    }\n    return NO;\n}\n\n@end\n```\n\n## NSConditionLock\n\nNSConditionLock 是对 NSCondition 的进一步封装，可以设置具体的条件值。\n\n### 相关API\n```\n/// 初始化锁，设置锁的条件1\nNSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:1];\n/// 如果条件为1就加锁\n[conditionLock lockWhenCondition:1];\n/// 解锁，并设置条件为2\n[conditionLock unlockWithCondition:2];\n```\n\n### 应用\n```\n@interface NSConditionLockDemo()\n@property (nonatomic, strong) NSConditionLock *conditionLock;\n@property (nonatomic, strong) NSMutableArray *data;\n@end\n\n@implementation NSConditionLockDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.conditionLock = [[NSConditionLock alloc] initWithCondition:1];\n        self.data = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    [[[NSThread alloc] initWithTarget:self selector:@selector(one) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(two) object:nil] start];\n    \n    sleep(2.);\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(three) object:nil] start];\n}\n\n- (void)one\n{\n    /// 如果条件等于1，继续往下执行\n    [self.conditionLock lockWhenCondition:1];\n    \n    NSLog(@\"1\");\n    \n    /// 解锁，设置条件为2\n    [self.conditionLock unlockWithCondition:2];\n}\n\n- (void)two\n{\n    /// 如果条件等于2，继续往下执行\n    [self.conditionLock lockWhenCondition:2];\n    \n    NSLog(@\"2\");\n    \n    /// 解锁，设置条件为3\n    [self.conditionLock unlockWithCondition:3];\n}\n\n- (void)three\n{\n    /// 如果条件等于3，继续往下执行\n    [self.conditionLock lockWhenCondition:3];\n    \n    NSLog(@\"3\");\n    \n    /// 解锁，设置条件为4\n    [self.conditionLock unlockWithCondition:4];\n}\n@end\n```\n\n打印结果：\n```\n16:04:40.425810+0800 多线程安全隐患[28831:334816] 1\n16:04:42.426001+0800 多线程安全隐患[28831:334904] 2\n16:04:44.426143+0800 多线程安全隐患[28831:334908] 3\n```\n\n可以看到 NSConditionLock 可以给线程之间设置优先级。\n\n如果使用 `-(void)lock` 方法只会判断锁是否处于加锁状态，如果不是就直接加锁，不会判断条件。\n\n### NSConditionLock 实现原理\n在 GNUstep 里的 source/Foundation 下面可以找到 NSLock.m 文件，在该文件里可以找到 NSConditionLock 的具体实现：\n```\n/// NSLock.h文件（Foundation）\n@interface NSConditionLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n/// 初始化\n- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;\n/// 条件\n@property (readonly) NSInteger condition;\n/// 如果条件成立就加锁\n- (void)lockWhenCondition:(NSInteger)condition;\n/// 尝试加锁，成功返回YES\n- (BOOL)tryLock;\n/// 如果条件成立就尝试加锁，成功返回YES\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n/// 解锁并设置条件\n- (void)unlockWithCondition:(NSInteger)condition;\n/// 在终止时间前加锁，成功返回YES\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n/// 在终止时间前，如果条件成立就加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n\n/// NSLock.m文件（GNUstep）\n@implementation NSConditionLock\n\n+ (id) allocWithZone: (NSZone*)z\n{\n    if (self == baseConditionLockClass && YES == traceLocks)\n    {\n        return class_createInstance(tracedConditionLockClass, 0);\n    }\n    return class_createInstance(self, 0);\n}\n\n+ (void) initialize\n{\n    [NSLock class];\t// Ensure mutex attributes are set up.\n}\n\n- (NSInteger) condition\n{\n    return _condition_value;\n}\n\n- (void) dealloc\n{\n    [_name release];\n    [_condition release];\n    [super dealloc];\n}\n\n- (id) init\n{\n    return [self initWithCondition: 0];\n}\n\n- (id) initWithCondition: (NSInteger)value\n{\n    if (nil != (self = [super init]))\n    {\n        if (nil == (_condition = [NSCondition new]))\n        {\n            DESTROY(self);\n        }\n        else\n        {\n            _condition_value = value;\n            [_condition setName:[NSString stringWithFormat: @\"condition-for-lock-%p\", self]];\n        }\n    }\n    return self;\n}\n\n- (BOOL) isLockedByCurrentThread\n{\n    return [_condition isLockedByCurrentThread];\n}\n\n- (void) lock\n{\n    [_condition lock];\n}\n\n- (BOOL) lockBeforeDate: (NSDate*)limit\n{\n    return [_condition lockBeforeDate: limit];\n}\n\n- (void) lockWhenCondition: (NSInteger)value\n{\n    [_condition lock];\n    while (value != _condition_value)\n    {\n        [_condition wait];\n    }\n}\n\n- (BOOL) lockWhenCondition: (NSInteger)condition_to_meet\n                beforeDate: (NSDate*)limitDate\n{\n    if (NO == [_condition lockBeforeDate: limitDate])\n    {\n        return NO;        // Not locked\n    }\n    if (condition_to_meet == _condition_value)\n    {\n        return YES;       // Keeping the lock\n    }\n    while ([_condition waitUntilDate: limitDate])\n    {\n        if (condition_to_meet == _condition_value)\n        {\n            return YES;   // Keeping the lock\n        }\n    }\n    [_condition unlock];\n    return NO;            // Not locked\n}\n\nMNAME\nMSTACK\n\n- (BOOL) tryLock\n{\n    return [_condition tryLock];\n}\n\n- (BOOL) tryLockWhenCondition: (NSInteger)condition_to_meet\n{\n    if ([_condition tryLock])\n    {\n        if (condition_to_meet == _condition_value)\n        {\n            return YES; // KEEP THE LOCK\n        }\n        else\n        {\n            [_condition unlock];\n        }\n    }\n    return NO;\n}\n\n- (void) unlock\n{\n    [_condition unlock];\n}\n\n- (void) unlockWithCondition: (NSInteger)value\n{\n    _condition_value = value;\n    [_condition broadcast];\n    [_condition unlock];\n}\n\n@end\n```\n\n## dispatch_semaphore\n\nsemaphore 叫做“信号量”。信号量的初始值，可以用来控制线程并发访问的最大数量。信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步。\n\n### 相关API\n```\n/// 初始化\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(5);\n/// 如果信号量的值 >= 0，就让信号量的值减1，然后继续往下执行代码\n/// 如果信号量的值 <= 0，就会休眠等待；当信号量的值变成 >0 时，就让信号量的值减1，然后继续往下执行代码\n/// DISPATCH_TIME_FOREVER 表示一直在这里等待信号量变成 >0；DISPATCH_TIME_NOW 判断完后不管信号量的值是否 >0 都继续往下执行\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n/// 让信号量的值+1\ndispatch_semaphore_signal(semaphore);\n```\n\n### 应用 - 控制最大并发数量\n```\n@interface SemaphoreDemo()\n@property (nonatomic, strong) dispatch_semaphore_t semaphore;\n@end\n\n@implementation SemaphoreDemo\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.semaphore = dispatch_semaphore_create(5);\n    }\n    return self;\n}\n\n- (void)otherTest\n{\n    for (int i=0; i < 20; i++) {\n        [[[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil] start];\n    }\n}\n\n- (void)test\n{\n    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n    \n    sleep(2);\n    NSLog(@\"test - %@\", [NSThread currentThread]);\n    \n    dispatch_semaphore_signal(self.semaphore);\n}\n@end\n```\n\n打印结果：\n```\n10:16:19.552038+0800 多线程安全隐患[10797:47431] test - <NSThread: 0x600002deb640>{number = 6, name = (null)}\n10:16:19.552041+0800 多线程安全隐患[10797:47434] test - <NSThread: 0x600002deb880>{number = 9, name = (null)}\n10:16:19.552076+0800 多线程安全隐患[10797:47441] test - <NSThread: 0x600002deba40>{number = 16, name = (null)}\n10:16:19.552043+0800 多线程安全隐患[10797:47433] test - <NSThread: 0x600002deb600>{number = 8, name = (null)}\n10:16:19.552082+0800 多线程安全隐患[10797:47435] test - <NSThread: 0x600002deb8c0>{number = 10, name = (null)}\n10:16:21.552319+0800 多线程安全隐患[10797:47445] test - <NSThread: 0x600002debb40>{number = 20, name = (null)}\n10:16:21.552317+0800 多线程安全隐患[10797:47432] test - <NSThread: 0x600002deb800>{number = 7, name = (null)}\n10:16:21.552447+0800 多线程安全隐患[10797:47439] test - <NSThread: 0x600002deb9c0>{number = 14, name = (null)}\n10:16:21.552460+0800 多线程安全隐患[10797:47438] test - <NSThread: 0x600002deb980>{number = 13, name = (null)}\n10:16:21.552463+0800 多线程安全隐患[10797:47449] test - <NSThread: 0x600002df16c0>{number = 24, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47436] test - <NSThread: 0x600002deb900>{number = 11, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47443] test - <NSThread: 0x600002debac0>{number = 18, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47444] test - <NSThread: 0x600002debb00>{number = 19, name = (null)}\n10:16:24.475953+0800 多线程安全隐患[10797:47450] test - <NSThread: 0x600002da8380>{number = 25, name = (null)}\n10:16:24.476004+0800 多线程安全隐患[10797:47446] test - <NSThread: 0x600002debb80>{number = 21, name = (null)}\n10:16:26.476651+0800 多线程安全隐患[10797:47437] test - <NSThread: 0x600002deb940>{number = 12, name = (null)}\n10:16:26.476652+0800 多线程安全隐患[10797:47448] test - <NSThread: 0x600002debc00>{number = 23, name = (null)}\n10:16:26.476658+0800 多线程安全隐患[10797:47447] test - <NSThread: 0x600002debbc0>{number = 22, name = (null)}\n10:16:26.476660+0800 多线程安全隐患[10797:47442] test - <NSThread: 0x600002deba80>{number = 17, name = (null)}\n10:16:26.476658+0800 多线程安全隐患[10797:47440] test - <NSThread: 0x600002deba00>{number = 15, name = (null)}\n```\n\n从打印结果可以看到，一共执行了4次，每次5条线程。这是因为初始化 semaphore 的条件是5，每调用一次 `dispatch_semaphore_wait` 会减1，减5次等于0后就不在执行其它线程了。每调用一次 `dispatch_semaphore_signal` 会加1，就会有新的线程开始调用 `dispatch_semaphore_wait` 对条件减1。 \n\n### 应用 - 解决卖票和存钱取钱问题\n```\n@interface SemaphoreDemo()\n@property (nonatomic, strong) dispatch_semaphore_t moneySemaphore;\n@property (nonatomic, strong) dispatch_semaphore_t ticketSemaphore;\n@end\n\n@implementation SemaphoreDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneySemaphore = dispatch_semaphore_create(1);\n        self.ticketSemaphore = dispatch_semaphore_create(1);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __drawMoney];\n    \n    dispatch_semaphore_signal(self.moneySemaphore);\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __saveManey];\n    \n    dispatch_semaphore_signal(self.moneySemaphore);\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    dispatch_semaphore_wait(self.ticketSemaphore, DISPATCH_TIME_FOREVER);\n    \n    [super __saleTicket];\n    \n    dispatch_semaphore_signal(self.ticketSemaphore);\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### dispatch_semaphore 汇编分析\n\n查看方式与 “OSSpinLock 汇编分析” 相同。可以看到第一次调用 `- (void)__saleTicket` 方法是在 Thread 9 对信号量减1。第二次调用 `- (void)__saleTicket` 方法是在 Thread 11，因为此时的信号量等于0，所以 Thread 15 处于等待信号量变成 >0 的状态。重复执行 `si` 指令，到第16行时会调用 `dispatch_semaphore_wait` 函数：\n![多线程33](多线程/多线程33.png)\n执行 `si` 指令，进入 `dispatch_semaphore_wait` 函数：\n![多线程34](多线程/多线程34.png)\n执行 `si` 指令，进入 `dispatch_semaphore_wait_slow` 函数：\n![多线程35](多线程/多线程35.png)\n重复执行 `si` 指令，在第35行，进入 `_dispatch_sema4_wait` 函数：\n![多线程36](多线程/多线程36.png)\n重复执行 `si` 指令，在第8行，调用 `semaphore_wait` 函数：\n![多线程37](多线程/多线程37.png)\n执行 `si` 指令，进入 `semaphore_wait` 函数：\n![多线程38](多线程/多线程38.png)\n执行 `si` 指令，进入 `semaphore_wait_trap` 函数：\n![多线程39](多线程/多线程39.png)\n重复执行 `si` 指令，在第4行，调用 `syscall` 函数。`syscall` 是系统调用，这个函数调用完成后，XCode 就又回到了OC代码页面，线程就进入休眠状态了（🔎 互斥锁标志）：\n![多线程40](多线程/多线程40.png)\n\n## dispatch_queue\n\n直接使用 GCD 的串行队列，也是可以实现线程同步的。因为线程同步的本质就是保证多条线程按顺序执行任务，所以串行队列可以通过控制执行顺序来实现线程同步。\n\n解决卖票和存钱取钱问题：\n```\n@interface SerialQueueDemo()\n@property (nonatomic, strong) dispatch_queue_t moneyQueue;\n@property (nonatomic, strong) dispatch_queue_t ticketQueue;\n@end\n\n@implementation SerialQueueDemo\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.moneyQueue = dispatch_queue_create(\"moneyQueue\", nil);\n        self.ticketQueue = dispatch_queue_create(\"ticketQueue\", nil);\n    }\n    return self;\n}\n\n/// 取钱\n- (void)__drawMoney\n{\n    dispatch_sync(self.moneyQueue, ^{\n       [super __drawMoney];\n    });\n}\n\n/// 存钱\n- (void)__saveManey\n{\n    dispatch_sync(self.moneyQueue, ^{\n       [super __saveManey];\n    });\n}\n\n/// 卖票\n- (void)__saleTicket\n{\n    dispatch_sync(self.ticketQueue, ^{\n       [super __saleTicket];\n    });\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n## @synchronized\n`@synchronized` 是对 mutex 递归锁的封装，`@synchronized(obj)` 内部会生成 obj 对应的递归锁，然后进行加锁、解锁操作。源码查看：[objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 objc-sync.mm 文件。\n\n### 解决卖票和存钱取钱问题\n\n为了解决不同对象调用的问题，存钱取钱的 `@synchronized()` 传入的是类对象 `[self class]`，卖票传入的是一个全局唯一的 NSObject 对象：\n```\n@implementation SynchronizeDemo\n\n///取钱\n- (void)__drawMoney\n{\n    @synchronized ([self class]) {\n        [super __drawMoney];\n    }\n}\n\n///存钱\n- (void)__saveManey\n{\n    @synchronized ([self class]) { /// 断点1\n        [super __saveManey];\n    }\n}\n\n///卖票\n- (void)__saleTicket\n{\n    static NSObject *object;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        object = [[NSObject alloc] init];\n    });\n    @synchronized (object) {\n        [super __saleTicket];\n    }\n}\n@end\n```\n\n打印结果同 OSSpinLock。\n\n### @synchronized 实现原理\n\n在断点1处查看汇编代码 Debug -> Debug Workflow -> Always Show Disassembly：\n![多线程32](多线程/多线程32.png)\n\n可以看到 `@synchronized()` 在开始和结束分别调用了 `objc_sync_enter()` 和 `objc_sync_exit()`，即：\n```\n///存钱\n- (void)__saveManey\n{\n    @synchronized ([self class]) { /// objc_sync_enter()\n        [super __saveManey];\n    } /// objc_sync_exit()\n}\n```\n\n源码查看：[objc4-781](https://opensource.apple.com/tarballs/objc4/) 中的 objc-sync.mm 文件\n```\n/// 加锁\nint objc_sync_enter(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE); /// 以 obj 为key，从哈希表里获取到对应的 spinlock_t\n        ASSERT(data);\n        data->mutex.lock(); /// 调用 mutex 上锁\n    } else {\n        // @synchronized(nil) does nothing\n        if (DebugNilSync) {\n            _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\");\n        }\n        objc_sync_nil();\n    }\n\n    return result;\n}\n\n/// 尝试加锁\nBOOL objc_sync_try_enter(id obj)\n{\n    BOOL result = YES;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE);\n        ASSERT(data);\n        result = data->mutex.tryLock();\n    } else {\n        // @synchronized(nil) does nothing\n        if (DebugNilSync) {\n            _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\");\n        }\n        objc_sync_nil();\n    }\n\n    return result;\n}\n\n/// 解锁\nint objc_sync_exit(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n    \n    if (obj) {\n        SyncData* data = id2data(obj, RELEASE); \n        if (!data) {\n            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n        } else {\n            bool okay = data->mutex.tryUnlock(); /// 调用 mutex 解锁\n            if (!okay) {\n                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n            }\n        }\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\n    return result;\n}\n```\n\n`SyncData` 实现：\n```\ntypedef struct alignas(CacheLineSize) SyncData {\n    struct SyncData* nextData;\n    DisguisedPtr<objc_object> object;\n    int32_t threadCount;  // number of THREADS using this block\n    recursive_mutex_t mutex; /// 对 os_unfair_recursive_lock 锁的封装👇\n} SyncData;\n\n#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock\n#define LIST_FOR_OBJ(obj) sDataLists[obj].data\n\nstatic SyncData* id2data(id object, enum usage why)\n{\n    spinlock_t *lockp = &LOCK_FOR_OBJ(object);\n    SyncData **listp = &LIST_FOR_OBJ(object);\n    SyncData* result = NULL;\n\n    ......\n}\n```\n\n`recursive_mutex_tt` 实现：\n```\nclass recursive_mutex_tt : nocopy_t {\n    os_unfair_recursive_lock mLock;\n\n  public:\n    constexpr recursive_mutex_tt() : mLock(OS_UNFAIR_RECURSIVE_LOCK_INIT) { /// 静态初始化方法，递归锁\n        lockdebug_remember_recursive_mutex(this);\n    }\n\n    constexpr recursive_mutex_tt(const fork_unsafe_lock_t unsafe)\n        : mLock(OS_UNFAIR_RECURSIVE_LOCK_INIT)\n    { }\n\n    void lock()\n    {\n        lockdebug_recursive_mutex_lock(this);\n        os_unfair_recursive_lock_lock(&mLock);\n    }\n\n    void unlock()\n    {\n        lockdebug_recursive_mutex_unlock(this);\n\n        os_unfair_recursive_lock_unlock(&mLock);\n    }\n\n    void forceReset()\n    {\n        lockdebug_recursive_mutex_unlock(this);\n\n        bzero(&mLock, sizeof(mLock));\n        mLock = os_unfair_recursive_lock OS_UNFAIR_RECURSIVE_LOCK_INIT;\n    }\n\n    bool tryLock()\n    {\n        if (os_unfair_recursive_lock_trylock(&mLock)) {\n            lockdebug_recursive_mutex_lock(this);\n            return true;\n        }\n        return false;\n    }\n\n    bool tryUnlock()\n    {\n        if (os_unfair_recursive_lock_tryunlock4objc(&mLock)) {\n            lockdebug_recursive_mutex_unlock(this);\n            return true;\n        }\n        return false;\n    }\n\n    void assertLocked() {\n        lockdebug_recursive_mutex_assert_locked(this);\n    }\n\n    void assertUnlocked() {\n        lockdebug_recursive_mutex_assert_unlocked(this);\n    }\n};\n```\n\n因为从源码中看到锁在初始化时传入的是 `OS_UNFAIR_RECURSIVE_LOCK_INIT`，所以 `@synchronized()` 其实就是一个递归锁。\n\n验证：\n```\n- (void)otherTest\n{\n    @synchronized (self) {\n        NSLog(@\"%s\", __func__);\n        [self otherTest];\n    }\n}\n```\n\n打印结果：\n```\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n-[SynchronizeDemo otherTest]\n......\n```\n\n# iOS线程同步方案性能比较\n\n性能从高到低排序\n* os_unfair_lock\n* OSSpinLock\n* dispatch_semaphore\n* pthread_mutex\n* dispatch_queue(DISPATCH_QUEUE_SERIAL)\n* NSLock\n* NSCondition\n* pthread_mutex(recursive)\n* NSRecursiveLock\n* NSConditionLock\n* @synchronized\n\n推荐使用\n* dispatch_semaphore\n* pthread_mutex\n\n## dispatch_semaphore\n不同方法使用 `dispatch_semaphore` 实现线程同步，每个方法都需要一把属于自己的锁，可以这样实现：\n```\n/// 加锁\n#define SemaphoreBegin \\\nstatic dispatch_semaphore_t semaphore; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    semaphore = dispatch_semaphore_create(1); \\\n}); \\\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n/// 解锁\n#define SemaphoreEnd \\\ndispatch_semaphore_signal(semaphore);\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n\n- (void)test2 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n\n- (void)test3 {\n    SemaphoreBegin\n    \n    NSLog(@\"%s\", __func__);\n    \n    SemaphoreEnd\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController test1]\n-[ViewController test2]\n-[ViewController test3]\n```\n\n## pthread_mutex\n```\n#define PthreadMutexBegain \\\nstatic pthread_mutex_t mutex; \\\nstatic dispatch_once_t onceToken; \\\ndispatch_once(&onceToken, ^{ \\\n    pthread_mutex_init(&mutex, NULL); \\\n}); \\\npthread_mutex_lock(&mutex);\n\n#define PthreadMutexEnd \\\npthread_mutex_unlock(&mutex);\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    sleep(2);\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n\n- (void)test2 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n\n- (void)test3 {\n    PthreadMutexBegain\n    \n    NSLog(@\"%s\", __func__);\n    \n    PthreadMutexEnd\n}\n@end\n```\n\n打印结果：\n```\n-[ViewController test1]\n-[ViewController test2]\n-[ViewController test3]\n```\n\n## 自旋锁、互斥锁比较\n\n* 什么情况使用自旋锁比较划算？  \n预计线程等待锁的时间很短；（线程1加锁后处理的事情很少，线程2不需要等太多时间，就没必要去休眠，只通过一个while循环稍微等一下就好）  \n加锁的代码（临界区）经常被调用，但竞争情况很少发生；（对于多条线程同时调用临界区的情况很少，而且临界区的调用比较频繁，使用自旋锁效率会更高）  \nCPU资源不紧张；（自旋锁的优点是效率高，缺点是一直占用CPU资源，如果CPU资源不紧张，比如多核，就可以忽略自旋锁的缺点）  \n多核处理器；\n\n* 什么情况使用互斥锁比较划算？  \n预计线程等待锁的时间较长；（线程1加锁后处理的事情很多，比如需要耗时2~3秒，此时自旋锁效率高的优点也没啥用了，不如让线程2去休眠，这样也减少了CPU资源的占用）  \n单核处理器；（这种情况以节省CPU资源为主，尽量不去占用CPU资源）  \n临界区有IO操作；（因为IO操作是比较占用CPU资源的，所以这种情况以节省CPU资源为主）  \n临界区代码复杂或者循环量大；（因为这种情况比较耗时，所以忽略效率比较高的自旋锁，选择节省CPU资源的互斥锁）  \n临界区竞争非常激烈；（很多线程会同事调用临界区的代码，为了节省CPU资源，选择互斥锁）\n\n## atomic\natom：原子，不可再分割的单位。atomic：原子性，用于保证属性 setter、getter 的原子性操作，相当于在 getter 和 setter 内部加了线程同步的锁。\n\n打开源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 objc-accessors.mm 文件，查看 setter 和 getter 方法 的实现：\n```\n/// setter 方法\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        /// 非原子性的不加锁\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        /// 原子性的要加锁\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n\n/// getter 方法\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    id *slot = (id*) ((char*)self + offset);\n    /// 非原子性的不加锁\n    if (!atomic) return *slot;\n        \n    /// 原子性的要加锁\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();\n    id value = objc_retain(*slot);\n    slotlock.unlock();\n    \n    return objc_autoreleaseReturnValue(value);\n}\n```\n\naotmic 并不能保证使用属性的过程是线程安全的：\n```\n@interface ViewController ()\n@property (atomic, copy) NSMutableArray *data;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.data = [NSMutableArray array];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil] start];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test2) object:nil] start];\n    [[[NSThread alloc] initWithTarget:self selector:@selector(test3) object:nil] start];\n}\n\n- (void)test1 {\n    [self.data addObject:@\"test1\"];\n}\n\n- (void)test2 {\n    [self.data addObject:@\"test2\"];\n}\n\n- (void)test3 {\n    [self.data addObject:@\"test3\"];\n}\n```\n\n上面这段代码中 data 是原子性的，所以 `self.data` 是线程安全的，但是 `addObject` 不是线程安全的，需要单独加锁：\n```\n- (void)test1 {\n    /// 加锁\n    [self.data addObject:@\"test1\"];\n    /// 解锁\n}\n\n- (void)test2 {\n    /// 加锁\n    [self.data addObject:@\"test2\"];\n    /// 解锁\n}\n\n- (void)test3 {\n    /// 加锁\n    [self.data addObject:@\"test3\"];\n    /// 解锁\n}\n```\n\n# iOS中的读写安全方案\n\n* 思考如何实现以下场景  \n  同一时间，只能有1个线程进行写的操作；  \n  同一时间，允许有多个线程进行读的操作；  \n  同一时间，不允许既有写的操作，又有读的操作；  \n\n上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有 `pthread_rwlock`（读写锁）和 `dispatch_barrier_async`（异步栅栏调用）。\n\n## pthread_rwlock\n\n### 相关API：\n```\n/// 初始化\npthread_rwlock_t lock;\npthread_rwlock_init(&lock, NULL);\n/// 读-加锁\npthread_rwlock_rdlock(&lock);\n/// 读-尝试加锁\npthread_rwlock_tryrdlock(&lock);\n/// 写-加锁\npthread_rwlock_wrlock(&lock);\n/// 写-尝试加锁\npthread_rwlock_trywrlock(&lock);\n/// 解锁\npthread_rwlock_unlock(&lock);\n/// 销毁\npthread_rwlock_destroy(&lock);\n```\n\n ### 应用\n ```\n@interface ViewController ()\n@property (nonatomic, assign) pthread_rwlock_t lock;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    /// 初始化\n    pthread_rwlock_init(&_lock, NULL);\n    \n    for (int i=0; i < 5; i++) {\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            [self read];\n        });\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            [self write];\n        });\n    }\n}\n\n- (void)read\n{\n    pthread_rwlock_rdlock(&_lock);\n    \n    NSLog(@\"%s\", __func__);\n    sleep(2);\n    \n    pthread_rwlock_unlock(&_lock);\n}\n\n- (void)write\n{\n    pthread_rwlock_wrlock(&_lock);\n    \n    NSLog(@\"%s\", __func__);\n    sleep(2);\n    \n    pthread_rwlock_unlock(&_lock);\n}\n\n- (void)dealloc\n{\n    pthread_rwlock_destroy(&_lock);\n}\n@end\n ```\n\n 打印结果：\n ```\n10:57:24.915613+0800 多线程安全隐患[3171:66309] -[ViewController read]\n10:57:24.915613+0800 多线程安全隐患[3171:66290] -[ViewController read]\n10:57:26.918756+0800 多线程安全隐患[3171:66295] -[ViewController write]\n10:57:28.921411+0800 多线程安全隐患[3171:66308] -[ViewController write]\n10:57:30.924043+0800 多线程安全隐患[3171:66299] -[ViewController read]\n10:57:32.927292+0800 多线程安全隐患[3171:66291] -[ViewController write]\n10:57:34.927716+0800 多线程安全隐患[3171:66327] -[ViewController read]\n10:57:36.930458+0800 多线程安全隐患[3171:66328] -[ViewController write]\n10:57:38.934914+0800 多线程安全隐患[3171:66329] -[ViewController read]\n10:57:40.940214+0800 多线程安全隐患[3171:66330] -[ViewController write]\n ```\n\n 从打印结果可以看到，read 和 read 操作之间存在同时被打印的情况，但是 read 和 write 操作、write 和 write 操作之间不存在同时被打印的情况。\n\n ## dispatch_barrier_async\n\n这个函数传入的并发队列必须是自己通过 `dispatch_queue_cretate` 创建的，如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于 `dispatch_async` 函数的效果。\n\n`dispatch_barrier_async` 方法能够保证当前只有这一个临界区在执行，就可以实现在写的时候，没有其它写操作和读操作。\n\n ### 相关API\n ```\n/// 初始化队列\ndispatch_queue_t queue = dispatch_queue_create(\"rw_queue\", DISPATCH_QUEUE_CONCURRENT);\n\n/// 读\ndispatch_async(queue, ^{\n    \n});\n\n/// 写\ndispatch_barrier_async(queue, ^{\n    \n});\n ```\n\n ### 应用\n ```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_queue_t queue;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.queue = dispatch_queue_create(\"rw_queue\", DISPATCH_QUEUE_CONCURRENT);\n    for (int i=0; i<5; i++) {\n        [self read];\n        [self read];\n        [self read];\n        [self write];\n        [self write];\n        [self write];\n    }\n}\n\n- (void)read\n{\n    dispatch_async(self.queue, ^{\n        NSLog(@\"read\");\n        sleep(2);\n    });\n}\n\n- (void)write\n{\n    dispatch_barrier_async(self.queue, ^{\n        NSLog(@\"write\");\n        sleep(2);\n    });\n}\n@end\n ```\n\n 打印结果：\n ```\n11:29:28.216697+0800 多线程安全隐患[3903:86003] read\n11:29:28.216708+0800 多线程安全隐患[3903:85991] read\n11:29:28.216724+0800 多线程安全隐患[3903:85989] read\n11:29:30.218087+0800 多线程安全隐患[3903:86003] write\n11:29:32.222250+0800 多线程安全隐患[3903:86003] write\n11:29:34.226490+0800 多线程安全隐患[3903:86003] write\n11:29:36.231180+0800 多线程安全隐患[3903:86003] read\n11:29:36.231210+0800 多线程安全隐患[3903:85983] read\n11:29:36.231265+0800 多线程安全隐患[3903:86132] read\n11:29:38.232286+0800 多线程安全隐患[3903:86003] write\n11:29:40.232572+0800 多线程安全隐患[3903:86003] write\n11:29:42.232894+0800 多线程安全隐患[3903:86003] write\n......\n ```\n\n 从打印结果可以看到，read 操作是可以同时进行的，write 操作只能一个一个执行。\n\n# 总结\n\n## 你理解的多线程？  \n  通过多线程可以处理耗时任务，减少主线程的压力。  \n  通过多线程可以处理一个复杂任务的不同部分，充分利用CPU资源，提升效率。  \n  多线程意味着你能够在同一个应用程序中运行多个线程，多线程应用程序就像是具有多个 CPU 在同时执行应用程序的代码。其实这是一种假象，线程数量并不等于 CPU 数量，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行。\n  ![多线程41](多线程/多线程41.png)\n\n## iOS的多线程方案有哪几种？你更倾向于哪一种？  \n\n### 性能从高到低排序\nos_unfair_lock  \nOSSpinLock  \ndispatch_semaphore  \npthread_mutex  \ndispatch_queue(DISPATCH_QUEUE_SERIAL)  \nNSLock  \nNSCondition  \npthread_mutex(recursive)  \nNSRecursiveLock  \nNSConditionLock  \n@synchronized\n\n### 推荐使用  \ndispatch_semaphore  \npthread_mutex\n\n## 你在项目中用过 GCD 吗？  \n### 回到主线程\n```\n- (void)action\n{\n    if (![NSThread isMainThread]) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self action];\n            return;\n        });\n    }\n}\n```\n\n### 等所有的网络请求结束后，再刷新UI\n```\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\ndispatch_queue_t queue = dispatch_queue_create(\"myRequestQueue\", NULL);\ndispatch_async(queue, ^{\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /// 减1\n    /// 请求全部完成\n    dispatch_async(dispatch_get_main_queue(), ^{\n        /// 回到主线程刷新UI\n    });\n});\n\n/// 网络请求1\n[self.server request1Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n\n/// 网络请求2\n[self.server request2Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n\n/// 网络请求3\n[self.server request3Completion:^(id responseObject) {\n    if (semaphore) dispatch_semaphore_signal(semaphore); /// 加1\n}];\n```\n\n### 延时执行\n```\n/// 延时5秒执行\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    /// 回到主线程执行 \n});\n```\n\n### 定时器\n```\n@interface ViewController ()\n@property (nonatomic, strong) dispatch_source_t timer;\n@end\n\n@implementation ViewController\n\n- (void)startTimer {\n\n    __weak typeof(self) weakSelf = self;\n    /// 初始化\n    _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));\n    /// 5秒后开始执行\n    dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));\n    /// 5秒执行一次\n    dispatch_source_set_timer(_timer, delayTime, 5.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n    dispatch_source_set_event_handler(_timer, ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf cancelTimer];\n        });\n    });\n    dispatch_resume(_timer);\n}\n\n- (void)cancelTimer {\n    if (_timer) {\n        dispatch_source_cancel(_timer);\n        _timer = nil;\n    }\n}\n@end\n```\n\n## GCD 的队列类型\nGCD的队列可以分为2大类型\n* 并发队列（Concurrent Dispatch Queue）  \n可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）；  \n并发功能只有在异步（dispatch_async）函数下才有效；\n\n* 串行队列（Serial Dispatch Queue）  \n让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）；\n\n主队列是一个特殊的串行队列，async 方法在主队列中添加任务不会开启新线程，并且是串行执行任务。\n\n## 说一下 OperationQueue 和 GCD 的区别，以及各自的优势\nOperationQueue 是对 GCD 的封装，更加面向对象。  \nGCD 相对于 OperationQueue 更加底层，效率更高。\n\n## 线程安全的处理手段有哪些？\n线程安全的处理是使用线程同步技术，包括加锁、信号量和串行队列。\n\n## OC你了解的锁有哪些？在你回答基础上进行二次提问；  \n\n性能从高到低排序：  \nos_unfair_lock  \nOSSpinLock  \ndispatch_semaphore  \npthread_mutex   \nNSLock  \nNSCondition  \npthread_mutex(recursive)  \nNSRecursiveLock  \nNSConditionLock  \n@synchronized\n\n### 追问一：自旋和互斥对比？\n* 什么情况使用自旋锁比较划算？  \n预计线程等待锁的时间很短；（线程1加锁后处理的事情很少，线程2不需要等太多时间，就没必要去休眠，只通过一个while循环稍微等一下就好）  \n加锁的代码（临界区）经常被调用，但竞争情况很少发生；（对于多条线程同时调用临界区的情况很少，而且临界区的调用比较频繁，使用自旋锁效率会更高）  \nCPU资源不紧张；（自旋锁的优点是效率高，缺点是一直占用CPU资源，如果CPU资源不紧张，比如多核，就可以忽略自旋锁的缺点）  \n多核处理器；\n\n* 什么情况使用互斥锁比较划算？  \n预计线程等待锁的时间较长；（线程1加锁后处理的事情很多，比如需要耗时2~3秒，此时自旋锁效率高的优点也没啥用了，不如让线程2去休眠，这样也减少了CPU资源的占用）  \n单核处理器；（这种情况以节省CPU资源为主，尽量不去占用CPU资源）  \n临界区有IO操作；（因为IO操作是比较占用CPU资源的，所以这种情况以节省CPU资源为主）  \n临界区代码复杂或者循环量大；（因为这种情况比较耗时，所以忽略效率比较高的自旋锁，选择节省CPU资源的互斥锁）  \n临界区竞争非常激烈；（很多线程会同事调用临界区的代码，为了节省CPU资源，选择互斥锁）\n\n### 追问二：使用以上锁需要注意哪些？  \n加锁后一定要解锁；  \n一个变量对应一个锁；  \n使用 `@synchronized(obj)` 传入的 obj 对象就相当于一个锁，如果有不同的对象调用临界区，可以使用类对象 `@synchronized([self class])`；  \n在使用 pthread_mutex_t、pthread_mutex_t 递归锁、pthread_mutex_t 条件 和 pthread_rwlock_t 锁时需要手动释放。\n\n### 追问三：用C/OC/C++，任选其一，实现自旋或互斥？\n参考上面的内容。\n\n## 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n\n- (void)test\n{\n    NSLog(@\"2\");\n}\n@end\n```\n\n上面有详解👆。\n\n## 请问下面代码的打印结果是什么？\n```\n@implementation ViewController\n- (void)test\n{\n    NSLog(@\"2\");\n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\n{\n    NSThread *thread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"1\");\n    }];\n    [thread start];\n    \n    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];\n}\n@end\n```\n\n上面有详解👆。\n\n\n[2w字 + 40张图带你参透并发编程！](https://juejin.im/post/6862464169158344717)\n\n","slug":"OC底层原理/多线程","published":1,"updated":"2023-08-22T09:52:13.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgva002xaq7k62a1f195"},{"title":"微信小程序","date":"2021-03-02T09:59:41.000Z","_content":"\n[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n<!-- more -->\n\n# 开发工具\n微信开发者工具相关内容：[微信官方文档-工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)。  \n小图标：[iconfont](https://www.iconfont.cn/)。  \n高效的设计稿标注、测量工具：[马克鳗](http://www.getmarkman.com/)。  \n数据：[聚合数据](https://www.juhe.cn/)。  \n小程序为了压缩体积，wxss 文件里设置图片，不支持本地资源图片，可以支持base64和网络图片：[base64图片在线转换工具](https://tool.chinaz.com/tools/imgtobase)。  \nCSS文档：[w3school](https://www.w3school.com.cn/cssref/index.asp)。  \n视频加密：[POLYV保利威](https://www.polyv.net/)。  \nminapp：VSCode 开发小程序插件。  \nBeautify：VSCode 代码格式化工具。  \n\n\n# 实战项目 DouBan\n![微信小程序01.png](微信小程序/微信小程序01.png)\n\n[小程序的生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)，打开 app.js 文件：\n```\nApp({\n\n  /**\n   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\n   */\n  onLaunch: function () {\n    \n  },\n\n  /**\n   * 当小程序启动，或从后台进入前台显示，会触发 onShow\n   */\n  onShow: function (options) {\n    \n  },\n\n  /**\n   * 当小程序从前台进入后台，会触发 onHide\n   */\n  onHide: function () {\n    \n  },\n\n  /**\n   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息\n   */\n  onError: function (msg) {\n    \n  }\n})\n```\n\n## 自定义组件\n[组件生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)，打开自定义组件的 .js 文件：\n```\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  },\n\n  /**\n   * 组件的生命周期方法列表\n   */\n  lifetimes: {\n    // 在组件实例进入页面节点树时执行\n    attached: function() {\n      \n    },\n\n    // 在组件实例被从页面节点树移除时执行\n    detached: function() {\n\n    },\n  },\n\n  /**\n   * 组件所在页面的生命周期\n   */\n  pageLifetimes: {\n    // 页面被展示\n    show: function() {\n\n    },\n\n    // 页面被隐藏\n    hide: function() {\n\n    },\n\n    // 页面尺寸变化\n    resize: function(size) {\n\n    }\n  }\n})\n```\n\n### stars\n自定义组件：评分（stars.wxml）：\n![微信小程序02.png](微信小程序/微信小程序02.png)\n\n#### stars.wxml\n```\n<!--components/stars/stars.wxml-->\n<view class='rate-group'>\n  <!-- 全黄 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{lights}}\" wx:key=\"*this\"\n    src='/images/rate_light.png'></image>\n  <!-- 半黄半灰 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{halfs}}\" wx:key=\"*this\"\n    src='/images/rate_half.png'></image>\n  <!-- 全灰 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{grays}}\" wx:key=\"*this\"\n    src='/images/rate_gray.png'></image>\n  <!-- 评分 -->\n  <text wx:if=\"{{istext}}\" style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>{{ratetext}}</text>\n</view>\n```\n\n在评分UI中，设置一个 view 作为五个星星和评分的容器：\n```\n<!--components/stars/stars.wxml-->\n<view class='rate-group'>\n  <!--内容-->\n</view>\n```\n\n`<view></view>`：创建 view 组件。  \n`class='rate-group'`：设置类名，方便在 stars.wxss 文件中设置布局。\n\n以创建黄色星星的的代码为例：\n```\n<image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{lights}}\" wx:key=\"*this\" src='/images/rate_light.png'></image>\n```\n\n`<image></image>`：创建 image 组件。  \n`style='width:{{starsize}}rpx;height:{{starsize}}rpx;'`：通过 style 设置 image 的宽高。  \n`wx:for=\"{{lights}}\" wx:key=\"*this\"`：通过 wx:for wx:key 遍历创建 image。  \n`src='/images/rate_light.png'`：指定 image 的文件路径。\n\n```\n<text wx:if=\"{{istext}}\" style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>{{ratetext}}</text>\n```\n\n`<text>{{ratetext}}</text>`：创建 text 组件。  \n`wx:if=\"{{istext}}\"`：如果条件成立，则创建 text。  \n`style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>`：指定字体大小、字体颜色。  \n`<text>{{ratetext}}</text>`：设置展示文案。  \n用于加载 stars.js 文件中的属性和变量，使用符号：`{% raw %}{{}}{% endraw %}`\n\n#### stars.wxss\nstars 组件的布局：\n```\n/* components/stars/stars.wxss */\n\n.rate-group {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 20rpx;\n  color: #ccc;\n}\n\n/* 设置图片的宽高 */\n.rate-group image {\n  width: 20rpx;\n  height: 20rpx;\n}\n```\n\n`display: flex;`：布局方式采用 flex 布局。  \n`justify-content: center;`：横向居中对齐。  \n`align-items: center;`：垂直居中对齐。  \n`font-size: 20rpx;`：在 .rate-group 容器中的字体大小。  \n`color: #ccc;`：在 .rate-group 容器中的字体颜色。  \n\n#### stars.js\n```\n// components/stars/stars.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    rate: {\n      type: Number,\n      value: 0,\n      observer(newVal, oldVal, changedPath) {\n        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'\n        // 通常 newVal 就是新设置的数据， oldVal 是旧数据\n        this.updateRate();\n      }\n    },\n    starsize: {\n      type: Number,\n      value: 20 //rpx\n    },\n    fontsize: {\n      type: Number,\n      value: 20 //rpx\n    },\n    fontcolor: {\n      type: String,\n      value: \"#ccc\"\n    },\n    istext: {\n      type: Boolean,\n      value: true\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n    updateRate: function () {\n      // 定义变量\n      var that = this;\n      var rate = that.properties.rate;\n      var intRate = parseInt(rate);\n      var light = parseInt(intRate / 2);\n      var half = intRate % 2;\n      var gray = 5 - light - half;\n      var lights = [];\n      var halfs = [];\n      var grays = [];\n      for (var index = 1; index <= light; index++) {\n        lights.push(index);\n      }\n      for (var index = 1; index <= half; index++) {\n        halfs.push(index);\n      }\n      for (var index = 1; index <= gray; index++) {\n        grays.push(index);\n      }\n      var ratetext = rate && rate > 0 ? rate.toFixed(1) : \"未评分\"\n      that.setData({\n        lights: lights,\n        halfs: halfs,\n        grays: grays,\n        ratetext: ratetext,\n      })\n    }\n  },\n\n  /**\n   * 组件的声明周期方法列表\n   */\n  lifetimes: {\n    // 在组件实例进入页面节点树时执行\n    attached: function(){\n      this.updateRate();\n    }\n  }\n})\n```\n\nstars 文件是自定义的组件，`rate、starsize、fontsize、fontcolor、istext` 都是 stars 文件的属性，是让调用者在调用时进行设置的，如果没有设置则使用默认值。`lights、halfs、grays、ratetext` 都是 stars 文件的变量，经过数据处理后，用于UI展示。\n\n更新UI：\n```\nthat.setData({\n  lights: lights,\n  halfs: halfs,\n  grays: grays,\n  ratetext: ratetext,\n})\n```\n\n### itemview\n自定义组件电影信息（itemview.wxml）：\n![微信小程序03.png](微信小程序/微信小程序03.png)\n\n#### itemview.wxml\n```\n<navigator wx:if=\"{{item}}\" class='item-navigator' url=\"{{itemurl}}\">\n  <view class='item-group'>\n    <!-- 封面 -->\n    <view class='thumbnail-group'>\n      <image class='thumbnail' src='{{item.cover.url}}'></image>\n    </view>\n    <!-- 名称 -->\n    <view class='item-title'>{{item.title}}</view>\n    <!-- 评分 -->\n    <stars rate=\"{{item.rating.value}}\"></stars>\n  </view>\n</navigator>\n\n<!-- 占位view -->\n<view wx:else class=\"item-navigator\"></view>\n```\n\nnavigator 组件是一个负责页面跳转的系统组件，具有响应点击事件和页面跳转功能。\n```\n<navigator url=\"{{itemurl}}\">\n  <!--内容-->\n</navigator>\n```\n\n`class='item-navigator'`：设置类名，便于布局。  \n`url=\"{{itemurl}}\"`：需要跳转的页面路径。因为是自定义组件，所以跳转路径由外部调用者传入。  \n`wx:if=\"{{item}}\" wx:else`：条件成立则创建 navigator 组件，否则创建空白 view。  \n\nstars 就是上面👆介绍的自定义组件-评分。设置 rate，其它属性使用默认值。\n```\n<stars rate=\"{{item.rating.value}}\"></stars>\n```\n\n#### itemview.json\n使用自定义组件的前提是在 .json 文件中导入了组件（`usingComponents`），如在 itemview.json 文件导入 `stars` 组件的文件路径：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\"\n  }\n}\n```\n\n#### itemview.wxss\n`itemview` 组件的布局：\n```\n.item-navigator {\n  width: 200rpx;\n  margin-right: 20rpx;\n  display: inline-block;\n}\n\n.item-navigator .item-group {\n  width: 100%;\n}\n\n.item-group .thumbnail-group {\n  width: 100%;\n  height: 284rpx;\n}\n\n.thumbnail-group .thumbnail {\n  width: 100%;\n  height: 100%;\n}\n\n.item-group .item-title {\n  font-size: 32rpx;\n  text-align: center;\n  margin-top: 20rpx;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  margin-bottom: 20rpx;\n}\n```\n\n`margin-right: 20rpx;`：是指容器本身右边距离其他容器有20像素，不包含在容器内；  \n`display: inline-block;`：垂直排列。  \n`width: 100%;`：宽度跟父view保持一致。  \n`text-align: center;`：字体居中显示。  \n`text-overflow: ellipsis;`：字体长度超过组件时显示为“...”。  \n`overflow: hidden;`：超出组件的view，隐藏。  \n`margin-bottom: 20rpx;`：设置底部边距。  \n\n#### itemview.js\n```\n// components/itemview/itemview.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    item: {\n      type: Object,\n      value: {}\n    },\n    itemurl: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n`itemview` 组件的属性有 `item、itemurl`，其中 item 是外部调用者创建好了的数据容器对象。itemurl 是外部调用者设置的跳转路径。\n\n### indexmodule\n![微信小程序04.png](微信小程序/微信小程序04.png)\n\n#### indexmodule.wxml\n```\n<!--components/indexmodule/indexmodule.wxml-->\n<view class='module-group'>\n  <!-- 标题、更多 -->\n  <view class='module-top'>\n    <view class='module-title'>{{title}}</view>\n    <navigator url=\"{{moreurl}}\" class='module-more'>更多</navigator>\n  </view>\n  <!-- 电影展示 -->\n  <scroll-view class='module-scroll-view' scroll-x=\"{{true}}\">\n    <itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n      itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n  </scroll-view>\n</view>\n```\n\n创建 scroll-view：\n```\n<scroll-view class='module-scroll-view' scroll-x=\"{{true}}\">\n  <!--内容-->\n</scroll-view>\n```\n\n`scroll-x=\"{{true}}\"`：设置滚动方向，x轴方向。  \n\n使用自定义组件：\n```\n<itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n      itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n```\n\n`item=\"{{item}}\"`：设置数据 item。  \n`itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"`：设置跳转页面的路径。路径中的 `?type={{type}}&id={{item.id}}\"` 是页面间跳转时的数据传递。  \n\n#### indexmodule.wxss\nindexmodule 组件的布局：\n```\n.module-group {\n  padding: 40rpx;\n  background-color: #fff;\n}\n\n.module-group .module-top {\n  font-size: 36rpx;\n  display: flex;\n  justify-content: space-between;\n}\n\n.module-group .module-title {\n  color: #494949;\n}\n\n.module-group .module-more {\n  color: #41be57;\n}\n\n.module-scroll-view {\n  margin-top: 40rpx;\n  width: 100%;\n  height: 400rpx;\n  white-space: nowrap;\n}\n```\n\n`padding: 40rpx;`：设置上下、左右边距。  \n`background-color: #fff;`：设置背景色。  \n`justify-content: space-between;`：项目沿主轴均匀分布，位于首尾两端的子容器与父容器紧紧挨着。  \n`white-space: nowrap;`：设置 scroll-view 不换行。 \n`margin-top: 40rpx;` 是指容器本身的顶部距离其他容器有40个像素，不包含在容器内；\n\n#### indexmodule.json\n在 .json 文件中导入了组件：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"itemview\": \"/components/itemview/itemview\"\n  }\n}\n```\n\n#### indexmodule.js\n为外部调用者提供了四个属性：`title、moreurl、items、type`：\n```\n// components/indexmodule/indexmodule.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    title: {\n      type: String,\n      value: \"\"\n    },\n    moreurl: {\n      type: String,\n      value: \"\"\n    },\n    items: {\n      type: Array,\n      value: []\n    },\n    type: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n### comment\n![微信小程序05](微信小程序/微信小程序05.png)\n\n#### comment.wxml\n为了方便布局，嵌套了多层view：\n```\n<view class=\"comment-group\">\n  <view class=\"left-comment\">\n    <image class=\"avatar\" src=\"{{item.user.avatar}}\"></image>\n  </view>\n  <view class=\"right-comment\">\n    <view class=\"username-rate\">\n      <text class=\"username\">{{item.user.name}}</text>\n      <stars rate=\"{{item.rating.value*2}}\" starsize=\"30\" istext=\"{{false}}\"></stars>\n    </view>\n    <view class=\"release-time\">{{item.create_time}}</view>\n    <view class=\"content\">{{item.comment}}</view>\n  </view>\n</view>\n```\n\n使用网络图片创建 image：\n```\n<image class=\"avatar\" src=\"{{item.user.avatar}}\"></image>\n```\n\n使用自定义组件 stars，自定义了星星的大小（starsize），不需要显示评分（istext = false）：\n```\n<stars rate=\"{{item.rating.value*2}}\" starsize=\"30\" istext=\"{{false}}\"></stars>\n```\n\n#### comment.wxss\n```\n.comment-group {\n  display: flex;\n  justify-content: flex-start;\n  padding-top: 40rpx;\n}\n\n.comment-group .left-comment {\n  width: 70rpx;\n  margin-right: 20rpx;\n}\n\n.left-comment .avatar {\n  width: 70rpx;\n  height: 70rpx;\n  border-radius: 50%;\n}\n\n.comment-group .right-comment {\n  flex: 1;\n}\n\n.right-comment .username-rate {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.username-rate .username {\n  font-size: 36rpx;\n  margin-right: 20rpx;\n}\n\n.release-time {\n  color: #b3b3b3;\n  font-size: 32rpx;\n  margin-top: 10rpx;\n}\n\n.content {\n  font-size: 32rpx;\n  color: #353535;\n  margin-top: 10rpx;\n}\n```\n\n`justify-content: flex-start;` 起始端对齐。默认就是这种对齐方式。  \n`padding-top: 40rpx;` 是指容器内的内容距离容器的顶部有40个像素，是包含在容器内的；  \n`border-radius: 50%;` 设置圆角，圆角大小等于宽度的一半。  \n\n#### comment.json\n在 .json 文件中导入了组件：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\"\n  }\n}\n```\n\n#### comment.js\n只需要一个参数 item 对象：\n```\n// components/comment/comment.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    item: {\n      type: Object,\n      value: {}\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n### searchbar\n![微信小程序06](微信小程序/微信小程序06.png)\n\n#### searchbar.wxml\n```\n<!--components/searchbar/searchbar.wxml-->\n<view class='searchbar'>\n  <navigator wx:if=\"{{isnavigator}}\" url='/pages/search/search' class='searh-navigator'></navigator>\n  <view wx:else class='search-input-group'>\n    <input class='search-input' placeholder='搜索' bindinput=\"onInputEvent\"></input>\n  </view>\n</view>\n```\n\n如果 isnavigator = true，创建导航组件，在点击搜索框时，跳转到 search 页面：\n```\n<navigator wx:if=\"{{isnavigator}}\" url='/pages/search/search' class='searh-navigator'></navigator>\n```\n\n如果 isnavigator = false，创建输入框：\n```\n<input class='search-input' placeholder='搜索' bindinput=\"onInputEvent\"></input>\n```\n\n#### searchbar.wxss\n```\n/* components/searchbar/searchbar.wxss */\n\n.searchbar {\n  background-color: #41be57;\n  padding: 20rpx; \n}\n\n.searh-navigator {\n  width: 100%;\n  height: 60rpx;\n  background-color: #fff;\n  border-radius: 10rpx;\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAPA0lEQVR4Xu2dj5UUNxLGpQgMERhHwBKBrUnAEIFxBOYiOByBIQKvIzBOYAQR3F4EhyM4iED3Pq/mPDvsTFep1b3qqq/f4wFvJc3qK/2mVKU/HQMfKkAFzioQqQ0VoALnFSAgHB1U4IICBITDgwoQEI4BKtCmAD1Im26s5UQBAuLE0OxmmwIEpE031nKiAAFxYmh2s00BAtKmG2s5UYCAODE0u9mmAAFp0421nChAQJwYmt1sU4CAtOnGWk4UICBODM1utilAQNp0Yy0nChAQJ4ZmN9sUICBturGWEwUIiBNDs5ttChCQNt1Yy4kCBMSJodnNNgUISJturOVEAQLixNDsZpsCBKRNN9ZyogABcWJodrNNAQLSphtrOVGAgDgxNLvZpgABadONtZwoQECcGJrdbFOAgLTpxlpOFCAgTgzNbrYpQEDadGMtJwoQECeGZjfbFCAgDbrlnB+VUp7GGJ+EEPDnu6Nmjv99X+s3IYRP9c9f/y6l3Ox2uw8NvwqrLKwAAREInHMGBN9XEADAI0G1liIfQwiA5n0I4UNKCf/m84AKEJAz4u/3++9jjM8rFADkIR54GsDyLoTwR0oJ/+ezogIE5Ejs6il+CiEAjIeC4pL5Acq7lNJvK44R1x9FQEIIOecfQggvT2KJkQcGPMl1COFtSgnTMj4LKeAakArG60G9hdTkmIL9nFLC33w6K+ASECNgnA4FgtIZDjTnCpCc81UI4ZcNTaVaTE5QWlQ7U8cFIFi3CCH8M4TwqqN2d5oqpfw7xoi07CEmwN/H8QF+BwCKB+soVzHGb5f6fWqM8g9mvuYpbB6QnDPWLX7vuXZRSvkcY0RGCUDczJn/V68GcK5KKc9jjF/PM+md2gjmX6eU3nZs01VTpgHJOWM61dNrIL2KNCvgWOSpwDyvsDzt9CGYdv3IjJdeTZOA1PUMeI3DlEavTK1RSvkQY0RKFWCsulBX+/GqlPIyxvhVcyduK+J3x5QLfeEjVMAcIPUbOHeYUsFbXM+ZPgltICqWc35ZQZkbtwAQxiYi1Y1lsTCIQgi/Cvv+RbEaW2AAvRl1OlK9CtZusLjZ+iB2ejFqH1s7tUQ9Mx5kLhwhBHiMV2tPo1qN2gEUTLkSN0RetoAJQObAUWMMgLHJnbMVlDd1t7GWN0ACT8JV+DPKbR6QnDOmVJhaqZ5Syp8xRoCxWEZK9QvNLIx0dinlTYyxJfOFDBeD93tssGlAcs6Yi2MBUPtsajql6dwMTQiJJUBaplU1CIfXMP1tiUxeKeW6wZsQkhNINulBair3X5pv1roV5OVWYw1NX1G2bq9BbKLJdjFw3zogjescZqdUU+A0eFpCciTqpjxI/VbEIqBmhfy3lJI6iJ8aeFv6ec4ZW1cw5ZKuxiOjhxTwqjsHRtR0a4BgyoAjsdLHPRwHoWpc8l4BCbbWvJAKbbXcZgDBt2DdlSu1BeE4UaoBEmxJwZeS22cTgNSp1X8U+6sIx5khXbf/Y5oqfZ55SWzcJ8hWAMHOXHiQyQcr47vdburytsl2LBdQBu447/LMsh6X+jY8IJpvvLo6fsXgcno455yxFiRNAbudam0BEEytJu+oqouA33meDkxj8XeJen3qjfAEI7JZmGq5u2JoaECU2ya4Cqwh5HYxEVNRaTziMq4bFhBlYI5rOUUxinIMmS+ec9akzr/x5kVGBkS0EbFOrRB3uHP/PeitU62PwvURd2sjQwKi9B64VRAw8WlUQDmVdeVFRgUEN5HgRpKLDzYg7nY7zbaTqSbd/ny/38OLSK4cchWLjAqIKHNV9wvxNFwHrBVeBBkteBEX+7SGA0S6pYQLgh2oOGpCGYu4WRcZERAcgcXbnKYenKU2cVx2qqNr/VyxeOhmdX0oQGpw/t+pAYEV891uN7l4ONUOf35XAan3rrVcBOujASK914qLggvRvd/vPwlTvi5sMBogWNW9uNEQ6x673W6pl2guNOy206ximuVicXYYQOr9TsheTT2u0oxTYvT+uXKa9dh6NmskQKTTKwbnvak4yWaFECbjwFoFx3JNp9lHAmRy+zWnVwuScdT0fr/HLl/JBXTm070jASJZHHQx710Hg/OfoohDzE93hwBEEX+4yJwMAIh0q4/505ujACI9l+D6fPRa4GjOiaSUhhhDS2kzROek+4CsG2MpI2vblS7Y1nZNf2mNAogkQDfvzrUDecnyOecibN90JmsIQPb7PS40m3q12NuUUs8Xcgrt77OY0CYQh4AsPUSE31bmU4pL66xpXwGIabsM4UGEgJj+ptIM3jXK5pylu6pNn+h8cEAUASEBWYOM+hnSxEkIgYAsaRdFSpGALGmIk7YVgJiODUfwIKI1EKZ4V6Tj9s4s6a0yprOLBGTdcbeZT5MCwinWwiaVTrHoQRY2RPsUizHIkqYhIEuq2942PcitdpxitY8h0zUJyMYAsb5iOxptBGQcQHAzouSVzkzzrkgRARkEEPwaXElfceQLP0oBiOkzOg8egygAMb3nRzhuVyumAMS0Zx8CEOHFyaZXbFcb+cIPUmxWJCBCTZuLSYzBu3ib5W2qKLEJGra+PjWEBxG6808ppcdN1mYltQI5ZyROJl8tQUDU0uor5JxFlwSEEMxfVKZXb5kaksSJh/ezjOJBRBsWQwimMybLDHV9q4pbZnjtj15efQ3FmRDzBtGr17+GdPtPCMF8ZnEIDwITCzNZjEP68/BFi8KYsMbovHp0BZP8tVgofR2x6bTiKmJPfIj0uK31AB0yDeNBFLeKcz1kYYpyzpPXwHoI0EcDBO/8kNwq/jGl9M3CY8Rt8wzQ75p+GA9S4xDpreJ8BcJCCOec+RqKI22HAkSxHvIegchCY8R1s4w/BvYgCveOXpi+E/YhKK3pdsQfU6+4c/MaiqE8SJ1mSa4hRVGuiXSmSDG9crNgOxwgCiNheLh4FXFnDs42l3OefIlqrexmy8+IgDwqpXwUvor4XUrpxVoDyPLnSKe33nZVDwcIBqHiFWAuVnPXAFOhuauF2lEBeRJCkLwSGmOH6yIzCVJ4jz93ux1s4+YZEpAGL2J+09ySI1LhPdwE5we9RwZE40U+1bTvxyUHksW2c86iW2VKKe68B+w9LCANXuQmpfTM4iBesk+KzJXpK0bPaTw6IE9KKdh+8pVwkHAjo1Co+gUkOsnp1XsM70GqEUXX8B+NC3fzZAUT/y8qnVrVCm41HdqDHKwpPEx1KI54BKnIm5aB46FO3VKCRcHJSxk8e49NeJDqRaRn1g/jG3AAEsDC50QBRdyBmq7WPU4HyyY8SIVEeuKQkFz4Ssg5/xpCwJb2ycfbqvl9gmwGEPzy+/1eel6EkNxjbQ0ctbpr77GZKdbB1ljxVWa1UJXTrdvtO2LPUfV2s6X9kivdlAepUy3pibfjfruFpAbkv0inVUeicaf06AuF58hW3IBy3IS77JYmW3WiNc/aVEE250GOplvXIYQfJiPNuwUACfZtoa7pp17+9rvgdOAdHUopn2OMVyklbtvZqgc5WFR6A/k9JLxOKf1slZCcM6ZUWCVveXje/0i1zXqQGo/gcBWO6D5tGAnv612/Zr4pq9dAMD53S/p1SunHBk3NVdk0IB0gwZQL2yjebdmyMwLxS90mJFufYh3FI3M8CZoBIIhNNuVNKhg/1enU1E0kLd8B7iHZvAc5hiSEgNV2beB+aALe5M0WYpMKBvqJOGPudGoKHNeQmAFkZnbreJDAiyCI/21q5Kz98xU8xrkuuYXEHCA1LnlZSnmjOEdy38AYBpQafMNjiPZQLQSuS0hMAlIhuSqlvIsxfj1zwGDqhXUTLJ6ttoV+5WmUVCJ3kJgF5JDhqoP7e+kImCgHr4I458MSsNRDTPhdn0vOamj7hLMdMUZMH68VFzWcfowrSEwDchSXPC+lXM+ccp0OFHgWrKXc1LWYzxpoKgxYv0GQjfMuOLy0RCYqYNt6jBEJiDvpbEIy/RXjApAjbzInyzWt5m0JTMMuHdQCDGs9SDQAjLNTQ0Jy2RRuADnyJt+VUl7HGL9da5Su+Tl1LxViJoAhWtchJOct5A6Qk2kXMl1zg/g1x//Zz6rxBTwkYgT1UWNCcr+0bgE5AgUp4VeN+7keHI4aXwCK2TuUCcmX5nQPyPHUq64ztK7ErwZLnUYh4AYYSBR0ewjJXSkJyMnQqhc5I+v1cjSvcvAW2DvWMo2SUkRI/laKgFwYNSPAUqGAl4C3EAXdUhAulSMkt+oQEOFoqivbSNEiC3a1VBYM7x+PMQIIHFx60G34hISACPG4v1jdI4XFvb8W+QBOLfnkXHYMHuHQWowRHgF/AATec7Kah5B23Dsk9CDSkeK4nGdICIjjga/puldICIhmlDgv6xESAuJ80Gu77w0SAqIdISyvfQvxsWKb2ypPQDjgmxTw4kkISNPwYCUo4AESAsKxPkuBGZBs4tXdBGTW8GDlmZ5k+HcfEhCO8S4KzPAkQ0NCQLoMDzYyw5MM/VoKAsKx3VWBRk8CSJ6NuBeNgHQdHmxshicZ8i1gBIRjehEFGj3JcAuJBGSR4cFGqyfB5dp4mY/mGSpoJyAa07GsWoGcs/alq4hH8AJR9c0s6l9OUIGACERikXkKABLlZeLDvESUgMyzPWsLFcBVq/WK1q+EVR6P4EUIiNBaLDZfAVyCUW/cl7xT8sVDn8lHjwnIfLuzBYUC9fILyR3JQ+zVIiAK47JoPwUEcQkC9Qe/xIKA9LM5W1IqcMGbDJPqJSBKo7J4fwWO7hzDFUq4D+zBPcehlwSkv73ZoiEFCIghY7Ir/RUgIP01ZYuGFCAghozJrvRXgID015QtGlKAgBgyJrvSXwEC0l9TtmhIAQJiyJjsSn8FCEh/TdmiIQUIiCFjsiv9FSAg/TVli4YUICCGjMmu9FeAgPTXlC0aUoCAGDImu9JfAQLSX1O2aEgBAmLImOxKfwUISH9N2aIhBQiIIWOyK/0VICD9NWWLhhQgIIaMya70V4CA9NeULRpSgIAYMia70l8BAtJfU7ZoSAECYsiY7Ep/BQhIf03ZoiEFCIghY7Ir/RUgIP01ZYuGFCAghozJrvRXgID015QtGlKAgBgyJrvSXwEC0l9TtmhIAQJiyJjsSn8FCEh/TdmiIQX+B7BN6BQFysCGAAAAAElFTkSuQmCC\");\n  background-position: center center;\n  background-repeat: no-repeat;\n  background-size: 6%;\n}\n\n.search-input-group {\n  width: 100%;\n  height: 60rpx;\n  background-color: #fff;\n  border-radius: 10rpx;\n  padding: 10rpx 20rpx;\n  box-sizing: border-box;\n}\n\n.search-input {\n  min-height: 40rpx;\n  height: 40rpx;\n  font-size: 12px;\n}\n```\n\n`border-radius: 10rpx;`：设置圆角大小 10rpx。  \n`background-image: url(\"\")`：设置背景图。因为 wxss 文件里使用的是本地图片资源，所以需要将图片转成base64。  \n`background-position: center center;`：设置图片垂直水平居中。  \n`box-sizing: border-box;`：设置的边框和内边距的值是包含在 width 内的。\n`min-height: 40rpx; height: 40rpx;`：同时设置最小高度和高度，防止光标偏移。  \n`background-repeat: no-repeat;`：背景图像将仅显示一次。\n\n#### search.js\n```\n// components/searchbar/searchbar.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    isnavigator: {\n      type: Boolean,\n      value: false\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n    // 输入框输入回调\n    onInputEvent: function(event) {\n      var value = event.detail.value;\n      var detail = {\"value\": value};\n      var options = {};\n      // 回调方法\n      this.triggerEvent(\"searchinput\",detail,options);\n    }\n  }\n})\n```\n\n`isnavigator` 用于判断是否创建导航控件。  \n`onInputEvent` 是输入框正在输入的回调事件。  \n`this.triggerEvent(\"searchinput\",detail,options);` 主动触发事件 triggerEvent，参数为 `\"searchinput\"`、`detail`、`options`。因为这里的 `searchbar` 是自定义组件，所以需要将输入事件传递给外部调用者，外部调用者需要实现 triggerEvent 事件：  \nsearch.json 文件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\"\n  }\n}\n```\n\nsearch.wxml 文件：\n```\n<!-- 搜索框 -->\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\nsearch.js 文件：\n```\nonItemTapEvent: function(event) {\n  var that = this;\n  var id = event.currentTarget.dataset.id;\n  var title = event.currentTarget.dataset.title;\n\n  // to do\n},\n```\n\n## 网络\n\n[网络请求API](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)\n\n### urls.js\n![微信小程序11](微信小程序/微信小程序11.png)\n\n定义构造器 globalUrls：\n```\nconst globalUrls = {\n    // 内容\n}\n```\n\n定义 url 变量：\n```\n// 列表\nmovieList: \"https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items\",\ntvList: \"https://m.douban.com/rexxar/api/v2/subject_collection/tv_hot/items\",\nshowList: \"https://m.douban.com/rexxar/api/v2/subject_collection/tv_variety_show/items\",\n// 详情\nmovieDetail: \"https://m.douban.com/rexxar/api/v2/movie/\",\ntvDetail: \"https://m.douban.com/rexxar/api/v2/tv/\",\nshowDetail: \"https://m.douban.com/rexxar/api/v2/tv/\",\n```\n\n创建方法，根据参数拼接 url：\n```\n// 标签\nmovieTags: function(id){\n  return \"https://m.douban.com/rexxar/api/v2/movie/\" + id + \"/tags?count=8\"\n},\ntvTags: function(id){\n  return \"https://m.douban.com/rexxar/api/v2/tv/\" + id + \"/tags?count=8\"\n},\nshowTags: function(id){\n  return this.tvTags(id);\n},\n// 评论\nmovieComments: function(id,start=0,count=3){\n  return \"https://m.douban.com/rexxar/api/v2/movie/\" + id + \"/interests?count=\" + count + \"&start=\" + start;\n},\ntvComments: function(id,start=0,count=3){\n  return \"https://m.douban.com/rexxar/api/v2/tv/\" + id + \"/interests?count=\" + count + \"&start=\" + start;\n},\nshowComments: function(id,start=0,count=3){\n  return this.tvComments(id,start,count);\n},\n// 搜索\nsearchUrl: function(q) {\n  return \"https://m.douban.com/rexxar/api/v2/search?type=movie&q=\" + q\n}\n```\n\n导出构造器 globalUrls，导出后外部调用者通过 `import { globalUrls } from \"urls.js\"` 导入后可用：\n```\nexport {globalUrls}\n```\n\n### network\n```\n// 导入 globalUrls 类\nimport { globalUrls } from \"urls.js\"\n\n\n// 定义构造器 network\nconst network = {\n  // 电影\n  getMovieList: function (params) {\n    params.type = \"movie\";\n    this.getItemList(params);\n  },\n\n  // 电视剧\n  getTVList: function (params) {\n    params.type = \"tv\";\n    this.getItemList(params);\n  },\n\n  // 综艺\n  getShowList: function (params) {\n    params.type = \"show\";\n    this.getItemList(params);\n  },\n\n  // 首页列表\n  getItemList: function (params) {\n    var url = \"\";\n    if (params.type == \"movie\") {\n      url = globalUrls.movieList;\n    } else if (params.type == \"tv\") {\n      url = globalUrls.tvList;\n    } else if (params.type == \"show\") {\n      url = globalUrls.showList;\n    } else { \n    \n    }\n    var count = params.count ? params.count : 7;\n    // 发起网络请求\n    wx.request({\n      // 设置请求url\n      url: url,\n      // 设置请求参数\n      data: {\n        count: count\n      },\n      // 请求成功回调\n      success: function(res) {\n        var items = res.data.subject_collection_items;\n        var itemCount = items.length;\n        var left = itemCount%3;\n        if (left === 2) {\n          items.push(null);\n        }\n        if (params && params.success) {\n          params.success(items);\n        }\n      }\n    })\n  },\n  \n  // 详情\n  getItemDetail: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieDetail + id;\n    } else if (type === \"tv\") {\n      url = globalUrls.tvDetail + id;\n    } else if (type === \"show\") {\n      url = globalUrls.showDetail + id;\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res) {\n        var item = res.data;\n        if (params.success) {\n          params.success(item);\n        }\n      }\n    })\n  },\n  \n  // 标签\n  getItemTags: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieTags(id);\n    } else if (type === \"tv\") {\n      url = globalUrls.tvTags(id);\n    } else if (type === \"show\") {\n      url = globalUrls.showTags(id);\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res) {\n        var tags = res.data.tags;\n        if (params.success) {\n          params.success(tags)\n        }\n      }\n    })\n  },\n\n  // 评论\n  getItemComments: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var start = params.start;\n    var count = params.count;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieComments(id,start,count);\n    } else if (type === \"tv\") {\n      url = globalUrls.tvComments(id,start,count);\n    } else if (type === \"show\") {\n      url = globalUrls.showComments(id,start,count);\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res){\n        var comment = res.data;\n        if (params.success) {\n          params.success(comment); \n        }\n      }\n    })\n  },\n\n  // 搜索\n  getSearch: function(params) {\n    var q = params.q;\n    var url = globalUrls.searchUrl(q);\n    wx.request({\n      url: url,\n      success: function(res){\n        var subjects = res.data.subjects;\n        if (params.success) {\n          params.success(subjects);\n        }\n      }\n    })\n  }\n}\n\n// 导出构造器 network，导出后外部调用者通过 `import {network} from \"../../utils/network.js\"` 导入后可用：\nexport { network }\n```\n\n## 页面\n[页面生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)\n\n生命周期函数在 .js 文件：[注册页面](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)：\n```\nPage({\n  \n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload: function () {\n    \n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh: function () {\n    \n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom: function () {\n    \n  },\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage: function () {\n    \n  }\n})\n```\n\n### 首页\n![微信小程序07](微信小程序/微信小程序07.png)\n\n#### index.wxml\n```\n<!--index.wxml-->\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n\n<!-- 电影 -->\n<indexmodule title=\"电影\" moreurl=\"/pages/list/list?type=movie\" items=\"{{movies}}\" type=\"movie\"></indexmodule>\n\n<!-- 电视剧 -->\n<indexmodule title=\"电视剧\" moreurl=\"/pages/list/list?type=tv\" items=\"{{tvs}}\" type=\"tv\"></indexmodule>\n\n<!-- 综艺 -->\n<indexmodule title=\"综艺\" moreurl=\"/pages/list/list?type=show\" items=\"{{shows}}\" type=\"show\"></indexmodule>\n```\n\n创建自定义组件 `searchbar`， 指定导航 isnavigator = true。\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n```\n\n创建三个自定义组件 `indexmodule`，分别用于展示电影、电视剧和综艺。`moreurl` 是更多按钮跳转的页面路径，`items` 是每一个电影的信息。\n```\n<indexmodule title=\"电影\" moreurl=\"/pages/list/list?type=movie\" items=\"{{movies}}\" type=\"movie\"></indexmodule>\n```\n\n#### index.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\",\n    \"indexmodule\": \"/components/indexmodule/indexmodule\"\n  }\n}\n```\n\n#### index.js\n```\n//index.js\nimport {network} from \"../../utils/network.js\"\nPage({\n  \n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n    \n    // 电影\n    network.getMovieList({\n      success: function(movies){\n        that.setData({\n          movies: movies,\n        })\n      }\n    })\n   \n    // 电视剧\n    network.getTVList({\n      success: function(tvs) {\n        that.setData({\n          tvs: tvs,\n        })\n      }\n    })\n    \n    // 综艺\n    network.getShowList({\n      success: function (shows){\n        that.setData({\n          shows: shows,\n        })\n      }\n    })\n  }\n})\n```\n\n导入 network.js 文件后才可以使用 `network`：\n```\nimport {network} from \"../../utils/network.js\"\n```\n\n请求数据，`network.getMovieList({ })` 方法内部的 `{}` 是方法 `getMovieList: function (params){ }` 需要的 `params`，可以看到这里的 `params` 内部只有一个 `success: function(movies){ }` 方法。在网络请求完成时，`network` 在 `getMovieList()` 方法内部可以通过 `params.success(moives)` 回调过来：\n```\n// 电影\nnetwork.getMovieList({\n  success: function(movies){\n    that.setData({\n      movies: movies,\n    })\n  }\n})\n```\n\n更新数据，并且重新渲染UI：\n```\nthat.setData({\n  movies: movies,\n})\n```\n\n### 更多\n![微信小程序07](微信小程序/微信小程序07.png)\n\n#### list.wxml\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n\n<view class=\"container\">\n  <itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n    itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n</view>\n```\n\n创建自定义组件 `searchbar`， 指定导航 isnavigator = true。\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n```\n\n遍历创建 itemview 组件，展示每一个 item 数据。\n```\n<itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n    itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n```\n\n#### list.wxml\n```\n.container {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n  padding: 30rpx\n}\n```\n\n`justify-content: space-between;` 项目沿主轴均匀分布，位于首尾两端的子容器与父容器紧紧挨着。  \n`flex-wrap: wrap;` 换行。  \n`padding: 30rpx` 边距30个像素。  \n\n#### list.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\",\n    \"itemview\": \"/components/itemview/itemview\"\n  }\n}\n```\n\n#### list.js\n```\n// pages/list/list.js\nimport { network } from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    type: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n\n    // 提示框\n    wx.showLoading({\n      title: '正在加载中...',\n    })\n    var title = \"\";\n    var type = options.type;\n    if (type === \"movie\") {\n      // 电影\n      title = \"电影\";\n      network.getMovieList({\n        success: function(movies){\n          that.setData({\n            items: movies,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    } else if (type === \"tv\") {\n      //电视剧\n      title = \"电视剧\";\n      network.getTVList({\n        success: function(tvs) {\n          that.setData({\n            items: tvs,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    } else {\n      // 综艺\n      title = \"综艺\";\n      network.getShowList({\n        success: function(shows) {\n          that.setData({\n            items: shows,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    }\n\n    // 设置导航栏的标题\n    wx.setNavigationBarTitle({\n      title: title,\n    })\n  }\n})\n```\n\n导入网络请求文件 network.js：\n```\nimport { network } from \"../../utils/network.js\"\n```\n\n定义变量 type：\n```\ndata: {\n  type: {\n    type: String,\n    value: \"\"\n  }\n},\n```\n\n显示提示框：\n```\nwx.showLoading({\n  title: '正在加载中...',\n})\n```\n\n移除提示框：\n```\nwx.hideLoading();\n```\n\n设置导航栏的标题：\n```\nwx.setNavigationBarTitle({\n  title: title,\n})\n```\n\n### 电影详情\n![微信小程序09](微信小程序/微信小程序09.png)\n\n#### detail.wxml\n```\n<view class=\"item-header\">\n  <view class=\"item-title\">{{item.title}} {{item.original_title}}（{{item.year}}）</view>\n  <view class=\"item-detail\">\n    <view class=\"left-detail\">\n      <!-- 评分 -->\n      <view class=\"item-rate\">\n        <stars rate=\"{{item.rating.value}}\" starsize=\"30\" fontsize=\"30\" fontcolor=\"#595959\"></stars>\n        <text class=\"comment-persons\">{{item.rating.count}}人评价</text>\n      </view>\n      <!-- 信息 -->\n      <view class=\"item-sub-detail\">\n        <view class=\"item-type\">\n          {{item.durations[0]}} {{item.genres}}\n        </view>\n        <view class=\"item-show\">\n          {{item.pubdate[0]}}上映 {{item.countries[0]}}\n        </view>\n        <view class=\"actors\">\n          {{item.authors}}\n        </view>\n      </view>\n    </view>\n    <!-- 封面 -->\n    <view class=\"right-detail\">\n      <image src=\"{{item.cover.image.small.url}}\"></image>\n    </view>\n  </view>\n</view>\n\n<!-- 标签 -->\n<view class=\"item-tags\">\n  <view class=\"item-tags-title\">豆瓣成员常用标签</view>\n  <view class=\"item-tags-list\">\n    <text wx:for=\"{{tags}}\" wx:key=\"*this\">{{item}}</text>\n  </view>\n</view>\n\n<!-- 评论 -->\n<view class=\"comment-list-group\">\n  <view class=\"comment-title\">短评({{comment.total}})</view>\n  <comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n</view>\n\n<!-- 查看更多短评 -->\n<navigator class=\"more-comment\"\n  url=\"/pages/comments/comments?id={{id}}&type={{type}}&thumbnail={{item.cover.image.small.url}}&title={{item.title}}&rate={{item.rating.value}}\">\n  查看更多短评</navigator>\n```\n\n创建自定义组件-评分，指定星星大小、字体大小和字体颜色：\n```\n<stars rate=\"{{item.rating.value}}\" starsize=\"30\" fontsize=\"30\" fontcolor=\"#595959\"></stars>\n```\n\n遍历创建自定义组件-评价：\n```\n<comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n```\n\n创建“查看更多短评”按钮，需要传递五个参数：`id、type、thumbnail、title、rete`。\n```\n<navigator class=\"more-comment\"\n  url=\"/pages/comments/comments?id={{id}}&type={{type}}&thumbnail={{item.cover.image.small.url}}&title={{item.title}}&rate={{item.rating.value}}\">\n  查看更多短评</navigator>\n```\n\n#### detail.wxss\n```\n.item-header {\n  padding: 60rpx 30rpx;\n}\n\n/* 电影名称 */\n.item-header .item-title {\n  font-size: 50rpx;\n}\n\n/* 评分 */\n.item-header .item-detail {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 20rpx;\n}\n\n.item-detail .left-detail {\n  flex: 1;\n  margin-right: 20rpx; \n}\n\n.left-detail .item-rate {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.item-rate .comment-persons {\n  font-size: 28rpx;\n  color: #ccc;\n  margin-left: 20rpx;\n}\n\n/* 电影封面 */\n.item-detail .right-detail {\n  width: 200rpx;\n  height: 300rpx;\n}\n\n.right-detail image {\n  width: 100%;\n  height: 100%;\n}\n\n/* 电影信息 */\n.item-sub-detail {\n  margin-top: 40rpx;\n  font-size: 32rpx;\n}\n\n.item-sub-detail view {\n  margin-bottom: 10rpx;\n}\n\n/* 标签 */\n.item-tags {\n  padding: 0rpx 30rpx;\n}\n\n.item-tags .item-tags-title {\n  color: #b3b3b3;\n  font-size: 32rpx;\n  margin-bottom: 20rpx;\n}\n\n.item-tags .item-tags-list {\n  display: flex;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n}\n\n.item-tags-list text {\n  padding: 10rpx 20rpx;\n  background-color: #f5f5f5;\n  font-size: 32rpx;\n  color: #353535;\n  text-align: center;\n  border-radius: 40rpx;\n  margin-right: 20rpx;\n  margin-bottom: 20rpx;\n}\n\n/* 评论列表 */\n.comment-list-group {\n  padding: 60rpx 30rpx;\n}\n\n.comment-list-group .comment-title {\n  font-size: 32rpx;\n  color: #b3b3b3;\n}\n\n/* 查看更多短评 */\n.more-comment {\n  text-align: center;\n  font-size: 36rpx;\n  color: #41be57;\n  margin-bottom: 40rpx;\n}\n```\n\n#### detail.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\",\n    \"comment\": \"/components/comment/comment\"\n  }\n}\n```\n\n#### detail.js\n```\n// pages/detail/detail.js\nimport {network} from \"../../utils/network.js\"\n\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    <!-- options 可以获取到页面跳转时传递的数据 -->\n    console.log(options);\n    var that = this;\n    var type = options.type;\n    var id = options.id;\n    that.setData({\n      type: type,\n      id: id\n    })\n    // 详情\n    network.getItemDetail({\n      type: type,\n      id: id,\n      success: function(item) {\n        var genres = item.genres;\n        genres = genres.join(\"/\");\n        item.genres = genres;\n\n        var actors = item.actors;\n        var actornames = [];\n        if (actors.length > 3) {\n          actors = actors.slice(0, 3);\n        }\n        for (var index=0; index<actors.length; index++) {\n          var actor = actors[index];\n          actornames.push(actor.name);\n        }\n        \n        actornames = actornames.join(\"/\");\n        var director = \"\";\n        if (item.directors.length > 0) {\n          director = item.directors[0].name;\n        }\n        var authors = director + \"(导演) /\" + actornames;\n        item.authors = authors;\n        \n        that.setData({\n          item: item\n        });\n      }\n    });\n    // 标签\n    network.getItemTags({\n      type: type,\n      id: id,\n      success: function (tags) {\n        that.setData({\n          tags: tags\n        })\n      }\n    });\n    // 评论\n    network.getItemComments({\n      type: type,\n      id: id,\n      success: function (comment) {\n        that.setData({\n          comment: comment\n        })\n      }\n    })\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow: function () {\n    // 滚动到顶部\n    wx.pageScrollTo({\n      scrollTop: 0,\n    })\n  }\n})\n```\n\n数据处理，将 [1, 2, 3] -> '1/2/3' 的样式：\n```\nactornames = actornames.join(\"/\");\n```\n\n`var actornames = [];` 定义一个可变数组。  \n`actornames.push(actor.name);` 向数组中添加元素。  \n\n### 评论\n![微信小程序10](微信小程序/微信小程序10.png)\n\n#### comments.wxml\n```\n<view class=\"container\">\n  <!-- 电影详情 -->\n  <view class=\"item-group\" bindtap=\"onItenTapEvent\">\n    <image class=\"thumbnail\" src=\"{{thumbnail}}\"></image>\n    <text class=\"item-title\">{{title}}</text>\n    <text class=\"item-rate\">{{rate}}</text>\n  </view>\n\n  <!-- 评论 -->\n  <view class=\"comment-title\">全部影评({{comment.total}})</view>\n  <comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n\n  <!-- 上一页、下一页 -->\n  <view class=\"page-btn-group\">\n    <button class=\"page-btn\" bindtap=\"onPrePageTap\" disabled=\"{{start <= 1}}\" loading=\"{{preLoading}}\">上一页</button>\n    <button class=\"page-btn\" bindtap=\"onNextPageTap\" loading=\"{{nextLoading}}\">下一页</button>\n  </view>\n</view>\n```\n\n#### comments.wxss\n```\n.container {\n  padding: 20rpx 30rpx;\n}\n\n.item-group {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.item-group .thumbnail{\n  width: 40rpx;\n  height: 50rpx;\n}\n\n.item-group .item-title {\n  font-size: 32rpx;\n  color: #41be57;\n  margin-left: 10rpx;\n  margin-right: 10rpx;\n}\n\n.item-group .item-rate {\n  font-size: 28rpx;\n  color: #ccc;\n}\n\n.comment-title {\n  margin-top: 60rpx;\n  font-size: 40rpx;\n}\n\n/* 上一页、下一页 */\n.page-btn-group {\n  margin-top: 40rpx;\n  margin-bottom: 40rpx;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.page-btn {\n  flex: 1;\n  height: 60rpx;\n  color: #898989;\n  border-color: #898989;\n  line-height: 60rpx;\n}\n```\n\n#### comments.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"comment\": \"/components/comment/comment\"\n  }\n}\n```\n\n#### comments.js\n```\n// pages/comments/comments.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    total: 0,\n    start: 1,\n    count: 20\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    console.log(options);\n    var that = this;\n    that.setData(options);\n\n    that.getComments(1);\n  },\n\n  /**\n   * 获取评论\n   */\n  getComments: function(start) {\n    var that = this;\n    var type = that.data.type;\n    var id = that.data.id;\n    if (start > that.data.start) {\n      that.setData({\n        nextLoading: true\n      })\n    } else {\n      that.setData({\n        preLoading: true\n      })\n    }\n\n    // 请求评论数据\n    network.getItemComments({\n      type: type,\n      id: id,\n      start: start,\n      count: 20,\n      success: function (comment) {\n        that.setData({\n          comment: comment,\n          start: start,\n          nextLoading: false,\n          preLoading: false,\n        });\n        wx.pageScrollTo({\n          scrollTop: 0,\n        })\n      }\n    })\n  },\n\n  // 返回上一页\n  onItenTapEvent: function(event) {\n    wx.navigateBack({});\n  },\n\n  // 上一页\n  onPrePageTap: function(event) {\n    var that = this;\n    var oldStart = that.data.start;\n    var start = oldStart - that.data.count;\n    if (start > 0) {\n      that.getComments(start);\n    }\n  },\n\n  // 下一页\n  onNextPageTap: function(event) {\n    var that = this;\n    var oldStart = that.data.start;\n    var start = oldStart + that.data.count;\n    that.getComments(start);\n  }\n})\n```\n\n### 搜索\n![微信小程序12](微信小程序/微信小程序12.png)\n\n#### search.wxml\n```\n<!-- 搜索框 -->\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n\n<!-- 历史记录 -->\n<view class=\"history-list-group\" wx:if=\"{{histories && !subjects}}\">\n  <view class=\"history-title\">\n    <view class=\"title\">历史记录</view>\n    <view class=\"clear\" bindtap=\"clearEvent\">清除</view>\n  </view>\n  <view wx:for=\"{{histories}}\" wx:key=\"{{item.id}}\" url=\"/pages/detail/detail?type=movie&id={{item.id}}\" class=\"history-group\">{{item.title}}</view>\n</view>\n\n<!-- 搜索结果 -->\n<view class=\"item-list-group\">\n  <view class=\"item-group\" wx:for=\"{{subjects}}\" wx:key=\"{{item.id}}\" bindtap=\"onItemTapEvent\" data-id=\"{{item.id}}\" data-title=\"{{item.title}}\">\n    <image class=\"thumbnail\" src=\"{{item.pic.normal}}\"></image>\n    <view class=\"info-group\">\n      <view class=\"title\">{{item.title}}</view>\n      <view class=\"rate-year\">{{item.rating.value}}分/{{item.year}}</view>\n    </view>\n  </view>\n</view>\n```\n\n使用自定义组件 `searchbar`，使用 `bindsearchinput=\"onSearchInputEvent\"` 绑定输入框的输入事件。其中的 `bindsearchinput` = `bind` + `searchinput`，而 `\"onSearchInputEvent\"` 是搜索页面需要实现的回调方法：\n```\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\n#### search.wxss\n```\n.item-list-group {\n  padding: 10rpx 20rpx;\n}\n\n.item-list-group .item-group {\n  padding: 10rpx 0;\n  border-bottom: 1rpx solid #e4e4e4;\n  display: flex;\n}\n\n.item-group .thumbnail{\n  width: 80rpx;\n  height: 100rpx;\n  margin-right: 20rpx;\n}\n\n.item-group .info-group {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n\n.info-group .title {\n  font-size: 32rpx;\n}\n\n.info-group .rate-year {\n  font-size: 28rpx;\n  color: #7b7b7b;\n}\n\n\n.history-list-group {\n  padding: 10rpx 20rpx;\n}\n\n.history-list-group .history-title {\n  display: flex;\n  justify-content: space-between;\n  padding: 20rpx 0;\n  background: #f9f9f9;\n  font-size: 28rpx;\n  color: #9e9e9e;\n}\n\n.history-list-group .history-group {\n  font-size: 32rpx;\n  padding: 20rpx 0;\n  border-bottom: 1rpx solid #e4e4e4;\n}\n\n/* \n padding:10px 5px 15px 20px;\n \n 上内边距是 10px\n 右内边距是 5px\n 下内边距是 15px\n 左内边距是 20px\n\n ---------\n padding:10px 5px 15px;\n\n 上内边距是 10px\n 右内边距和左内边距是 5px\n 下内边距是 15px\n\n ---------\n padding:10px 5px;\n\n 上内边距和下内边距是 10px\n 右内边距和左内边距是 5px\n\n ---------\n padding:10px;\n\n 所有 4 个内边距都是 10px\n */\n```\n\n#### search.json\n使用自定义组件 searchbar：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\"\n  }\n}\n```\n\n#### search.js\n```\n// pages/search/search.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n    wx.getStorage({\n      key: 'searched',\n      success: function(res) {\n        console.log(res)\n        var data = res.data;\n        that.setData({\n          histories: data\n        })\n      },\n    })\n  },\n\n  // 输入框输入事件\n  onSearchInputEvent: function(event) {\n    var that = this;\n    var value = event.detail.value;\n    if (!value || value === \"\") {\n      that.setData({\n        subjects: null\n      });\n      return;\n    }\n    network.getSearch({\n      q: value,\n      success: function(subjects){\n        that.setData({\n          subjects: subjects\n        })\n      }\n    })\n  },\n\n  // 选中某一条搜索结果\n  onItemTapEvent: function(event) {\n    var that = this;\n    var id = event.currentTarget.dataset.id;\n    var title = event.currentTarget.dataset.title;\n    var histories = that.data.histories;\n    if (!histories) {\n      histories = [];\n    }\n    var isExisted = false;\n    for (var index=0; index<histories.length;index++) {\n      var movie = histories[index];\n      if (movie.id === id) {\n        isExisted = true;\n        break;\n      }\n    }\n    if (!isExisted) {\n      histories.push({ title: title, id: id })\n      wx.setStorage({\n        key: 'searched',\n        data: histories,\n        success: function () {\n          console.log(\"保存成功！\");\n        }\n      })\n    }\n    \n    // 页面跳转\n    wx.navigateTo({\n      url: \"/pages/detail/detail?type=movie&id=\"+id,\n    })\n  },\n\n  clearEvent: function() {\n    var that = this;\n    wx.removeStorage({\n      key: 'searched',\n      success: function(res) {\n        console.log(\"删除成功!\");\n        that.setData({\n          histories: null\n        });\n      },\n    });\n  }\n})\n```\n\n## 总结\n\n### 更新UI\n```\nthat.setData({\n  lights: lights,\n  halfs: halfs,\n  grays: grays,\n  ratetext: ratetext,\n})\n```\n\n### 页面跳转\n创建 `navigator` 组件；  \n设置跳转路径 `url`；  \n`type、id`：在 `url` 中通过符号 `?` 加入参数，实现页面间传值。  \n```\n<navigator url=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"> </navigator>\n```\n\n### padding、padding-top、margin-top 和 top 的区别\n```\npadding:10px 5px 15px 20px; //上内边距是 10px，右内边距是 5px，下内边距是 15px，左内边距是 20px\n\npadding:10px 5px 15px; //上内边距是 10px，右内边距和左内边距是 5px，下内边距是 15px\n\npadding:10px 5px; //上内边距和下内边距是 10px，右内边距和左内边距是 5px\n\npadding:10px; //所有 4 个内边距都是 10px\n\npadding-top:10px; //是指容器内的内容距离容器的顶部有10个像素，是包含在容器内的\n\nmargin-top:10px; //是指容器本身的顶部距离其他容器有10个像素，不包含在容器内\n\ntop:10px; //是指容器本身的顶部距离页面的顶端有10个像素\n```\n\n### observer（监听属性）  \n属性被改变时执行的函数（可选），也可以写成在 `methods` 段中定义的方法名字符串, 如：`'_propertyChange'`。通常 `newVal` 就是新设置的数据，`oldVal` 是旧数据\n```\nproperties: {\n  rate: {\n    type: Number,\n    value: 0,\n    observer(newVal, oldVal, changedPath) {\n      this.updateRate();\n    }\n  }\n}\n```\n\n### 事件回调、主动触发\n组件内通过主动触发回调方法，实现事件传递，同时使用到组件的文件需要绑定回调方法。以 `searchbar` 组件为例：  \nsearchbar.js 文件：\n```\n/**\n  * 组件的方法列表\n  */\nmethods: {\n  // 输入框输入回调\n  onInputEvent: function(event) {\n    var value = event.detail.value;\n    var detail = {\"value\": value};\n    var options = {};\n    // 回调方法\n    this.triggerEvent(\"searchinput\",detail,options);\n  }\n}\n```\n\nsearch.wxml 文件：\n```\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\n`bindsearchinput` = `bind` + `searchinput`。`\"onSearchInputEvent\"` 是需要实现的回调事件。\n\nsearch.js 文件：\n```\n// pages/search/search.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  // 输入框输入事件\n  onSearchInputEvent: function(event) {\n    var that = this;\n    var value = event.detail.value;\n    // to do\n  }\n})\n```\n\n### 加载动画\n```\n// 显示加载动画\nwx.showLoading({\n  title: '正在加载中...',\n})\n\n// 移除加载动画\nwx.hideLoading();\n```\n\n### scroll-view 滚动到指定位置\n```\n// 滚动到顶部\nwx.pageScrollTo({\n  scrollTop: 0,\n})\n```\n\n### 网络请求\n```\n// 发起网络请求\nwx.request({\n  // 设置请求url\n  url: url,\n  // 设置请求参数\n  data: {\n    count: count\n  },\n  // 请求成功回调\n  success: function(res) {\n    console.log(res);\n  }\n})\n```\n\n### 构造器\n可以单独创建一个 .js 文件，在文件内部创建构造器。以 `globalUrls、ntework` 为例，构造器内部可以定义变量、构造方法，这样外部调用者不需要初始化，可以直接使用 `globalUrls、ntework` 调用构造器内部的变量和方法，同 iOS 里的类方法。\n```\nconst globalUrls = {\n    // 内容\n}\n```\n\n\n# ES6语法\nES6 是 ECMAScript 6 的简写，ECMAScript 6 泛指“下一代 JavaScript 语言”，具体每年发布的都有自己的专属名称，比如2015年发布的则为 ESMAScript 2015。目前说的 ES6 语法，一般值得都是 ESMAScript 2015版。[ECMAScript](https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin) 是 JavaScript 的标准，JavaScript 是 ECMAScript 的一种实现，另外的 ECMAScript 方言还有 Jscript 和 ActionScript。\n\n在小程序开发工具中开启ES6：在微信开发者工具中->详情->ES6转ES5。\n\n## 定义变量\n\n### let\n`let` 跟 `var` 一样，也是用来定义变量，但是他比 `var` 更加的安全，体现在以下两点：\n1. 不会出现变量提升的情况。\n   ```\n   console.log(a);\n   var a = 10;\n   ```\n\n   变量 `a` 是在打印的后面定义的，但是以上的代码并不会出错，而是会打印 `undefined`，因为var会把变量 `a` 提升到代码最开始的地方进行定义。但是如果使用 `let` 就不会出现这种问题了：\n   ```\n   console.log(b);\n   let b = 10;\n   ```\n\n   此时再去打印的时候，就直接会抛出一个错误 `ReferenceError: b is not defined.`，这才是正确的方式。\n\n   注意：小程序中不能真正解析ES6语法，他只是借助了第三方工具将 ES6 语法转成 ES5 语法运行的，在底层也是用 `var` 来代替 `let` 的，所以依然会发生变量提升。\n\n2. 只在当前代码块内有效。\n   ```\n   for(var i=0;i<=3;i++){\n     console.log(i);\n   }\n   console.log(i);\n   ```\n\n   正常逻辑下，在 for 循环结束后 i 就不能够再使用了，但是这里的打印结果是 3 而不是抛出异常，这种现象在一些情况下也会阐释莫名其妙的错误，影响开发。但是 `let` 就不会出现这种情况：\n   ```\n   for(let i=0; i<=3; i++){\n     console.log(i);\n   }\n   console.log(i);\n   ```\n\n   此时再打印i的时候，就会抛出错误 `ReferenceError: b is not defined.`。\n\n### const\n`const` 是用来定义常量的，常量是一旦定义好了以后，就不能够再修改了：\n```\nconst PI = 3.14;\nPI = 3 // 会抛出异常\n```\n\n`const` 只是用来限制指向的内存地址不能改变，但是如果这个内存地址上的数据改变了，是可以的：\n```\nconst mylist = [1,2,3];\nmylist.push(4);\nconsole.log(mylist);\n```\n\n打印结果：\n```\n[1,2,3,4]\n```\n\n## 函数\n### 默认参数\n```\nfunction fetch(url, method=\"get\"){\n    console.log(url);\n    console.log(method);\n}\n```\n\n`method=\"get\"` 表示在调用 `fetch` 函数的时，可以不传 `method` 参数，他会默认使用 `get`：\n```\nfetch(\"http://www.baidu.com/\"); //method == get\nfetch(\"http://www.baidu.com/\",\"post\") // method == post\n```\n\n* 定义默认参数的时候，默认参数必须要在非默认参数的后面。\n\n有多个默认值的情况：\n```\nfunction person(name, age=18, gender='男'){\n    console.log(name, age, gender);\n}\n```\n\n在调用 `person` 函数时，如果只提供 `gender`，不提供 `age`，那么必须与解构赋值默认值结合使用：\n```\nfunction person(name, {age=18 ,gender='女'} = {}){\n    console.log(name, age, gender);\n}\n\nperson(\"知了\",{gender:\"男\"});\n```\n\n### 箭头函数\n函数作为一个参数变量传递的时候，为了简化写法，可以使用箭头函数来实现：\n```\nwx.request({\n    url: \"http://www.baidu.com/\",\n    success: function(res){\n        // to do\n    }\n});\n```\n\n对上面的代码使用箭头函数：\n```\nwx.request({\n    url: 'http://www.baidu.com/',\n    success: res => {\n        // to do \n    }\n});\n```\n\n#### 箭头函数的语法\n```\n(参数1,参数2) => {代码块}\n```\n\n定义一个网络请求的方法：\n```\nfunction request(url,success) {\n  if (success) {\n    let result = success();\n    console.log(result);\n  }\n}\n```\n\n如果只有一行代码，那么可以不用花括号（`(a,b) => a+b` 返回 a+b 的结果）：\n```\nrequest(\"http://www.baidu.com/\", (res1, res2) => true);\n```\n\n如果只有一个参数，可以不使用圆括号（`a => a+1`）：\n```\nrequest(\"http://www.baidu.com/\", res => {\n  console.log(res);\n  return true;\n});\n```\n\n如果没有参数：\n```\nrequest(\"http://www.baidu.com/\", () => {\n  console.log(\"111111\");\n  return true;\n});\n```\n\n### Promise\n`Promise` 的实现原理：\n```\nconst p = new Promise(function(resolve,reject){\n    setTimeout(() => {\n        // 如果执行以下代码，那么会执行下面的then函数\n        resolve(\"success\");\n    },1000);\n    \n    setTimeout(() => {\n        // 如果执行以下代码，那么会执行下面的catch函数\n        reject(\"fail\")\n    },1000);\n\n    // 如果以上代码都执行完，那么只会调用下面的then方法，因为resolve的调用在前面。\n});\n\np.then((res) => {\n  console.log(res);\n}).catch((error) => {\n  console.log(error);\n});\n```\n\n## 类\n在 ESS 中实现一个类：\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n在 ES6 中实现一个类：\n```\nclass Person{\n  // 构造函数\n  constructor(name,age){\n    this.name = name;\n    this.age = age;\n  }\n\n  sayHello(){\n    console.log(\"hello world\");\n  }\n}\n\nlet p = new Person(\"zhiliao\",18);\np.sayHello();\n```\n\n### 定义静态方法\n使用 `static` 关键字定义的静态方法，该静态方法是只属于类，不属于对象。在使用这个方法的时候直接通过类名就可以调用：\n```\nclass Utils{\n  constructor(){}\n  static timeFormat(time){\n    // to do\n  }\n}\n\n// 调用\nUtils.timeFormat(\"2021/1/1\")\n```\n\n## 模块\n在传统的 JS 中，没有办法在多个 js 文件中互相导入，对于大型项目来说很不方便。因此 ES6 提供了一个模块的功能。\n\n### export\n认在一个js文件中写好的代码或者变量，是不能够给其他的文件使用的，如果想要被外部使用，那么需要使用export关键字：\n```\n// utils.js\nvar name = \"zhiliao\";\nfunction dateFormat(date){\n    // 格式化代码\n}\nclass Person{\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }\n}\n\n// 导出\nexport {name,dateFormat,Person}\n```\n\n### import\n以上文件进行 `export` 了，那么以后其他文件想要使用的，则需要从这个文件中把需要的进行 `import`：\n```\n// from 后面是一个相对路径\nimport {name,dateFormat,Person} from \"utils.js\";\n```\n\n# 云开发\n\n[小程序·云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)\n\n## 创建小程序\n[创建小程序](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/quick-start/miniprogram.html)\n![微信小程序13](微信小程序/微信小程序13.png)\n![微信小程序14](微信小程序/微信小程序14.png)\n\n## 数据库\n### 创建程序\n新建项目 databasedemo：\n![微信小程序15](微信小程序/微信小程序15.png)\n\n### 初始化云开发\n在 app.js 文件中的 `onLaunch()` 方法 [初始化](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/init.html) 数据库：\n```\nApp({\n\n  /**\n   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\n   */\n  onLaunch: function () {\n    wx.cloud.init({\n      env: \"环境ID\"\n      traceUser: true\n    })\n  }\n})\n```\n`env`：指定所有服务的默认环境。  \n`traceUser`：是否在将用户访问记录到用户管理中，在控制台中可见。  \n\n### 创建集合\n在云开发的数据库中，使用的是 `NoSQL` 类型的数据库。关系型数据库中的表，对应的是 `NoSQL` 中的一个集合。所以在所数据操作之前，应该先创建一个集合。创建完集合后，也不需要跟关系型数据库一样，先定义好这个集合中的字段，而是直接插入数据，并且插入数据的时候，每条数据的字段无需保持一致！\n![微信小程序16](微信小程序/微信小程序16.png)\n\n### 获取数据库对象\n可以通过 `wx.cloud.database` 函数来获取数据库对象，这个函数默认会使用 `wx.cloud.init` 方法中提供的环境下的数据库。如果想要使用其他环境的数据库，可以给 `wx.cloud.database` 方法传递一个 `env` 参数，比如：`wx.cloud.database({ \"env\":\"数据库环境ID\" })`。\n\n### 获取集合对象\n可以通过 `db.collection(\"集合名称\")` 来获取集合对象，比如通过 `const test = db.collection(\"test\")` 获取到 `test` 集合对象，然后就可以对 `test` 来进行操作了。\n\n### 插入数据\n调用集合 `test` 的 `add()` 方法来插入数据：\n```\n// 数据库\nconst db = wx.cloud.database();\n\nPage({\n  /**\n   * 添加数据\n   */\n  add: function (options) {\n    // 集合\n    db.collection(\"test\").add({\n      data: {\n        title: \"测试标题\",\n        pub_date: new Date(\"2021-04-01\"),\n        author: \"测试作者\",\n        content: \"测试内容\"\n      }\n    }).then(res => {\n      console.log(res);\n    })\n  }\n})\n```\n\n![微信小程序17](微信小程序/微信小程序17.png)\n\n### 获取数据\n1.获取集合里的所有数据（考虑到性能，小程序一次性最多只能获取20条数据）\n```\nget: function (options) {\n  db.collection(\"test\").get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n2.根据 `id` 获取指定某一条数据（通过 `id` 获取数据需要通过 `doc()` 函数来实现）\n```\ngetById: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n3.根据条件获取数据，可以通过 where 函数来实现\n```\ngetBy: function (options) {\n  db.collection(\"test\").where({\n    title: \"测试标题\"\n  }).get().then(res => {\n    console.log(res);\n  })\n}\n```\n\n### 删除数据\n```\n/**\n * 删除一条数据,需要知道这条数据的 id\n */\nremove: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").remove().then(res => {\n    console.log(res);\n  })\n}\n```\n\n删除多条数据（只能在服务端实现，需要用到云函数）：\n```\ndb.collection(\"article\").where({\n    title: \"知了\"\n}).remove().then(res => {\n    console.log(res);\n});\n```\n\n### 更新数据\n```\n/**\n * 局部数据：局部更新是一次性只更新一条数据中的某几个字段的值，用的是update方法。 \n */\nupdate: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").update({\n    data: {\n      title: \"测试作者2\"\n    }\n  }).then(res => {\n    console.log(res);\n  })\n},\n\n/**\n * 整体更新：整体更新是一次性把所有数据都更新，用的是set方法 \n */\nupdateAll: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").set({\n    data: {\n        title: \"测试标题3\",\n        author: \"测试作者2\",\n        content: \"测试内容2\"\n    }\n  })\n}\n```\n\n一次更新多个数据：需要在服务器端，使用云函数来实现。 \n\n### command指令\n获取 command 对象：\n```\nconst db = wx.cloud.database();\nconst _ = db.command;\n```\n\n#### 查询指令\n通过 `db.command` 实现条件查询。\n##### command.eq\n示例一，在 `test` 集合中，找到字段 `author == \"测试作者03\"` 的数据：  \n第一种方式，通过制定数据查询：\n```\ndb.collection(\"test\").where({\n  author: \"测试作者03\"\n}).get().then(res => {\n  console.log(res);\n});\n```\n\n第二种方式，通过eq指令查询：\n```\neqcommand: function(){\n  db.collection(\"test\").where({\n    author: _.eq(\"测试作者03\")\n  }).get().then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序18](微信小程序/微信小程序18.png)\n`author: _.eq(\"测试作者03\")` 强调用是等于，`author: \"测试作者03\"` 强调的事匹配条件。\n\n示例二，匹配 `dic.key == \"测试对象03\"` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: {\n    key: \"测试对象03\"\n  }\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n指定数据方式可以获取到两条数据，这两条数据的 `dic` 对象的 `key` 等于\"测试对象03\"。\n![微信小程序19](微信小程序/微信小程序19.png)\n\n示例三，匹配 `dic.key == \"测试对象03\"` 且 `dic.key02 == \"测试对象03\"` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: {\n    key: \"测试对象03\",\n    key02: \"测试对象03\"\n  }\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序20](微信小程序/微信小程序20.png)\n\n示例四，获取 `dic == { key: \"测试对象\" }` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: _.eq({\n    key: \"测试对象03\"\n  })\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序21](微信小程序/微信小程序21.png)\n\n##### command.neq\n表示字段不等于某个值，和 `db.command.eq` 相反。\n\n##### command.lt\n表示小于某个值。比如查找小于2021/4/1 10:00:00发布的数据：\n```\ndb.collection(\"test\").where({\n  pub_date: _.lt(new Date(\"2021/4/1 10:00:00\"))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序22](微信小程序/微信小程序22.png)\n\n##### command.lte\n表示小于或者等于某个值。与 `command.lt` 类似。\n\n##### command.gt\n表示大于某个值。与 `command.lt` 类似。\n\n##### command.gte\n表示大于或者等于某个值。与 `command.lte` 类似。\n\n##### command.in\n查询筛选条件，表示字段的值需在给定的数组内。比如查找北京日报和今日头条两个作者发表的文章：\n```\ndb.collection(\"test\").where({\n  author: _.in([\"测试作者01\", \"测试作者02\"])\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序23](微信小程序/微信小程序23.png)\n\n##### command.nin\n查询筛选条件，表示字段的值需不在给定的数组内。与 `command.in` 类似。\n\n##### command.and\n查询指令，用于表示逻辑 \"与\" 的关系，表示需同时满足多个查询筛选条件。比如获取发表在 2021/4/1 10:00:00 和 2021/4/1 11:00:00 之间的所有数据：\n```\n// 1.普通调用\ndb.collection(\"test\").where({\n  pub_date: _.and(_.gte(new Date(\"2021/4/1 10:00:00\")), _.lte(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n\n// 2.链式调用\ndb.collection(\"test\").where({\n  pub_date: _.gte(new Date(\"2021/4/1 10:00:00\")).and(_.lte(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序24](微信小程序/微信小程序24.png)\n\n##### command.or\n查询指令，用于表示逻辑 \"或\" 的关系，表示需同时满足多个查询筛选条件。或指令有两种用法：\n1. 可以进行字段值的 “或” 操作；\n2. 可以进行跨字段的 “或” 操作。\n\n示例一，一个字段的或操作（比如获取时间在 2021/4/1 10:00:00 前或者 2021/4/1 11:00:00 后的数据）：\n```\ndb.collection(\"test\").where({\n  pub_date: _.or(_.lt(new Date(\"2021/4/1 10:00:00\")), _.gt(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序25](微信小程序/微信小程序25.png)\n\n示例二，跨字段或操作（比如想要获取时间在 2021/4/1 10:00:00 前，或者是作者中包含 “测试作者01” 的数据）：\n```\ndb.collection(\"test\").where(\n  _.or([\n    {\n      pub_date: _.lt(new Date(\"2021/4/1 10:00:00\"))\n    },\n    {\n      author: \"测试作者01\"\n    }\n  ])\n).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序26](微信小程序/微信小程序26.png)\n注意：`where()` 没有 `{}`，`or()` 内部是一个数组 `[]`。\n\n#### 更新指令\n\n##### command.set\n更新指令。用于设定字段等于指定值。比如以下是一条数据：\n![微信小程序27](微信小程序/微信小程序27.png)\n\n如果想将这个数据中的 `dic` 变成 `{ \"key\": \"测试对象\" } `，那么通过传统的方式是无法实现的：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: {\n      \"key\": \"测试对象\"\n    }\n  }\n}).then(res => {\n  console.log(res)\n})\n```\n\n上面这种方式，只能将 `dic.key` 改成“测试对象”，即 `dic == { key: \"测试对象\", key02: \"测试对象03\" }`，所以需要用 `_.set` 方法：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: _.set({\n      key: \"测试对象\"\n    })\n  }\n}).then(res => {\n  console.log(res);\n})\n```\n\n![微信小程序28](微信小程序/微信小程序28.png)\n\n##### command.remove\n更新指令。用于表示删除某个字段。比如我们想将author这个字段删除，那么就可以调用这个方法。示例代码如下：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: _.remove()\n  }\n}).then(res => {\n  console.log(res);\n})\n```\n\n![微信小程序29](微信小程序/微信小程序29.png)\n\n##### command.inc\n更新指令。用于指示字段自增某个值，这是个原子操作，使用这个操作指令而不是先读数据、再加、再写回的好处是：\n\n原子性：多个用户同时写，对数据库来说都是将字段加一，不会有后来者覆写前者的情况。\n减少一次网络请求：不需先读再写。\n比如 `test` 集合中的一条数据加一个 `read_count` 字段，给这个字段加1，那么可以使用以下方式实现：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    read_count: _.inc(1)\n  }\n})\n```\n\n运行两次：\n![微信小程序30](微信小程序/微信小程序30.png)\n\n##### command.mul\n自乘指令，跟 `command.inc` 一样。\n\n##### command.push\n更新指令，对一个值为数组的字段，往数组尾部添加一个或多个值。如果该字段原为空，则创建该字段并设数组为传入值。  \n比如要给 `test` 集合中的某条数据添加标签，那么可以使用以下方式来实现：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    tags: _.push([\"新闻\"])\n  }\n})\n```\n\n![微信小程序31](微信小程序/微信小程序31.png)\n\n##### command.pop\n更新指令，对一个值为数组的字段，将数组尾部元素删除。\n\n##### command.shift\n更新指令，对一个值为数组的字段，将数组头部元素删除。\n\n##### command.unshift\n更新指令，对一个值为数组的字段，往数组头部添加一个或多个值。如果该字段原为空，则创建该字段并设数组为传入值。\n\n### 高级查询\n#### collection.count\n统计集合记录数或统计查询语句对应的结果记录数，注意这与集合权限设置有关，一个用户仅能统计其有读权限的记录数。比如查找所有由“测试作者03”发布的数据的个数：\n```\ndb.collection(\"test\").where({\n  author: \"测试作者03\"\n}).count().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序32](微信小程序/微信小程序32.png)\n\n#### collection.orderBy\n该方法接受两个参数：\n1. 一个必填字符串参数 `fieldName` 用于定义需要排序的字段；\n2. 一个字符串参数 `order` 定义排序顺序，`order` 只能取 `asc` 或 `desc`。\n\n注意：\n1. 如果需要对嵌套字段排序，需要用 \"点表示法\" 连接嵌套字段，比如 `author.age` 表示字段 `author` 里的嵌套字段 `age`。\n2. 同时也支持按多个字段排序，多次调用 `orderBy` 即可，多字段排序时的顺序会按照 `orderBy` 调用顺序先后对多个字段排序。\n\n比如通过“阅读量”从大到小以及“作者的年龄”从小到大进行排序。那么可以使用以下代码来实现：\n```\norderBy: function (options) {\n  db.collection(\"test\")\n  .orderBy(\"read_count\", \"desc\")\n  .orderBy(\"author.age\", \"asc\")\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n没有指定字段的数据也会返回并且默认排在后面：\n![微信小程序33](微信小程序/微信小程序33.png)\n\n#### collection.limit\n指定查询结果集数量上限。比如一次性获取10篇文章，那么可以通过以下代码来实现：\n```\nlimit: function (options) {\n  db.collection(\"test\").limit(10)\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序34](微信小程序/微信小程序34.png)\n\n#### collection.skip\n指定查询返回结果时从指定序列后的结果开始返回，常用于分页。比如跳过前面4篇文章，从第11篇开始获取。代码如下：\n```\nskip: function (options) {\n  db.collection(\"test\").skip(4)\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序35](微信小程序/微信小程序35.png)\n\n#### collection.field\n指定返回结果中记录需返回的字段。比如只想获取 `test` 文章中的 `author` 字段。那么可以使用以下代码来实现：\n```\nfield: function (options) {\n  db.collection(\"test\").field({\n    read_count: true\n  }).get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n结果显示，如果数据中没有指定的字段也会返回：\n![微信小程序36](微信小程序/微信小程序36.png)\n\n## 文件管理\n小程序文件管理官方文档：[文件](https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.saveFile.html)。\n\n### wx.saveFile(Object object)  \n保存文件到本地。注意：saveFile 会把临时文件移动，因此调用成功后传入的 tempFilePath 将不可用\n```\n/**\n * 生命周期函数--监听页面显示\n */\nonShow: function () {\n  wx.chooseImage({\n    success: function (res) {\n      const tempFilePaths = res.tempFilePaths\n      wx.saveFile({\n        tempFilePath: tempFilePaths[0],\n        success (res) {\n          const savedFilePath = res.saveFile;\n          console.log(res)\n        }\n      })\n    }\n  })\n},\n```\n\n## 云函数\n### node环境搭建\n因为云函数在服务器上是运行在 node.js 环境中的，并且云函数会用到一些第三方库。先在本地编写好，再提交到云服务器，所以本地也需要安装好一套 node.js 环境。原则上，本地的 node.js 版本应该跟云服务器的版本一致。\n\n### 初始化环境\n在以上文件夹中，右键->初始化环境：\n![微信小程序37](微信小程序/微信小程序37.png)\n\n### 创建云函数\n在 `cloudfunctions` 文件夹上，右键->创建云函数，填入云函数的名称，然后点击确定即可创建好。然后就可以在相应的 `index.js` 文件中写代码了。示例代码如下：\n```\n// 云函数入口文件\nconst cloud = require('wx-server-sdk')\n\ncloud.init()\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const x = event.x;\n  const y = event.y;\n\n  return {\n    result: x + y\n  }\n}\n```\n\n### 上传和部署\n在本地创建完云函数后，需要上传到服务器并部署。只需要在相应函数的文件夹上：右键 -> 上传并部署：云端安装依赖。\n![微信小程序38](微信小程序/微信小程序38.png)\n\n### 在云函数中操作数据库\n在云函数中操作数据库、文件等，可以通过 `wx-server-sdk` 实现。这个 sdk 与小程序端的 API 有以下两点不同：\n1. 服务端的 API 仅支持 Promise 风格调用。\n2. 服务端 API 可以进行批量的 update 和 remove 操作。\n\n获取微博数据示例：\n```\n// 云函数入口文件\nconst cloud = require('wx-server-sdk')\ncloud.init()\n\n// 数据库\nconst db = cloud.database();\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取微信调用上下文\n  const wxContext = cloud.getWXContext()\n  // 小程序用户 openid\n  const openId = wxContext.OPENID;\n\n  const start = event.start;\n  // 获取 weibo 集合\n  let promise = db.collection(\"weibo\");\n  if (start > 0) {\n    promise = promise.skip(start);\n  }\n  // 异步获取10调微博数据，按创建时间，倒序\n  const weiboRes = await promise.limit(10).orderBy(\"create_time\", \"desc\").get()\n  const weibos = weiboRes.data;\n  if(weibos.length > 0){\n    weibos.forEach((weibo,index) => {\n      weibo.isPraised = false;\n      if(weibo.praises && weibo.praises.length > 0){\n        weibo.praises.forEach((praise,index) => {\n          if(praise == openId){\n            weibo.isPraised = true;\n          }\n        })\n      }\n    })\n  }\n  // 返回数据\n  return {\n    weibos\n  }\n}\n```\n\n","source":"_posts/Other/微信小程序.md","raw":"---\ntitle: 微信小程序\ndate: 2021-03-02 17:59:41\ntags: Other\n---\n\n[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n<!-- more -->\n\n# 开发工具\n微信开发者工具相关内容：[微信官方文档-工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)。  \n小图标：[iconfont](https://www.iconfont.cn/)。  \n高效的设计稿标注、测量工具：[马克鳗](http://www.getmarkman.com/)。  \n数据：[聚合数据](https://www.juhe.cn/)。  \n小程序为了压缩体积，wxss 文件里设置图片，不支持本地资源图片，可以支持base64和网络图片：[base64图片在线转换工具](https://tool.chinaz.com/tools/imgtobase)。  \nCSS文档：[w3school](https://www.w3school.com.cn/cssref/index.asp)。  \n视频加密：[POLYV保利威](https://www.polyv.net/)。  \nminapp：VSCode 开发小程序插件。  \nBeautify：VSCode 代码格式化工具。  \n\n\n# 实战项目 DouBan\n![微信小程序01.png](微信小程序/微信小程序01.png)\n\n[小程序的生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)，打开 app.js 文件：\n```\nApp({\n\n  /**\n   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\n   */\n  onLaunch: function () {\n    \n  },\n\n  /**\n   * 当小程序启动，或从后台进入前台显示，会触发 onShow\n   */\n  onShow: function (options) {\n    \n  },\n\n  /**\n   * 当小程序从前台进入后台，会触发 onHide\n   */\n  onHide: function () {\n    \n  },\n\n  /**\n   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息\n   */\n  onError: function (msg) {\n    \n  }\n})\n```\n\n## 自定义组件\n[组件生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)，打开自定义组件的 .js 文件：\n```\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  },\n\n  /**\n   * 组件的生命周期方法列表\n   */\n  lifetimes: {\n    // 在组件实例进入页面节点树时执行\n    attached: function() {\n      \n    },\n\n    // 在组件实例被从页面节点树移除时执行\n    detached: function() {\n\n    },\n  },\n\n  /**\n   * 组件所在页面的生命周期\n   */\n  pageLifetimes: {\n    // 页面被展示\n    show: function() {\n\n    },\n\n    // 页面被隐藏\n    hide: function() {\n\n    },\n\n    // 页面尺寸变化\n    resize: function(size) {\n\n    }\n  }\n})\n```\n\n### stars\n自定义组件：评分（stars.wxml）：\n![微信小程序02.png](微信小程序/微信小程序02.png)\n\n#### stars.wxml\n```\n<!--components/stars/stars.wxml-->\n<view class='rate-group'>\n  <!-- 全黄 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{lights}}\" wx:key=\"*this\"\n    src='/images/rate_light.png'></image>\n  <!-- 半黄半灰 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{halfs}}\" wx:key=\"*this\"\n    src='/images/rate_half.png'></image>\n  <!-- 全灰 -->\n  <image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{grays}}\" wx:key=\"*this\"\n    src='/images/rate_gray.png'></image>\n  <!-- 评分 -->\n  <text wx:if=\"{{istext}}\" style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>{{ratetext}}</text>\n</view>\n```\n\n在评分UI中，设置一个 view 作为五个星星和评分的容器：\n```\n<!--components/stars/stars.wxml-->\n<view class='rate-group'>\n  <!--内容-->\n</view>\n```\n\n`<view></view>`：创建 view 组件。  \n`class='rate-group'`：设置类名，方便在 stars.wxss 文件中设置布局。\n\n以创建黄色星星的的代码为例：\n```\n<image style='width:{{starsize}}rpx;height:{{starsize}}rpx;' wx:for=\"{{lights}}\" wx:key=\"*this\" src='/images/rate_light.png'></image>\n```\n\n`<image></image>`：创建 image 组件。  \n`style='width:{{starsize}}rpx;height:{{starsize}}rpx;'`：通过 style 设置 image 的宽高。  \n`wx:for=\"{{lights}}\" wx:key=\"*this\"`：通过 wx:for wx:key 遍历创建 image。  \n`src='/images/rate_light.png'`：指定 image 的文件路径。\n\n```\n<text wx:if=\"{{istext}}\" style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>{{ratetext}}</text>\n```\n\n`<text>{{ratetext}}</text>`：创建 text 组件。  \n`wx:if=\"{{istext}}\"`：如果条件成立，则创建 text。  \n`style='font-size:{{fontsize}}rpx;color:{{fontcolor}};'>`：指定字体大小、字体颜色。  \n`<text>{{ratetext}}</text>`：设置展示文案。  \n用于加载 stars.js 文件中的属性和变量，使用符号：`{% raw %}{{}}{% endraw %}`\n\n#### stars.wxss\nstars 组件的布局：\n```\n/* components/stars/stars.wxss */\n\n.rate-group {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 20rpx;\n  color: #ccc;\n}\n\n/* 设置图片的宽高 */\n.rate-group image {\n  width: 20rpx;\n  height: 20rpx;\n}\n```\n\n`display: flex;`：布局方式采用 flex 布局。  \n`justify-content: center;`：横向居中对齐。  \n`align-items: center;`：垂直居中对齐。  \n`font-size: 20rpx;`：在 .rate-group 容器中的字体大小。  \n`color: #ccc;`：在 .rate-group 容器中的字体颜色。  \n\n#### stars.js\n```\n// components/stars/stars.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    rate: {\n      type: Number,\n      value: 0,\n      observer(newVal, oldVal, changedPath) {\n        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'\n        // 通常 newVal 就是新设置的数据， oldVal 是旧数据\n        this.updateRate();\n      }\n    },\n    starsize: {\n      type: Number,\n      value: 20 //rpx\n    },\n    fontsize: {\n      type: Number,\n      value: 20 //rpx\n    },\n    fontcolor: {\n      type: String,\n      value: \"#ccc\"\n    },\n    istext: {\n      type: Boolean,\n      value: true\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n    updateRate: function () {\n      // 定义变量\n      var that = this;\n      var rate = that.properties.rate;\n      var intRate = parseInt(rate);\n      var light = parseInt(intRate / 2);\n      var half = intRate % 2;\n      var gray = 5 - light - half;\n      var lights = [];\n      var halfs = [];\n      var grays = [];\n      for (var index = 1; index <= light; index++) {\n        lights.push(index);\n      }\n      for (var index = 1; index <= half; index++) {\n        halfs.push(index);\n      }\n      for (var index = 1; index <= gray; index++) {\n        grays.push(index);\n      }\n      var ratetext = rate && rate > 0 ? rate.toFixed(1) : \"未评分\"\n      that.setData({\n        lights: lights,\n        halfs: halfs,\n        grays: grays,\n        ratetext: ratetext,\n      })\n    }\n  },\n\n  /**\n   * 组件的声明周期方法列表\n   */\n  lifetimes: {\n    // 在组件实例进入页面节点树时执行\n    attached: function(){\n      this.updateRate();\n    }\n  }\n})\n```\n\nstars 文件是自定义的组件，`rate、starsize、fontsize、fontcolor、istext` 都是 stars 文件的属性，是让调用者在调用时进行设置的，如果没有设置则使用默认值。`lights、halfs、grays、ratetext` 都是 stars 文件的变量，经过数据处理后，用于UI展示。\n\n更新UI：\n```\nthat.setData({\n  lights: lights,\n  halfs: halfs,\n  grays: grays,\n  ratetext: ratetext,\n})\n```\n\n### itemview\n自定义组件电影信息（itemview.wxml）：\n![微信小程序03.png](微信小程序/微信小程序03.png)\n\n#### itemview.wxml\n```\n<navigator wx:if=\"{{item}}\" class='item-navigator' url=\"{{itemurl}}\">\n  <view class='item-group'>\n    <!-- 封面 -->\n    <view class='thumbnail-group'>\n      <image class='thumbnail' src='{{item.cover.url}}'></image>\n    </view>\n    <!-- 名称 -->\n    <view class='item-title'>{{item.title}}</view>\n    <!-- 评分 -->\n    <stars rate=\"{{item.rating.value}}\"></stars>\n  </view>\n</navigator>\n\n<!-- 占位view -->\n<view wx:else class=\"item-navigator\"></view>\n```\n\nnavigator 组件是一个负责页面跳转的系统组件，具有响应点击事件和页面跳转功能。\n```\n<navigator url=\"{{itemurl}}\">\n  <!--内容-->\n</navigator>\n```\n\n`class='item-navigator'`：设置类名，便于布局。  \n`url=\"{{itemurl}}\"`：需要跳转的页面路径。因为是自定义组件，所以跳转路径由外部调用者传入。  \n`wx:if=\"{{item}}\" wx:else`：条件成立则创建 navigator 组件，否则创建空白 view。  \n\nstars 就是上面👆介绍的自定义组件-评分。设置 rate，其它属性使用默认值。\n```\n<stars rate=\"{{item.rating.value}}\"></stars>\n```\n\n#### itemview.json\n使用自定义组件的前提是在 .json 文件中导入了组件（`usingComponents`），如在 itemview.json 文件导入 `stars` 组件的文件路径：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\"\n  }\n}\n```\n\n#### itemview.wxss\n`itemview` 组件的布局：\n```\n.item-navigator {\n  width: 200rpx;\n  margin-right: 20rpx;\n  display: inline-block;\n}\n\n.item-navigator .item-group {\n  width: 100%;\n}\n\n.item-group .thumbnail-group {\n  width: 100%;\n  height: 284rpx;\n}\n\n.thumbnail-group .thumbnail {\n  width: 100%;\n  height: 100%;\n}\n\n.item-group .item-title {\n  font-size: 32rpx;\n  text-align: center;\n  margin-top: 20rpx;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  margin-bottom: 20rpx;\n}\n```\n\n`margin-right: 20rpx;`：是指容器本身右边距离其他容器有20像素，不包含在容器内；  \n`display: inline-block;`：垂直排列。  \n`width: 100%;`：宽度跟父view保持一致。  \n`text-align: center;`：字体居中显示。  \n`text-overflow: ellipsis;`：字体长度超过组件时显示为“...”。  \n`overflow: hidden;`：超出组件的view，隐藏。  \n`margin-bottom: 20rpx;`：设置底部边距。  \n\n#### itemview.js\n```\n// components/itemview/itemview.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    item: {\n      type: Object,\n      value: {}\n    },\n    itemurl: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n`itemview` 组件的属性有 `item、itemurl`，其中 item 是外部调用者创建好了的数据容器对象。itemurl 是外部调用者设置的跳转路径。\n\n### indexmodule\n![微信小程序04.png](微信小程序/微信小程序04.png)\n\n#### indexmodule.wxml\n```\n<!--components/indexmodule/indexmodule.wxml-->\n<view class='module-group'>\n  <!-- 标题、更多 -->\n  <view class='module-top'>\n    <view class='module-title'>{{title}}</view>\n    <navigator url=\"{{moreurl}}\" class='module-more'>更多</navigator>\n  </view>\n  <!-- 电影展示 -->\n  <scroll-view class='module-scroll-view' scroll-x=\"{{true}}\">\n    <itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n      itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n  </scroll-view>\n</view>\n```\n\n创建 scroll-view：\n```\n<scroll-view class='module-scroll-view' scroll-x=\"{{true}}\">\n  <!--内容-->\n</scroll-view>\n```\n\n`scroll-x=\"{{true}}\"`：设置滚动方向，x轴方向。  \n\n使用自定义组件：\n```\n<itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n      itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n```\n\n`item=\"{{item}}\"`：设置数据 item。  \n`itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"`：设置跳转页面的路径。路径中的 `?type={{type}}&id={{item.id}}\"` 是页面间跳转时的数据传递。  \n\n#### indexmodule.wxss\nindexmodule 组件的布局：\n```\n.module-group {\n  padding: 40rpx;\n  background-color: #fff;\n}\n\n.module-group .module-top {\n  font-size: 36rpx;\n  display: flex;\n  justify-content: space-between;\n}\n\n.module-group .module-title {\n  color: #494949;\n}\n\n.module-group .module-more {\n  color: #41be57;\n}\n\n.module-scroll-view {\n  margin-top: 40rpx;\n  width: 100%;\n  height: 400rpx;\n  white-space: nowrap;\n}\n```\n\n`padding: 40rpx;`：设置上下、左右边距。  \n`background-color: #fff;`：设置背景色。  \n`justify-content: space-between;`：项目沿主轴均匀分布，位于首尾两端的子容器与父容器紧紧挨着。  \n`white-space: nowrap;`：设置 scroll-view 不换行。 \n`margin-top: 40rpx;` 是指容器本身的顶部距离其他容器有40个像素，不包含在容器内；\n\n#### indexmodule.json\n在 .json 文件中导入了组件：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"itemview\": \"/components/itemview/itemview\"\n  }\n}\n```\n\n#### indexmodule.js\n为外部调用者提供了四个属性：`title、moreurl、items、type`：\n```\n// components/indexmodule/indexmodule.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    title: {\n      type: String,\n      value: \"\"\n    },\n    moreurl: {\n      type: String,\n      value: \"\"\n    },\n    items: {\n      type: Array,\n      value: []\n    },\n    type: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n### comment\n![微信小程序05](微信小程序/微信小程序05.png)\n\n#### comment.wxml\n为了方便布局，嵌套了多层view：\n```\n<view class=\"comment-group\">\n  <view class=\"left-comment\">\n    <image class=\"avatar\" src=\"{{item.user.avatar}}\"></image>\n  </view>\n  <view class=\"right-comment\">\n    <view class=\"username-rate\">\n      <text class=\"username\">{{item.user.name}}</text>\n      <stars rate=\"{{item.rating.value*2}}\" starsize=\"30\" istext=\"{{false}}\"></stars>\n    </view>\n    <view class=\"release-time\">{{item.create_time}}</view>\n    <view class=\"content\">{{item.comment}}</view>\n  </view>\n</view>\n```\n\n使用网络图片创建 image：\n```\n<image class=\"avatar\" src=\"{{item.user.avatar}}\"></image>\n```\n\n使用自定义组件 stars，自定义了星星的大小（starsize），不需要显示评分（istext = false）：\n```\n<stars rate=\"{{item.rating.value*2}}\" starsize=\"30\" istext=\"{{false}}\"></stars>\n```\n\n#### comment.wxss\n```\n.comment-group {\n  display: flex;\n  justify-content: flex-start;\n  padding-top: 40rpx;\n}\n\n.comment-group .left-comment {\n  width: 70rpx;\n  margin-right: 20rpx;\n}\n\n.left-comment .avatar {\n  width: 70rpx;\n  height: 70rpx;\n  border-radius: 50%;\n}\n\n.comment-group .right-comment {\n  flex: 1;\n}\n\n.right-comment .username-rate {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.username-rate .username {\n  font-size: 36rpx;\n  margin-right: 20rpx;\n}\n\n.release-time {\n  color: #b3b3b3;\n  font-size: 32rpx;\n  margin-top: 10rpx;\n}\n\n.content {\n  font-size: 32rpx;\n  color: #353535;\n  margin-top: 10rpx;\n}\n```\n\n`justify-content: flex-start;` 起始端对齐。默认就是这种对齐方式。  \n`padding-top: 40rpx;` 是指容器内的内容距离容器的顶部有40个像素，是包含在容器内的；  \n`border-radius: 50%;` 设置圆角，圆角大小等于宽度的一半。  \n\n#### comment.json\n在 .json 文件中导入了组件：\n```\n{\n  \"component\": true,\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\"\n  }\n}\n```\n\n#### comment.js\n只需要一个参数 item 对象：\n```\n// components/comment/comment.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    item: {\n      type: Object,\n      value: {}\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n\n  }\n})\n```\n\n### searchbar\n![微信小程序06](微信小程序/微信小程序06.png)\n\n#### searchbar.wxml\n```\n<!--components/searchbar/searchbar.wxml-->\n<view class='searchbar'>\n  <navigator wx:if=\"{{isnavigator}}\" url='/pages/search/search' class='searh-navigator'></navigator>\n  <view wx:else class='search-input-group'>\n    <input class='search-input' placeholder='搜索' bindinput=\"onInputEvent\"></input>\n  </view>\n</view>\n```\n\n如果 isnavigator = true，创建导航组件，在点击搜索框时，跳转到 search 页面：\n```\n<navigator wx:if=\"{{isnavigator}}\" url='/pages/search/search' class='searh-navigator'></navigator>\n```\n\n如果 isnavigator = false，创建输入框：\n```\n<input class='search-input' placeholder='搜索' bindinput=\"onInputEvent\"></input>\n```\n\n#### searchbar.wxss\n```\n/* components/searchbar/searchbar.wxss */\n\n.searchbar {\n  background-color: #41be57;\n  padding: 20rpx; \n}\n\n.searh-navigator {\n  width: 100%;\n  height: 60rpx;\n  background-color: #fff;\n  border-radius: 10rpx;\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAPA0lEQVR4Xu2dj5UUNxLGpQgMERhHwBKBrUnAEIFxBOYiOByBIQKvIzBOYAQR3F4EhyM4iED3Pq/mPDvsTFep1b3qqq/f4wFvJc3qK/2mVKU/HQMfKkAFzioQqQ0VoALnFSAgHB1U4IICBITDgwoQEI4BKtCmAD1Im26s5UQBAuLE0OxmmwIEpE031nKiAAFxYmh2s00BAtKmG2s5UYCAODE0u9mmAAFp0421nChAQJwYmt1sU4CAtOnGWk4UICBODM1utilAQNp0Yy0nChAQJ4ZmN9sUICBturGWEwUIiBNDs5ttChCQNt1Yy4kCBMSJodnNNgUISJturOVEAQLixNDsZpsCBKRNN9ZyogABcWJodrNNAQLSphtrOVGAgDgxNLvZpgABadONtZwoQECcGJrdbFOAgLTpxlpOFCAgTgzNbrYpQEDadGMtJwoQECeGZjfbFCAgDbrlnB+VUp7GGJ+EEPDnu6Nmjv99X+s3IYRP9c9f/y6l3Ox2uw8NvwqrLKwAAREInHMGBN9XEADAI0G1liIfQwiA5n0I4UNKCf/m84AKEJAz4u/3++9jjM8rFADkIR54GsDyLoTwR0oJ/+ezogIE5Ejs6il+CiEAjIeC4pL5Acq7lNJvK44R1x9FQEIIOecfQggvT2KJkQcGPMl1COFtSgnTMj4LKeAakArG60G9hdTkmIL9nFLC33w6K+ASECNgnA4FgtIZDjTnCpCc81UI4ZcNTaVaTE5QWlQ7U8cFIFi3CCH8M4TwqqN2d5oqpfw7xoi07CEmwN/H8QF+BwCKB+soVzHGb5f6fWqM8g9mvuYpbB6QnDPWLX7vuXZRSvkcY0RGCUDczJn/V68GcK5KKc9jjF/PM+md2gjmX6eU3nZs01VTpgHJOWM61dNrIL2KNCvgWOSpwDyvsDzt9CGYdv3IjJdeTZOA1PUMeI3DlEavTK1RSvkQY0RKFWCsulBX+/GqlPIyxvhVcyduK+J3x5QLfeEjVMAcIPUbOHeYUsFbXM+ZPgltICqWc35ZQZkbtwAQxiYi1Y1lsTCIQgi/Cvv+RbEaW2AAvRl1OlK9CtZusLjZ+iB2ejFqH1s7tUQ9Mx5kLhwhBHiMV2tPo1qN2gEUTLkSN0RetoAJQObAUWMMgLHJnbMVlDd1t7GWN0ACT8JV+DPKbR6QnDOmVJhaqZ5Syp8xRoCxWEZK9QvNLIx0dinlTYyxJfOFDBeD93tssGlAcs6Yi2MBUPtsajql6dwMTQiJJUBaplU1CIfXMP1tiUxeKeW6wZsQkhNINulBair3X5pv1roV5OVWYw1NX1G2bq9BbKLJdjFw3zogjescZqdUU+A0eFpCciTqpjxI/VbEIqBmhfy3lJI6iJ8aeFv6ec4ZW1cw5ZKuxiOjhxTwqjsHRtR0a4BgyoAjsdLHPRwHoWpc8l4BCbbWvJAKbbXcZgDBt2DdlSu1BeE4UaoBEmxJwZeS22cTgNSp1X8U+6sIx5khXbf/Y5oqfZ55SWzcJ8hWAMHOXHiQyQcr47vdburytsl2LBdQBu447/LMsh6X+jY8IJpvvLo6fsXgcno455yxFiRNAbudam0BEEytJu+oqouA33meDkxj8XeJen3qjfAEI7JZmGq5u2JoaECU2ya4Cqwh5HYxEVNRaTziMq4bFhBlYI5rOUUxinIMmS+ec9akzr/x5kVGBkS0EbFOrRB3uHP/PeitU62PwvURd2sjQwKi9B64VRAw8WlUQDmVdeVFRgUEN5HgRpKLDzYg7nY7zbaTqSbd/ny/38OLSK4cchWLjAqIKHNV9wvxNFwHrBVeBBkteBEX+7SGA0S6pYQLgh2oOGpCGYu4WRcZERAcgcXbnKYenKU2cVx2qqNr/VyxeOhmdX0oQGpw/t+pAYEV891uN7l4ONUOf35XAan3rrVcBOujASK914qLggvRvd/vPwlTvi5sMBogWNW9uNEQ6x673W6pl2guNOy206ximuVicXYYQOr9TsheTT2u0oxTYvT+uXKa9dh6NmskQKTTKwbnvak4yWaFECbjwFoFx3JNp9lHAmRy+zWnVwuScdT0fr/HLl/JBXTm070jASJZHHQx710Hg/OfoohDzE93hwBEEX+4yJwMAIh0q4/505ujACI9l+D6fPRa4GjOiaSUhhhDS2kzROek+4CsG2MpI2vblS7Y1nZNf2mNAogkQDfvzrUDecnyOecibN90JmsIQPb7PS40m3q12NuUUs8Xcgrt77OY0CYQh4AsPUSE31bmU4pL66xpXwGIabsM4UGEgJj+ptIM3jXK5pylu6pNn+h8cEAUASEBWYOM+hnSxEkIgYAsaRdFSpGALGmIk7YVgJiODUfwIKI1EKZ4V6Tj9s4s6a0yprOLBGTdcbeZT5MCwinWwiaVTrHoQRY2RPsUizHIkqYhIEuq2942PcitdpxitY8h0zUJyMYAsb5iOxptBGQcQHAzouSVzkzzrkgRARkEEPwaXElfceQLP0oBiOkzOg8egygAMb3nRzhuVyumAMS0Zx8CEOHFyaZXbFcb+cIPUmxWJCBCTZuLSYzBu3ib5W2qKLEJGra+PjWEBxG6808ppcdN1mYltQI5ZyROJl8tQUDU0uor5JxFlwSEEMxfVKZXb5kaksSJh/ezjOJBRBsWQwimMybLDHV9q4pbZnjtj15efQ3FmRDzBtGr17+GdPtPCMF8ZnEIDwITCzNZjEP68/BFi8KYsMbovHp0BZP8tVgofR2x6bTiKmJPfIj0uK31AB0yDeNBFLeKcz1kYYpyzpPXwHoI0EcDBO/8kNwq/jGl9M3CY8Rt8wzQ75p+GA9S4xDpreJ8BcJCCOec+RqKI22HAkSxHvIegchCY8R1s4w/BvYgCveOXpi+E/YhKK3pdsQfU6+4c/MaiqE8SJ1mSa4hRVGuiXSmSDG9crNgOxwgCiNheLh4FXFnDs42l3OefIlqrexmy8+IgDwqpXwUvor4XUrpxVoDyPLnSKe33nZVDwcIBqHiFWAuVnPXAFOhuauF2lEBeRJCkLwSGmOH6yIzCVJ4jz93ux1s4+YZEpAGL2J+09ySI1LhPdwE5we9RwZE40U+1bTvxyUHksW2c86iW2VKKe68B+w9LCANXuQmpfTM4iBesk+KzJXpK0bPaTw6IE9KKdh+8pVwkHAjo1Co+gUkOsnp1XsM70GqEUXX8B+NC3fzZAUT/y8qnVrVCm41HdqDHKwpPEx1KI54BKnIm5aB46FO3VKCRcHJSxk8e49NeJDqRaRn1g/jG3AAEsDC50QBRdyBmq7WPU4HyyY8SIVEeuKQkFz4Ssg5/xpCwJb2ycfbqvl9gmwGEPzy+/1eel6EkNxjbQ0ctbpr77GZKdbB1ljxVWa1UJXTrdvtO2LPUfV2s6X9kivdlAepUy3pibfjfruFpAbkv0inVUeicaf06AuF58hW3IBy3IS77JYmW3WiNc/aVEE250GOplvXIYQfJiPNuwUACfZtoa7pp17+9rvgdOAdHUopn2OMVyklbtvZqgc5WFR6A/k9JLxOKf1slZCcM6ZUWCVveXje/0i1zXqQGo/gcBWO6D5tGAnv612/Zr4pq9dAMD53S/p1SunHBk3NVdk0IB0gwZQL2yjebdmyMwLxS90mJFufYh3FI3M8CZoBIIhNNuVNKhg/1enU1E0kLd8B7iHZvAc5hiSEgNV2beB+aALe5M0WYpMKBvqJOGPudGoKHNeQmAFkZnbreJDAiyCI/21q5Kz98xU8xrkuuYXEHCA1LnlZSnmjOEdy38AYBpQafMNjiPZQLQSuS0hMAlIhuSqlvIsxfj1zwGDqhXUTLJ6ttoV+5WmUVCJ3kJgF5JDhqoP7e+kImCgHr4I458MSsNRDTPhdn0vOamj7hLMdMUZMH68VFzWcfowrSEwDchSXPC+lXM+ccp0OFHgWrKXc1LWYzxpoKgxYv0GQjfMuOLy0RCYqYNt6jBEJiDvpbEIy/RXjApAjbzInyzWt5m0JTMMuHdQCDGs9SDQAjLNTQ0Jy2RRuADnyJt+VUl7HGL9da5Su+Tl1LxViJoAhWtchJOct5A6Qk2kXMl1zg/g1x//Zz6rxBTwkYgT1UWNCcr+0bgE5AgUp4VeN+7keHI4aXwCK2TuUCcmX5nQPyPHUq64ztK7ErwZLnUYh4AYYSBR0ewjJXSkJyMnQqhc5I+v1cjSvcvAW2DvWMo2SUkRI/laKgFwYNSPAUqGAl4C3EAXdUhAulSMkt+oQEOFoqivbSNEiC3a1VBYM7x+PMQIIHFx60G34hISACPG4v1jdI4XFvb8W+QBOLfnkXHYMHuHQWowRHgF/AATec7Kah5B23Dsk9CDSkeK4nGdICIjjga/puldICIhmlDgv6xESAuJ80Gu77w0SAqIdISyvfQvxsWKb2ypPQDjgmxTw4kkISNPwYCUo4AESAsKxPkuBGZBs4tXdBGTW8GDlmZ5k+HcfEhCO8S4KzPAkQ0NCQLoMDzYyw5MM/VoKAsKx3VWBRk8CSJ6NuBeNgHQdHmxshicZ8i1gBIRjehEFGj3JcAuJBGSR4cFGqyfB5dp4mY/mGSpoJyAa07GsWoGcs/alq4hH8AJR9c0s6l9OUIGACERikXkKABLlZeLDvESUgMyzPWsLFcBVq/WK1q+EVR6P4EUIiNBaLDZfAVyCUW/cl7xT8sVDn8lHjwnIfLuzBYUC9fILyR3JQ+zVIiAK47JoPwUEcQkC9Qe/xIKA9LM5W1IqcMGbDJPqJSBKo7J4fwWO7hzDFUq4D+zBPcehlwSkv73ZoiEFCIghY7Ir/RUgIP01ZYuGFCAghozJrvRXgID015QtGlKAgBgyJrvSXwEC0l9TtmhIAQJiyJjsSn8FCEh/TdmiIQUIiCFjsiv9FSAg/TVli4YUICCGjMmu9FeAgPTXlC0aUoCAGDImu9JfAQLSX1O2aEgBAmLImOxKfwUISH9N2aIhBQiIIWOyK/0VICD9NWWLhhQgIIaMya70V4CA9NeULRpSgIAYMia70l8BAtJfU7ZoSAECYsiY7Ep/BQhIf03ZoiEFCIghY7Ir/RUgIP01ZYuGFCAghozJrvRXgID015QtGlKAgBgyJrvSXwEC0l9TtmhIAQJiyJjsSn8FCEh/TdmiIQX+B7BN6BQFysCGAAAAAElFTkSuQmCC\");\n  background-position: center center;\n  background-repeat: no-repeat;\n  background-size: 6%;\n}\n\n.search-input-group {\n  width: 100%;\n  height: 60rpx;\n  background-color: #fff;\n  border-radius: 10rpx;\n  padding: 10rpx 20rpx;\n  box-sizing: border-box;\n}\n\n.search-input {\n  min-height: 40rpx;\n  height: 40rpx;\n  font-size: 12px;\n}\n```\n\n`border-radius: 10rpx;`：设置圆角大小 10rpx。  \n`background-image: url(\"\")`：设置背景图。因为 wxss 文件里使用的是本地图片资源，所以需要将图片转成base64。  \n`background-position: center center;`：设置图片垂直水平居中。  \n`box-sizing: border-box;`：设置的边框和内边距的值是包含在 width 内的。\n`min-height: 40rpx; height: 40rpx;`：同时设置最小高度和高度，防止光标偏移。  \n`background-repeat: no-repeat;`：背景图像将仅显示一次。\n\n#### search.js\n```\n// components/searchbar/searchbar.js\nComponent({\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    isnavigator: {\n      type: Boolean,\n      value: false\n    }\n  },\n\n  /**\n   * 组件的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 组件的方法列表\n   */\n  methods: {\n    // 输入框输入回调\n    onInputEvent: function(event) {\n      var value = event.detail.value;\n      var detail = {\"value\": value};\n      var options = {};\n      // 回调方法\n      this.triggerEvent(\"searchinput\",detail,options);\n    }\n  }\n})\n```\n\n`isnavigator` 用于判断是否创建导航控件。  \n`onInputEvent` 是输入框正在输入的回调事件。  \n`this.triggerEvent(\"searchinput\",detail,options);` 主动触发事件 triggerEvent，参数为 `\"searchinput\"`、`detail`、`options`。因为这里的 `searchbar` 是自定义组件，所以需要将输入事件传递给外部调用者，外部调用者需要实现 triggerEvent 事件：  \nsearch.json 文件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\"\n  }\n}\n```\n\nsearch.wxml 文件：\n```\n<!-- 搜索框 -->\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\nsearch.js 文件：\n```\nonItemTapEvent: function(event) {\n  var that = this;\n  var id = event.currentTarget.dataset.id;\n  var title = event.currentTarget.dataset.title;\n\n  // to do\n},\n```\n\n## 网络\n\n[网络请求API](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)\n\n### urls.js\n![微信小程序11](微信小程序/微信小程序11.png)\n\n定义构造器 globalUrls：\n```\nconst globalUrls = {\n    // 内容\n}\n```\n\n定义 url 变量：\n```\n// 列表\nmovieList: \"https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items\",\ntvList: \"https://m.douban.com/rexxar/api/v2/subject_collection/tv_hot/items\",\nshowList: \"https://m.douban.com/rexxar/api/v2/subject_collection/tv_variety_show/items\",\n// 详情\nmovieDetail: \"https://m.douban.com/rexxar/api/v2/movie/\",\ntvDetail: \"https://m.douban.com/rexxar/api/v2/tv/\",\nshowDetail: \"https://m.douban.com/rexxar/api/v2/tv/\",\n```\n\n创建方法，根据参数拼接 url：\n```\n// 标签\nmovieTags: function(id){\n  return \"https://m.douban.com/rexxar/api/v2/movie/\" + id + \"/tags?count=8\"\n},\ntvTags: function(id){\n  return \"https://m.douban.com/rexxar/api/v2/tv/\" + id + \"/tags?count=8\"\n},\nshowTags: function(id){\n  return this.tvTags(id);\n},\n// 评论\nmovieComments: function(id,start=0,count=3){\n  return \"https://m.douban.com/rexxar/api/v2/movie/\" + id + \"/interests?count=\" + count + \"&start=\" + start;\n},\ntvComments: function(id,start=0,count=3){\n  return \"https://m.douban.com/rexxar/api/v2/tv/\" + id + \"/interests?count=\" + count + \"&start=\" + start;\n},\nshowComments: function(id,start=0,count=3){\n  return this.tvComments(id,start,count);\n},\n// 搜索\nsearchUrl: function(q) {\n  return \"https://m.douban.com/rexxar/api/v2/search?type=movie&q=\" + q\n}\n```\n\n导出构造器 globalUrls，导出后外部调用者通过 `import { globalUrls } from \"urls.js\"` 导入后可用：\n```\nexport {globalUrls}\n```\n\n### network\n```\n// 导入 globalUrls 类\nimport { globalUrls } from \"urls.js\"\n\n\n// 定义构造器 network\nconst network = {\n  // 电影\n  getMovieList: function (params) {\n    params.type = \"movie\";\n    this.getItemList(params);\n  },\n\n  // 电视剧\n  getTVList: function (params) {\n    params.type = \"tv\";\n    this.getItemList(params);\n  },\n\n  // 综艺\n  getShowList: function (params) {\n    params.type = \"show\";\n    this.getItemList(params);\n  },\n\n  // 首页列表\n  getItemList: function (params) {\n    var url = \"\";\n    if (params.type == \"movie\") {\n      url = globalUrls.movieList;\n    } else if (params.type == \"tv\") {\n      url = globalUrls.tvList;\n    } else if (params.type == \"show\") {\n      url = globalUrls.showList;\n    } else { \n    \n    }\n    var count = params.count ? params.count : 7;\n    // 发起网络请求\n    wx.request({\n      // 设置请求url\n      url: url,\n      // 设置请求参数\n      data: {\n        count: count\n      },\n      // 请求成功回调\n      success: function(res) {\n        var items = res.data.subject_collection_items;\n        var itemCount = items.length;\n        var left = itemCount%3;\n        if (left === 2) {\n          items.push(null);\n        }\n        if (params && params.success) {\n          params.success(items);\n        }\n      }\n    })\n  },\n  \n  // 详情\n  getItemDetail: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieDetail + id;\n    } else if (type === \"tv\") {\n      url = globalUrls.tvDetail + id;\n    } else if (type === \"show\") {\n      url = globalUrls.showDetail + id;\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res) {\n        var item = res.data;\n        if (params.success) {\n          params.success(item);\n        }\n      }\n    })\n  },\n  \n  // 标签\n  getItemTags: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieTags(id);\n    } else if (type === \"tv\") {\n      url = globalUrls.tvTags(id);\n    } else if (type === \"show\") {\n      url = globalUrls.showTags(id);\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res) {\n        var tags = res.data.tags;\n        if (params.success) {\n          params.success(tags)\n        }\n      }\n    })\n  },\n\n  // 评论\n  getItemComments: function(params) {\n    var type = params.type;\n    var id = params.id;\n    var start = params.start;\n    var count = params.count;\n    var url = \"\";\n    if (type === \"movie\") {\n      url = globalUrls.movieComments(id,start,count);\n    } else if (type === \"tv\") {\n      url = globalUrls.tvComments(id,start,count);\n    } else if (type === \"show\") {\n      url = globalUrls.showComments(id,start,count);\n    } else {\n\n    }\n    wx.request({\n      url: url,\n      success: function(res){\n        var comment = res.data;\n        if (params.success) {\n          params.success(comment); \n        }\n      }\n    })\n  },\n\n  // 搜索\n  getSearch: function(params) {\n    var q = params.q;\n    var url = globalUrls.searchUrl(q);\n    wx.request({\n      url: url,\n      success: function(res){\n        var subjects = res.data.subjects;\n        if (params.success) {\n          params.success(subjects);\n        }\n      }\n    })\n  }\n}\n\n// 导出构造器 network，导出后外部调用者通过 `import {network} from \"../../utils/network.js\"` 导入后可用：\nexport { network }\n```\n\n## 页面\n[页面生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)\n\n生命周期函数在 .js 文件：[注册页面](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)：\n```\nPage({\n  \n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide: function () {\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload: function () {\n    \n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh: function () {\n    \n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom: function () {\n    \n  },\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage: function () {\n    \n  }\n})\n```\n\n### 首页\n![微信小程序07](微信小程序/微信小程序07.png)\n\n#### index.wxml\n```\n<!--index.wxml-->\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n\n<!-- 电影 -->\n<indexmodule title=\"电影\" moreurl=\"/pages/list/list?type=movie\" items=\"{{movies}}\" type=\"movie\"></indexmodule>\n\n<!-- 电视剧 -->\n<indexmodule title=\"电视剧\" moreurl=\"/pages/list/list?type=tv\" items=\"{{tvs}}\" type=\"tv\"></indexmodule>\n\n<!-- 综艺 -->\n<indexmodule title=\"综艺\" moreurl=\"/pages/list/list?type=show\" items=\"{{shows}}\" type=\"show\"></indexmodule>\n```\n\n创建自定义组件 `searchbar`， 指定导航 isnavigator = true。\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n```\n\n创建三个自定义组件 `indexmodule`，分别用于展示电影、电视剧和综艺。`moreurl` 是更多按钮跳转的页面路径，`items` 是每一个电影的信息。\n```\n<indexmodule title=\"电影\" moreurl=\"/pages/list/list?type=movie\" items=\"{{movies}}\" type=\"movie\"></indexmodule>\n```\n\n#### index.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\",\n    \"indexmodule\": \"/components/indexmodule/indexmodule\"\n  }\n}\n```\n\n#### index.js\n```\n//index.js\nimport {network} from \"../../utils/network.js\"\nPage({\n  \n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n    \n    // 电影\n    network.getMovieList({\n      success: function(movies){\n        that.setData({\n          movies: movies,\n        })\n      }\n    })\n   \n    // 电视剧\n    network.getTVList({\n      success: function(tvs) {\n        that.setData({\n          tvs: tvs,\n        })\n      }\n    })\n    \n    // 综艺\n    network.getShowList({\n      success: function (shows){\n        that.setData({\n          shows: shows,\n        })\n      }\n    })\n  }\n})\n```\n\n导入 network.js 文件后才可以使用 `network`：\n```\nimport {network} from \"../../utils/network.js\"\n```\n\n请求数据，`network.getMovieList({ })` 方法内部的 `{}` 是方法 `getMovieList: function (params){ }` 需要的 `params`，可以看到这里的 `params` 内部只有一个 `success: function(movies){ }` 方法。在网络请求完成时，`network` 在 `getMovieList()` 方法内部可以通过 `params.success(moives)` 回调过来：\n```\n// 电影\nnetwork.getMovieList({\n  success: function(movies){\n    that.setData({\n      movies: movies,\n    })\n  }\n})\n```\n\n更新数据，并且重新渲染UI：\n```\nthat.setData({\n  movies: movies,\n})\n```\n\n### 更多\n![微信小程序07](微信小程序/微信小程序07.png)\n\n#### list.wxml\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n\n<view class=\"container\">\n  <itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n    itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n</view>\n```\n\n创建自定义组件 `searchbar`， 指定导航 isnavigator = true。\n```\n<searchbar isnavigator=\"{{true}}\"></searchbar>\n```\n\n遍历创建 itemview 组件，展示每一个 item 数据。\n```\n<itemview wx:for=\"{{items}}\" wx:key=\"{{item.title}}\" item=\"{{item}}\"\n    itemurl=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"></itemview>\n```\n\n#### list.wxml\n```\n.container {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n  padding: 30rpx\n}\n```\n\n`justify-content: space-between;` 项目沿主轴均匀分布，位于首尾两端的子容器与父容器紧紧挨着。  \n`flex-wrap: wrap;` 换行。  \n`padding: 30rpx` 边距30个像素。  \n\n#### list.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\",\n    \"itemview\": \"/components/itemview/itemview\"\n  }\n}\n```\n\n#### list.js\n```\n// pages/list/list.js\nimport { network } from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    type: {\n      type: String,\n      value: \"\"\n    }\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n\n    // 提示框\n    wx.showLoading({\n      title: '正在加载中...',\n    })\n    var title = \"\";\n    var type = options.type;\n    if (type === \"movie\") {\n      // 电影\n      title = \"电影\";\n      network.getMovieList({\n        success: function(movies){\n          that.setData({\n            items: movies,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    } else if (type === \"tv\") {\n      //电视剧\n      title = \"电视剧\";\n      network.getTVList({\n        success: function(tvs) {\n          that.setData({\n            items: tvs,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    } else {\n      // 综艺\n      title = \"综艺\";\n      network.getShowList({\n        success: function(shows) {\n          that.setData({\n            items: shows,\n            type: type\n          });\n          // 移除提示框\n          wx.hideLoading();\n        },\n        count: 1000\n      })\n    }\n\n    // 设置导航栏的标题\n    wx.setNavigationBarTitle({\n      title: title,\n    })\n  }\n})\n```\n\n导入网络请求文件 network.js：\n```\nimport { network } from \"../../utils/network.js\"\n```\n\n定义变量 type：\n```\ndata: {\n  type: {\n    type: String,\n    value: \"\"\n  }\n},\n```\n\n显示提示框：\n```\nwx.showLoading({\n  title: '正在加载中...',\n})\n```\n\n移除提示框：\n```\nwx.hideLoading();\n```\n\n设置导航栏的标题：\n```\nwx.setNavigationBarTitle({\n  title: title,\n})\n```\n\n### 电影详情\n![微信小程序09](微信小程序/微信小程序09.png)\n\n#### detail.wxml\n```\n<view class=\"item-header\">\n  <view class=\"item-title\">{{item.title}} {{item.original_title}}（{{item.year}}）</view>\n  <view class=\"item-detail\">\n    <view class=\"left-detail\">\n      <!-- 评分 -->\n      <view class=\"item-rate\">\n        <stars rate=\"{{item.rating.value}}\" starsize=\"30\" fontsize=\"30\" fontcolor=\"#595959\"></stars>\n        <text class=\"comment-persons\">{{item.rating.count}}人评价</text>\n      </view>\n      <!-- 信息 -->\n      <view class=\"item-sub-detail\">\n        <view class=\"item-type\">\n          {{item.durations[0]}} {{item.genres}}\n        </view>\n        <view class=\"item-show\">\n          {{item.pubdate[0]}}上映 {{item.countries[0]}}\n        </view>\n        <view class=\"actors\">\n          {{item.authors}}\n        </view>\n      </view>\n    </view>\n    <!-- 封面 -->\n    <view class=\"right-detail\">\n      <image src=\"{{item.cover.image.small.url}}\"></image>\n    </view>\n  </view>\n</view>\n\n<!-- 标签 -->\n<view class=\"item-tags\">\n  <view class=\"item-tags-title\">豆瓣成员常用标签</view>\n  <view class=\"item-tags-list\">\n    <text wx:for=\"{{tags}}\" wx:key=\"*this\">{{item}}</text>\n  </view>\n</view>\n\n<!-- 评论 -->\n<view class=\"comment-list-group\">\n  <view class=\"comment-title\">短评({{comment.total}})</view>\n  <comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n</view>\n\n<!-- 查看更多短评 -->\n<navigator class=\"more-comment\"\n  url=\"/pages/comments/comments?id={{id}}&type={{type}}&thumbnail={{item.cover.image.small.url}}&title={{item.title}}&rate={{item.rating.value}}\">\n  查看更多短评</navigator>\n```\n\n创建自定义组件-评分，指定星星大小、字体大小和字体颜色：\n```\n<stars rate=\"{{item.rating.value}}\" starsize=\"30\" fontsize=\"30\" fontcolor=\"#595959\"></stars>\n```\n\n遍历创建自定义组件-评价：\n```\n<comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n```\n\n创建“查看更多短评”按钮，需要传递五个参数：`id、type、thumbnail、title、rete`。\n```\n<navigator class=\"more-comment\"\n  url=\"/pages/comments/comments?id={{id}}&type={{type}}&thumbnail={{item.cover.image.small.url}}&title={{item.title}}&rate={{item.rating.value}}\">\n  查看更多短评</navigator>\n```\n\n#### detail.wxss\n```\n.item-header {\n  padding: 60rpx 30rpx;\n}\n\n/* 电影名称 */\n.item-header .item-title {\n  font-size: 50rpx;\n}\n\n/* 评分 */\n.item-header .item-detail {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 20rpx;\n}\n\n.item-detail .left-detail {\n  flex: 1;\n  margin-right: 20rpx; \n}\n\n.left-detail .item-rate {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.item-rate .comment-persons {\n  font-size: 28rpx;\n  color: #ccc;\n  margin-left: 20rpx;\n}\n\n/* 电影封面 */\n.item-detail .right-detail {\n  width: 200rpx;\n  height: 300rpx;\n}\n\n.right-detail image {\n  width: 100%;\n  height: 100%;\n}\n\n/* 电影信息 */\n.item-sub-detail {\n  margin-top: 40rpx;\n  font-size: 32rpx;\n}\n\n.item-sub-detail view {\n  margin-bottom: 10rpx;\n}\n\n/* 标签 */\n.item-tags {\n  padding: 0rpx 30rpx;\n}\n\n.item-tags .item-tags-title {\n  color: #b3b3b3;\n  font-size: 32rpx;\n  margin-bottom: 20rpx;\n}\n\n.item-tags .item-tags-list {\n  display: flex;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n}\n\n.item-tags-list text {\n  padding: 10rpx 20rpx;\n  background-color: #f5f5f5;\n  font-size: 32rpx;\n  color: #353535;\n  text-align: center;\n  border-radius: 40rpx;\n  margin-right: 20rpx;\n  margin-bottom: 20rpx;\n}\n\n/* 评论列表 */\n.comment-list-group {\n  padding: 60rpx 30rpx;\n}\n\n.comment-list-group .comment-title {\n  font-size: 32rpx;\n  color: #b3b3b3;\n}\n\n/* 查看更多短评 */\n.more-comment {\n  text-align: center;\n  font-size: 36rpx;\n  color: #41be57;\n  margin-bottom: 40rpx;\n}\n```\n\n#### detail.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"stars\": \"/components/stars/stars\",\n    \"comment\": \"/components/comment/comment\"\n  }\n}\n```\n\n#### detail.js\n```\n// pages/detail/detail.js\nimport {network} from \"../../utils/network.js\"\n\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    <!-- options 可以获取到页面跳转时传递的数据 -->\n    console.log(options);\n    var that = this;\n    var type = options.type;\n    var id = options.id;\n    that.setData({\n      type: type,\n      id: id\n    })\n    // 详情\n    network.getItemDetail({\n      type: type,\n      id: id,\n      success: function(item) {\n        var genres = item.genres;\n        genres = genres.join(\"/\");\n        item.genres = genres;\n\n        var actors = item.actors;\n        var actornames = [];\n        if (actors.length > 3) {\n          actors = actors.slice(0, 3);\n        }\n        for (var index=0; index<actors.length; index++) {\n          var actor = actors[index];\n          actornames.push(actor.name);\n        }\n        \n        actornames = actornames.join(\"/\");\n        var director = \"\";\n        if (item.directors.length > 0) {\n          director = item.directors[0].name;\n        }\n        var authors = director + \"(导演) /\" + actornames;\n        item.authors = authors;\n        \n        that.setData({\n          item: item\n        });\n      }\n    });\n    // 标签\n    network.getItemTags({\n      type: type,\n      id: id,\n      success: function (tags) {\n        that.setData({\n          tags: tags\n        })\n      }\n    });\n    // 评论\n    network.getItemComments({\n      type: type,\n      id: id,\n      success: function (comment) {\n        that.setData({\n          comment: comment\n        })\n      }\n    })\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow: function () {\n    // 滚动到顶部\n    wx.pageScrollTo({\n      scrollTop: 0,\n    })\n  }\n})\n```\n\n数据处理，将 [1, 2, 3] -> '1/2/3' 的样式：\n```\nactornames = actornames.join(\"/\");\n```\n\n`var actornames = [];` 定义一个可变数组。  \n`actornames.push(actor.name);` 向数组中添加元素。  \n\n### 评论\n![微信小程序10](微信小程序/微信小程序10.png)\n\n#### comments.wxml\n```\n<view class=\"container\">\n  <!-- 电影详情 -->\n  <view class=\"item-group\" bindtap=\"onItenTapEvent\">\n    <image class=\"thumbnail\" src=\"{{thumbnail}}\"></image>\n    <text class=\"item-title\">{{title}}</text>\n    <text class=\"item-rate\">{{rate}}</text>\n  </view>\n\n  <!-- 评论 -->\n  <view class=\"comment-title\">全部影评({{comment.total}})</view>\n  <comment wx:for=\"{{comment.interests}}\" wx:key=\"{{item.id}}\" item=\"{{item}}\"></comment>\n\n  <!-- 上一页、下一页 -->\n  <view class=\"page-btn-group\">\n    <button class=\"page-btn\" bindtap=\"onPrePageTap\" disabled=\"{{start <= 1}}\" loading=\"{{preLoading}}\">上一页</button>\n    <button class=\"page-btn\" bindtap=\"onNextPageTap\" loading=\"{{nextLoading}}\">下一页</button>\n  </view>\n</view>\n```\n\n#### comments.wxss\n```\n.container {\n  padding: 20rpx 30rpx;\n}\n\n.item-group {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.item-group .thumbnail{\n  width: 40rpx;\n  height: 50rpx;\n}\n\n.item-group .item-title {\n  font-size: 32rpx;\n  color: #41be57;\n  margin-left: 10rpx;\n  margin-right: 10rpx;\n}\n\n.item-group .item-rate {\n  font-size: 28rpx;\n  color: #ccc;\n}\n\n.comment-title {\n  margin-top: 60rpx;\n  font-size: 40rpx;\n}\n\n/* 上一页、下一页 */\n.page-btn-group {\n  margin-top: 40rpx;\n  margin-bottom: 40rpx;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n.page-btn {\n  flex: 1;\n  height: 60rpx;\n  color: #898989;\n  border-color: #898989;\n  line-height: 60rpx;\n}\n```\n\n#### comments.json\n在 .json 文件中导入了组件：\n```\n{\n  \"usingComponents\": {\n    \"comment\": \"/components/comment/comment\"\n  }\n}\n```\n\n#### comments.js\n```\n// pages/comments/comments.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    total: 0,\n    start: 1,\n    count: 20\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    console.log(options);\n    var that = this;\n    that.setData(options);\n\n    that.getComments(1);\n  },\n\n  /**\n   * 获取评论\n   */\n  getComments: function(start) {\n    var that = this;\n    var type = that.data.type;\n    var id = that.data.id;\n    if (start > that.data.start) {\n      that.setData({\n        nextLoading: true\n      })\n    } else {\n      that.setData({\n        preLoading: true\n      })\n    }\n\n    // 请求评论数据\n    network.getItemComments({\n      type: type,\n      id: id,\n      start: start,\n      count: 20,\n      success: function (comment) {\n        that.setData({\n          comment: comment,\n          start: start,\n          nextLoading: false,\n          preLoading: false,\n        });\n        wx.pageScrollTo({\n          scrollTop: 0,\n        })\n      }\n    })\n  },\n\n  // 返回上一页\n  onItenTapEvent: function(event) {\n    wx.navigateBack({});\n  },\n\n  // 上一页\n  onPrePageTap: function(event) {\n    var that = this;\n    var oldStart = that.data.start;\n    var start = oldStart - that.data.count;\n    if (start > 0) {\n      that.getComments(start);\n    }\n  },\n\n  // 下一页\n  onNextPageTap: function(event) {\n    var that = this;\n    var oldStart = that.data.start;\n    var start = oldStart + that.data.count;\n    that.getComments(start);\n  }\n})\n```\n\n### 搜索\n![微信小程序12](微信小程序/微信小程序12.png)\n\n#### search.wxml\n```\n<!-- 搜索框 -->\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n\n<!-- 历史记录 -->\n<view class=\"history-list-group\" wx:if=\"{{histories && !subjects}}\">\n  <view class=\"history-title\">\n    <view class=\"title\">历史记录</view>\n    <view class=\"clear\" bindtap=\"clearEvent\">清除</view>\n  </view>\n  <view wx:for=\"{{histories}}\" wx:key=\"{{item.id}}\" url=\"/pages/detail/detail?type=movie&id={{item.id}}\" class=\"history-group\">{{item.title}}</view>\n</view>\n\n<!-- 搜索结果 -->\n<view class=\"item-list-group\">\n  <view class=\"item-group\" wx:for=\"{{subjects}}\" wx:key=\"{{item.id}}\" bindtap=\"onItemTapEvent\" data-id=\"{{item.id}}\" data-title=\"{{item.title}}\">\n    <image class=\"thumbnail\" src=\"{{item.pic.normal}}\"></image>\n    <view class=\"info-group\">\n      <view class=\"title\">{{item.title}}</view>\n      <view class=\"rate-year\">{{item.rating.value}}分/{{item.year}}</view>\n    </view>\n  </view>\n</view>\n```\n\n使用自定义组件 `searchbar`，使用 `bindsearchinput=\"onSearchInputEvent\"` 绑定输入框的输入事件。其中的 `bindsearchinput` = `bind` + `searchinput`，而 `\"onSearchInputEvent\"` 是搜索页面需要实现的回调方法：\n```\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\n#### search.wxss\n```\n.item-list-group {\n  padding: 10rpx 20rpx;\n}\n\n.item-list-group .item-group {\n  padding: 10rpx 0;\n  border-bottom: 1rpx solid #e4e4e4;\n  display: flex;\n}\n\n.item-group .thumbnail{\n  width: 80rpx;\n  height: 100rpx;\n  margin-right: 20rpx;\n}\n\n.item-group .info-group {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n\n.info-group .title {\n  font-size: 32rpx;\n}\n\n.info-group .rate-year {\n  font-size: 28rpx;\n  color: #7b7b7b;\n}\n\n\n.history-list-group {\n  padding: 10rpx 20rpx;\n}\n\n.history-list-group .history-title {\n  display: flex;\n  justify-content: space-between;\n  padding: 20rpx 0;\n  background: #f9f9f9;\n  font-size: 28rpx;\n  color: #9e9e9e;\n}\n\n.history-list-group .history-group {\n  font-size: 32rpx;\n  padding: 20rpx 0;\n  border-bottom: 1rpx solid #e4e4e4;\n}\n\n/* \n padding:10px 5px 15px 20px;\n \n 上内边距是 10px\n 右内边距是 5px\n 下内边距是 15px\n 左内边距是 20px\n\n ---------\n padding:10px 5px 15px;\n\n 上内边距是 10px\n 右内边距和左内边距是 5px\n 下内边距是 15px\n\n ---------\n padding:10px 5px;\n\n 上内边距和下内边距是 10px\n 右内边距和左内边距是 5px\n\n ---------\n padding:10px;\n\n 所有 4 个内边距都是 10px\n */\n```\n\n#### search.json\n使用自定义组件 searchbar：\n```\n{\n  \"usingComponents\": {\n    \"searchbar\": \"/components/searchbar/searchbar\"\n  }\n}\n```\n\n#### search.js\n```\n// pages/search/search.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    var that = this;\n    wx.getStorage({\n      key: 'searched',\n      success: function(res) {\n        console.log(res)\n        var data = res.data;\n        that.setData({\n          histories: data\n        })\n      },\n    })\n  },\n\n  // 输入框输入事件\n  onSearchInputEvent: function(event) {\n    var that = this;\n    var value = event.detail.value;\n    if (!value || value === \"\") {\n      that.setData({\n        subjects: null\n      });\n      return;\n    }\n    network.getSearch({\n      q: value,\n      success: function(subjects){\n        that.setData({\n          subjects: subjects\n        })\n      }\n    })\n  },\n\n  // 选中某一条搜索结果\n  onItemTapEvent: function(event) {\n    var that = this;\n    var id = event.currentTarget.dataset.id;\n    var title = event.currentTarget.dataset.title;\n    var histories = that.data.histories;\n    if (!histories) {\n      histories = [];\n    }\n    var isExisted = false;\n    for (var index=0; index<histories.length;index++) {\n      var movie = histories[index];\n      if (movie.id === id) {\n        isExisted = true;\n        break;\n      }\n    }\n    if (!isExisted) {\n      histories.push({ title: title, id: id })\n      wx.setStorage({\n        key: 'searched',\n        data: histories,\n        success: function () {\n          console.log(\"保存成功！\");\n        }\n      })\n    }\n    \n    // 页面跳转\n    wx.navigateTo({\n      url: \"/pages/detail/detail?type=movie&id=\"+id,\n    })\n  },\n\n  clearEvent: function() {\n    var that = this;\n    wx.removeStorage({\n      key: 'searched',\n      success: function(res) {\n        console.log(\"删除成功!\");\n        that.setData({\n          histories: null\n        });\n      },\n    });\n  }\n})\n```\n\n## 总结\n\n### 更新UI\n```\nthat.setData({\n  lights: lights,\n  halfs: halfs,\n  grays: grays,\n  ratetext: ratetext,\n})\n```\n\n### 页面跳转\n创建 `navigator` 组件；  \n设置跳转路径 `url`；  \n`type、id`：在 `url` 中通过符号 `?` 加入参数，实现页面间传值。  \n```\n<navigator url=\"/pages/detail/detail?type={{type}}&id={{item.id}}\"> </navigator>\n```\n\n### padding、padding-top、margin-top 和 top 的区别\n```\npadding:10px 5px 15px 20px; //上内边距是 10px，右内边距是 5px，下内边距是 15px，左内边距是 20px\n\npadding:10px 5px 15px; //上内边距是 10px，右内边距和左内边距是 5px，下内边距是 15px\n\npadding:10px 5px; //上内边距和下内边距是 10px，右内边距和左内边距是 5px\n\npadding:10px; //所有 4 个内边距都是 10px\n\npadding-top:10px; //是指容器内的内容距离容器的顶部有10个像素，是包含在容器内的\n\nmargin-top:10px; //是指容器本身的顶部距离其他容器有10个像素，不包含在容器内\n\ntop:10px; //是指容器本身的顶部距离页面的顶端有10个像素\n```\n\n### observer（监听属性）  \n属性被改变时执行的函数（可选），也可以写成在 `methods` 段中定义的方法名字符串, 如：`'_propertyChange'`。通常 `newVal` 就是新设置的数据，`oldVal` 是旧数据\n```\nproperties: {\n  rate: {\n    type: Number,\n    value: 0,\n    observer(newVal, oldVal, changedPath) {\n      this.updateRate();\n    }\n  }\n}\n```\n\n### 事件回调、主动触发\n组件内通过主动触发回调方法，实现事件传递，同时使用到组件的文件需要绑定回调方法。以 `searchbar` 组件为例：  \nsearchbar.js 文件：\n```\n/**\n  * 组件的方法列表\n  */\nmethods: {\n  // 输入框输入回调\n  onInputEvent: function(event) {\n    var value = event.detail.value;\n    var detail = {\"value\": value};\n    var options = {};\n    // 回调方法\n    this.triggerEvent(\"searchinput\",detail,options);\n  }\n}\n```\n\nsearch.wxml 文件：\n```\n<searchbar bindsearchinput=\"onSearchInputEvent\"></searchbar>\n```\n\n`bindsearchinput` = `bind` + `searchinput`。`\"onSearchInputEvent\"` 是需要实现的回调事件。\n\nsearch.js 文件：\n```\n// pages/search/search.js\nimport {network} from \"../../utils/network.js\"\n\nPage({\n\n  // 输入框输入事件\n  onSearchInputEvent: function(event) {\n    var that = this;\n    var value = event.detail.value;\n    // to do\n  }\n})\n```\n\n### 加载动画\n```\n// 显示加载动画\nwx.showLoading({\n  title: '正在加载中...',\n})\n\n// 移除加载动画\nwx.hideLoading();\n```\n\n### scroll-view 滚动到指定位置\n```\n// 滚动到顶部\nwx.pageScrollTo({\n  scrollTop: 0,\n})\n```\n\n### 网络请求\n```\n// 发起网络请求\nwx.request({\n  // 设置请求url\n  url: url,\n  // 设置请求参数\n  data: {\n    count: count\n  },\n  // 请求成功回调\n  success: function(res) {\n    console.log(res);\n  }\n})\n```\n\n### 构造器\n可以单独创建一个 .js 文件，在文件内部创建构造器。以 `globalUrls、ntework` 为例，构造器内部可以定义变量、构造方法，这样外部调用者不需要初始化，可以直接使用 `globalUrls、ntework` 调用构造器内部的变量和方法，同 iOS 里的类方法。\n```\nconst globalUrls = {\n    // 内容\n}\n```\n\n\n# ES6语法\nES6 是 ECMAScript 6 的简写，ECMAScript 6 泛指“下一代 JavaScript 语言”，具体每年发布的都有自己的专属名称，比如2015年发布的则为 ESMAScript 2015。目前说的 ES6 语法，一般值得都是 ESMAScript 2015版。[ECMAScript](https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin) 是 JavaScript 的标准，JavaScript 是 ECMAScript 的一种实现，另外的 ECMAScript 方言还有 Jscript 和 ActionScript。\n\n在小程序开发工具中开启ES6：在微信开发者工具中->详情->ES6转ES5。\n\n## 定义变量\n\n### let\n`let` 跟 `var` 一样，也是用来定义变量，但是他比 `var` 更加的安全，体现在以下两点：\n1. 不会出现变量提升的情况。\n   ```\n   console.log(a);\n   var a = 10;\n   ```\n\n   变量 `a` 是在打印的后面定义的，但是以上的代码并不会出错，而是会打印 `undefined`，因为var会把变量 `a` 提升到代码最开始的地方进行定义。但是如果使用 `let` 就不会出现这种问题了：\n   ```\n   console.log(b);\n   let b = 10;\n   ```\n\n   此时再去打印的时候，就直接会抛出一个错误 `ReferenceError: b is not defined.`，这才是正确的方式。\n\n   注意：小程序中不能真正解析ES6语法，他只是借助了第三方工具将 ES6 语法转成 ES5 语法运行的，在底层也是用 `var` 来代替 `let` 的，所以依然会发生变量提升。\n\n2. 只在当前代码块内有效。\n   ```\n   for(var i=0;i<=3;i++){\n     console.log(i);\n   }\n   console.log(i);\n   ```\n\n   正常逻辑下，在 for 循环结束后 i 就不能够再使用了，但是这里的打印结果是 3 而不是抛出异常，这种现象在一些情况下也会阐释莫名其妙的错误，影响开发。但是 `let` 就不会出现这种情况：\n   ```\n   for(let i=0; i<=3; i++){\n     console.log(i);\n   }\n   console.log(i);\n   ```\n\n   此时再打印i的时候，就会抛出错误 `ReferenceError: b is not defined.`。\n\n### const\n`const` 是用来定义常量的，常量是一旦定义好了以后，就不能够再修改了：\n```\nconst PI = 3.14;\nPI = 3 // 会抛出异常\n```\n\n`const` 只是用来限制指向的内存地址不能改变，但是如果这个内存地址上的数据改变了，是可以的：\n```\nconst mylist = [1,2,3];\nmylist.push(4);\nconsole.log(mylist);\n```\n\n打印结果：\n```\n[1,2,3,4]\n```\n\n## 函数\n### 默认参数\n```\nfunction fetch(url, method=\"get\"){\n    console.log(url);\n    console.log(method);\n}\n```\n\n`method=\"get\"` 表示在调用 `fetch` 函数的时，可以不传 `method` 参数，他会默认使用 `get`：\n```\nfetch(\"http://www.baidu.com/\"); //method == get\nfetch(\"http://www.baidu.com/\",\"post\") // method == post\n```\n\n* 定义默认参数的时候，默认参数必须要在非默认参数的后面。\n\n有多个默认值的情况：\n```\nfunction person(name, age=18, gender='男'){\n    console.log(name, age, gender);\n}\n```\n\n在调用 `person` 函数时，如果只提供 `gender`，不提供 `age`，那么必须与解构赋值默认值结合使用：\n```\nfunction person(name, {age=18 ,gender='女'} = {}){\n    console.log(name, age, gender);\n}\n\nperson(\"知了\",{gender:\"男\"});\n```\n\n### 箭头函数\n函数作为一个参数变量传递的时候，为了简化写法，可以使用箭头函数来实现：\n```\nwx.request({\n    url: \"http://www.baidu.com/\",\n    success: function(res){\n        // to do\n    }\n});\n```\n\n对上面的代码使用箭头函数：\n```\nwx.request({\n    url: 'http://www.baidu.com/',\n    success: res => {\n        // to do \n    }\n});\n```\n\n#### 箭头函数的语法\n```\n(参数1,参数2) => {代码块}\n```\n\n定义一个网络请求的方法：\n```\nfunction request(url,success) {\n  if (success) {\n    let result = success();\n    console.log(result);\n  }\n}\n```\n\n如果只有一行代码，那么可以不用花括号（`(a,b) => a+b` 返回 a+b 的结果）：\n```\nrequest(\"http://www.baidu.com/\", (res1, res2) => true);\n```\n\n如果只有一个参数，可以不使用圆括号（`a => a+1`）：\n```\nrequest(\"http://www.baidu.com/\", res => {\n  console.log(res);\n  return true;\n});\n```\n\n如果没有参数：\n```\nrequest(\"http://www.baidu.com/\", () => {\n  console.log(\"111111\");\n  return true;\n});\n```\n\n### Promise\n`Promise` 的实现原理：\n```\nconst p = new Promise(function(resolve,reject){\n    setTimeout(() => {\n        // 如果执行以下代码，那么会执行下面的then函数\n        resolve(\"success\");\n    },1000);\n    \n    setTimeout(() => {\n        // 如果执行以下代码，那么会执行下面的catch函数\n        reject(\"fail\")\n    },1000);\n\n    // 如果以上代码都执行完，那么只会调用下面的then方法，因为resolve的调用在前面。\n});\n\np.then((res) => {\n  console.log(res);\n}).catch((error) => {\n  console.log(error);\n});\n```\n\n## 类\n在 ESS 中实现一个类：\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n在 ES6 中实现一个类：\n```\nclass Person{\n  // 构造函数\n  constructor(name,age){\n    this.name = name;\n    this.age = age;\n  }\n\n  sayHello(){\n    console.log(\"hello world\");\n  }\n}\n\nlet p = new Person(\"zhiliao\",18);\np.sayHello();\n```\n\n### 定义静态方法\n使用 `static` 关键字定义的静态方法，该静态方法是只属于类，不属于对象。在使用这个方法的时候直接通过类名就可以调用：\n```\nclass Utils{\n  constructor(){}\n  static timeFormat(time){\n    // to do\n  }\n}\n\n// 调用\nUtils.timeFormat(\"2021/1/1\")\n```\n\n## 模块\n在传统的 JS 中，没有办法在多个 js 文件中互相导入，对于大型项目来说很不方便。因此 ES6 提供了一个模块的功能。\n\n### export\n认在一个js文件中写好的代码或者变量，是不能够给其他的文件使用的，如果想要被外部使用，那么需要使用export关键字：\n```\n// utils.js\nvar name = \"zhiliao\";\nfunction dateFormat(date){\n    // 格式化代码\n}\nclass Person{\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }\n}\n\n// 导出\nexport {name,dateFormat,Person}\n```\n\n### import\n以上文件进行 `export` 了，那么以后其他文件想要使用的，则需要从这个文件中把需要的进行 `import`：\n```\n// from 后面是一个相对路径\nimport {name,dateFormat,Person} from \"utils.js\";\n```\n\n# 云开发\n\n[小程序·云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)\n\n## 创建小程序\n[创建小程序](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/quick-start/miniprogram.html)\n![微信小程序13](微信小程序/微信小程序13.png)\n![微信小程序14](微信小程序/微信小程序14.png)\n\n## 数据库\n### 创建程序\n新建项目 databasedemo：\n![微信小程序15](微信小程序/微信小程序15.png)\n\n### 初始化云开发\n在 app.js 文件中的 `onLaunch()` 方法 [初始化](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/init.html) 数据库：\n```\nApp({\n\n  /**\n   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\n   */\n  onLaunch: function () {\n    wx.cloud.init({\n      env: \"环境ID\"\n      traceUser: true\n    })\n  }\n})\n```\n`env`：指定所有服务的默认环境。  \n`traceUser`：是否在将用户访问记录到用户管理中，在控制台中可见。  \n\n### 创建集合\n在云开发的数据库中，使用的是 `NoSQL` 类型的数据库。关系型数据库中的表，对应的是 `NoSQL` 中的一个集合。所以在所数据操作之前，应该先创建一个集合。创建完集合后，也不需要跟关系型数据库一样，先定义好这个集合中的字段，而是直接插入数据，并且插入数据的时候，每条数据的字段无需保持一致！\n![微信小程序16](微信小程序/微信小程序16.png)\n\n### 获取数据库对象\n可以通过 `wx.cloud.database` 函数来获取数据库对象，这个函数默认会使用 `wx.cloud.init` 方法中提供的环境下的数据库。如果想要使用其他环境的数据库，可以给 `wx.cloud.database` 方法传递一个 `env` 参数，比如：`wx.cloud.database({ \"env\":\"数据库环境ID\" })`。\n\n### 获取集合对象\n可以通过 `db.collection(\"集合名称\")` 来获取集合对象，比如通过 `const test = db.collection(\"test\")` 获取到 `test` 集合对象，然后就可以对 `test` 来进行操作了。\n\n### 插入数据\n调用集合 `test` 的 `add()` 方法来插入数据：\n```\n// 数据库\nconst db = wx.cloud.database();\n\nPage({\n  /**\n   * 添加数据\n   */\n  add: function (options) {\n    // 集合\n    db.collection(\"test\").add({\n      data: {\n        title: \"测试标题\",\n        pub_date: new Date(\"2021-04-01\"),\n        author: \"测试作者\",\n        content: \"测试内容\"\n      }\n    }).then(res => {\n      console.log(res);\n    })\n  }\n})\n```\n\n![微信小程序17](微信小程序/微信小程序17.png)\n\n### 获取数据\n1.获取集合里的所有数据（考虑到性能，小程序一次性最多只能获取20条数据）\n```\nget: function (options) {\n  db.collection(\"test\").get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n2.根据 `id` 获取指定某一条数据（通过 `id` 获取数据需要通过 `doc()` 函数来实现）\n```\ngetById: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n3.根据条件获取数据，可以通过 where 函数来实现\n```\ngetBy: function (options) {\n  db.collection(\"test\").where({\n    title: \"测试标题\"\n  }).get().then(res => {\n    console.log(res);\n  })\n}\n```\n\n### 删除数据\n```\n/**\n * 删除一条数据,需要知道这条数据的 id\n */\nremove: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").remove().then(res => {\n    console.log(res);\n  })\n}\n```\n\n删除多条数据（只能在服务端实现，需要用到云函数）：\n```\ndb.collection(\"article\").where({\n    title: \"知了\"\n}).remove().then(res => {\n    console.log(res);\n});\n```\n\n### 更新数据\n```\n/**\n * 局部数据：局部更新是一次性只更新一条数据中的某几个字段的值，用的是update方法。 \n */\nupdate: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").update({\n    data: {\n      title: \"测试作者2\"\n    }\n  }).then(res => {\n    console.log(res);\n  })\n},\n\n/**\n * 整体更新：整体更新是一次性把所有数据都更新，用的是set方法 \n */\nupdateAll: function (options) {\n  db.collection(\"test\").doc(\"b00064a76066e9340d0936c379481d64\").set({\n    data: {\n        title: \"测试标题3\",\n        author: \"测试作者2\",\n        content: \"测试内容2\"\n    }\n  })\n}\n```\n\n一次更新多个数据：需要在服务器端，使用云函数来实现。 \n\n### command指令\n获取 command 对象：\n```\nconst db = wx.cloud.database();\nconst _ = db.command;\n```\n\n#### 查询指令\n通过 `db.command` 实现条件查询。\n##### command.eq\n示例一，在 `test` 集合中，找到字段 `author == \"测试作者03\"` 的数据：  \n第一种方式，通过制定数据查询：\n```\ndb.collection(\"test\").where({\n  author: \"测试作者03\"\n}).get().then(res => {\n  console.log(res);\n});\n```\n\n第二种方式，通过eq指令查询：\n```\neqcommand: function(){\n  db.collection(\"test\").where({\n    author: _.eq(\"测试作者03\")\n  }).get().then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序18](微信小程序/微信小程序18.png)\n`author: _.eq(\"测试作者03\")` 强调用是等于，`author: \"测试作者03\"` 强调的事匹配条件。\n\n示例二，匹配 `dic.key == \"测试对象03\"` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: {\n    key: \"测试对象03\"\n  }\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n指定数据方式可以获取到两条数据，这两条数据的 `dic` 对象的 `key` 等于\"测试对象03\"。\n![微信小程序19](微信小程序/微信小程序19.png)\n\n示例三，匹配 `dic.key == \"测试对象03\"` 且 `dic.key02 == \"测试对象03\"` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: {\n    key: \"测试对象03\",\n    key02: \"测试对象03\"\n  }\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序20](微信小程序/微信小程序20.png)\n\n示例四，获取 `dic == { key: \"测试对象\" }` 的数据：\n```\ndb.collection(\"test\").where({\n  dic: _.eq({\n    key: \"测试对象03\"\n  })\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序21](微信小程序/微信小程序21.png)\n\n##### command.neq\n表示字段不等于某个值，和 `db.command.eq` 相反。\n\n##### command.lt\n表示小于某个值。比如查找小于2021/4/1 10:00:00发布的数据：\n```\ndb.collection(\"test\").where({\n  pub_date: _.lt(new Date(\"2021/4/1 10:00:00\"))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序22](微信小程序/微信小程序22.png)\n\n##### command.lte\n表示小于或者等于某个值。与 `command.lt` 类似。\n\n##### command.gt\n表示大于某个值。与 `command.lt` 类似。\n\n##### command.gte\n表示大于或者等于某个值。与 `command.lte` 类似。\n\n##### command.in\n查询筛选条件，表示字段的值需在给定的数组内。比如查找北京日报和今日头条两个作者发表的文章：\n```\ndb.collection(\"test\").where({\n  author: _.in([\"测试作者01\", \"测试作者02\"])\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序23](微信小程序/微信小程序23.png)\n\n##### command.nin\n查询筛选条件，表示字段的值需不在给定的数组内。与 `command.in` 类似。\n\n##### command.and\n查询指令，用于表示逻辑 \"与\" 的关系，表示需同时满足多个查询筛选条件。比如获取发表在 2021/4/1 10:00:00 和 2021/4/1 11:00:00 之间的所有数据：\n```\n// 1.普通调用\ndb.collection(\"test\").where({\n  pub_date: _.and(_.gte(new Date(\"2021/4/1 10:00:00\")), _.lte(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n\n// 2.链式调用\ndb.collection(\"test\").where({\n  pub_date: _.gte(new Date(\"2021/4/1 10:00:00\")).and(_.lte(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序24](微信小程序/微信小程序24.png)\n\n##### command.or\n查询指令，用于表示逻辑 \"或\" 的关系，表示需同时满足多个查询筛选条件。或指令有两种用法：\n1. 可以进行字段值的 “或” 操作；\n2. 可以进行跨字段的 “或” 操作。\n\n示例一，一个字段的或操作（比如获取时间在 2021/4/1 10:00:00 前或者 2021/4/1 11:00:00 后的数据）：\n```\ndb.collection(\"test\").where({\n  pub_date: _.or(_.lt(new Date(\"2021/4/1 10:00:00\")), _.gt(new Date(\"2021/4/1 11:00:00\")))\n}).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序25](微信小程序/微信小程序25.png)\n\n示例二，跨字段或操作（比如想要获取时间在 2021/4/1 10:00:00 前，或者是作者中包含 “测试作者01” 的数据）：\n```\ndb.collection(\"test\").where(\n  _.or([\n    {\n      pub_date: _.lt(new Date(\"2021/4/1 10:00:00\"))\n    },\n    {\n      author: \"测试作者01\"\n    }\n  ])\n).get().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序26](微信小程序/微信小程序26.png)\n注意：`where()` 没有 `{}`，`or()` 内部是一个数组 `[]`。\n\n#### 更新指令\n\n##### command.set\n更新指令。用于设定字段等于指定值。比如以下是一条数据：\n![微信小程序27](微信小程序/微信小程序27.png)\n\n如果想将这个数据中的 `dic` 变成 `{ \"key\": \"测试对象\" } `，那么通过传统的方式是无法实现的：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: {\n      \"key\": \"测试对象\"\n    }\n  }\n}).then(res => {\n  console.log(res)\n})\n```\n\n上面这种方式，只能将 `dic.key` 改成“测试对象”，即 `dic == { key: \"测试对象\", key02: \"测试对象03\" }`，所以需要用 `_.set` 方法：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: _.set({\n      key: \"测试对象\"\n    })\n  }\n}).then(res => {\n  console.log(res);\n})\n```\n\n![微信小程序28](微信小程序/微信小程序28.png)\n\n##### command.remove\n更新指令。用于表示删除某个字段。比如我们想将author这个字段删除，那么就可以调用这个方法。示例代码如下：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    dic: _.remove()\n  }\n}).then(res => {\n  console.log(res);\n})\n```\n\n![微信小程序29](微信小程序/微信小程序29.png)\n\n##### command.inc\n更新指令。用于指示字段自增某个值，这是个原子操作，使用这个操作指令而不是先读数据、再加、再写回的好处是：\n\n原子性：多个用户同时写，对数据库来说都是将字段加一，不会有后来者覆写前者的情况。\n减少一次网络请求：不需先读再写。\n比如 `test` 集合中的一条数据加一个 `read_count` 字段，给这个字段加1，那么可以使用以下方式实现：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    read_count: _.inc(1)\n  }\n})\n```\n\n运行两次：\n![微信小程序30](微信小程序/微信小程序30.png)\n\n##### command.mul\n自乘指令，跟 `command.inc` 一样。\n\n##### command.push\n更新指令，对一个值为数组的字段，往数组尾部添加一个或多个值。如果该字段原为空，则创建该字段并设数组为传入值。  \n比如要给 `test` 集合中的某条数据添加标签，那么可以使用以下方式来实现：\n```\ndb.collection(\"test\").doc(\"b00064a760741e750e1185f2595e14a6\").update({\n  data: {\n    tags: _.push([\"新闻\"])\n  }\n})\n```\n\n![微信小程序31](微信小程序/微信小程序31.png)\n\n##### command.pop\n更新指令，对一个值为数组的字段，将数组尾部元素删除。\n\n##### command.shift\n更新指令，对一个值为数组的字段，将数组头部元素删除。\n\n##### command.unshift\n更新指令，对一个值为数组的字段，往数组头部添加一个或多个值。如果该字段原为空，则创建该字段并设数组为传入值。\n\n### 高级查询\n#### collection.count\n统计集合记录数或统计查询语句对应的结果记录数，注意这与集合权限设置有关，一个用户仅能统计其有读权限的记录数。比如查找所有由“测试作者03”发布的数据的个数：\n```\ndb.collection(\"test\").where({\n  author: \"测试作者03\"\n}).count().then(res => {\n  console.log(res)\n})\n```\n\n![微信小程序32](微信小程序/微信小程序32.png)\n\n#### collection.orderBy\n该方法接受两个参数：\n1. 一个必填字符串参数 `fieldName` 用于定义需要排序的字段；\n2. 一个字符串参数 `order` 定义排序顺序，`order` 只能取 `asc` 或 `desc`。\n\n注意：\n1. 如果需要对嵌套字段排序，需要用 \"点表示法\" 连接嵌套字段，比如 `author.age` 表示字段 `author` 里的嵌套字段 `age`。\n2. 同时也支持按多个字段排序，多次调用 `orderBy` 即可，多字段排序时的顺序会按照 `orderBy` 调用顺序先后对多个字段排序。\n\n比如通过“阅读量”从大到小以及“作者的年龄”从小到大进行排序。那么可以使用以下代码来实现：\n```\norderBy: function (options) {\n  db.collection(\"test\")\n  .orderBy(\"read_count\", \"desc\")\n  .orderBy(\"author.age\", \"asc\")\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n没有指定字段的数据也会返回并且默认排在后面：\n![微信小程序33](微信小程序/微信小程序33.png)\n\n#### collection.limit\n指定查询结果集数量上限。比如一次性获取10篇文章，那么可以通过以下代码来实现：\n```\nlimit: function (options) {\n  db.collection(\"test\").limit(10)\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序34](微信小程序/微信小程序34.png)\n\n#### collection.skip\n指定查询返回结果时从指定序列后的结果开始返回，常用于分页。比如跳过前面4篇文章，从第11篇开始获取。代码如下：\n```\nskip: function (options) {\n  db.collection(\"test\").skip(4)\n  .get()\n  .then(res => {\n    console.log(res);\n  })\n}\n```\n\n![微信小程序35](微信小程序/微信小程序35.png)\n\n#### collection.field\n指定返回结果中记录需返回的字段。比如只想获取 `test` 文章中的 `author` 字段。那么可以使用以下代码来实现：\n```\nfield: function (options) {\n  db.collection(\"test\").field({\n    read_count: true\n  }).get().then(res => {\n    console.log(res)\n  })\n}\n```\n\n结果显示，如果数据中没有指定的字段也会返回：\n![微信小程序36](微信小程序/微信小程序36.png)\n\n## 文件管理\n小程序文件管理官方文档：[文件](https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.saveFile.html)。\n\n### wx.saveFile(Object object)  \n保存文件到本地。注意：saveFile 会把临时文件移动，因此调用成功后传入的 tempFilePath 将不可用\n```\n/**\n * 生命周期函数--监听页面显示\n */\nonShow: function () {\n  wx.chooseImage({\n    success: function (res) {\n      const tempFilePaths = res.tempFilePaths\n      wx.saveFile({\n        tempFilePath: tempFilePaths[0],\n        success (res) {\n          const savedFilePath = res.saveFile;\n          console.log(res)\n        }\n      })\n    }\n  })\n},\n```\n\n## 云函数\n### node环境搭建\n因为云函数在服务器上是运行在 node.js 环境中的，并且云函数会用到一些第三方库。先在本地编写好，再提交到云服务器，所以本地也需要安装好一套 node.js 环境。原则上，本地的 node.js 版本应该跟云服务器的版本一致。\n\n### 初始化环境\n在以上文件夹中，右键->初始化环境：\n![微信小程序37](微信小程序/微信小程序37.png)\n\n### 创建云函数\n在 `cloudfunctions` 文件夹上，右键->创建云函数，填入云函数的名称，然后点击确定即可创建好。然后就可以在相应的 `index.js` 文件中写代码了。示例代码如下：\n```\n// 云函数入口文件\nconst cloud = require('wx-server-sdk')\n\ncloud.init()\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const x = event.x;\n  const y = event.y;\n\n  return {\n    result: x + y\n  }\n}\n```\n\n### 上传和部署\n在本地创建完云函数后，需要上传到服务器并部署。只需要在相应函数的文件夹上：右键 -> 上传并部署：云端安装依赖。\n![微信小程序38](微信小程序/微信小程序38.png)\n\n### 在云函数中操作数据库\n在云函数中操作数据库、文件等，可以通过 `wx-server-sdk` 实现。这个 sdk 与小程序端的 API 有以下两点不同：\n1. 服务端的 API 仅支持 Promise 风格调用。\n2. 服务端 API 可以进行批量的 update 和 remove 操作。\n\n获取微博数据示例：\n```\n// 云函数入口文件\nconst cloud = require('wx-server-sdk')\ncloud.init()\n\n// 数据库\nconst db = cloud.database();\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取微信调用上下文\n  const wxContext = cloud.getWXContext()\n  // 小程序用户 openid\n  const openId = wxContext.OPENID;\n\n  const start = event.start;\n  // 获取 weibo 集合\n  let promise = db.collection(\"weibo\");\n  if (start > 0) {\n    promise = promise.skip(start);\n  }\n  // 异步获取10调微博数据，按创建时间，倒序\n  const weiboRes = await promise.limit(10).orderBy(\"create_time\", \"desc\").get()\n  const weibos = weiboRes.data;\n  if(weibos.length > 0){\n    weibos.forEach((weibo,index) => {\n      weibo.isPraised = false;\n      if(weibo.praises && weibo.praises.length > 0){\n        weibo.praises.forEach((praise,index) => {\n          if(praise == openId){\n            weibo.isPraised = true;\n          }\n        })\n      }\n    })\n  }\n  // 返回数据\n  return {\n    weibos\n  }\n}\n```\n\n","slug":"Other/微信小程序","published":1,"updated":"2023-08-22T09:52:14.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgz80034aq7khz36ansn"},{"title":"面向对象编程","date":"2023-05-04T02:41:19.000Z","_content":"\n* [概述](#概述)\n* [枚举](#枚举)\n* [属性](#属性)\n* [方法](#方法)\n* [下标](#下标)\n* [初始化和反初始化](#初始化和反初始化)\n* [继承](#继承)\n* [多态](#多态)\n* [扩展](#扩展)\n* [协议](#协议)\n* [协议和扩展](#协议和扩展)\n* [面向协议编程](#面向协议编程)\n\n<!-- more -->\n\n## 概述\n\nSwift 的类、结构体、枚举中都可以定义属性、方法、下标、构造体和嵌套类型。在 Swift 中，枚举和结构体是值类型，类是引用类型。从整体的功能上看 Swift 的枚举、结构体、类三者具有完全平等的地位。\n\n### 面向对象的三大特性\n\n1. **封装（Encapsulation）**：隐藏类的实现细节，让使用者只能通过预定的方法来访问。\n2. **继承（inheritance）**：指子类从父类继承方法，使得子类具有父类相同的行为。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。\n3. **多态（polymorphism）**：指同一个方法在不同的对象上有不同的实现方式。\n\n### 基本单元\n\n1. 枚举（enum）\n2. 结构体（struct）\n3. 类（class）\n4. 协议（protocol）\n5. 扩展（extension）\n\n### 类和结构体相似点\n\n1. **属性**：定义属性用来存储值；\n2. **方法**：定义方法用于提供功能；\n3. **下标**：定义下标脚本用来允许使用下标语法访问值；\n4. **扩展**：可以被扩展提供默认所没有的功能；\n5. **协议**：遵循协议来针对特定类型提供标准功能。\n6. **初始化器**：定义初始化器用于初始化状态；\n\n### 类和结构体的不同点\n\n1. **继承**：允许一个类继承另一个类的特征；\n2. **类型转换**：允许在运行时检查和解释一个类实例的类型；\n3. **反初始化器**：允许一个类实例释放所有被分配的资源；\n4. **引用计数**：允许不止一个对类实例的引用。\n\n## 枚举\n\n### 枚举语法\n\n用 `enum` 关键字来定义一个枚举，然后将所有的定义内容放在大括号`{}`中。\n\n```swift\nenum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n\n多个成员值可以出现在同一行中，用逗号隔开：\n\n```swift\nenum CompassPoint {\n    case north, south, east, west\n}\n```\n\n每个枚举都定义了一个全新的类型。枚举的名字需要首字母大写（例如：`CompassPoint`）。要给枚举类型起一个单数的名字，从而使得枚举能够通俗易懂、顾名思义。\n\n### 使用 Switch 语句来匹配枚举值\n\n使用 `switch` 语句匹配每一个单独的枚举值：\n\n```swift\nenum CompassPoint {\n    case north, south, east, west\n}\n\nlet directionToHead = CompassPoint.south\nswitch directionToHead {\ncase .north:\n    print(\"north\")\ncase .south:\n    print(\"south\")\ncase .east:\n    print(\"east\")\ncase .west:\n    print(\"weat\")\n}\n\n// Prints \"south\"\n```\n\n### 遍历枚举的 case\n\n1. `CaseIterable`：通过在枚举名字后面写 `CaseIterable`，来允许枚举被遍历。\n2. `allCases`：Swift 的枚举暴露了一个集合 `allCases`，同字面义，该集合包含对应枚举类型的所有情况。\n\n```swift\nenum CompassPoint: CaseIterable {\n    case north\n    case south\n    case east\n    case west\n}\n\nfor direction in CompassPoint.allCases {\n    print(direction)\n}\n```\n\n打印结果：\n\n```js\nnorth\nsouth\neast\nwest\n```\n\n📢注意：这里的 `direction` 是 `CompassPoint` 类型，不是字符串。虽然打印结果看着像字符串，但是不是的。\n\n```swift\nfor direction in CompassPoint.allCases {\n    if direction is CompassPoint {\n        print(direction)\n    }\n}\n```\n\n打印结果：\n\n```js\nnorth\nsouth\neast\nwest\n```\n\n### 关联值\n\n可以定义枚举来存储任意类型的关联值，不同枚举成员关联值的类型可以不同。\n\n定义一个枚举，支持条形码和二维码：\n\n```swift\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n\nvar productBarCode = Barcode.upc(8, 85909, 51226, 3)\nprint(productBarCode)\n\nproductBarCode = .qrCode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nprint(productBarCode)\n```\n\n打印结果：\n\n```js\nupc(8, 85909, 51226, 3)\nqrCode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n```\n\n`upc` 有四个关联值，都是 `Int` 类型；`qrCode` 有一个关联值，`String` 类型。\n\n使用 `switch` **匹配值**：\n\n```swift\nswitch productBarCode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode)\")\n}\n\n// Prints \"QR code: ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n```\n\n### 原始值\n\n原始值：指枚举成员可以用相同类型的**默认值**预先填充。\n\n```swift\nenum ASCIIControlCharacter: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}\n```\n\n#### 预设原始值\n\n在操作存储整数或字符串原始值枚举的时候，因为Swift的枚举会自动分配值（在没有分配值时），所以不用显示的为每一个成员分配原始值。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n\nenum CompassPoint: String {\n    case north, south, east, west\n}\n```\n\n使用 `rawValue` 获取其值：\n\n```swift\nprint(Planet.earth.rawValue)\n// Prints \"3\"\n\nprint(CompassPoint.south.rawValue)\n// Prints \"south\"\n```\n\n`.earth` 的原始值被自动分配成了 3，`.south` 的原始值被自动分配成了字符串“south”。\n\n这里的 `CompassPoint.south.rawValue` 是字符串类型。\n\n#### 从原始值初始化\n\n枚举提供了一个默认初始化器，该初始化器可以接收一个形式参数 rawValue，返回一个枚举成员或者 nil。\n\n使用初始化器创建一个枚举实例：\n\n```swift\nlet possiblePlanet = Planet(rawValue: 7)\nprint(possiblePlanet!)\n// Prints \"uranus\"\n```\n\n或者：\n\n```swift\nlet positionToFind = 11\nif let somePlanet = Planet(rawValue: positionToFind) {\n    switch somePlanet {\n    case .earth:\n        print(\"earth\")\n    default:\n        print(\"Not a safe place for humans\")\n    }\n} else {\n    print(\"There isn't a planet at position \\(positionToFind)\")\n}\n// Prints \"There isn't a planet at position 11\"\n```\n\n### 递归枚举（indirect）\n\n递归枚举：枚举成员的**关联值是枚举**。\n\n因为编译器在操作递归枚举时必须插入间接寻址层，所以在声明枚举时需要使用 `indirect` 关键字来明确该枚举是递归枚举。\n\n实现 `(1 + 2) * 3`，先算加法，再算乘法：\n\n```swift\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n\n// 执行函数\nfunc evaluate(_ expression: ArithmeticExpression) -> Int {\n    switch expression {\n    case let .number(value):\n        return value\n    case let .addition(left, right):\n        return evaluate(left) + evaluate(right)\n    case let .multiplication(left, right):\n        return evaluate(left) * evaluate(right)\n    }\n}\n\n// (1 + 2) * 3\nlet one = ArithmeticExpression.number(1)\nlet two = ArithmeticExpression.number(2)\nlet sum = ArithmeticExpression.addition(one, two)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(3))\n\nprint(evaluate(product))\n// Prints \"9\"\n```\n\n因为 `switch` 实现了所有 case，所以不用 `default` 字段。\n\n## 属性\n\n### 存储属性\n\n存储属性是特定类和结构体实例一部分，可以是变量存储属性（var），也可以是常量存储属性（let）。\n\n```swift\nclass DataManager {\n    var fileName = \"data.text\"\n    let filePath: String\n    init(name: String, path: String) {\n        fileName = name\n        filePath = path\n    }\n}\n```\n\n#### 常量结构体实例的存储属性\n\n如果创建了一个结构体的实例，并且把实例赋给常量，则不能修改该实例的属性，即使是声明为变量的属性。即**常量结构体实例，不允许修改其属性**。\n\n![01.png](面向对象编程/01.png)\n\n#### 延迟存储属性\n\n在声明属性时，通过在声明前面标注 `lazy` 修改语来表示一个延迟存储属性，即**被 `lazy` 修饰符标记的属性**。延迟存储属性的初始值会延迟到在其第一次使用时才进行计算。\n\n延迟存储属性的线程安全问题：在延迟存储属性还没有被初始化时，同时被多个线程访问，则**无法保证属性值只初始化一次**。\n\n```swift\nclass DataImporter {\n    var fileName = \"data.text\"\n    init() {\n        print(\"DataImporter inits\")\n    }\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n}\n\nlet manager = DataManager()\nmanager.data.append(\"some data\")\nmanager.data.append(\"some more data\")\nprint(\"manager.data.append finish\")\nprint(manager.importer.fileName)\n```\n\n打印结果：\n\n```js\nmanager.data.append finish\nDataImporter inits\ndata.text\n```\n\n“DataImporter inits” 是在执行完 `manager.data.append()`，直到调用 `print(manager.importer.fileName)` 之前才打印的。\n\n### 计算属性\n\n类、结构体和枚举也能够定义计算属性，与存储属性不同，**计算属性不存储值**。计算属性通过提供一个读取器和一个设置器，间接实现读取和修改其它的属性和值。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set(newCenter) {\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 简写 setter\n\n计算属性的设置器有一个默认的名字 newValue，可以不用为设置器传入的值定义名字。\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            return Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 简写 getter\n\n如果整个读取器 getter 的函数体是一个单一的表达式，则 getter 会隐式返回这个表达式。可以省略 return：\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 只读计算属性\n\n只读计算属性：计算属性只有读取器，没有设置器。只读属性可以返回一个值，但是不能修改。可以通过点语法访问只读计算属性。\n\n因为计算属性的值是不固定的，所以必须用 `var` 关键字定义计算属性为变量属性，包括只读计算属性。\n\n`let` 关键字只用于常量属性，明确属性在初始化后就不能更改。\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n    }\n}\n```\n\n或者简写成：\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        return Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n    }\n}\n```\n\n### 属性观察者\n\n`willSet` 会在一个新值**被存储之前被调用**。新的属性值会以常量形式参数传递，默认名字为 newValue，也可以自定义名字。\n`didSet` 会在一个新值**被存储后被调用**。旧的属性值会以常量形式参数传递，默认名字为 oldValue，也可以自定义名字。如果在属性的 `didSet` 里给该属性赋值，则会覆盖 `willSet` 里设置的值。\n\n```swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"About to set totalSteps to \\(newTotalSteps)\")\n        }\n        didSet {\n            if totalSteps > oldValue {\n                print(\"Added \\(totalSteps - oldValue) steps\")\n            }\n        }\n    }\n}\n\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\nstepCounter.totalSteps = 300\n```\n\n打印结果：\n\n```js\nAbout to set totalSteps to 200\nAdded 200 steps\nAbout to set totalSteps to 300\nAdded 100 steps\n```\n\n#### 全局和局部变量\n\n观察属性的能力同样对全局变量和局部变量有效。全局变量是定义在任何函数、方法、闭包或者类型环境之外的变量。局部变量是定义在函数、方法或者闭包环境之中的变量。\n\n```swift\nvar count: Int = 0 {\n    willSet {\n        print(\"About to set count to \\(newValue)\")\n    }\n    didSet {\n        if count > oldValue {\n            print(\"Added \\(count - oldValue)\")\n        }\n    }\n}\n\ncount = 10\nprint(count)\n```\n\n打印结果：\n\n```js\nAbout to set count to 10\nAdded 10\n10\n```\n\n### 类型属性（static）\n\n使用 `static` 关键字定义类型属性。**类类型**的计算属性，可以使用 `class` 关键字来允许子类重写父类对类型属性的实现。\n\n```swift\nclass SomeClass {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 27\n    }\n    class var overrideableComputedTypeProperty: Int {\n        return 107\n    }\n}\n```\n\n## 方法\n\n### 实例方法\n\n实例方法是属于特定类实例、结构体实例或者枚举实例的函数。实例方法为实例提供功能性，可以提供访问和修改属性的方法，也可以提供与实例目的相关的功能。\n\n定义一个**类**，在实例方法中修改**类的属性**：\n\n```swift\nclass Counter {\n    var count = 0\n    func increment() {\n        count += 1\n    }\n    func increment(by amount: Int) {\n        count += amount\n    }\n    func reset() {\n        count = 0\n    }\n}\n```\n\n#### 隐含属性-self\n\n每一个类的实例都隐含一个 `self` 属性，它代表实力本身，可以使用它来调用实例方法。\n\n如果没有显示的写出 `self`，则在方法中调用属性或方法时，Swift 会假定调用的是当前实例中的属性或方法。\n\n📢注意：当实例方法的形式参数名与某个实例属性名相同时，形式参数名具有优先权，可以使用 `self` 调用属性来区分形式参数名和属性名。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    func isToTheRightOf(x: Double) -> Bool {\n        return self.x > x\n    }\n}\n\nlet somePoint = Point(x: 2.0, y: 2.0)\nif somePoint.isToTheRightOf(x: 1.0) {\n    print(\"This point is to the right of the line where x == 1.0\")\n}\n\n// Prints \"This point is to the right of the line where x == 1.0\"\n```\n\n#### 在实例方法中修改属性-mutating（异变方法）\n\n结构体和枚举是值类型，默认情况下，**值类型属性不能被自身的实例方法修改**。可以在 `func` 关键字前放一个 `mutating` 关键字来指定方法可以修改属性。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\n\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n#### 在 mutating 方法中赋值给 self\n\n结构体的异变方法可以指定整个实例给隐含的 `self` 属性。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n#### 枚举的 mutating 方法\n\n枚举的异变方法可以设置隐含的 `self` 属性为相同枚举里的不同成员。\n\n```swift\nenum TriStateSwitch {\n    case off, low, high\n    mutating func next() {\n        switch self {\n        case .off:\n            self = .low\n        case .low:\n            self = .high\n        case .high:\n            self = .off\n        }\n    }\n}\n\nvar ovenLight = TriStateSwitch.off\novenLight.next()\nprint(ovenLight)\n// Prints \"low\"\n```\n\n### 类型方法（static）\n\n通过在 `func` 关键字前面使用 `static` 关键字来明确一个类型方法。类同样可以使用 `class` 关键字来允许子类重写父类对类型方法的实现。\n\n```swift\nclass SomeClass {\n    class func someTypeMethod() {\n        print(\"someTypeMethod\")\n    }\n}\nSomeClass.someTypeMethod()\n// Prints \"someTypeMethod\"\n```\n\n## 下标\n\n类、结构体和枚举可以定义下标，它可以作为访问集合、列表或序列成员元素的快捷方式。\n\n下标的作用：\n\n1. 可以通过索引值来设置或检索值，而不用分别为设置或检索提供实例方法。\n\n2. 可以为一个类型定义多个下标，下标会根据传入的索引值的类型，选择合适的下标重载使用。\n\n3. 可以使用多个输入形参来定义下标，以满足自定义类型的需求。\n\n### 下标语法（subscript）\n\n使用关键字 `subscript` 定义下标。与实例方法相同，可以指定一个或多个输入形式参数和返回类型。与实例方法不同的是，下标可以是读写的，也可以是只读的。\n\n下标脚本（`subscript`）允许通过在实例名后面的**方括号内写一个或多个值**，对该类的实例进行查询。\n\n```swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\n\nlet threeTimesTable = TimesTable(multiplier: 3)\nprint(\"six times three is \\(threeTimesTable[6])\")\n// Prints \"six times three is 18\"\n```\n\n### 下标参数\n\n1. 下标可以接收任意数量的输入形式参数，并且这些输入形式参数可以是任意类型；\n2. 下标可以返回任何类型；\n3. 下标可以使用变量形式参数（`var`）和可变实行参数（`...`），但是不能使用输入输出形式参数（`inout`），也不能提供默认形式参数。\n\n### 实例下标\n\n```swift\n// 矩阵\nstruct Matrix {\n    // 行，列\n    let rows: Int, columns: Int\n    // 坐标\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(repeating: 0.0, count: rows * columns)\n    }\n    func indexIsValid(row: Int, column: Int) -> Bool {\n        return row >= 0 && row <= rows && columns >= 0 && columns <= columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nmatrix[0, 1] = 1.5\nmatrix[1, 0] = 3.2\nprint(matrix.grid)\n// Prints \"[0.0, 1.5, 3.2, 0.0]\"\n```\n\n![02.png](面向对象编程/02.png)\n\n### 类型下标（static）\n\n除了定义实例下标外，也可以定义类型本身的下标。在 `subscript` 关键字前加 `static` 关键字来标记类型下标。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n    static subscript(n: Int) -> Planet {\n        return Planet(rawValue: n)!\n    }\n}\nlet mars = Planet[3]\nprint(mars)\n// Prints \"earth\"\n```\n\n同样的，使用 `class` 关键字，可以允许子类重写父类的下标实现。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n    static subscript(n: Int) -> Planet {\n        return Planet(rawValue: n)!\n    }\n}\n\nclass PlanetClass {\n    class subscript(n: Int) -> Planet {\n        return Planet[n]\n    }\n}\n\nclass SubPlanetClass {\n    class subscript(n: Int) -> Planet {\n        return Planet[n + 1]\n    }\n}\n\nprint(PlanetClass[3])\n// Prints \"earth\"\nprint(SubPlanetClass[3])\n// Prints \"mars\"\n```\n\n## 初始化和反初始化\n\n### 初始化器\n\n初始化器在创建特定类型的实例时被调用。\n\n如下所示：在初始化器里给存储属性设置初始值：\n\n```swift\n// 温度计\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature) Fahrenheit\")\n// Prints \"The default temperature is 32.0 Fahrenheit\"\n```\n\n### 默认的属性值\n\n存储属性的初始值，可以在初始化器设置，也可以**在属性定义的时候设置**。\n\n如下所示，在存储属性定义的时候设置初始值：\n\n```swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature) Fahrenheit\")\n// Prints \"The default temperature is 32.0 Fahrenheit\"\n```\n\n### 默认的初始化器\n\n当结构体或类没有提供初始化器时，Swfit 会提供一个默认的初始化器。\n\n没有提供初始化器的**类**，必须设置默认属性值：\n\n```swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity = 1\n    var purchased = false\n}\n\nvar item = ShoppingListItem()\n```\n\n提供了初始化器的结构体或类，可以不设置默认属性值：\n\n```swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity: Int\n    var purchased: Bool\n    init() {\n        quantity = 1\n        purchased = false\n    }\n}\n\nvar item = ShoppingListItem()\n```\n\n### 自定义初始化\n\n可以通过为初始化器添加形式参数的方式，实现自定义类型和值的名称。初始化形式参数与函数的形式参数具有相同的功能和语法。\n\n```swift\n// 摄氏度\nstruct Celsius {\n    var temperatureInCelsius: Double\n    // 华氏温度计的(冰点为32度，沸点为212度)\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    // 开(开尔文温标的计量单位，1开氏度相当于1摄氏度)\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n}\n// 水的沸点\nlet boilingPointOfWater = Celsius(fromFahrenheit: 212.0)\n// 水的冰点\nlet freezingPointOfWater = Celsius(fromKelvin: 273.15)\n\nprint(boilingPointOfWater.temperatureInCelsius)\n// Prints \"100.0\"\nprint(freezingPointOfWater.temperatureInCelsius)\n// Prints \"0.0\"\n```\n\n### 在初始化中分配常量属性\n\n常量属性：赋值后不能修改。\n\n在初始化结束前，要保证常量属性被设置了确定的值，可以在初始化的任意时刻设置。\n\n```swift\nclass SurveyQuestion {\n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\n\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")\nbeetsQuestion.ask()\n// Prints \"How about beets?\"\nbeetsQuestion.response = \"I like beets.\"\n```\n\n### 结构体的成员初始化器\n\n如果结构体类型中没有定义自定义初始化器，系统会提供一个默认的成员初始化器。没有提供初始化器的**类**，必须设置默认属性值。但是**结构体的**成员初始化器允许存储属性没有默认值。\n\n```swift\nstruct Size {\n    var width: Float, height = 0.0\n}\nlet twoByTwo = Size(width: 1.0, height: 1.0)\nprint(twoByTwo)\n// Prints \"Size(width: 1.0, height: 1.0)\"\n```\n\n### 值类型的初始化器委托\n\n初始化器委托：初始化器可以调用其他初始化器来执行部分实例的初始化。避免了多个初始化器里冗余代码。\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\n\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {\n        self.init(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\n    }\n    // 值类型的简单初始化器\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet rect1 = Rect()\nlet rect2 = Rect(center: Point(x: 1.0, y: 1.0), size: Size(width: 2.0, height: 2.0))\nlet rect3 = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\nprint(\"rect1: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect1: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\nprint(\"rect2: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect2: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\nprint(\"rect3: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect3: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\n```\n\n### 类的继承和初始化\n\n### 指定初始化器和便捷初始化器（convenience）\n\n用与**值类型的简单初始化器**相同的方式类写类的**指定初始化器**：\n\n```swift\ninit(origin: Point, size: Size) {\n    self.origin = origin\n    self.size = size\n}\n```\n\n将 `convenience` 修饰符放到 `init` 关键字前定义**便捷初始化器**：\n\n```swift\nconvenience init() {\n    self.init(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\n}\n```\n\n![03.png](面向对象编程/03.png)\n\n### 类的初始化委托\n\n1. 指定初始化**必须**从它的直系父类调用指定初始化器（子类必须要调用父类）。\n2. 便捷初始化器**必须**从相同的类里调用另一个初始化器（便捷初始化器或指定初始化器）。\n3. 便捷初始化器**最终**必须调用一个指定初始化器。\n\n![04.png](面向对象编程/04.png)\n\n### 两段式初始化\n\nSwift 的类初始化是一个两段式过程：\n\n* 第一阶段：**每一个**存储属性被引入类并分配一个初始值。\n* 第二阶段：每个类都可以在新的实例准备使用之前定制它的存储属性。\n\n#### 两段式初始化-阶段一\n\n1. 指定初始化器或便捷初始化器在类中被**调用**；\n2. 为这个类的新实例**分配内存**，内存还没有被初始化；\n3. 这个类的指定初始化器确保所有由该类引入的存储属性都有一个值。现在这些**存储属性的内存被初始化了**；\n4. 指定初始化器上交**父类的初始化器**为其存储属性执行相同任务；\n5. 这个调用父类初始化器的过程将沿着**初始化链**一直向上进行，直到到达初始化器链的最顶部；\n6. 一旦达到初始化器的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为**完全初始化**了，此时第一阶段完成。\n\n![09.png](面向对象编程/09.png)\n\n#### 两段式初始化-阶段二\n\n从顶部初始化器往下，初始化链中的每一个**指定初始化器**都有机会进一步定制实例。在第二阶段，初始化器能够访问 `self`，并且可以修改它的属性、调用它的实例方法等等。\n\n最终，初始化链中任何**便捷初始化器**都有机会定制实例以及使用 `self`。\n\n![10.png](面向对象编程/10.png)\n\n### 安全检查\n\n1、指定初始化器必须保证在向上委托给父类初始化器之前，**其所在的类引入的所有属性**都要初始化完成。（子类必须先初始化自己的所有属性，再调用父类的初始化器）\n\n![05.png](面向对象编程/05.png)\n\n2、指定初始化器必须先向上委托父类初始化器，然后才能为**继承的属性**设置新值，否则指定初始化器赋予的新值会被父类中的初始化器所覆盖。（**子类必须先调用父类的初始化器，再初始化父类的属性**）\n\n![06.png](面向对象编程/06.png)\n\n3、便捷初始化器必须先委托同类中的其它初始化器，然后再为**任意属性**赋值，否则便捷初始化器赋予的新值会被自己类中其它指定初始化器所覆盖。\n\n![07.png](面向对象编程/07.png)\n\n4、初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 `self` 作为值。\n\n![08.png](面向对象编程/08.png)\n\n正确的执行顺序：\n\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name;\n        self.age = age\n    }\n    convenience init() {\n        self.init(name: \"[unnamed]\", age: 0)\n    }\n}\n\nclass Teacher: Person {\n    var salary: Int\n    init(name: String, age: Int, salary: Int) {\n        // 1、初始化自定义属性\n        self.salary = salary\n        // 2、委托父类初始化器\n        super.init(name: name, age: age)\n        // 3、修改父类属性\n        self.name = name + \"老师\"\n        // 4、调用实例方法\n        self.showInfo()\n    }\n    convenience init(name: String) {\n        self.init(name: name, age: 30, salary: 5000)\n    }\n    \n    func showInfo() {\n        print(\"teacher name \\(name), age \\(age), salary \\(salary)\")\n    }\n}\n\nlet teacher = Teacher(name: \"kevin\")\n// Prints \"teacher name kevin老师, age 30, salary 5000\"\n```\n\n### 初始化器的继承和重写（override）\n\n与 Object-C 中的子类不同，Swfit 的子类不会默认继承父类的初始化器。Swift 的这种机制防止父类的简单初始化器被一个更专用的子类继承，并被用来创建一个没有完全初始化或错误初始化的新实例的情况。**只有在特定情况下才会继承父类的初始化器**。\n\n如果想自定义子类来实现一个或多个父类相同的初始化器，可以在子类中为初始化器提供定制的实现。如果提供的子类初始化器完全匹配父类指定初始化器，则可以重写父类的初始化器。**通过在子类初始化器定义的前面写 `override` 修饰符，实现对该方法的重写。**同默认初始化器一样，即使是自动提供的默认初始化器也可以重写。\n\n### 初始化器的自动继承\n\n规则1：如果子类没有定义任何指定初始化器，它会自动继承父类所有的**指定初始化器**。\n\n规则2：如果子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承父类所有的**便捷初始化器**。\n\n### 可失败初始化器（init?/init!）\n\n类、结构体或枚举的可失败初始化器引用场景：\n\n1. 初始化传入无效的形式参数值；\n2. 缺少某种外部所需的资源；\n3. 其他阻止初始化的情况。\n\n定义方式：\n\n1. 通过在 `init` 关键字后面添加问号（`init?`）的方式来定义一个可失败初始化器以创建一个合适类型的可选项实例。\n\n2. 通过在 `init` 关键字后面添加惊叹号（`init!`）的方式来定义一个可失败初始化器以创建一个**隐式展开**具有合适类型的可选项实例。\n\n### 必要初始化器（required）\n\n在类的初始化器前添加 `required` 修饰符来表明所有该类的子类都必须实现该初始化器。\n\n### 反初始化（deinit）\n\n在类的**实例被释放**的时候，反初始化器就会立即被调用。使用 `deinit` 关键字来写反初始化器，同写初始化器要用 `init` 关键字一样。反初始化器只在类类型中有效。\n\n反初始化器的调用时机：\n\n1. 反初始化器会在实例被释放之前自动被调用。\n2. 不能自行调用反初始化器。\n3. 父类的反初始化器可以被子类继承，并且子类的反初始化器实现结束之后父类的反初始化器会被调用。\n4. 父类的反初始化器总会被调用，就算子类没有反初始化器。\n\n每个类当中只能有一个反初始化器。反初始化器不接收任何形式参数，并且不需要写圆括号。\n\n```swift\ndeinit {\n    // perform the deinitialization\n}\n```\n\n## 继承\n\n### 定义基类\n\nSwift 类不会从一个通用基类继承，**任何不从另一个类继承的类都是所谓的基类**。如果没有指定特定父类的类都会以基类的形式创建。\n\n```swift\n/// 定义一个交通工具类\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // to do\n    }\n}\n```\n\n### 子类\n\n**子类是基于现有类创建新类的行为**。子类从现有的类继承了一些特征，可以重新定义继承来的特征，也可以为子类添加新的特征。为了表明子类有父类，要把子类写在父类的前面，用冒号分隔（`subClass : superClass`）。\n\n```swift\n/// 定义一个自行车类，继承自交通工具类\nclass Bicycle : Vehicle {\n    // 自定义新的属性，是否有车筐\n    var hasBasket = false\n}\n\nlet bicycle = Bicycle()\nbicycle.hasBasket = true\nbicycle.currentSpeed = 15.0\nprint(\"Bicycle: \\(bicycle.description)\")\n// Prints \"Bicycle: traveling at 15.0 miles per hour\"\n```\n\n### 重写（override）\n\n重写：子类可以提供自己的实例方法、类型方法、实例属性、类型属性或下标脚本的自定义实现，否则子类将会从父类继承。\n\n如果想要重写而不是继承一个特征，需要在重写定义前面加上 `override` 关键字，表明提供一个重写，而不是额外提供一个相同的定义。额外提供一个相同的定义可能导致意想不到的行为，并且任何没有使用 `override` 关键字的重写都会在编译时报错。\n\n### 访问父类的方法、属性和下标脚本\n\n可以通过使用 `super` 前缀访问父类的方法、属性或下标脚本。\n\n1. 一个命名为 `somoeMethod()` 的重写方法可以通过 `super.someMethod()` 在重写方法的实现中调用父类版本的 `someMethod()` 方法。\n2. 一个命名为 `someProperty` 的重写属性可以通过 `super.someProperty` 在重写的 getter 或 setter 实现中访问父类版本的 `someProperty` 属性。\n3. 一个命名为 `someIndex` 的重写下标脚本可以通过 `super[someIndex]` 在重写的下标脚本实现中访问父类版本中相同的下标脚本。\n\n### 重写方法\n\n在子类中重写一个继承的实例方法或类型方法来提供定制的或替代的方法实现。\n\n```swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // to do\n    }\n}\n\n/// 定义一个火车类，继承自交通工具类\nclass Train: Vehicle {\n    // 重写发声方法\n    override func makeNoise() {\n        print(\"火车鸣笛~\")\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// Prints \"火车鸣笛~\"\n```\n\n### 重写属性的 getter 和 setter\n\n可以提供一个自定义的 `getter` 或 `setter` 方法来重写任意继承的属性（存储属性或计算属性）。\n\n```swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprint(\"Car: \\(car.description)\")\n// Prints \"Car: traveling at 25.0 miles per hour in gear 3\"\n```\n\n### 重写属性的观察器\n\n可以使用属性重写来为继承的属性添加属性观察器（`willSet`、`didSet`）。\n\n注意：\n\n1. 因为常量存储属性（`let`）和只读的计算属性（`readonly`）不支持改变，所以不能提供 `willSet` 和 `didSet` 来监听值的改变（它们不会变）。\n2. 不能为同一个属性同时提供重写的 `setter` 和重写的属性观察器。自定义的 `setter` 就可以实现监听值的改变。\n\n```swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automaticCar = AutomaticCar()\nautomaticCar.currentSpeed = 35.0\nprint(\"AutomaticCar: \\(automaticCar.description)\")\n// Prints \"AutomaticCar: traveling at 35.0 miles per hour in gear 4\"\n```\n\n### 组织重写（final）\n\n通过在方法、属性或者下标甲苯的关键字前写 `final` 修饰符，来阻止其被重写（如：`final var`，`final func`，`final class func`，`final subscript`）。\n\n## 多态\n\n多态是面向对象三大特性之一，指同一个方法在不同的对象上有不同的实现方式。\n\n### 类型\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n// Prints \"Array<MediaItem>\"\n\nlet library1 = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\")\n]\nprint(type(of: library1))\n// Prints \"Array<Movie>\"\n\nlet library2 = [\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\")\n]\nprint(type(of: library2))\n// Prints \"Array<Song>\"\n```\n\n### 类型检查（is）\n\n使用类型检查操作符`is`来检查**一个实例是否属于一个特定的子类**，如果实例是该子类类型，类型检查操作符返回 true，否则返回 false。\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n\nfor item in library {\n    if item is Song {\n        print(item.name)\n    }\n}\n```\n\n打印结果：\n\n```js\nArray<MediaItem>\nBlue Suede Shoes\nThe One And Only\nNever Gonna Give You Up\n```\n\n### 向下类型转换（as?/as!）\n\n某个**类类型**的常量或变量可能实际上引用自一个子类的实例，可以使用类型转换操作符`as?`或`as!`将它向下类型转换至其子类类型。因为向下类型转换可能失败，所以类型转换操作符有两个不同的形式`as?`和`as!`。\n\n1. `as?`，条件形式，返回一个将要向下类型转换的值的可选项。\n2. `as!`，强制形式，将向下类型转换和**强制展开**结合为一个步骤。\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n\nfor item in library {\n    if let song = item as? Song {\n        print(\"Song: \\(song.name)\")\n    }\n}\n```\n\n打印结果：\n\n```js\nArray<MediaItem>\nSong: Blue Suede Shoes\nSong: The One And Only\nSong: Never Gonna Give You Up\n```\n\n### 不确定类型 Any 和 AnyObject\n\nSwift 为不确定的类型提供了两种特殊的类型别名：\n\n1. `AnyObject`：表示**任何类类型**的实例。\n2. `Any`：表示**任何类型**，包括函数类型。\n\n### 嵌套类型\n\nSwift 中的类、结构体和枚举可以进行嵌套，即**在某一个类型的内部定义类型**，嵌套类型能够访问它外部的成员。\n\n这种类型嵌套在 Java 中称为内部类，在 C# 中称为嵌套类。\n\n嵌套类\n\n```swift\nclass Person {\n    var body = Body() \n    \n    class Body {\n        var height = 175\n        var weight = 80\n        func profile() -> String {\n            return \"Height: \\(self.height), Weight: \\(self.weight)\"\n        }\n    }\n}\n\nlet p = Person()\nprint(p.body.profile())\n// Prints \"Height: 175, Weight: 80\"\n```\n\n嵌套结构体\n\n```swift\nstruct Shapes {\n    struct Line {\n        var x = 0\n        var y = 0\n        var length = 0\n    }\n    \n    struct Rectangle {\n        var x = 0\n        var y = 0\n        var width = 0\n        var height = 0\n        var area = 0\n    }\n    \n    struct Circle {\n        let pi = 3.1415926\n        var radius = 0.0\n    }\n}\n\nvar c = Shapes.Circle()\nc.radius = 45.0\n```\n\n## 扩展\n\n扩展为现有的类、结构体、枚举类型或协议添加了新功能，包括为无访问权限的源代码扩展类型的能力（逆向建模）。\n\n扩展和 Object-C 中的 category 类似，与 Object-C 的分类不同的是 Swift 的扩展没有名字。\n\n```swift\nclass Person {\n\n}\n\n// 扩展：让 Person 实现 Hashable 协议\nextension Person : Hashable {\n\n}\n```\n\n### 扩展（extension）的能力\n\n1. 添加计算实例属性和计算类型属性；\n2. 定义实例方法和类型方法；\n3. 提供新初始化器；\n4. 定义下标；\n5. 定义和使用新内嵌类型；\n6. 使现有的类型遵循某些以。\n7. **扩展可以向一个类型添加新的方法，但是不能重写已有的方法。**\n\n#### 扩展的能力-计算属性\n\n* 扩展可以向已有的类型添加计算实例属性和计算类型属性。\n\n```swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprint(\"One inch is \\(oneInch) meters\")\nlet threeFeet = 3.ft\nprint(\"Three feet is \\(threeFeet) meters\")\n```\n\n打印结果：\n\n```swift\nOne inch is 0.0254 meters\nThree feet is 0.914399970739201 meters\n```\n\n#### 扩展的能力-初始化器\n\n* 扩展可以向已有的类型添加新的初始化器。\n\n通过扩展可以使初始化器接收自定义类型作为形式参数，也可以提供该类型原始实现中未包含的额外初始化选项。\n\n扩展能为类添加新的**便捷初始化器**，但是不能添指定初始化或反初始化器。**指定初始化器和反初始化器必须由原来类的实现提供**。\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\n\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))\nprint(centerRect.origin)\n// Prints \"Point(x: 2.5, y: 2.5)\"\n```\n\n#### 扩展的能力-方法\n\n扩展可以为已有的类型添加新的实例方法和类型方法。\n\n```swift\nextension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n\n2.repetitions {\n    print(\"Hello!\")\n}\n```\n\n打印结果：\n\n```js\nHello!\nHello!\n```\n\n#### 扩展的能力-mutating方法\n\n扩展的实例方法仍可以修改（异变）实例本身。\n\n结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 `mutating`，和原本实现的一遍方法一样。\n\n```swift\nextension Int {\n    mutating func sequare() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.sequare()\nprint(someInt)\n// Prints \"9\"\n```\n\n#### 扩展的能力-下标\n\n扩展能为已有的类型添加新的下标。\n\n```swift\nextension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\nprint(746381295[0])\n// Prints \"5\"\nprint(746381295[1])\n// Prints \"9\"\nprint(746381295[2])\n// Prints \"2\"\nprint(746381295[8])\n// Prints \"7\"\n```\n\n#### 扩展的能力-添加内嵌类型\n\n```swift\nextension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n\nprint(0.kind)\n// Prints \"zero\"\nprint(100.kind)\n// Prints \"positive\"\nprint((0-1).kind)\n// Prints \"negative\"\n```\n\n## 协议\n\n### 协议的语法\n\n自定义类型声明时，**将协议名放在类型名的冒号之后**来表示该类型采纳一个特定的协议，多个协议可以用逗号分开列出。若一个类拥有父类，将这个父类名放在其采纳的协议名**之前**，并用逗号分隔。\n\n![10](面向对象编程/11.png)\n\n### 属性要求\n\n协议可以要求所有遵循该协议的类型，提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性时存储型属性还是计算型属性，它只具体要求——**属性有特定的名称和类型**。\n\n协议同时要求——**一个属性必须明确是可读的或可读可写**：\n\n1. 若协议要求一个属性为可读可写的，那么该属性不能用常量储存属性或只读计算属性来满足。\n\n2. 若协议要求一个属性为可读的，那么任何种类的属性都能满足这个要求。\n\n读写计算属性和只读计算属性：\n\n```swift\nprotocol SomeProtocol {\n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n```\n\n制度计算属性：\n\n```swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed {\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n// Prints \"John Appleseed\"\n```\n\n只读计算属性\n\n```swift\nclass Starship: FullyNamed {\n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n        return (prefix != nil ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")\nprint(ncc1701.fullName)\n// Prints \"USS Enterprise\"\n```\n\n在协议中定义**类型属性**时在前面添加 `static` 关键字。当类的实现使用 `class` 或 `static` 关键字前缀声明类型属性要求时，这个规则仍然适用。\n\n```swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n\n### 方法要求\n\n协议可以要求采纳的类型**实现指定的实例方法和类方法**。\n\n1. 这些方法作为协议定义的一部分，书写方式与正常实例和类方法的方式完全相同，但是不需要大括号和方法的主题；\n2. 允许方法拥有参数，与正常的方法使用同样的规则；\n3. 方法参数不能定义默认值。\n\n在类实现时，类型方法要求使用 `class` 或 `static` 作为关键字前缀，协议中同样适用。\n\n```swift\nprotocol AnotherProtocol {\n    func someMethod(element: String)\n    static func anotherMethod(element: Int)\n}\n```\n\n### mutating 方法要求\n\n对于协议里定义的实例方法，如果想要异变采用了该协议的类型实例，就要在方法的定义当中使用 `mutating` 关键字。这允许结构体和枚举类型能采用相应协议并满足方法要求。\n\n```swift\nprotocol MoveProtocol {\n    mutating func moveBy(x deltaX: Int, y deltaY: Int)\n}\n\nstruct Point: MoveProtocol {\n    var x = 0, y = 0\n    mutating func moveBy(x deltaX: Int, y deltaY: Int) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n\nvar p = Point(x: 1, y: 1)\np.moveBy(x: 1, y: 1)\nprint(p)\n// Prints \"Point(x: 2, y: 2)\"\n```\n\n### 初始化器要求\n\n协议可以要求遵循协议的类型实现指定的初始化器。\n\n协议在定义初始化器时和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号（初始化的实体）。\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n```\n\n### 初始化器要求的类实现\n\n一、如果想让遵循协议的类满足协议的初始化器要求，在实现协议指定的初始化器或便捷初始化器时，必须使用 `required` 关键字修饰初始化器的实现。\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n如果遵循了协议，且实现了协议指定的初始化器，没有使用 `required` 关键字，则会报错：\n\n![12](面向对象编程/12.png)\n\n二、如果一个子类重写了父类指定的初始化器，并且遵循协议实现了初始化器要求，那么就要为这个初始化器的实现添加 `required` 和 `override` 两个修饰符。\n\n![15](面向对象编程/15.png)\n\n如果重写了方法，没有加 `override` 关键字，则会报错：\n\n![13](面向对象编程/13.png)\n\n如果遵循了协议实现了初始化器要求，没有加 `required` 关键字，则会报错：\n\n![14](面向对象编程/14.png)\n\n### 将协议作为类型\n\n1. 在函数、方法或者初始化器里作为形式参数类型或者返回类型；\n2. 作为常量、变量或者属性的类型；\n3. 作为数组、字典或者其他存储器的元素的类型。\n\n### 协议继承\n\n协议可以继承一个或者多个其他协议，并且可以在继承的基础之上添加更多要求。协议继承的语法与类继承的语法相似，只不过可以选择列出**多个继承的协议**，使用逗号分隔。\n\n![16](面向对象编程/16.png)\n\n### 类专用的协议（AnyObject）\n\n通过添加 `AnyObject` 关键字到协议的继承列表，可以**限制协议只能被类类型采纳**，并且不是结构体或者枚举。\n\n![17](面向对象编程/17.png)\n\n### 协议组合（&）\n\n可以使用协议组合来复合多个协议到一个要求里。协议组合不定义任何新的协议类型。\n\n协议组合使用 `SomeProtocol & AnotherProtocol` 的形式。可以列举任意数量的协议，用和符号`&`连接，使用逗号`,`分隔。除了协议列表，协议组合也能包含类类型，这允许标明一个需要的父类。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nfunc wishHappyBirthday(to celebrator: Named & Aged) {\n    print(\"Happy birthday, \\(celebrator.name), you'er \\(celebrator.age)\")\n}\n\nlet birthdayPerson = Person(name: \"kevin\", age: 18)\nwishHappyBirthday(to: birthdayPerson)\n// Prints \"Happy birthday, kevin, you'er 18\"\n```\n\n### 可选协议要求（optional）\n\n可以给协议定义可选要求，这些要求不需要强制遵循协议的类型实现。\n\n可选要求使用 `optional` 修饰符作为前缀放在协议的定义中。\n\n可选要求允许 Object-C 操作，协议和可选要求必须使用 `@objc` 标志标记，注意 `@objc` 协议只能被继承自 Object-C 类或其他 `@objc` 类采纳，他们不能被结构体或者枚举采纳。\n\n## 协议和扩展\n\n### 在扩展里添加协议遵循\n\n可以通过扩展为一个已经存在的类型**采纳**和**遵循**一个新的协议，即使无法访问现有类型的源代码也能实现。\n\n扩展可以添加新的属性、方法和小标到已经存在的类型，并且因此允许添加协议需要的任何**要求**。\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name zhangsan age 35\"\n```\n\n### 有条件的遵循协议\n\n泛型类型可能**只在某些情况下**满足一个协议的要求，比如当类型的泛型形式参数也遵循对应协议时。\n\n可以通过在扩展类型时列出限制让泛型类型**有条件地遵循某协议**，即在采纳协议的名字后面写泛型 `where` 分句。\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Array: TextRepresentable where Element: TextRepresentable {\n    var desc: String {\n        let itemDesc = self.map{ $0.desc }\n        return itemDesc.joined(separator: \",\")\n    }\n}\n\nlet array = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(array.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n如果参数没有遵循 协议：\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Array: TextRepresentable {\n    var desc: String {\n        var temp = \"\"\n        for element in self {\n            if let p = element as? Person {\n                if temp.count > 0 {\n                    temp += \",\"\n                }\n                temp += \"name \\(p.name) age \\(p.age)\"\n            }\n        }\n        return temp\n    }\n}\n\nlet array = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(array.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n通过对比可见，有效的遵循协议可以更好的简化代码和逻辑。\n\n### 使用扩展声明采纳协议\n\n如果一个类型已经**遵循**了协议的所有**要求**，但是还没有声明该属性**采纳**了这个协议，则可以通过一个空的扩展来让该类型**采纳**这个协议。👇\n\n```swift\n// Hamster 已经遵循了 TextRepresentable 协议的需求，但是还没有声明“采纳了 TextRepresentable 协议”\nstruct Hamster {\n    var name: String\n    var desc: String {\n        return \"A hamster named \\(name)\"\n    }\n}\n\n// 通过一个空的扩展让 Hamster 采纳 TextRepresentable 协议\nextension Hamster: TextRepresentable {}\n```\n\n### 协议扩展\n\n协议可以通过扩展来提供方法和属性的实现，来实现**遵循协议类型**，这就允许在协议自身定义行为，而不是在每一个遵循的类里或者全局函数里定义行为。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.moreThan35())\n// Print \"true\"\n```\n\n### 给协议提供默认实现\n\n可以使用协议扩展来给协议的任一方法或者计算属性要求提供默认实现：\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension TextRepresentable {\n    var desc: String {\n        return \"name and age\"\n    }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n//    var desc: String {\n//        return \"name \\(name) age \\(age)\"\n//    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name and age\"\n```\n\n如果**遵循类型**（`Person`）给这个协议（`TextRepresentable`）的**要求**（`var desc(): String { get }`）提供了自己的实现，那么该实现会替代扩展中提供的默认实现：\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension TextRepresentable {\n    var desc: String {\n        return \"name and age\"\n    }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name zhangsan age 35\"\n```\n\n### 给协议扩展添加限制\n\n通过扩展可以为类型添加方法和属性，也可以在添加这些方法和属性时设定限制。在扩展协议名字后边使用 `where` 分句来写这些限制。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Collection where Iterator.Element: TextRepresentable {\n    var desc: String {\n        let itemDesc = self.map{ $0.desc }\n        return itemDesc.joined(separator: \",\")\n    }\n}\n\nlet collection = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(collection.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n如果 Collection 中包含没有采纳 `TextRepresentable` 协议的对象，则不能使用扩展里提供的 `desc()` 方法：\n\n![18](面向对象编程/18.png)\n\n## 面向协议编程\n\n### OOP（面向对象编程）\n\nOOP（Object Oriented Programming）即面向对象程序设计，是以建立模型体现出来的抽象思维过程和面向对象的方法。\n\n几乎所有的编程语言都支持OOP，Java、Ruby等语言的设计理念中几乎将一切事物都看做对象，对象即中心、对象即真理。\n\n> 面向对象三要素：\n>\n> 1. 封装\n> 将事物抽象为类，把对外接口暴露，将实现和内部数据隐藏。\n> 2. 继承\n> 可以使用现有类的所有功能，并在无序重新编写原来的类的情况下对这些功能进行扩展。\n> <1> 通过继承创建的类称为“子类”或“派生类”。\n> <2> 被继承的类称为“基类”、“父类”或“超类”。\n> <3> 继承的过程，被称为从一般到特殊的过程。\n> <4> 一个子类只能有一个基类，可以通过**多级继承**来实现多重继承。（在某些 OOP 语言中，一个子类可以继承多个基类。）\n> 3. 多态\n> 允许将子类类型的指针赋值给父类类型的指针。\n\nOOP 的缺陷：\n\n1. 继承机制要求在开始之前就能设计好整个程序的框架、结构、事物间的连接关系。这要求开发者必须有很好的分类设计能力，将不同的属性和方法分配到合适的层次里面去。设计清晰明了的继承体系总是很难的。（**C++标准库不是面向对象的**）\n\n2. 结构天生对改动有抵抗特性。这也是为什么 OOP 领域中所有程序员都对重构讳莫如深，有些框架到最后代码量几句膨胀变得难以维护从而失控。（**修改行为比修改结构体简单**）\n\n3. 继承机制带来的另一个问题是：很多语言都不提供多继承，我们不得不在父类塞入更多的内容，子类中会存在无用的父类属性和方法，而这些冗余代码给子类带来的一定的风险，而且对于层级很深的代码结构体来说 Bug 修复将会成为难题。（**组合优于继承**）\n\n4. **对象**（Class，引用类型）的状态不是编码的好友，相反是编码的敌人。对象固有的状态在分享和传递过程中很难追踪调试，尤其在并行程序编码中问题就更加明显，很难查找对象在哪一个并行线程发生了改变。OOP 所带来的可变、不确定、复杂等特征完全与并行编程中倡导的小型化、核心化、高效化完全背离。在并行编程中，值类型的优势更加明显，一个值在传递后，不会因为传递出去的值的变化而变化，即并行线程间修改的值都是独立的。（**值类型优于引用类型**）\n\n### POP（面向协议编程）\n\nProtocol oriented programming。\n\n协议为方法、属性等定义了蓝图，然后类、结构体或枚举可以采用该协议。\n\n在 Objective-C 中数组的实现遵循的是 OOP 编程范式。可变数组 `NSMutableArray` 继承自 `NSArray`，`NSArray` 继承自 `NSObject`。同时`NSArray` 采纳了 `NSCopying`、`NSFastEnumeration`、`NSMutableCopying`、`NSSecureCoding` 等协议。\n\n![19](面向对象编程/19.png)\n\n在 Swift 中数组的实现遵循的是 POP 编程范式。`Array` 没有继承自任何类，而是遵循了一系列的协议，不同的协议定义了不同功能的蓝图。\n\n![20](面向对象编程/20.png)\n\n### OOP vs POP\n\n**OOP 关心对象是什么，POP 关心对象做什么。**\n\n#### OOP 关心对象是什么\n\n采用 OOP 实现不同种类的运动员：\n\n首页不同种类的运动员统称为运动员，运动员都是人，所以有以下方案\n\n1、定义人类，一个有名字、年龄和说话等基本能力的人类：\n\n```swift\nclass Human {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    \n    func sayHi() {\n        print(\"say Hi\")\n    }\n}\n```\n\n2、定义运动员，一个人类运动员（继承自“人类”），他可以自定义自我介绍的内容：\n\n```swift\nclass Athlete: Human {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n3、定义田径运动员、游泳运动员，他们统称为运动员（继承自“运动员”），并可以定义属于自己的特有的能力：\n\n```swift\nclass Runner: Athlete {\n    func run() {\n        print(\"run\")\n    }\n}\n\nclass Swimmer: Athlete {\n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n🤔**思考**：如果既是田径运动员，又是游泳运动员？\n\n```swift\nclass RunnerAndSwimmer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n直接定义一个“田径游泳”运动员，这个命名真的很 OC。\n\n如果还是篮球运动员A，则可以写成 “RunnerAndSwimmerAndBasketballPlayer”，而且还可以一直 and 下去，“RunnerAndSwimmerAndBasketballPlayerAnd...”。\n\n即：“田径” + “游泳” + “篮球”\n\n```swift\nclass RunnerAndSwimmerAndBasketballPlayer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func swim() {\n        print(\"swim\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n如果这时有一个运动员B，相对于第一个除了不是“田径”运动员外其他的都是，则需要定义一个类，类名可以写成 “SwimmerAndBasketballPlayer”。\n\n即：“游泳” + “篮球”\n\n```swift\nclass SwimmerAndBasketballPlayer: Athlete {\n    func swim() {\n        print(\"swim\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n运动员C：“田径” + “篮球”\n\n```swift\nclass RunnerAndBasketballPlayer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n4、定义裁判，裁判肯定是一个人类\n\n```swift\nclass Referee: Human {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n🤔**思考**：如果既是运动员，又是裁判？\n\n```swift\nclass Referee: Athlete {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n让裁判继承自运动员，来表明这个裁判也是属于运动员这一类里的。显示生活中虽然裁判有可能是从运动员发展来的，但是这里显然裁判和运动员是两个职业，并没有从属关系。\n\n#### POP 关心对象做什么\n\n1、定义人类应该具备的基本属性，田径运动员的基本属性，游泳运动员的基本属性：\n\n```swift\nprotocol Human {\n    var name: String { get set }\n    var age: Int { get set }\n    func sayHi()\n}\n\nprotocol Runnalbe {\n    func run()\n}\n\nprotocol Swimming {\n    func swim()\n}\n```\n\n2、田径运动员：“人类” + “田径”\n\n```swift\nstruct Runner: Human, Runnalbe {\n    var name = \"zhangsan\"\n    var age = 35\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func run() {\n        print(\"run\")\n    }\n}\n```\n\n3、游泳运动员：“人类” + “游泳”\n\n```swift\nstruct Swimmer: Human, Swimming {\n    var name = \"lisi\"\n    var age = 18\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n4、运动健将：“人类” + “田径” + “游泳”\n\n```swift\nstruct AllAroundAthlete: Human, Runnalbe, Swimming {\n    var name: String = \"wangwu\"\n    var age: Int = 25\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func run() {\n        print(\"run\")\n    }\n    \n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n### POP\n\nObjective-C 的UIKit框架部分继承结构图👇：\n\n![21](面向对象编程/21.png)\n\n#### 《怪物城堡 Monster Castle》\n\n开发一款塔防游戏《怪物城堡 Monster Castle》。\n\n使用 OOP 开发，游戏中的角色：\n\n1. 主要分为两类角色 `Castle` 和 `Monster`；\n2. `Castle` 包括电脑玩家 `AI Player` 和真实玩家 `Human Player`；\n3. `Monster` 包括三种怪物 `Munch Monster`、`Quirk Monster` 和 `Zap Monster`。\n\n![22](面向对象编程/22.png)\n\n游戏中的能力：\n\n1. `Castle` 和 `Zap Monster` 有射击的能力。\n\n![23](面向对象编程/23.png)\n\n通过封装一个 Shooting Helper 类来实现射击的能力，则 Castle 和 Zap Monster 通过 Shooting Helper 来进行射击。\n\n虽然一个专门负责射击的类可以实现需求，但是无法从 Castle 和 Zap Monster 的**定义**里面看出他们是拥有射击的能力的，只有去**内部实现**里查找 Shooting Helper 的存在，才能知道这两个角色是有射击能力的，而另外两个 Munch Monster 和 Quirk Monster 是没有设计能力的。\n\n---\n\n如果使用 POP 开发，则不再关心角色的分类，所有的角色都是 `GameObject` 的子类，它们的不同点在于他们拥有的能力不同。\n\n游戏中的角色：`AI Player`（电脑玩家）、`Human Player`（真实玩家）、`Munch Monster`（蒙奇怪物）、`Quirk Monster`（魁克怪物）、`Zap Monster`（扎普怪物）。\n游戏中的能力：`Gun Trait`（强制特性）、`Render Trait`（渲染特性）、`Movement Trait`（运动特性）、`Health Trait`（血条）、`AI Trait`\n\n![24](面向对象编程/24.png)\n\n则代码中角色的形成，完全由他所拥有的能力提现出来：\n\n```swift\nclass AIPlayer: GameObject, AITrait, GunTrait, RenderTrait, HealthTrait {\n\n}\n\nclass ZapMonster: GameObject, GunTrait, RenderTrait, HealthTrait, MovementTrait {\n\n}\n```\n\n---\n\n#### POP - 设计一个登录功能\n\n![25](面向对象编程/25.png)\n\n首先是使用 OOP 实现：\n\n```swift\nclass LoginViewController: UIViewController {\n    private func isUsernameValid(username: String) -> Bool {\n        return true\n    }\n    \n    private func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n    \n    @IBAction func loginButtonPressed() {\n        if isUsernameValid(username: usernameTextField.text!) &&\n           isPasswordValid(password: passwordTextField.text!) {\n           // proceed with login\n        } else {\n           // show alert\n        }\n    }\n}\n```\n\n对验证方法进一步封装：\n\n```swift\nclass UsernameValidator {\n    func isUsernameValid(username: String) -> Bool {\n        return true\n    }\n}\n\nclass PasswordValidator {\n    func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n}\n\nclass LoginViewController: UIViewController {\n    let usernameValidator = UsernameValidator()\n    let passwordValidator = PasswordValidator()\n    \n    @IBAction func loginButtonPressed() {\n        if usernameValidator.isUsernameValid(username: usernameTextField.text!) &&\n           passwordValidator.isPasswordValid(password: passwordTextField.text!) {\n           // proceed with login\n        } else {\n           // show alert\n        }\n    }\n}\n```\n\n使用 POP 实现：\n\n```swift\nprotocol ValidatesUsername {\n    func isUsernameValid(username: String) -> Bool\n}\n\nextension ValidatesUsername {\n    func isUsernameValid(username: String) -> Bool {\n        if /* username too short */ {\n            return false\n        } else if /* username has invalid characters */ {\n            return false\n        } else {\n            return true\n        }\n    }\n}\n\nprotocol ValidetesPassword {\n    func isPasswordValid(password: String) -> Bool\n}\n\nextension ValidetesPassword {\n    func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n}\n\nclass LoginViewController: UIViewController, ValidatesUsername, ValidetesPassword {\n    @IBAction func loginButtonPressed() {\n        if isUsernameValid(username: usernameTextField.text!) &&\n           isPasswordValid(password: passwordTextField.text!) {\n            // proceed with login\n        } else {\n            // show alert\n        }\n    }\n}\n```\n","source":"_posts/Swift/面向对象编程.md","raw":"---\ntitle: 面向对象编程\ndate: 2023-05-04 10:41:19\ntags: Swift\n---\n\n* [概述](#概述)\n* [枚举](#枚举)\n* [属性](#属性)\n* [方法](#方法)\n* [下标](#下标)\n* [初始化和反初始化](#初始化和反初始化)\n* [继承](#继承)\n* [多态](#多态)\n* [扩展](#扩展)\n* [协议](#协议)\n* [协议和扩展](#协议和扩展)\n* [面向协议编程](#面向协议编程)\n\n<!-- more -->\n\n## 概述\n\nSwift 的类、结构体、枚举中都可以定义属性、方法、下标、构造体和嵌套类型。在 Swift 中，枚举和结构体是值类型，类是引用类型。从整体的功能上看 Swift 的枚举、结构体、类三者具有完全平等的地位。\n\n### 面向对象的三大特性\n\n1. **封装（Encapsulation）**：隐藏类的实现细节，让使用者只能通过预定的方法来访问。\n2. **继承（inheritance）**：指子类从父类继承方法，使得子类具有父类相同的行为。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。\n3. **多态（polymorphism）**：指同一个方法在不同的对象上有不同的实现方式。\n\n### 基本单元\n\n1. 枚举（enum）\n2. 结构体（struct）\n3. 类（class）\n4. 协议（protocol）\n5. 扩展（extension）\n\n### 类和结构体相似点\n\n1. **属性**：定义属性用来存储值；\n2. **方法**：定义方法用于提供功能；\n3. **下标**：定义下标脚本用来允许使用下标语法访问值；\n4. **扩展**：可以被扩展提供默认所没有的功能；\n5. **协议**：遵循协议来针对特定类型提供标准功能。\n6. **初始化器**：定义初始化器用于初始化状态；\n\n### 类和结构体的不同点\n\n1. **继承**：允许一个类继承另一个类的特征；\n2. **类型转换**：允许在运行时检查和解释一个类实例的类型；\n3. **反初始化器**：允许一个类实例释放所有被分配的资源；\n4. **引用计数**：允许不止一个对类实例的引用。\n\n## 枚举\n\n### 枚举语法\n\n用 `enum` 关键字来定义一个枚举，然后将所有的定义内容放在大括号`{}`中。\n\n```swift\nenum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n\n多个成员值可以出现在同一行中，用逗号隔开：\n\n```swift\nenum CompassPoint {\n    case north, south, east, west\n}\n```\n\n每个枚举都定义了一个全新的类型。枚举的名字需要首字母大写（例如：`CompassPoint`）。要给枚举类型起一个单数的名字，从而使得枚举能够通俗易懂、顾名思义。\n\n### 使用 Switch 语句来匹配枚举值\n\n使用 `switch` 语句匹配每一个单独的枚举值：\n\n```swift\nenum CompassPoint {\n    case north, south, east, west\n}\n\nlet directionToHead = CompassPoint.south\nswitch directionToHead {\ncase .north:\n    print(\"north\")\ncase .south:\n    print(\"south\")\ncase .east:\n    print(\"east\")\ncase .west:\n    print(\"weat\")\n}\n\n// Prints \"south\"\n```\n\n### 遍历枚举的 case\n\n1. `CaseIterable`：通过在枚举名字后面写 `CaseIterable`，来允许枚举被遍历。\n2. `allCases`：Swift 的枚举暴露了一个集合 `allCases`，同字面义，该集合包含对应枚举类型的所有情况。\n\n```swift\nenum CompassPoint: CaseIterable {\n    case north\n    case south\n    case east\n    case west\n}\n\nfor direction in CompassPoint.allCases {\n    print(direction)\n}\n```\n\n打印结果：\n\n```js\nnorth\nsouth\neast\nwest\n```\n\n📢注意：这里的 `direction` 是 `CompassPoint` 类型，不是字符串。虽然打印结果看着像字符串，但是不是的。\n\n```swift\nfor direction in CompassPoint.allCases {\n    if direction is CompassPoint {\n        print(direction)\n    }\n}\n```\n\n打印结果：\n\n```js\nnorth\nsouth\neast\nwest\n```\n\n### 关联值\n\n可以定义枚举来存储任意类型的关联值，不同枚举成员关联值的类型可以不同。\n\n定义一个枚举，支持条形码和二维码：\n\n```swift\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n\nvar productBarCode = Barcode.upc(8, 85909, 51226, 3)\nprint(productBarCode)\n\nproductBarCode = .qrCode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nprint(productBarCode)\n```\n\n打印结果：\n\n```js\nupc(8, 85909, 51226, 3)\nqrCode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n```\n\n`upc` 有四个关联值，都是 `Int` 类型；`qrCode` 有一个关联值，`String` 类型。\n\n使用 `switch` **匹配值**：\n\n```swift\nswitch productBarCode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode)\")\n}\n\n// Prints \"QR code: ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n```\n\n### 原始值\n\n原始值：指枚举成员可以用相同类型的**默认值**预先填充。\n\n```swift\nenum ASCIIControlCharacter: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}\n```\n\n#### 预设原始值\n\n在操作存储整数或字符串原始值枚举的时候，因为Swift的枚举会自动分配值（在没有分配值时），所以不用显示的为每一个成员分配原始值。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n\nenum CompassPoint: String {\n    case north, south, east, west\n}\n```\n\n使用 `rawValue` 获取其值：\n\n```swift\nprint(Planet.earth.rawValue)\n// Prints \"3\"\n\nprint(CompassPoint.south.rawValue)\n// Prints \"south\"\n```\n\n`.earth` 的原始值被自动分配成了 3，`.south` 的原始值被自动分配成了字符串“south”。\n\n这里的 `CompassPoint.south.rawValue` 是字符串类型。\n\n#### 从原始值初始化\n\n枚举提供了一个默认初始化器，该初始化器可以接收一个形式参数 rawValue，返回一个枚举成员或者 nil。\n\n使用初始化器创建一个枚举实例：\n\n```swift\nlet possiblePlanet = Planet(rawValue: 7)\nprint(possiblePlanet!)\n// Prints \"uranus\"\n```\n\n或者：\n\n```swift\nlet positionToFind = 11\nif let somePlanet = Planet(rawValue: positionToFind) {\n    switch somePlanet {\n    case .earth:\n        print(\"earth\")\n    default:\n        print(\"Not a safe place for humans\")\n    }\n} else {\n    print(\"There isn't a planet at position \\(positionToFind)\")\n}\n// Prints \"There isn't a planet at position 11\"\n```\n\n### 递归枚举（indirect）\n\n递归枚举：枚举成员的**关联值是枚举**。\n\n因为编译器在操作递归枚举时必须插入间接寻址层，所以在声明枚举时需要使用 `indirect` 关键字来明确该枚举是递归枚举。\n\n实现 `(1 + 2) * 3`，先算加法，再算乘法：\n\n```swift\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n\n// 执行函数\nfunc evaluate(_ expression: ArithmeticExpression) -> Int {\n    switch expression {\n    case let .number(value):\n        return value\n    case let .addition(left, right):\n        return evaluate(left) + evaluate(right)\n    case let .multiplication(left, right):\n        return evaluate(left) * evaluate(right)\n    }\n}\n\n// (1 + 2) * 3\nlet one = ArithmeticExpression.number(1)\nlet two = ArithmeticExpression.number(2)\nlet sum = ArithmeticExpression.addition(one, two)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(3))\n\nprint(evaluate(product))\n// Prints \"9\"\n```\n\n因为 `switch` 实现了所有 case，所以不用 `default` 字段。\n\n## 属性\n\n### 存储属性\n\n存储属性是特定类和结构体实例一部分，可以是变量存储属性（var），也可以是常量存储属性（let）。\n\n```swift\nclass DataManager {\n    var fileName = \"data.text\"\n    let filePath: String\n    init(name: String, path: String) {\n        fileName = name\n        filePath = path\n    }\n}\n```\n\n#### 常量结构体实例的存储属性\n\n如果创建了一个结构体的实例，并且把实例赋给常量，则不能修改该实例的属性，即使是声明为变量的属性。即**常量结构体实例，不允许修改其属性**。\n\n![01.png](面向对象编程/01.png)\n\n#### 延迟存储属性\n\n在声明属性时，通过在声明前面标注 `lazy` 修改语来表示一个延迟存储属性，即**被 `lazy` 修饰符标记的属性**。延迟存储属性的初始值会延迟到在其第一次使用时才进行计算。\n\n延迟存储属性的线程安全问题：在延迟存储属性还没有被初始化时，同时被多个线程访问，则**无法保证属性值只初始化一次**。\n\n```swift\nclass DataImporter {\n    var fileName = \"data.text\"\n    init() {\n        print(\"DataImporter inits\")\n    }\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n}\n\nlet manager = DataManager()\nmanager.data.append(\"some data\")\nmanager.data.append(\"some more data\")\nprint(\"manager.data.append finish\")\nprint(manager.importer.fileName)\n```\n\n打印结果：\n\n```js\nmanager.data.append finish\nDataImporter inits\ndata.text\n```\n\n“DataImporter inits” 是在执行完 `manager.data.append()`，直到调用 `print(manager.importer.fileName)` 之前才打印的。\n\n### 计算属性\n\n类、结构体和枚举也能够定义计算属性，与存储属性不同，**计算属性不存储值**。计算属性通过提供一个读取器和一个设置器，间接实现读取和修改其它的属性和值。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set(newCenter) {\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 简写 setter\n\n计算属性的设置器有一个默认的名字 newValue，可以不用为设置器传入的值定义名字。\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            return Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 简写 getter\n\n如果整个读取器 getter 的函数体是一个单一的表达式，则 getter 会隐式返回这个表达式。可以省略 return：\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 只读计算属性\n\n只读计算属性：计算属性只有读取器，没有设置器。只读属性可以返回一个值，但是不能修改。可以通过点语法访问只读计算属性。\n\n因为计算属性的值是不固定的，所以必须用 `var` 关键字定义计算属性为变量属性，包括只读计算属性。\n\n`let` 关键字只用于常量属性，明确属性在初始化后就不能更改。\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n        }\n    }\n}\n```\n\n或者简写成：\n\n```swift\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        return Point(x: origin.x + (size.width / 2), y: origin.y + (size.height / 2))\n    }\n}\n```\n\n### 属性观察者\n\n`willSet` 会在一个新值**被存储之前被调用**。新的属性值会以常量形式参数传递，默认名字为 newValue，也可以自定义名字。\n`didSet` 会在一个新值**被存储后被调用**。旧的属性值会以常量形式参数传递，默认名字为 oldValue，也可以自定义名字。如果在属性的 `didSet` 里给该属性赋值，则会覆盖 `willSet` 里设置的值。\n\n```swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"About to set totalSteps to \\(newTotalSteps)\")\n        }\n        didSet {\n            if totalSteps > oldValue {\n                print(\"Added \\(totalSteps - oldValue) steps\")\n            }\n        }\n    }\n}\n\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\nstepCounter.totalSteps = 300\n```\n\n打印结果：\n\n```js\nAbout to set totalSteps to 200\nAdded 200 steps\nAbout to set totalSteps to 300\nAdded 100 steps\n```\n\n#### 全局和局部变量\n\n观察属性的能力同样对全局变量和局部变量有效。全局变量是定义在任何函数、方法、闭包或者类型环境之外的变量。局部变量是定义在函数、方法或者闭包环境之中的变量。\n\n```swift\nvar count: Int = 0 {\n    willSet {\n        print(\"About to set count to \\(newValue)\")\n    }\n    didSet {\n        if count > oldValue {\n            print(\"Added \\(count - oldValue)\")\n        }\n    }\n}\n\ncount = 10\nprint(count)\n```\n\n打印结果：\n\n```js\nAbout to set count to 10\nAdded 10\n10\n```\n\n### 类型属性（static）\n\n使用 `static` 关键字定义类型属性。**类类型**的计算属性，可以使用 `class` 关键字来允许子类重写父类对类型属性的实现。\n\n```swift\nclass SomeClass {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 27\n    }\n    class var overrideableComputedTypeProperty: Int {\n        return 107\n    }\n}\n```\n\n## 方法\n\n### 实例方法\n\n实例方法是属于特定类实例、结构体实例或者枚举实例的函数。实例方法为实例提供功能性，可以提供访问和修改属性的方法，也可以提供与实例目的相关的功能。\n\n定义一个**类**，在实例方法中修改**类的属性**：\n\n```swift\nclass Counter {\n    var count = 0\n    func increment() {\n        count += 1\n    }\n    func increment(by amount: Int) {\n        count += amount\n    }\n    func reset() {\n        count = 0\n    }\n}\n```\n\n#### 隐含属性-self\n\n每一个类的实例都隐含一个 `self` 属性，它代表实力本身，可以使用它来调用实例方法。\n\n如果没有显示的写出 `self`，则在方法中调用属性或方法时，Swift 会假定调用的是当前实例中的属性或方法。\n\n📢注意：当实例方法的形式参数名与某个实例属性名相同时，形式参数名具有优先权，可以使用 `self` 调用属性来区分形式参数名和属性名。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    func isToTheRightOf(x: Double) -> Bool {\n        return self.x > x\n    }\n}\n\nlet somePoint = Point(x: 2.0, y: 2.0)\nif somePoint.isToTheRightOf(x: 1.0) {\n    print(\"This point is to the right of the line where x == 1.0\")\n}\n\n// Prints \"This point is to the right of the line where x == 1.0\"\n```\n\n#### 在实例方法中修改属性-mutating（异变方法）\n\n结构体和枚举是值类型，默认情况下，**值类型属性不能被自身的实例方法修改**。可以在 `func` 关键字前放一个 `mutating` 关键字来指定方法可以修改属性。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\n\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n#### 在 mutating 方法中赋值给 self\n\n结构体的异变方法可以指定整个实例给隐含的 `self` 属性。\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n#### 枚举的 mutating 方法\n\n枚举的异变方法可以设置隐含的 `self` 属性为相同枚举里的不同成员。\n\n```swift\nenum TriStateSwitch {\n    case off, low, high\n    mutating func next() {\n        switch self {\n        case .off:\n            self = .low\n        case .low:\n            self = .high\n        case .high:\n            self = .off\n        }\n    }\n}\n\nvar ovenLight = TriStateSwitch.off\novenLight.next()\nprint(ovenLight)\n// Prints \"low\"\n```\n\n### 类型方法（static）\n\n通过在 `func` 关键字前面使用 `static` 关键字来明确一个类型方法。类同样可以使用 `class` 关键字来允许子类重写父类对类型方法的实现。\n\n```swift\nclass SomeClass {\n    class func someTypeMethod() {\n        print(\"someTypeMethod\")\n    }\n}\nSomeClass.someTypeMethod()\n// Prints \"someTypeMethod\"\n```\n\n## 下标\n\n类、结构体和枚举可以定义下标，它可以作为访问集合、列表或序列成员元素的快捷方式。\n\n下标的作用：\n\n1. 可以通过索引值来设置或检索值，而不用分别为设置或检索提供实例方法。\n\n2. 可以为一个类型定义多个下标，下标会根据传入的索引值的类型，选择合适的下标重载使用。\n\n3. 可以使用多个输入形参来定义下标，以满足自定义类型的需求。\n\n### 下标语法（subscript）\n\n使用关键字 `subscript` 定义下标。与实例方法相同，可以指定一个或多个输入形式参数和返回类型。与实例方法不同的是，下标可以是读写的，也可以是只读的。\n\n下标脚本（`subscript`）允许通过在实例名后面的**方括号内写一个或多个值**，对该类的实例进行查询。\n\n```swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\n\nlet threeTimesTable = TimesTable(multiplier: 3)\nprint(\"six times three is \\(threeTimesTable[6])\")\n// Prints \"six times three is 18\"\n```\n\n### 下标参数\n\n1. 下标可以接收任意数量的输入形式参数，并且这些输入形式参数可以是任意类型；\n2. 下标可以返回任何类型；\n3. 下标可以使用变量形式参数（`var`）和可变实行参数（`...`），但是不能使用输入输出形式参数（`inout`），也不能提供默认形式参数。\n\n### 实例下标\n\n```swift\n// 矩阵\nstruct Matrix {\n    // 行，列\n    let rows: Int, columns: Int\n    // 坐标\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(repeating: 0.0, count: rows * columns)\n    }\n    func indexIsValid(row: Int, column: Int) -> Bool {\n        return row >= 0 && row <= rows && columns >= 0 && columns <= columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nmatrix[0, 1] = 1.5\nmatrix[1, 0] = 3.2\nprint(matrix.grid)\n// Prints \"[0.0, 1.5, 3.2, 0.0]\"\n```\n\n![02.png](面向对象编程/02.png)\n\n### 类型下标（static）\n\n除了定义实例下标外，也可以定义类型本身的下标。在 `subscript` 关键字前加 `static` 关键字来标记类型下标。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n    static subscript(n: Int) -> Planet {\n        return Planet(rawValue: n)!\n    }\n}\nlet mars = Planet[3]\nprint(mars)\n// Prints \"earth\"\n```\n\n同样的，使用 `class` 关键字，可以允许子类重写父类的下标实现。\n\n```swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n    static subscript(n: Int) -> Planet {\n        return Planet(rawValue: n)!\n    }\n}\n\nclass PlanetClass {\n    class subscript(n: Int) -> Planet {\n        return Planet[n]\n    }\n}\n\nclass SubPlanetClass {\n    class subscript(n: Int) -> Planet {\n        return Planet[n + 1]\n    }\n}\n\nprint(PlanetClass[3])\n// Prints \"earth\"\nprint(SubPlanetClass[3])\n// Prints \"mars\"\n```\n\n## 初始化和反初始化\n\n### 初始化器\n\n初始化器在创建特定类型的实例时被调用。\n\n如下所示：在初始化器里给存储属性设置初始值：\n\n```swift\n// 温度计\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature) Fahrenheit\")\n// Prints \"The default temperature is 32.0 Fahrenheit\"\n```\n\n### 默认的属性值\n\n存储属性的初始值，可以在初始化器设置，也可以**在属性定义的时候设置**。\n\n如下所示，在存储属性定义的时候设置初始值：\n\n```swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature) Fahrenheit\")\n// Prints \"The default temperature is 32.0 Fahrenheit\"\n```\n\n### 默认的初始化器\n\n当结构体或类没有提供初始化器时，Swfit 会提供一个默认的初始化器。\n\n没有提供初始化器的**类**，必须设置默认属性值：\n\n```swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity = 1\n    var purchased = false\n}\n\nvar item = ShoppingListItem()\n```\n\n提供了初始化器的结构体或类，可以不设置默认属性值：\n\n```swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity: Int\n    var purchased: Bool\n    init() {\n        quantity = 1\n        purchased = false\n    }\n}\n\nvar item = ShoppingListItem()\n```\n\n### 自定义初始化\n\n可以通过为初始化器添加形式参数的方式，实现自定义类型和值的名称。初始化形式参数与函数的形式参数具有相同的功能和语法。\n\n```swift\n// 摄氏度\nstruct Celsius {\n    var temperatureInCelsius: Double\n    // 华氏温度计的(冰点为32度，沸点为212度)\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    // 开(开尔文温标的计量单位，1开氏度相当于1摄氏度)\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n}\n// 水的沸点\nlet boilingPointOfWater = Celsius(fromFahrenheit: 212.0)\n// 水的冰点\nlet freezingPointOfWater = Celsius(fromKelvin: 273.15)\n\nprint(boilingPointOfWater.temperatureInCelsius)\n// Prints \"100.0\"\nprint(freezingPointOfWater.temperatureInCelsius)\n// Prints \"0.0\"\n```\n\n### 在初始化中分配常量属性\n\n常量属性：赋值后不能修改。\n\n在初始化结束前，要保证常量属性被设置了确定的值，可以在初始化的任意时刻设置。\n\n```swift\nclass SurveyQuestion {\n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\n\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")\nbeetsQuestion.ask()\n// Prints \"How about beets?\"\nbeetsQuestion.response = \"I like beets.\"\n```\n\n### 结构体的成员初始化器\n\n如果结构体类型中没有定义自定义初始化器，系统会提供一个默认的成员初始化器。没有提供初始化器的**类**，必须设置默认属性值。但是**结构体的**成员初始化器允许存储属性没有默认值。\n\n```swift\nstruct Size {\n    var width: Float, height = 0.0\n}\nlet twoByTwo = Size(width: 1.0, height: 1.0)\nprint(twoByTwo)\n// Prints \"Size(width: 1.0, height: 1.0)\"\n```\n\n### 值类型的初始化器委托\n\n初始化器委托：初始化器可以调用其他初始化器来执行部分实例的初始化。避免了多个初始化器里冗余代码。\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\n\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {\n        self.init(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\n    }\n    // 值类型的简单初始化器\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet rect1 = Rect()\nlet rect2 = Rect(center: Point(x: 1.0, y: 1.0), size: Size(width: 2.0, height: 2.0))\nlet rect3 = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\nprint(\"rect1: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect1: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\nprint(\"rect2: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect2: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\nprint(\"rect3: \\(rect1.origin), \\(rect1.size)\")\n// Prints \"rect3: Point(x: 0.0, y: 0.0), Size(width: 2.0, height: 2.0)\"\n```\n\n### 类的继承和初始化\n\n### 指定初始化器和便捷初始化器（convenience）\n\n用与**值类型的简单初始化器**相同的方式类写类的**指定初始化器**：\n\n```swift\ninit(origin: Point, size: Size) {\n    self.origin = origin\n    self.size = size\n}\n```\n\n将 `convenience` 修饰符放到 `init` 关键字前定义**便捷初始化器**：\n\n```swift\nconvenience init() {\n    self.init(origin: Point(x: 0.0, y: 0.0), size: Size(width: 2.0, height: 2.0))\n}\n```\n\n![03.png](面向对象编程/03.png)\n\n### 类的初始化委托\n\n1. 指定初始化**必须**从它的直系父类调用指定初始化器（子类必须要调用父类）。\n2. 便捷初始化器**必须**从相同的类里调用另一个初始化器（便捷初始化器或指定初始化器）。\n3. 便捷初始化器**最终**必须调用一个指定初始化器。\n\n![04.png](面向对象编程/04.png)\n\n### 两段式初始化\n\nSwift 的类初始化是一个两段式过程：\n\n* 第一阶段：**每一个**存储属性被引入类并分配一个初始值。\n* 第二阶段：每个类都可以在新的实例准备使用之前定制它的存储属性。\n\n#### 两段式初始化-阶段一\n\n1. 指定初始化器或便捷初始化器在类中被**调用**；\n2. 为这个类的新实例**分配内存**，内存还没有被初始化；\n3. 这个类的指定初始化器确保所有由该类引入的存储属性都有一个值。现在这些**存储属性的内存被初始化了**；\n4. 指定初始化器上交**父类的初始化器**为其存储属性执行相同任务；\n5. 这个调用父类初始化器的过程将沿着**初始化链**一直向上进行，直到到达初始化器链的最顶部；\n6. 一旦达到初始化器的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为**完全初始化**了，此时第一阶段完成。\n\n![09.png](面向对象编程/09.png)\n\n#### 两段式初始化-阶段二\n\n从顶部初始化器往下，初始化链中的每一个**指定初始化器**都有机会进一步定制实例。在第二阶段，初始化器能够访问 `self`，并且可以修改它的属性、调用它的实例方法等等。\n\n最终，初始化链中任何**便捷初始化器**都有机会定制实例以及使用 `self`。\n\n![10.png](面向对象编程/10.png)\n\n### 安全检查\n\n1、指定初始化器必须保证在向上委托给父类初始化器之前，**其所在的类引入的所有属性**都要初始化完成。（子类必须先初始化自己的所有属性，再调用父类的初始化器）\n\n![05.png](面向对象编程/05.png)\n\n2、指定初始化器必须先向上委托父类初始化器，然后才能为**继承的属性**设置新值，否则指定初始化器赋予的新值会被父类中的初始化器所覆盖。（**子类必须先调用父类的初始化器，再初始化父类的属性**）\n\n![06.png](面向对象编程/06.png)\n\n3、便捷初始化器必须先委托同类中的其它初始化器，然后再为**任意属性**赋值，否则便捷初始化器赋予的新值会被自己类中其它指定初始化器所覆盖。\n\n![07.png](面向对象编程/07.png)\n\n4、初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 `self` 作为值。\n\n![08.png](面向对象编程/08.png)\n\n正确的执行顺序：\n\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name;\n        self.age = age\n    }\n    convenience init() {\n        self.init(name: \"[unnamed]\", age: 0)\n    }\n}\n\nclass Teacher: Person {\n    var salary: Int\n    init(name: String, age: Int, salary: Int) {\n        // 1、初始化自定义属性\n        self.salary = salary\n        // 2、委托父类初始化器\n        super.init(name: name, age: age)\n        // 3、修改父类属性\n        self.name = name + \"老师\"\n        // 4、调用实例方法\n        self.showInfo()\n    }\n    convenience init(name: String) {\n        self.init(name: name, age: 30, salary: 5000)\n    }\n    \n    func showInfo() {\n        print(\"teacher name \\(name), age \\(age), salary \\(salary)\")\n    }\n}\n\nlet teacher = Teacher(name: \"kevin\")\n// Prints \"teacher name kevin老师, age 30, salary 5000\"\n```\n\n### 初始化器的继承和重写（override）\n\n与 Object-C 中的子类不同，Swfit 的子类不会默认继承父类的初始化器。Swift 的这种机制防止父类的简单初始化器被一个更专用的子类继承，并被用来创建一个没有完全初始化或错误初始化的新实例的情况。**只有在特定情况下才会继承父类的初始化器**。\n\n如果想自定义子类来实现一个或多个父类相同的初始化器，可以在子类中为初始化器提供定制的实现。如果提供的子类初始化器完全匹配父类指定初始化器，则可以重写父类的初始化器。**通过在子类初始化器定义的前面写 `override` 修饰符，实现对该方法的重写。**同默认初始化器一样，即使是自动提供的默认初始化器也可以重写。\n\n### 初始化器的自动继承\n\n规则1：如果子类没有定义任何指定初始化器，它会自动继承父类所有的**指定初始化器**。\n\n规则2：如果子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承父类所有的**便捷初始化器**。\n\n### 可失败初始化器（init?/init!）\n\n类、结构体或枚举的可失败初始化器引用场景：\n\n1. 初始化传入无效的形式参数值；\n2. 缺少某种外部所需的资源；\n3. 其他阻止初始化的情况。\n\n定义方式：\n\n1. 通过在 `init` 关键字后面添加问号（`init?`）的方式来定义一个可失败初始化器以创建一个合适类型的可选项实例。\n\n2. 通过在 `init` 关键字后面添加惊叹号（`init!`）的方式来定义一个可失败初始化器以创建一个**隐式展开**具有合适类型的可选项实例。\n\n### 必要初始化器（required）\n\n在类的初始化器前添加 `required` 修饰符来表明所有该类的子类都必须实现该初始化器。\n\n### 反初始化（deinit）\n\n在类的**实例被释放**的时候，反初始化器就会立即被调用。使用 `deinit` 关键字来写反初始化器，同写初始化器要用 `init` 关键字一样。反初始化器只在类类型中有效。\n\n反初始化器的调用时机：\n\n1. 反初始化器会在实例被释放之前自动被调用。\n2. 不能自行调用反初始化器。\n3. 父类的反初始化器可以被子类继承，并且子类的反初始化器实现结束之后父类的反初始化器会被调用。\n4. 父类的反初始化器总会被调用，就算子类没有反初始化器。\n\n每个类当中只能有一个反初始化器。反初始化器不接收任何形式参数，并且不需要写圆括号。\n\n```swift\ndeinit {\n    // perform the deinitialization\n}\n```\n\n## 继承\n\n### 定义基类\n\nSwift 类不会从一个通用基类继承，**任何不从另一个类继承的类都是所谓的基类**。如果没有指定特定父类的类都会以基类的形式创建。\n\n```swift\n/// 定义一个交通工具类\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // to do\n    }\n}\n```\n\n### 子类\n\n**子类是基于现有类创建新类的行为**。子类从现有的类继承了一些特征，可以重新定义继承来的特征，也可以为子类添加新的特征。为了表明子类有父类，要把子类写在父类的前面，用冒号分隔（`subClass : superClass`）。\n\n```swift\n/// 定义一个自行车类，继承自交通工具类\nclass Bicycle : Vehicle {\n    // 自定义新的属性，是否有车筐\n    var hasBasket = false\n}\n\nlet bicycle = Bicycle()\nbicycle.hasBasket = true\nbicycle.currentSpeed = 15.0\nprint(\"Bicycle: \\(bicycle.description)\")\n// Prints \"Bicycle: traveling at 15.0 miles per hour\"\n```\n\n### 重写（override）\n\n重写：子类可以提供自己的实例方法、类型方法、实例属性、类型属性或下标脚本的自定义实现，否则子类将会从父类继承。\n\n如果想要重写而不是继承一个特征，需要在重写定义前面加上 `override` 关键字，表明提供一个重写，而不是额外提供一个相同的定义。额外提供一个相同的定义可能导致意想不到的行为，并且任何没有使用 `override` 关键字的重写都会在编译时报错。\n\n### 访问父类的方法、属性和下标脚本\n\n可以通过使用 `super` 前缀访问父类的方法、属性或下标脚本。\n\n1. 一个命名为 `somoeMethod()` 的重写方法可以通过 `super.someMethod()` 在重写方法的实现中调用父类版本的 `someMethod()` 方法。\n2. 一个命名为 `someProperty` 的重写属性可以通过 `super.someProperty` 在重写的 getter 或 setter 实现中访问父类版本的 `someProperty` 属性。\n3. 一个命名为 `someIndex` 的重写下标脚本可以通过 `super[someIndex]` 在重写的下标脚本实现中访问父类版本中相同的下标脚本。\n\n### 重写方法\n\n在子类中重写一个继承的实例方法或类型方法来提供定制的或替代的方法实现。\n\n```swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // to do\n    }\n}\n\n/// 定义一个火车类，继承自交通工具类\nclass Train: Vehicle {\n    // 重写发声方法\n    override func makeNoise() {\n        print(\"火车鸣笛~\")\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// Prints \"火车鸣笛~\"\n```\n\n### 重写属性的 getter 和 setter\n\n可以提供一个自定义的 `getter` 或 `setter` 方法来重写任意继承的属性（存储属性或计算属性）。\n\n```swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprint(\"Car: \\(car.description)\")\n// Prints \"Car: traveling at 25.0 miles per hour in gear 3\"\n```\n\n### 重写属性的观察器\n\n可以使用属性重写来为继承的属性添加属性观察器（`willSet`、`didSet`）。\n\n注意：\n\n1. 因为常量存储属性（`let`）和只读的计算属性（`readonly`）不支持改变，所以不能提供 `willSet` 和 `didSet` 来监听值的改变（它们不会变）。\n2. 不能为同一个属性同时提供重写的 `setter` 和重写的属性观察器。自定义的 `setter` 就可以实现监听值的改变。\n\n```swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automaticCar = AutomaticCar()\nautomaticCar.currentSpeed = 35.0\nprint(\"AutomaticCar: \\(automaticCar.description)\")\n// Prints \"AutomaticCar: traveling at 35.0 miles per hour in gear 4\"\n```\n\n### 组织重写（final）\n\n通过在方法、属性或者下标甲苯的关键字前写 `final` 修饰符，来阻止其被重写（如：`final var`，`final func`，`final class func`，`final subscript`）。\n\n## 多态\n\n多态是面向对象三大特性之一，指同一个方法在不同的对象上有不同的实现方式。\n\n### 类型\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n// Prints \"Array<MediaItem>\"\n\nlet library1 = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\")\n]\nprint(type(of: library1))\n// Prints \"Array<Movie>\"\n\nlet library2 = [\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\")\n]\nprint(type(of: library2))\n// Prints \"Array<Song>\"\n```\n\n### 类型检查（is）\n\n使用类型检查操作符`is`来检查**一个实例是否属于一个特定的子类**，如果实例是该子类类型，类型检查操作符返回 true，否则返回 false。\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n\nfor item in library {\n    if item is Song {\n        print(item.name)\n    }\n}\n```\n\n打印结果：\n\n```js\nArray<MediaItem>\nBlue Suede Shoes\nThe One And Only\nNever Gonna Give You Up\n```\n\n### 向下类型转换（as?/as!）\n\n某个**类类型**的常量或变量可能实际上引用自一个子类的实例，可以使用类型转换操作符`as?`或`as!`将它向下类型转换至其子类类型。因为向下类型转换可能失败，所以类型转换操作符有两个不同的形式`as?`和`as!`。\n\n1. `as?`，条件形式，返回一个将要向下类型转换的值的可选项。\n2. `as!`，强制形式，将向下类型转换和**强制展开**结合为一个步骤。\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n\nprint(type(of: library))\n\nfor item in library {\n    if let song = item as? Song {\n        print(\"Song: \\(song.name)\")\n    }\n}\n```\n\n打印结果：\n\n```js\nArray<MediaItem>\nSong: Blue Suede Shoes\nSong: The One And Only\nSong: Never Gonna Give You Up\n```\n\n### 不确定类型 Any 和 AnyObject\n\nSwift 为不确定的类型提供了两种特殊的类型别名：\n\n1. `AnyObject`：表示**任何类类型**的实例。\n2. `Any`：表示**任何类型**，包括函数类型。\n\n### 嵌套类型\n\nSwift 中的类、结构体和枚举可以进行嵌套，即**在某一个类型的内部定义类型**，嵌套类型能够访问它外部的成员。\n\n这种类型嵌套在 Java 中称为内部类，在 C# 中称为嵌套类。\n\n嵌套类\n\n```swift\nclass Person {\n    var body = Body() \n    \n    class Body {\n        var height = 175\n        var weight = 80\n        func profile() -> String {\n            return \"Height: \\(self.height), Weight: \\(self.weight)\"\n        }\n    }\n}\n\nlet p = Person()\nprint(p.body.profile())\n// Prints \"Height: 175, Weight: 80\"\n```\n\n嵌套结构体\n\n```swift\nstruct Shapes {\n    struct Line {\n        var x = 0\n        var y = 0\n        var length = 0\n    }\n    \n    struct Rectangle {\n        var x = 0\n        var y = 0\n        var width = 0\n        var height = 0\n        var area = 0\n    }\n    \n    struct Circle {\n        let pi = 3.1415926\n        var radius = 0.0\n    }\n}\n\nvar c = Shapes.Circle()\nc.radius = 45.0\n```\n\n## 扩展\n\n扩展为现有的类、结构体、枚举类型或协议添加了新功能，包括为无访问权限的源代码扩展类型的能力（逆向建模）。\n\n扩展和 Object-C 中的 category 类似，与 Object-C 的分类不同的是 Swift 的扩展没有名字。\n\n```swift\nclass Person {\n\n}\n\n// 扩展：让 Person 实现 Hashable 协议\nextension Person : Hashable {\n\n}\n```\n\n### 扩展（extension）的能力\n\n1. 添加计算实例属性和计算类型属性；\n2. 定义实例方法和类型方法；\n3. 提供新初始化器；\n4. 定义下标；\n5. 定义和使用新内嵌类型；\n6. 使现有的类型遵循某些以。\n7. **扩展可以向一个类型添加新的方法，但是不能重写已有的方法。**\n\n#### 扩展的能力-计算属性\n\n* 扩展可以向已有的类型添加计算实例属性和计算类型属性。\n\n```swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprint(\"One inch is \\(oneInch) meters\")\nlet threeFeet = 3.ft\nprint(\"Three feet is \\(threeFeet) meters\")\n```\n\n打印结果：\n\n```swift\nOne inch is 0.0254 meters\nThree feet is 0.914399970739201 meters\n```\n\n#### 扩展的能力-初始化器\n\n* 扩展可以向已有的类型添加新的初始化器。\n\n通过扩展可以使初始化器接收自定义类型作为形式参数，也可以提供该类型原始实现中未包含的额外初始化选项。\n\n扩展能为类添加新的**便捷初始化器**，但是不能添指定初始化或反初始化器。**指定初始化器和反初始化器必须由原来类的实现提供**。\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\n\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))\nprint(centerRect.origin)\n// Prints \"Point(x: 2.5, y: 2.5)\"\n```\n\n#### 扩展的能力-方法\n\n扩展可以为已有的类型添加新的实例方法和类型方法。\n\n```swift\nextension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n\n2.repetitions {\n    print(\"Hello!\")\n}\n```\n\n打印结果：\n\n```js\nHello!\nHello!\n```\n\n#### 扩展的能力-mutating方法\n\n扩展的实例方法仍可以修改（异变）实例本身。\n\n结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 `mutating`，和原本实现的一遍方法一样。\n\n```swift\nextension Int {\n    mutating func sequare() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.sequare()\nprint(someInt)\n// Prints \"9\"\n```\n\n#### 扩展的能力-下标\n\n扩展能为已有的类型添加新的下标。\n\n```swift\nextension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\nprint(746381295[0])\n// Prints \"5\"\nprint(746381295[1])\n// Prints \"9\"\nprint(746381295[2])\n// Prints \"2\"\nprint(746381295[8])\n// Prints \"7\"\n```\n\n#### 扩展的能力-添加内嵌类型\n\n```swift\nextension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n\nprint(0.kind)\n// Prints \"zero\"\nprint(100.kind)\n// Prints \"positive\"\nprint((0-1).kind)\n// Prints \"negative\"\n```\n\n## 协议\n\n### 协议的语法\n\n自定义类型声明时，**将协议名放在类型名的冒号之后**来表示该类型采纳一个特定的协议，多个协议可以用逗号分开列出。若一个类拥有父类，将这个父类名放在其采纳的协议名**之前**，并用逗号分隔。\n\n![10](面向对象编程/11.png)\n\n### 属性要求\n\n协议可以要求所有遵循该协议的类型，提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性时存储型属性还是计算型属性，它只具体要求——**属性有特定的名称和类型**。\n\n协议同时要求——**一个属性必须明确是可读的或可读可写**：\n\n1. 若协议要求一个属性为可读可写的，那么该属性不能用常量储存属性或只读计算属性来满足。\n\n2. 若协议要求一个属性为可读的，那么任何种类的属性都能满足这个要求。\n\n读写计算属性和只读计算属性：\n\n```swift\nprotocol SomeProtocol {\n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n```\n\n制度计算属性：\n\n```swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed {\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n// Prints \"John Appleseed\"\n```\n\n只读计算属性\n\n```swift\nclass Starship: FullyNamed {\n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n        return (prefix != nil ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")\nprint(ncc1701.fullName)\n// Prints \"USS Enterprise\"\n```\n\n在协议中定义**类型属性**时在前面添加 `static` 关键字。当类的实现使用 `class` 或 `static` 关键字前缀声明类型属性要求时，这个规则仍然适用。\n\n```swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n\n### 方法要求\n\n协议可以要求采纳的类型**实现指定的实例方法和类方法**。\n\n1. 这些方法作为协议定义的一部分，书写方式与正常实例和类方法的方式完全相同，但是不需要大括号和方法的主题；\n2. 允许方法拥有参数，与正常的方法使用同样的规则；\n3. 方法参数不能定义默认值。\n\n在类实现时，类型方法要求使用 `class` 或 `static` 作为关键字前缀，协议中同样适用。\n\n```swift\nprotocol AnotherProtocol {\n    func someMethod(element: String)\n    static func anotherMethod(element: Int)\n}\n```\n\n### mutating 方法要求\n\n对于协议里定义的实例方法，如果想要异变采用了该协议的类型实例，就要在方法的定义当中使用 `mutating` 关键字。这允许结构体和枚举类型能采用相应协议并满足方法要求。\n\n```swift\nprotocol MoveProtocol {\n    mutating func moveBy(x deltaX: Int, y deltaY: Int)\n}\n\nstruct Point: MoveProtocol {\n    var x = 0, y = 0\n    mutating func moveBy(x deltaX: Int, y deltaY: Int) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n\nvar p = Point(x: 1, y: 1)\np.moveBy(x: 1, y: 1)\nprint(p)\n// Prints \"Point(x: 2, y: 2)\"\n```\n\n### 初始化器要求\n\n协议可以要求遵循协议的类型实现指定的初始化器。\n\n协议在定义初始化器时和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号（初始化的实体）。\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n```\n\n### 初始化器要求的类实现\n\n一、如果想让遵循协议的类满足协议的初始化器要求，在实现协议指定的初始化器或便捷初始化器时，必须使用 `required` 关键字修饰初始化器的实现。\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n如果遵循了协议，且实现了协议指定的初始化器，没有使用 `required` 关键字，则会报错：\n\n![12](面向对象编程/12.png)\n\n二、如果一个子类重写了父类指定的初始化器，并且遵循协议实现了初始化器要求，那么就要为这个初始化器的实现添加 `required` 和 `override` 两个修饰符。\n\n![15](面向对象编程/15.png)\n\n如果重写了方法，没有加 `override` 关键字，则会报错：\n\n![13](面向对象编程/13.png)\n\n如果遵循了协议实现了初始化器要求，没有加 `required` 关键字，则会报错：\n\n![14](面向对象编程/14.png)\n\n### 将协议作为类型\n\n1. 在函数、方法或者初始化器里作为形式参数类型或者返回类型；\n2. 作为常量、变量或者属性的类型；\n3. 作为数组、字典或者其他存储器的元素的类型。\n\n### 协议继承\n\n协议可以继承一个或者多个其他协议，并且可以在继承的基础之上添加更多要求。协议继承的语法与类继承的语法相似，只不过可以选择列出**多个继承的协议**，使用逗号分隔。\n\n![16](面向对象编程/16.png)\n\n### 类专用的协议（AnyObject）\n\n通过添加 `AnyObject` 关键字到协议的继承列表，可以**限制协议只能被类类型采纳**，并且不是结构体或者枚举。\n\n![17](面向对象编程/17.png)\n\n### 协议组合（&）\n\n可以使用协议组合来复合多个协议到一个要求里。协议组合不定义任何新的协议类型。\n\n协议组合使用 `SomeProtocol & AnotherProtocol` 的形式。可以列举任意数量的协议，用和符号`&`连接，使用逗号`,`分隔。除了协议列表，协议组合也能包含类类型，这允许标明一个需要的父类。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nfunc wishHappyBirthday(to celebrator: Named & Aged) {\n    print(\"Happy birthday, \\(celebrator.name), you'er \\(celebrator.age)\")\n}\n\nlet birthdayPerson = Person(name: \"kevin\", age: 18)\nwishHappyBirthday(to: birthdayPerson)\n// Prints \"Happy birthday, kevin, you'er 18\"\n```\n\n### 可选协议要求（optional）\n\n可以给协议定义可选要求，这些要求不需要强制遵循协议的类型实现。\n\n可选要求使用 `optional` 修饰符作为前缀放在协议的定义中。\n\n可选要求允许 Object-C 操作，协议和可选要求必须使用 `@objc` 标志标记，注意 `@objc` 协议只能被继承自 Object-C 类或其他 `@objc` 类采纳，他们不能被结构体或者枚举采纳。\n\n## 协议和扩展\n\n### 在扩展里添加协议遵循\n\n可以通过扩展为一个已经存在的类型**采纳**和**遵循**一个新的协议，即使无法访问现有类型的源代码也能实现。\n\n扩展可以添加新的属性、方法和小标到已经存在的类型，并且因此允许添加协议需要的任何**要求**。\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name zhangsan age 35\"\n```\n\n### 有条件的遵循协议\n\n泛型类型可能**只在某些情况下**满足一个协议的要求，比如当类型的泛型形式参数也遵循对应协议时。\n\n可以通过在扩展类型时列出限制让泛型类型**有条件地遵循某协议**，即在采纳协议的名字后面写泛型 `where` 分句。\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Array: TextRepresentable where Element: TextRepresentable {\n    var desc: String {\n        let itemDesc = self.map{ $0.desc }\n        return itemDesc.joined(separator: \",\")\n    }\n}\n\nlet array = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(array.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n如果参数没有遵循 协议：\n\n```swift\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension Array: TextRepresentable {\n    var desc: String {\n        var temp = \"\"\n        for element in self {\n            if let p = element as? Person {\n                if temp.count > 0 {\n                    temp += \",\"\n                }\n                temp += \"name \\(p.name) age \\(p.age)\"\n            }\n        }\n        return temp\n    }\n}\n\nlet array = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(array.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n通过对比可见，有效的遵循协议可以更好的简化代码和逻辑。\n\n### 使用扩展声明采纳协议\n\n如果一个类型已经**遵循**了协议的所有**要求**，但是还没有声明该属性**采纳**了这个协议，则可以通过一个空的扩展来让该类型**采纳**这个协议。👇\n\n```swift\n// Hamster 已经遵循了 TextRepresentable 协议的需求，但是还没有声明“采纳了 TextRepresentable 协议”\nstruct Hamster {\n    var name: String\n    var desc: String {\n        return \"A hamster named \\(name)\"\n    }\n}\n\n// 通过一个空的扩展让 Hamster 采纳 TextRepresentable 协议\nextension Hamster: TextRepresentable {}\n```\n\n### 协议扩展\n\n协议可以通过扩展来提供方法和属性的实现，来实现**遵循协议类型**，这就允许在协议自身定义行为，而不是在每一个遵循的类里或者全局函数里定义行为。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.moreThan35())\n// Print \"true\"\n```\n\n### 给协议提供默认实现\n\n可以使用协议扩展来给协议的任一方法或者计算属性要求提供默认实现：\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension TextRepresentable {\n    var desc: String {\n        return \"name and age\"\n    }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n//    var desc: String {\n//        return \"name \\(name) age \\(age)\"\n//    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name and age\"\n```\n\n如果**遵循类型**（`Person`）给这个协议（`TextRepresentable`）的**要求**（`var desc(): String { get }`）提供了自己的实现，那么该实现会替代扩展中提供的默认实现：\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nextension TextRepresentable {\n    var desc: String {\n        return \"name and age\"\n    }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Aged {\n    func moreThan35() -> Bool {\n        return age >= 35\n    }\n}\n\nlet p = Person(name: \"zhangsan\", age: 35)\nprint(p.desc)\n// Prints \"name zhangsan age 35\"\n```\n\n### 给协议扩展添加限制\n\n通过扩展可以为类型添加方法和属性，也可以在添加这些方法和属性时设定限制。在扩展协议名字后边使用 `where` 分句来写这些限制。\n\n```swift\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\nprotocol TextRepresentable {\n    var desc: String { get }\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nextension Person: TextRepresentable {\n    var desc: String {\n        return \"name \\(name) age \\(age)\"\n    }\n}\n\nextension Collection where Iterator.Element: TextRepresentable {\n    var desc: String {\n        let itemDesc = self.map{ $0.desc }\n        return itemDesc.joined(separator: \",\")\n    }\n}\n\nlet collection = [Person(name: \"zhangsan\", age: 20), Person(name: \"lis\", age: 30)];\nprint(collection.desc)\n// Prints \"name zhangsan age 20,name lis age 30\"\n```\n\n如果 Collection 中包含没有采纳 `TextRepresentable` 协议的对象，则不能使用扩展里提供的 `desc()` 方法：\n\n![18](面向对象编程/18.png)\n\n## 面向协议编程\n\n### OOP（面向对象编程）\n\nOOP（Object Oriented Programming）即面向对象程序设计，是以建立模型体现出来的抽象思维过程和面向对象的方法。\n\n几乎所有的编程语言都支持OOP，Java、Ruby等语言的设计理念中几乎将一切事物都看做对象，对象即中心、对象即真理。\n\n> 面向对象三要素：\n>\n> 1. 封装\n> 将事物抽象为类，把对外接口暴露，将实现和内部数据隐藏。\n> 2. 继承\n> 可以使用现有类的所有功能，并在无序重新编写原来的类的情况下对这些功能进行扩展。\n> <1> 通过继承创建的类称为“子类”或“派生类”。\n> <2> 被继承的类称为“基类”、“父类”或“超类”。\n> <3> 继承的过程，被称为从一般到特殊的过程。\n> <4> 一个子类只能有一个基类，可以通过**多级继承**来实现多重继承。（在某些 OOP 语言中，一个子类可以继承多个基类。）\n> 3. 多态\n> 允许将子类类型的指针赋值给父类类型的指针。\n\nOOP 的缺陷：\n\n1. 继承机制要求在开始之前就能设计好整个程序的框架、结构、事物间的连接关系。这要求开发者必须有很好的分类设计能力，将不同的属性和方法分配到合适的层次里面去。设计清晰明了的继承体系总是很难的。（**C++标准库不是面向对象的**）\n\n2. 结构天生对改动有抵抗特性。这也是为什么 OOP 领域中所有程序员都对重构讳莫如深，有些框架到最后代码量几句膨胀变得难以维护从而失控。（**修改行为比修改结构体简单**）\n\n3. 继承机制带来的另一个问题是：很多语言都不提供多继承，我们不得不在父类塞入更多的内容，子类中会存在无用的父类属性和方法，而这些冗余代码给子类带来的一定的风险，而且对于层级很深的代码结构体来说 Bug 修复将会成为难题。（**组合优于继承**）\n\n4. **对象**（Class，引用类型）的状态不是编码的好友，相反是编码的敌人。对象固有的状态在分享和传递过程中很难追踪调试，尤其在并行程序编码中问题就更加明显，很难查找对象在哪一个并行线程发生了改变。OOP 所带来的可变、不确定、复杂等特征完全与并行编程中倡导的小型化、核心化、高效化完全背离。在并行编程中，值类型的优势更加明显，一个值在传递后，不会因为传递出去的值的变化而变化，即并行线程间修改的值都是独立的。（**值类型优于引用类型**）\n\n### POP（面向协议编程）\n\nProtocol oriented programming。\n\n协议为方法、属性等定义了蓝图，然后类、结构体或枚举可以采用该协议。\n\n在 Objective-C 中数组的实现遵循的是 OOP 编程范式。可变数组 `NSMutableArray` 继承自 `NSArray`，`NSArray` 继承自 `NSObject`。同时`NSArray` 采纳了 `NSCopying`、`NSFastEnumeration`、`NSMutableCopying`、`NSSecureCoding` 等协议。\n\n![19](面向对象编程/19.png)\n\n在 Swift 中数组的实现遵循的是 POP 编程范式。`Array` 没有继承自任何类，而是遵循了一系列的协议，不同的协议定义了不同功能的蓝图。\n\n![20](面向对象编程/20.png)\n\n### OOP vs POP\n\n**OOP 关心对象是什么，POP 关心对象做什么。**\n\n#### OOP 关心对象是什么\n\n采用 OOP 实现不同种类的运动员：\n\n首页不同种类的运动员统称为运动员，运动员都是人，所以有以下方案\n\n1、定义人类，一个有名字、年龄和说话等基本能力的人类：\n\n```swift\nclass Human {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    \n    func sayHi() {\n        print(\"say Hi\")\n    }\n}\n```\n\n2、定义运动员，一个人类运动员（继承自“人类”），他可以自定义自我介绍的内容：\n\n```swift\nclass Athlete: Human {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n3、定义田径运动员、游泳运动员，他们统称为运动员（继承自“运动员”），并可以定义属于自己的特有的能力：\n\n```swift\nclass Runner: Athlete {\n    func run() {\n        print(\"run\")\n    }\n}\n\nclass Swimmer: Athlete {\n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n🤔**思考**：如果既是田径运动员，又是游泳运动员？\n\n```swift\nclass RunnerAndSwimmer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n直接定义一个“田径游泳”运动员，这个命名真的很 OC。\n\n如果还是篮球运动员A，则可以写成 “RunnerAndSwimmerAndBasketballPlayer”，而且还可以一直 and 下去，“RunnerAndSwimmerAndBasketballPlayerAnd...”。\n\n即：“田径” + “游泳” + “篮球”\n\n```swift\nclass RunnerAndSwimmerAndBasketballPlayer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func swim() {\n        print(\"swim\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n如果这时有一个运动员B，相对于第一个除了不是“田径”运动员外其他的都是，则需要定义一个类，类名可以写成 “SwimmerAndBasketballPlayer”。\n\n即：“游泳” + “篮球”\n\n```swift\nclass SwimmerAndBasketballPlayer: Athlete {\n    func swim() {\n        print(\"swim\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n运动员C：“田径” + “篮球”\n\n```swift\nclass RunnerAndBasketballPlayer: Athlete {\n    func run() {\n        print(\"run\")\n    }\n\n    func playBasketball() {\n        print(\"play basketball\")\n    }\n}\n```\n\n4、定义裁判，裁判肯定是一个人类\n\n```swift\nclass Referee: Human {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n🤔**思考**：如果既是运动员，又是裁判？\n\n```swift\nclass Referee: Athlete {\n    override func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n}\n```\n\n让裁判继承自运动员，来表明这个裁判也是属于运动员这一类里的。显示生活中虽然裁判有可能是从运动员发展来的，但是这里显然裁判和运动员是两个职业，并没有从属关系。\n\n#### POP 关心对象做什么\n\n1、定义人类应该具备的基本属性，田径运动员的基本属性，游泳运动员的基本属性：\n\n```swift\nprotocol Human {\n    var name: String { get set }\n    var age: Int { get set }\n    func sayHi()\n}\n\nprotocol Runnalbe {\n    func run()\n}\n\nprotocol Swimming {\n    func swim()\n}\n```\n\n2、田径运动员：“人类” + “田径”\n\n```swift\nstruct Runner: Human, Runnalbe {\n    var name = \"zhangsan\"\n    var age = 35\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func run() {\n        print(\"run\")\n    }\n}\n```\n\n3、游泳运动员：“人类” + “游泳”\n\n```swift\nstruct Swimmer: Human, Swimming {\n    var name = \"lisi\"\n    var age = 18\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n4、运动健将：“人类” + “田径” + “游泳”\n\n```swift\nstruct AllAroundAthlete: Human, Runnalbe, Swimming {\n    var name: String = \"wangwu\"\n    var age: Int = 25\n    \n    func sayHi() {\n        print(\"Hi, I'm \\(name)\")\n    }\n    \n    func run() {\n        print(\"run\")\n    }\n    \n    func swim() {\n        print(\"swim\")\n    }\n}\n```\n\n### POP\n\nObjective-C 的UIKit框架部分继承结构图👇：\n\n![21](面向对象编程/21.png)\n\n#### 《怪物城堡 Monster Castle》\n\n开发一款塔防游戏《怪物城堡 Monster Castle》。\n\n使用 OOP 开发，游戏中的角色：\n\n1. 主要分为两类角色 `Castle` 和 `Monster`；\n2. `Castle` 包括电脑玩家 `AI Player` 和真实玩家 `Human Player`；\n3. `Monster` 包括三种怪物 `Munch Monster`、`Quirk Monster` 和 `Zap Monster`。\n\n![22](面向对象编程/22.png)\n\n游戏中的能力：\n\n1. `Castle` 和 `Zap Monster` 有射击的能力。\n\n![23](面向对象编程/23.png)\n\n通过封装一个 Shooting Helper 类来实现射击的能力，则 Castle 和 Zap Monster 通过 Shooting Helper 来进行射击。\n\n虽然一个专门负责射击的类可以实现需求，但是无法从 Castle 和 Zap Monster 的**定义**里面看出他们是拥有射击的能力的，只有去**内部实现**里查找 Shooting Helper 的存在，才能知道这两个角色是有射击能力的，而另外两个 Munch Monster 和 Quirk Monster 是没有设计能力的。\n\n---\n\n如果使用 POP 开发，则不再关心角色的分类，所有的角色都是 `GameObject` 的子类，它们的不同点在于他们拥有的能力不同。\n\n游戏中的角色：`AI Player`（电脑玩家）、`Human Player`（真实玩家）、`Munch Monster`（蒙奇怪物）、`Quirk Monster`（魁克怪物）、`Zap Monster`（扎普怪物）。\n游戏中的能力：`Gun Trait`（强制特性）、`Render Trait`（渲染特性）、`Movement Trait`（运动特性）、`Health Trait`（血条）、`AI Trait`\n\n![24](面向对象编程/24.png)\n\n则代码中角色的形成，完全由他所拥有的能力提现出来：\n\n```swift\nclass AIPlayer: GameObject, AITrait, GunTrait, RenderTrait, HealthTrait {\n\n}\n\nclass ZapMonster: GameObject, GunTrait, RenderTrait, HealthTrait, MovementTrait {\n\n}\n```\n\n---\n\n#### POP - 设计一个登录功能\n\n![25](面向对象编程/25.png)\n\n首先是使用 OOP 实现：\n\n```swift\nclass LoginViewController: UIViewController {\n    private func isUsernameValid(username: String) -> Bool {\n        return true\n    }\n    \n    private func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n    \n    @IBAction func loginButtonPressed() {\n        if isUsernameValid(username: usernameTextField.text!) &&\n           isPasswordValid(password: passwordTextField.text!) {\n           // proceed with login\n        } else {\n           // show alert\n        }\n    }\n}\n```\n\n对验证方法进一步封装：\n\n```swift\nclass UsernameValidator {\n    func isUsernameValid(username: String) -> Bool {\n        return true\n    }\n}\n\nclass PasswordValidator {\n    func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n}\n\nclass LoginViewController: UIViewController {\n    let usernameValidator = UsernameValidator()\n    let passwordValidator = PasswordValidator()\n    \n    @IBAction func loginButtonPressed() {\n        if usernameValidator.isUsernameValid(username: usernameTextField.text!) &&\n           passwordValidator.isPasswordValid(password: passwordTextField.text!) {\n           // proceed with login\n        } else {\n           // show alert\n        }\n    }\n}\n```\n\n使用 POP 实现：\n\n```swift\nprotocol ValidatesUsername {\n    func isUsernameValid(username: String) -> Bool\n}\n\nextension ValidatesUsername {\n    func isUsernameValid(username: String) -> Bool {\n        if /* username too short */ {\n            return false\n        } else if /* username has invalid characters */ {\n            return false\n        } else {\n            return true\n        }\n    }\n}\n\nprotocol ValidetesPassword {\n    func isPasswordValid(password: String) -> Bool\n}\n\nextension ValidetesPassword {\n    func isPasswordValid(password: String) -> Bool {\n        return true\n    }\n}\n\nclass LoginViewController: UIViewController, ValidatesUsername, ValidetesPassword {\n    @IBAction func loginButtonPressed() {\n        if isUsernameValid(username: usernameTextField.text!) &&\n           isPasswordValid(password: passwordTextField.text!) {\n            // proceed with login\n        } else {\n            // show alert\n        }\n    }\n}\n```\n","slug":"Swift/面向对象编程","published":1,"updated":"2023-08-22T09:52:14.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgz90035aq7kwcyqpk3p"},{"title":"gitalk","date":"2020-10-11T01:28:22.000Z","_content":"\n安装 gitalk。\n\n<!-- more -->\n\n[gitalk](https://github.com/gitalk/gitalk/blob/master/readme-cn.md)：\n![gitalk01](gitalk/gitalk01.png)\n\n可能会遇到的问题：[issue](https://github.com/gitalk/gitalk/issues/115#event-1539518527)\n\n# OAuth Apps\n![gitalk02](gitalk/gitalk02.png)\n![gitalk03](gitalk/gitalk03.png)\n![gitalk04](gitalk/gitalk04.png)\n创建成功，以后可以在这里找到 Client ID 和 Client Secret：\n![gitalk05](gitalk/gitalk05.png)\n\n# 配置 gitalk\n\n## 新建 md5.min.js\n在 `themes\\NexT\\source\\js\\src\\` 路径下新建 md5.min.js 文件，添加代码：\n```\n!function(n){\"use strict\";function t(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}function r(n,t){return n<<t|n>>>32-t}function e(n,e,o,u,c,f){return t(r(t(t(e,n),t(u,f)),c),o)}function o(n,t,r,o,u,c,f){return e(t&r|~t&o,n,t,u,c,f)}function u(n,t,r,o,u,c,f){return e(t&o|r&~o,n,t,u,c,f)}function c(n,t,r,o,u,c,f){return e(t^r^o,n,t,u,c,f)}function f(n,t,r,o,u,c,f){return e(r^(t|~o),n,t,u,c,f)}function i(n,r){n[r>>5]|=128<<r%32,n[14+(r+64>>>9<<4)]=r;var e,i,a,d,h,l=1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e<n.length;e+=16)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],7,-680876936),g,v,n[e+1],12,-389564586),l,g,n[e+2],17,606105819),m,l,n[e+3],22,-1044525330),v=o(v,m=o(m,l=o(l,g,v,m,n[e+4],7,-176418897),g,v,n[e+5],12,1200080426),l,g,n[e+6],17,-1473231341),m,l,n[e+7],22,-45705983),v=o(v,m=o(m,l=o(l,g,v,m,n[e+8],7,1770035416),g,v,n[e+9],12,-1958414417),l,g,n[e+10],17,-42063),m,l,n[e+11],22,-1990404162),v=o(v,m=o(m,l=o(l,g,v,m,n[e+12],7,1804603682),g,v,n[e+13],12,-40341101),l,g,n[e+14],17,-1502002290),m,l,n[e+15],22,1236535329),v=u(v,m=u(m,l=u(l,g,v,m,n[e+1],5,-165796510),g,v,n[e+6],9,-1069501632),l,g,n[e+11],14,643717713),m,l,n[e],20,-373897302),v=u(v,m=u(m,l=u(l,g,v,m,n[e+5],5,-701558691),g,v,n[e+10],9,38016083),l,g,n[e+15],14,-660478335),m,l,n[e+4],20,-405537848),v=u(v,m=u(m,l=u(l,g,v,m,n[e+9],5,568446438),g,v,n[e+14],9,-1019803690),l,g,n[e+3],14,-187363961),m,l,n[e+8],20,1163531501),v=u(v,m=u(m,l=u(l,g,v,m,n[e+13],5,-1444681467),g,v,n[e+2],9,-51403784),l,g,n[e+7],14,1735328473),m,l,n[e+12],20,-1926607734),v=c(v,m=c(m,l=c(l,g,v,m,n[e+5],4,-378558),g,v,n[e+8],11,-2022574463),l,g,n[e+11],16,1839030562),m,l,n[e+14],23,-35309556),v=c(v,m=c(m,l=c(l,g,v,m,n[e+1],4,-1530992060),g,v,n[e+4],11,1272893353),l,g,n[e+7],16,-155497632),m,l,n[e+10],23,-1094730640),v=c(v,m=c(m,l=c(l,g,v,m,n[e+13],4,681279174),g,v,n[e],11,-358537222),l,g,n[e+3],16,-722521979),m,l,n[e+6],23,76029189),v=c(v,m=c(m,l=c(l,g,v,m,n[e+9],4,-640364487),g,v,n[e+12],11,-421815835),l,g,n[e+15],16,530742520),m,l,n[e+2],23,-995338651),v=f(v,m=f(m,l=f(l,g,v,m,n[e],6,-198630844),g,v,n[e+7],10,1126891415),l,g,n[e+14],15,-1416354905),m,l,n[e+5],21,-57434055),v=f(v,m=f(m,l=f(l,g,v,m,n[e+12],6,1700485571),g,v,n[e+3],10,-1894986606),l,g,n[e+10],15,-1051523),m,l,n[e+1],21,-2054922799),v=f(v,m=f(m,l=f(l,g,v,m,n[e+8],6,1873313359),g,v,n[e+15],10,-30611744),l,g,n[e+6],15,-1560198380),m,l,n[e+13],21,1309151649),v=f(v,m=f(m,l=f(l,g,v,m,n[e+4],6,-145523070),g,v,n[e+11],10,-1120210379),l,g,n[e+2],15,718787259),m,l,n[e+9],21,-343485551),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);return[l,g,v,m]}function a(n){var t,r=\"\",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}function d(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}function h(n){return a(i(d(n),8*n.length))}function l(n,t){var r,e,o=d(n),u=[],c=[];for(u[15]=c[15]=void 0,o.length>16&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(d(t)),512+8*t.length),a(i(c.concat(e),640))}function g(n){var t,r,e=\"\";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),e+=\"0123456789abcdef\".charAt(t>>>4&15)+\"0123456789abcdef\".charAt(15&t);return e}function v(n){return unescape(encodeURIComponent(n))}function m(n){return h(v(n))}function p(n){return g(m(n))}function s(n,t){return l(v(n),v(t))}function C(n,t){return g(s(n,t))}function A(n,t,r){return t?r?s(t,n):C(t,n):r?m(n):p(n)}\"function\"==typeof define&&define.amd?define(function(){return A}):\"object\"==typeof module&&module.exports?module.exports=A:n.md5=A}(this);\n```\n\n## 新建 gitalk.swig\n在 `\\themes\\NexT\\layout\\_third-party\\comments\\` 路径下新建 gitalk.swig 文件，文件内容：\n```\n{% if page.comments && theme.gitalk.enable %}\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\">\n  <script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"></script>\n  <script src=\"/js/src/md5.min.js\"></script>\n  <div id=\"gitalk-container\"></div>\n  <script type=\"text/javascript\">\n    var gitalk = new Gitalk({\n      clientID: '{{ theme.gitalk.ClientID }}',\n      clientSecret: '{{ theme.gitalk.ClientSecret }}',\n      repo: '{{ theme.gitalk.repo }}',\n      owner: '{{ theme.gitalk.githubID }}',\n      admin: ['{{ theme.gitalk.adminUser }}'],\n      id: md5(location.pathname),\n      distractionFreeMode: '{{ theme.gitalk.distractionFreeMode }}'\n    })\n    gitalk.render('gitalk-container')\n  </script>\n{% endif %}\n```\n\n## 修改 comments.swig\n找到 `\\themes\\NexT\\layout\\_partials\\comments.swig`，添加代码：\n```\n{% elseif theme.gitalk.enable %}\n  <div id=\"gitalk-container\"></div>\n```\n\n需要跟其他配置同级，如：\n```\n{% elseif theme.valine.appid and theme.valine.appkey %}\n  <div class=\"comments\" id=\"comments\"></div>\n{% elseif theme.gitalk.enable %}\n  <div id=\"gitalk-container\"></div>\n{% endif %}\n```\n\n## 修改 index.swig\n找到 `\\themes\\NexT\\layout\\_third-party\\comments\\index.swig`，添加代码：\n```\n{% include 'gitalk.swig' %}\n```\n\n## 新建 gitalk.styl\n在 `\\source\\css\\_common\\components\\third-party\\` 路径下新建 gitalk.styl 文件，添加代码：\n```\n.gt-header a, .gt-comments a, .gt-popup a\n  border-bottom: none;\n.gt-container .gt-popup .gt-action.is--active:before\n  top: 0.7em;\n```\n\n## 新建 third-party.styl\n在 `\\source\\css\\_common\\components\\third-party\\` 路径下新建 gitalk.styl 文件，添加代码：\n```\n@import \"gitalk\";\n```\n\n## 修改 _config.yml\n`themes\\_config.yml`，添加代码：\n```\ngitalk:\n  enable: true\n  githubID: KevinYangGit  # 如：josonle   \n  repo: KevinYangGit.github.io   # 例：josonle.github.io\n  ClientID: 上文提到的ID\n  ClientSecret: 上文提到的Secret\n  adminUser: KevinYangGit #指定可初始化评论账户\n  distractionFreeMode: true #启用快捷键 Ctrl+Enter提交评论\n  createIssueManually: true ##如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮\n```\n\n# 部署\n`hexo clean && hexo g && hexo d`\n","source":"_posts/Other/Personal blog/gitalk.md","raw":"---\ntitle: gitalk\ndate: 2020-10-11 09:28:22\ntags: Other\n---\n\n安装 gitalk。\n\n<!-- more -->\n\n[gitalk](https://github.com/gitalk/gitalk/blob/master/readme-cn.md)：\n![gitalk01](gitalk/gitalk01.png)\n\n可能会遇到的问题：[issue](https://github.com/gitalk/gitalk/issues/115#event-1539518527)\n\n# OAuth Apps\n![gitalk02](gitalk/gitalk02.png)\n![gitalk03](gitalk/gitalk03.png)\n![gitalk04](gitalk/gitalk04.png)\n创建成功，以后可以在这里找到 Client ID 和 Client Secret：\n![gitalk05](gitalk/gitalk05.png)\n\n# 配置 gitalk\n\n## 新建 md5.min.js\n在 `themes\\NexT\\source\\js\\src\\` 路径下新建 md5.min.js 文件，添加代码：\n```\n!function(n){\"use strict\";function t(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}function r(n,t){return n<<t|n>>>32-t}function e(n,e,o,u,c,f){return t(r(t(t(e,n),t(u,f)),c),o)}function o(n,t,r,o,u,c,f){return e(t&r|~t&o,n,t,u,c,f)}function u(n,t,r,o,u,c,f){return e(t&o|r&~o,n,t,u,c,f)}function c(n,t,r,o,u,c,f){return e(t^r^o,n,t,u,c,f)}function f(n,t,r,o,u,c,f){return e(r^(t|~o),n,t,u,c,f)}function i(n,r){n[r>>5]|=128<<r%32,n[14+(r+64>>>9<<4)]=r;var e,i,a,d,h,l=1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e<n.length;e+=16)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],7,-680876936),g,v,n[e+1],12,-389564586),l,g,n[e+2],17,606105819),m,l,n[e+3],22,-1044525330),v=o(v,m=o(m,l=o(l,g,v,m,n[e+4],7,-176418897),g,v,n[e+5],12,1200080426),l,g,n[e+6],17,-1473231341),m,l,n[e+7],22,-45705983),v=o(v,m=o(m,l=o(l,g,v,m,n[e+8],7,1770035416),g,v,n[e+9],12,-1958414417),l,g,n[e+10],17,-42063),m,l,n[e+11],22,-1990404162),v=o(v,m=o(m,l=o(l,g,v,m,n[e+12],7,1804603682),g,v,n[e+13],12,-40341101),l,g,n[e+14],17,-1502002290),m,l,n[e+15],22,1236535329),v=u(v,m=u(m,l=u(l,g,v,m,n[e+1],5,-165796510),g,v,n[e+6],9,-1069501632),l,g,n[e+11],14,643717713),m,l,n[e],20,-373897302),v=u(v,m=u(m,l=u(l,g,v,m,n[e+5],5,-701558691),g,v,n[e+10],9,38016083),l,g,n[e+15],14,-660478335),m,l,n[e+4],20,-405537848),v=u(v,m=u(m,l=u(l,g,v,m,n[e+9],5,568446438),g,v,n[e+14],9,-1019803690),l,g,n[e+3],14,-187363961),m,l,n[e+8],20,1163531501),v=u(v,m=u(m,l=u(l,g,v,m,n[e+13],5,-1444681467),g,v,n[e+2],9,-51403784),l,g,n[e+7],14,1735328473),m,l,n[e+12],20,-1926607734),v=c(v,m=c(m,l=c(l,g,v,m,n[e+5],4,-378558),g,v,n[e+8],11,-2022574463),l,g,n[e+11],16,1839030562),m,l,n[e+14],23,-35309556),v=c(v,m=c(m,l=c(l,g,v,m,n[e+1],4,-1530992060),g,v,n[e+4],11,1272893353),l,g,n[e+7],16,-155497632),m,l,n[e+10],23,-1094730640),v=c(v,m=c(m,l=c(l,g,v,m,n[e+13],4,681279174),g,v,n[e],11,-358537222),l,g,n[e+3],16,-722521979),m,l,n[e+6],23,76029189),v=c(v,m=c(m,l=c(l,g,v,m,n[e+9],4,-640364487),g,v,n[e+12],11,-421815835),l,g,n[e+15],16,530742520),m,l,n[e+2],23,-995338651),v=f(v,m=f(m,l=f(l,g,v,m,n[e],6,-198630844),g,v,n[e+7],10,1126891415),l,g,n[e+14],15,-1416354905),m,l,n[e+5],21,-57434055),v=f(v,m=f(m,l=f(l,g,v,m,n[e+12],6,1700485571),g,v,n[e+3],10,-1894986606),l,g,n[e+10],15,-1051523),m,l,n[e+1],21,-2054922799),v=f(v,m=f(m,l=f(l,g,v,m,n[e+8],6,1873313359),g,v,n[e+15],10,-30611744),l,g,n[e+6],15,-1560198380),m,l,n[e+13],21,1309151649),v=f(v,m=f(m,l=f(l,g,v,m,n[e+4],6,-145523070),g,v,n[e+11],10,-1120210379),l,g,n[e+2],15,718787259),m,l,n[e+9],21,-343485551),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);return[l,g,v,m]}function a(n){var t,r=\"\",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}function d(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}function h(n){return a(i(d(n),8*n.length))}function l(n,t){var r,e,o=d(n),u=[],c=[];for(u[15]=c[15]=void 0,o.length>16&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(d(t)),512+8*t.length),a(i(c.concat(e),640))}function g(n){var t,r,e=\"\";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),e+=\"0123456789abcdef\".charAt(t>>>4&15)+\"0123456789abcdef\".charAt(15&t);return e}function v(n){return unescape(encodeURIComponent(n))}function m(n){return h(v(n))}function p(n){return g(m(n))}function s(n,t){return l(v(n),v(t))}function C(n,t){return g(s(n,t))}function A(n,t,r){return t?r?s(t,n):C(t,n):r?m(n):p(n)}\"function\"==typeof define&&define.amd?define(function(){return A}):\"object\"==typeof module&&module.exports?module.exports=A:n.md5=A}(this);\n```\n\n## 新建 gitalk.swig\n在 `\\themes\\NexT\\layout\\_third-party\\comments\\` 路径下新建 gitalk.swig 文件，文件内容：\n```\n{% if page.comments && theme.gitalk.enable %}\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\">\n  <script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"></script>\n  <script src=\"/js/src/md5.min.js\"></script>\n  <div id=\"gitalk-container\"></div>\n  <script type=\"text/javascript\">\n    var gitalk = new Gitalk({\n      clientID: '{{ theme.gitalk.ClientID }}',\n      clientSecret: '{{ theme.gitalk.ClientSecret }}',\n      repo: '{{ theme.gitalk.repo }}',\n      owner: '{{ theme.gitalk.githubID }}',\n      admin: ['{{ theme.gitalk.adminUser }}'],\n      id: md5(location.pathname),\n      distractionFreeMode: '{{ theme.gitalk.distractionFreeMode }}'\n    })\n    gitalk.render('gitalk-container')\n  </script>\n{% endif %}\n```\n\n## 修改 comments.swig\n找到 `\\themes\\NexT\\layout\\_partials\\comments.swig`，添加代码：\n```\n{% elseif theme.gitalk.enable %}\n  <div id=\"gitalk-container\"></div>\n```\n\n需要跟其他配置同级，如：\n```\n{% elseif theme.valine.appid and theme.valine.appkey %}\n  <div class=\"comments\" id=\"comments\"></div>\n{% elseif theme.gitalk.enable %}\n  <div id=\"gitalk-container\"></div>\n{% endif %}\n```\n\n## 修改 index.swig\n找到 `\\themes\\NexT\\layout\\_third-party\\comments\\index.swig`，添加代码：\n```\n{% include 'gitalk.swig' %}\n```\n\n## 新建 gitalk.styl\n在 `\\source\\css\\_common\\components\\third-party\\` 路径下新建 gitalk.styl 文件，添加代码：\n```\n.gt-header a, .gt-comments a, .gt-popup a\n  border-bottom: none;\n.gt-container .gt-popup .gt-action.is--active:before\n  top: 0.7em;\n```\n\n## 新建 third-party.styl\n在 `\\source\\css\\_common\\components\\third-party\\` 路径下新建 gitalk.styl 文件，添加代码：\n```\n@import \"gitalk\";\n```\n\n## 修改 _config.yml\n`themes\\_config.yml`，添加代码：\n```\ngitalk:\n  enable: true\n  githubID: KevinYangGit  # 如：josonle   \n  repo: KevinYangGit.github.io   # 例：josonle.github.io\n  ClientID: 上文提到的ID\n  ClientSecret: 上文提到的Secret\n  adminUser: KevinYangGit #指定可初始化评论账户\n  distractionFreeMode: true #启用快捷键 Ctrl+Enter提交评论\n  createIssueManually: true ##如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮\n```\n\n# 部署\n`hexo clean && hexo g && hexo d`\n","slug":"Other/Personal blog/gitalk","published":1,"updated":"2023-08-22T09:52:14.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgza0037aq7klm2ler9k"},{"title":"Runtime","date":"2020-06-12T10:27:54.000Z","_content":"\n思考：\n* 讲一下 OC 的消息机制\n* 消息转发机制流程\n* 什么是 Runtime？平时项目中有用过么？\n* Runtime 的具体应用\n\n<!-- more -->\n\n* 打印结果分别是什么？\n```\n//打印1\n@interface Person : NSObject\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n@end\n\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"[self class] = %@\", [self class]);\n        NSLog(@\"[super class] = %@\", [super class]);\n        NSLog(@\"[self superclass] = %@\", [self superclass]);\n        NSLog(@\"[super superclass] = %@\", [super superclass]);\n    }\n    return self;\n}\n@end\n\n//打印2\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];\n        BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];\n        BOOL res3 = [[Person class] isKindOfClass:[Person class]];\n        BOOL res4 = [[Person class] isMemberOfClass:[Person class]];\n        NSLog(@\"%d %d %d %d\", res1, res2, res3, res4);\n    }\n    return 0;\n}\n```\n\n* 以下代码能不能执行成功？如果可以，打印结果是什么？\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)print;\n@end\n\n@implementation Person\n- (void)print {\n    NSLog(@\"my name's %@\", self.name);\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj print];\n}\n@end\n```\n\nObjective-C 是一门动态性比较强的编程语言，跟 C、C++ 等语言有着很大的不同，Objective-C 的动态性是由 Runtime API 来支撑的，Runtime API 提供的接口基本都是 C 语言的，源码由 C\\C++\\汇编语言编写。\n\n# isa 详解\n学习 Runtime，首先要了解它底层的一些常用数据结构，比如 isa 指针。在 arm64 架构之前，isa 就是一个普通的指针，存储着 Class、Meta-Class 对象的内存地址。从 arm64 架构开始，对 isa 进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。\n\n## 位运算\n```\n@interface Person : NSObject\n@property (nonatomic, assign, getter=isTall) BOOL tall;\n@property (nonatomic, assign, getter=isRich) BOOL rich;\n@property (nonatomic, assign, getter=isHandsome) BOOL handsome;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = YES;\n        person.handsome = YES;\n        \n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n        NSLog(@\"person的大小：%zd\", class_getInstanceSize([person class]));\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：1, handsome：1\nperson的大小：16\n```\n\ntall（1个字节）+ rich（1个字节）+ handsome（1个字节）+ isa（8个字节）= 11个字节。根据内存对齐原则，person 的内存大小是16个字节。\n\n因为 tall、rich 和 handsome 都是 BOOL 类型，它们的值只有0和1，所以可以用3个二进制位来存储他们的值。\n\n### 设计  \n定义一个 char 类型的变量 _tallRichHandsome 用来存储3个 BOOL 类型变量的值：\n```\n@interface Person()\n{\n    char _tallRichHandsome; //0b 0000 0000\n}\n@end\n```\n\n_tallRichHandsome 占1个字节（8位：`0b 0000 0000`），让它最右边的3位（`0b00000111`）分别存储 tall、rich 和 handsome：\n```\n0b 0000 0111 //_tallRichHandsome（tall：YES, rich：YES, handsome：YES）\n\n0b 0000 0001 //tall\n0b 0000 0010 //rich\n0b 0000 0100 //handsome\n```\n\n### 取值\n* 按位与运算符（`&`）  \n定义：参加运算的两个数据，按二进制位进行“与”运算。  \n运算规则：`0&0=0`，`0&1=0`，`1&0=0`，`1&1=1`。  \n总结：两位同时为1，结果才为1，否则结果为0。 \n\n因为“与”运算可以获取到特定位的值，所以可以通过“与”运算分别获取三个变量的值：\n\n初始化 _tallRichHandsome\n```\n_tallRichHandsome = 0b00000101; //（tall：YES, rich：NO, handsome：YES）\n```\n\n获取 tall（`_tallRichHandsome & 0b00000001`）\n```\n  0b00000101\n& 0b00000001\n-------------\n  0b00000001\n```\n\n获取 rich（`_tallRichHandsome & 0b00000010`）\n```\n  0b00000101\n& 0b00000010\n-------------\n  0b00000000\n```\n\n获取 handsome（`_tallRichHandsome & 0b00000100`）\n```\n  0b00000101\n& 0b00000100\n-------------\n  0b00000100\n```\n\n代码实现：\n```\n@interface Person : NSObject\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n@end\n\n@interface Person()\n{\n    char _tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _tallRichHandsome = 0b00000101;\n    }\n    return self;\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & 1); //1（十进制）== 0b 0000 0001（二进制）\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & 2); //2（十进制）== 0b 0000 0010（二进制）\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & 4); //4（十进制）== 0b 0000 0100（二进制）\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：0, handsome：1\n```\n\n因为返回的是 BOOL 类型，而“与”运算取出的是有值（`0b00000001`、`0b00000100`）和0（`0b00000000`），所以为了可以获取到 YES 和 NO，可以在“与”运算的结果前加`!!`取反两次：\n```\n!(0b00000000)   YES\n!!(0b00000000)  NO   //!!(_tallRichHandsome & 2)\n \n!(0b00000001)   NO\n!!(0b00000001)  YES  //!!(_tallRichHandsome & 1)\n\n!(0b00000100)   NO\n!!(0b00000100)  YES  //!!(_tallRichHandsome & 4)\n```\n\n### 掩码\n上面👆的实现太抽象，可以使用掩码增加可读性：\n```\n#define TallMask 1\n#define RichMask 2\n#define HandsomeMask 4\n```\n\n直接使用二进制定义掩码会更直观：\n```\n#define TallMask 0b00000001\n#define RichMask 0b00000010\n#define HandsomeMask 0b00000100\n```\n\n使用位移运算符，简化代码：\n```\n#define TallMask (1<<0)     //左移0位：0b00000001（二进制），1（十进制）\n#define RichMask (1<<1)     //左移1位：0b00000010（二进制），2（十进制）\n#define HandsomeMask (1<<2) //左移2位：0b00000100（二进制），4（十进制）\n```\n\n* 左移运算符（`<<`）  \n定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n\n最终实现：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n@implementation Person\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & HandsomeMask);\n}\n@end\n```\n\n### 设值\n* 按位或运算符（`|`）  \n定义：参加运算的两个对象，按二进制位进行“或”运算。  \n运算规则：`0|0=0`，`0|1=1`，`1|0=1`，`1|1=1`。  \n总结：参加运算的两个对象只要有一个为1，其值为1。\n\n* 取反运算符 (`~`)  \n定义：参加运算的一个数据，按二进制进行“取反”运算。  \n运算规则：`~1=0`，`~0=1`。  \n总结：对一个二进制数按位取反，即将0变1，1变0。\n\n设置 YES 时，跟 _tallRichHandsome 进行按位“或”运算，修改特定位置的值。  \n设置 NO 时，先对 rich 的二进制数按位取反，再跟 _tallRichHandsome 进行按位“与”运算。\n\n初始化 _tallRichHandsome\n```\n_tallRichHandsome = 0b00000010; //（tall：NO, rich：YES, handsome：NO）\n```\n\n设置 tall 为 YES（`_tallRichHandsome |= 0b00000001`）\n```\n  0b00000010\n| 0b00000001\n-------------\n  0b00000011\n```\n\n设置 rich 为 NO（`_tallRichHandsome &= ~0b00000010`）\n```\n  0b00000010\n& 0b11111101  //~0b00000010（按位取反） \n-------------\n  0b00000000\n```\n\n设置 handsome 为 YES（`_tallRichHandsome |= 0b00000001`）\n```\n  0b00000010\n| 0b00000100\n-------------\n  0b00000110\n```\n\n代码实现：\n```\n@interface Person : NSObject\n- (void)setTall:(BOOL)tall;\n- (void)setRich:(BOOL)rich;\n- (void)setHandsome:(BOOL)handsome;\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n@end\n\n\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n\n@interface Person()\n{\n    char _tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (void)setTall:(BOOL)tall {\n    if (tall) {\n        _tallRichHandsome |= TallMask;\n    } else {\n        _tallRichHandsome &= ~TallMask;\n    }\n}\n\n- (void)setRich:(BOOL)rich {\n    if (rich) {\n        _tallRichHandsome |= RichMask;\n    } else {\n        _tallRichHandsome &= ~RichMask;\n    }\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    if (handsome) {\n        _tallRichHandsome |= HandsomeMask;\n    } else {\n        _tallRichHandsome &= ~HandsomeMask;\n    }\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & HandsomeMask);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：0, handsome：1\n```\n\n## 位域\n位域，C 语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。利用位段能够用较少的位数存储数据。\n\n机构体的第一个成员变量在结构体内存的最右边一个二进制位，其它变量依次从左往右排。\n\n使用位域增加可读性。定义结构体 _tallRichHandsome，成员变量 tall，并通过“`:`”设置 tall 在内存中只占1位。\n```\n@interface Person()\n{\n    struct {\n        char tall : 1; //1位\n    } _tallRichHandsome; //1个字节\n}\n@end\n\n@implementation Person\n- (void)setTall:(BOOL)tall {\n    _tallRichHandsome.tall = tall;\n}\n\n- (BOOL)isTall {\n    BOOL ret = _tallRichHandsome.tall;\n    return ret; //断点2\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        NSLog(@\"tall：%d\", person.isTall); //断点1\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：-1\n```\n\n在断点1处查看 _tallRichHandsome 的内存：\n```\n(lldb) p/x &(person->_tallRichHandsome)\n((anonymous struct) *) $0 = 0x0000000100493d98\n(lldb) x 0x0000000100493d98\n0x100493d98: 01 00 00 00 00 00 00 00 2d 5b 4e 53 54 61 62 50  ........-[NSTabP\n0x100493da8: 69 63 6b 65 72 56 69 65 77 43 6f 6e 74 72 6f 6c  ickerViewControl\n```\n\n内存中的“01”是十六进制的，转成二进制就是`0b 0000 0001`。即 tall：YES。\n\n在断点2处查看 ret 的内存：\n```\n(lldb) p/x & ret\n(BOOL *) $0 = 0x00007ffeefbff4ff 255\n(lldb) x 0x00007ffeefbff4ff\n0x7ffeefbff4ff: ff b1 4e cb 5e ff 7f 00 00 90 81 16 03 01 00 00  ..N.^...........\n0x7ffeefbff50f: 00 50 f5 bf ef fe 7f 00 00 90 0c 00 00 01 00 00  .P..............\n```\n\n内存中的“ff”是十六进制的（0xFF），转成二进制就是`0b11111111`，转成十进制是255（无符号）或-1（有符号）。这是因为 tall 原本是一个二进制位，即 tall：0b1，而返回值要求的是 BOOL 类型的值（8位：`0b00000000`），所以在返回时 tall 强转成了一个8位的值：\n```\n0b1 -> 0b 1111 1111（二进制） //0xff（十六进制）\n```\n\n因为在系统中整数是以补码形式存放的，所以要想找到打印结果为“-1”的原因需要先算出 `0b11111111` 的原码。\n* 补码求原码  \n如果补码的符号位为“0”，表示是一个正数，其原码就是补码。  \n如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。  \n\n因为 tall 是一个 char 类型的整型变量，是有符号的（LLVM），所以此时的 `0b11111111` 是有符号的。\n\n因为 `0b11111111` 的最高位是符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。其余七位取反后为 `0b10000000`；再加1，所以是 `0b10000001`，十进制就是 -1。所以 tall 在设置为 YES 时，打印结果是 -1。\n\n如果将 tall 设置为 NO 的话，_tallRichHandsome 和 ret 的内存都是 `0b00000000`。\n```\n(lldb) p/x &(person->_tallRichHandsome)\n((anonymous struct) *) $1 = 0x0000000102c6fb28\n(lldb) x 0x0000000102c6fb28\n0x102c6fb28: 00 00 00 00 00 00 00 00 2d 5b 4e 53 56 69 62 72  ........-[NSVibr\n0x102c6fb38: 61 6e 74 53 70 6c 69 74 44 69 76 69 64 65 72 56  antSplitDividerV\n\n(lldb) p/x & ret\n(BOOL *) $0 = 0x00007ffeefbff4ff NO\n(lldb) x 0x00007ffeefbff4ff\n0x7ffeefbff4ff: 00 b1 4e cb 5e ff 7f 00 00 20 fb c6 02 01 00 00  ..N.^.... ......\n0x7ffeefbff50f: 00 50 f5 bf ef fe 7f 00 00 8d 0c 00 00 01 00 00  .P..............\n```\n\n综上所述，在对 tall 进行修改时，会有两个返回值“-1”和“0”。为了保证返回的结果正确，可以使用上面👆提到过的取反两次`!!`。\n\n最终实现：  \n定义结构体 _tallRichHandsome，同时定义成员变量 tall、rich 和 handsome，并通过“:”设置她们在内存中只占1位：\n```\n@interface Person()\n{\n    struct {\n        char tall : 1; //只占1位\n        char rich : 1;\n        char handsome : 1;\n    } _tallRichHandsome;\n}\n@end\n\n@implementation Person\n- (void)setTall:(BOOL)tall {\n    _tallRichHandsome.tall = tall;\n}\n\n- (void)setRich:(BOOL)rich {\n    _tallRichHandsome.rich = rich;\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    _tallRichHandsome.handsome = handsome;\n}\n\n- (BOOL)isTall {\n    return !!_tallRichHandsome.tall;\n}\n\n- (BOOL)isRich {\n    return !!_tallRichHandsome.rich;\n}\n\n- (BOOL)isHandsome {\n    return !!_tallRichHandsome.handsome;\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome); //断点1\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n tall：1, rich：0, handsome：1\n```\n\n_tallRichHandsome 的二级制就是`0b00000111`，tall 是第一个成员变量在最右边，然后依次从左往右排。\n\n## 共用体（union）\n\n### struct\nstruct 结构体里的成员变量各自拥有一块内存，单独存在：\n![Runtime01](Runtime/Runtime01.png)\n\n定义一个结构体 Date，内部有三个 int 类型的成员变量 year、month 和 day：\n```\nstruct Date {\n    int year;  //4个字节\n    int month; //4个字节\n    int day;   //4个字节\n}; //12个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //struct Date date = {2020, 6, 17};\n        struct Date date;\n        date.year = 2020;\n        date.month = 6;\n        date.day = 17;\n        NSLog(@\"year：%d, month：%d, day：%d\", date.year, date.month, date.day);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：6, day：17\n```\n\n因为三个变量各自拥有自己的内存，所以打印结果各不相同。\n\n### union\nunion 共用体里的成员变量共用一块内存，共用体的内存大小以成员变量的最大内存为准：\n![Runtime02](Runtime/Runtime02.png)\n\n定义共用体 Date，内部有三个 int 类型的变量 year、month 和 day：\n```\nunion Date {\n    int year;  //4个字节\n    int month; //4个字节\n    int day;   //4个字节\n}; //4个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        union Date date;\n        date.year = 2020;\n        NSLog(@\"year：%d, month：%d, day：%d\", date.year, date.month, date.day);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：2020, day：2020\n```\n\n因为三个变量共用一块内存，所以三个变量访问的内存是同一块内存地址。\n\n定义共用体 Date，内部有一个 int 类型的变量 year 和一个 char 类型的变量 month：\n```\nunion Date {\n    int year;   //4个字节\n    char month; //1个字节\n}; //4个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        union Date date;\n        date.year = 2020;\n        NSLog(@\"year：%d, month：%d\", date.year, date.month);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：2020\n```\n\n### 实现\n将位运算和位域结合在一起定义一个共用体，用位运算读取/写入变量的值，用位域增加可读性：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n@interface Person()\n{\n    union {\n        char bits;\n        struct {\n            char tall : 1;\n            char rich : 1;\n            char handsome : 1;\n        };\n    }_tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (void)setTall:(BOOL)tall {\n    if (tall) {\n        _tallRichHandsome.bits |= TallMask;\n    } else {\n        _tallRichHandsome.bits &= ~TallMask;\n    }\n}\n\n- (void)setRich:(BOOL)rich {\n    if (rich) {\n        _tallRichHandsome.bits |= RichMask;\n    } else {\n        _tallRichHandsome.bits &= ~RichMask;\n    }\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    if (handsome) {\n        _tallRichHandsome.bits |= HandsomeMask;\n    } else {\n        _tallRichHandsome.bits &= ~HandsomeMask;\n    }\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome.bits & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome.bits & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome.bits & HandsomeMask);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = NO;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：0, rich：0, handsome：1\n```\n\n这里定义的 tall、rich 和 handsome 都是占1个二进制位的，如果想要修改它们占二进制位的个数，bits 也要修改为相应的定义：\n\ntall、rich 和 handsome 都是占4个二进制位，那 bits 就需要定义成 int 类型（4个字节），掩码也需要占4个二进制位：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<4)\n#define HandsomeMask (1<<8)\n\n@interface Person()\n{\n    union {\n        int bits;\n        struct {\n            char tall : 4;\n            char rich : 4;\n            char handsome : 4;\n        };\n    }_tallRichHandsome;\n}\n@end\n```\n\n掩码也可以写成：\n```\n#define TallMask (0b1111<<0)\n#define RichMask (0b1111<<4)\n#define HandsomeMask (0b1111<<8)\n```\n\n或者\n```\n#define TallMask (15<<0)\n#define RichMask (15<<4)\n#define HandsomeMask (15<<8)\n```\n\n## isa\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 isa 的定义。  \n\n找到 OC 对象的结构体 objc_object：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n    \n    ··· //省略一堆方法\n}\n```\n\n### isa_t\n\n可以看到 isa 是一个 isa_t 类型的变量，Jump To Definition -> isa_t：\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    //位域\n    struct { \n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n```\n\n位域中是一个宏 ISA_BITFIELD，ISA_BITFIELD 在 `__arm64__`（真机） 和 `__x86_64__`（mac电脑/模拟器） 架构有不同的定义：\n```\n# if __arm64__ //真机上市 arm64\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__ //模拟器是 x86 架构\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                        \\\n      uintptr_t nonpointer        : 1;                                         \\\n      uintptr_t has_assoc         : 1;                                         \\\n      uintptr_t has_cxx_dtor      : 1;                                         \\\n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                         \\\n      uintptr_t weakly_referenced : 1;                                         \\\n      uintptr_t deallocating      : 1;                                         \\\n      uintptr_t has_sidetable_rc  : 1;                                         \\\n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n\n# else\n#   error unknown architecture for packed isa\n# endif\n```\n\n将宏 `ISA_BITFIELD` 替换掉，保留真机（arm64）代码，可以看到一个比较完整的 isa_t：\n![Runtime05](Runtime/Runtime05.png)\n\n 因为 isa 指针的定义区分 `__arm64__`（真机）和 `__x86_64__`（mac/模拟器），所以需要用真机运行项目才能看到 `ISA_BITFIELD` 正确的成员变量的值：\n ```\n int main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n ```\n\n查看 person 对象的 isa 指针的内存：\n```\n(lldb) p/x person->isa\n(Class) $0 = 0x1A100455641 Person\n```\n\n转成二进制：\n![Runtime04](Runtime/Runtime04.png)\n\n### 位域  \n* nonpointer  \n0，代表普通的指针，isa 只存储着 Class、Meta-Class 对象的内存地址  \n1，代表优化过，isa 使用位域存储更多的信息\n* has_assoc  \n是否有设置过关联对象，如果没有，释放时会更快\n* has_cxx_dtor  \n是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快\n* shiftcls  \n存储着 Class、Meta-Class 对象的内存地址信息\n* magic  \n用于在调试时分辨对象是否未完成初始化\n* weakly_referenced  \n是否有被弱引用指向过，如果没有，释放时会更快\n* deallocating  \n对象是否正在释放\n* extra_rc  \n里面存储的值是引用计数器减1\n* has_sidetable_rc  \n引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中\n\n![Runtime06](Runtime/Runtime06.png)\nnonpointer：占1个二进制位，在最低位为1（第0位）。  \nhas_assoc（has_associate）：占1个二进制位，为0（第1位）。  \nhas_cxx_dtor：占1个二进制位，为0（第2位）。     \nshiftcls：占33个二进制位（从第3位到第35位）。 \nmagic：占6个二进制位（从第36位到第41位）。magic 的值可以从宏 `ISA_MAGIC_VALUE` 看到（1a）。magic == 1a 表示初始化成功。  \nweakly_referenced：占1个二进制位，为0（第42位）。  \ndeallocating：占1个二进制位，为0（第43位）。   \nhas_sidetable_rc：占1个二进制位，为0（第44位）。  \nextra_rc（extra_retain_count）：占19个二进制位，为0（从第45位到63位）。\n\n#### has_assoc 和 weakly_referenced\n\nhas_assoc 和 weakly_referenced 标记的是曾经是否设置过，如果添加了 __weak 和关联对象再移除掉，这两个变量的值依然是1：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    weakPerson = nil;\n    objc_setAssociatedObject(person, @\"name\", @\"Tom\", OBJC_ASSOCIATION_COPY_NONATOMIC); //添加关联对象\n    objc_setAssociatedObject(person, @\"name\", nil, OBJC_ASSOCIATION_COPY_NONATOMIC); //移除关联对象\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n查看内存：\n![Runtime07](Runtime/Runtime07.png)\n\n#### 如果没有，释放时会更快\n如果 has_assoc、has_cxx_dtor 和 weakly_referenced 为0，即没有添加过关联对象、没有析构函数和没有被弱引用指向过，会让实例对象的释放变得更快。这点可以从源码里看出来。  \n\n销毁实列对象的方法 objc_destructInstance：\n```\n/***********************************************************************\n* objc_destructInstance\n* Destroys an instance without freeing memory. \n* Calls C++ destructors.\n* Calls ARC ivar cleanup.\n* Removes associative references.\n* Returns `obj`. Does nothing if `obj` is nil.\n**********************************************************************/\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n```\n\n可以看到在销毁实例对象的方法里，判断了有没有析构函数和关联对象，如果有的话需要先处理析构函数和关联对象。\n\nJump To Definition -> clearDeallocating：\n```\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```\n\nJump To Definition -> clearDeallocating_slow：\n```\n// Slow path of clearDeallocating() \n// for objects with nonpointer isa\n// that were ever weakly referenced \n// or whose retain count ever overflowed to the side table.\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n\n在 `clearDeallocating()` 方法里判断了是否有弱引用指向过，如果有的话需要在 `clearDeallocating_slow()` 方法里处理 weakly_referenced。\n\n### ISA_MASK \n通过 `isa & ISA_MASK ` 能够取出 shiftcls 的值（Class、Meta-Class 对象的内存地址信息）。因为 `ISA_MASK` 最后面三位都是0，所以获取到的 Class、Meta-Class 对象的内存地址的最后三位肯定也为0。`ISA_MASK`：\n![Runtime03](Runtime/Runtime03.png)\n\n证明：\n```\n@interface ViewController()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%p\", [ViewController class]);\n    NSLog(@\"%p\", object_getClass([ViewController class]));\n    NSLog(@\"%p\", [Person class]);\n    NSLog(@\"%p\", object_getClass([Person class]));\n}\n@end\n```\n\n打印结果：\n```\n0x1007d5550\n0x1007d5578\n0x1007d5618\n0x1007d55f0\n```\n\n可以看到打印结果的最后一位都是”8“或”0“，即”`1000`“或”`0000`“。所以 Class、Meta-Class 对象的内存地址的最后三为为0。\n\n## 位运算补充\n\n用左移定义枚举的成员变量，用”或“运算传入多个值，用”与“运算获取传入的都有哪些值：\n```\ntypedef enum {\n    OptionsOne = 1<<0,\n    OptionsTwo = 1<<1,\n    OptionsThree = 1<<2,\n    OptionsFour = 1<<3\n} Options;\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)setOptions:(Options)option {\n    if (option & OptionsOne) {\n        NSLog(@\"OptionsOne\");\n    }\n    if (option & OptionsTwo) {\n        NSLog(@\"OptionsTwo\");\n    }\n    if (option & OptionsThree) {\n        NSLog(@\"OptionsThree\");\n    }\n    if (option & OptionsFour) {\n        NSLog(@\"OptionsFour\");\n    }\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self setOptions:OptionsOne | OptionsTwo | OptionsFour];\n}\n@end\n```\n\n打印结果：\n```\nOptionsOne\nOptionsTwo\nOptionsFour\n```\n\n# Class 的结构\n\n类对象和元类对象都是 Class 类型的对象，元类对象是一种特殊的类对象。\n\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 objc_class 的定义。 \n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\n    ...... //省略\n}\n\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    ...... //省略\n}\n```\n\n结构图：\n![Runtime08](Runtime/Runtime08.png)\n\n结构图里出现的 `rw`和 `ro` 分别表示 readwrite 和 readonly。\n\n## class_rw_t\nclass_rw_t 里面的 methods、properties、protocols 是二维数组，是可读可写的，包含了类的初始内容、分类的内容。  \n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    ...... //省略\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    ...... //省略\n}\n```\n\n![Runtime09](Runtime/Runtime09.png)\n\n类的信息在编译时是放在 class_ro_t 里的，在程序运行时，会将类的 class_ro_t 里的信息和分类的信息（注意顺序）合并起来放到 class_rw_t 里。找到合并分类信息的方法 `realizeClassWithoutSwift()`：\n```\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n    runtimeLock.assertLocked();\n\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n\n    if (!cls) return nil;\n    if (cls->isRealized()) return cls;\n    ASSERT(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n\n    auto ro = (const class_ro_t *)cls->data(); //取出类信息 ro\n    auto isMeta = ro->flags & RO_META;\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();\n        ro = cls->data()->ro();\n        ASSERT(!isMeta);\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        rw = objc::zalloc<class_rw_t>(); //初始化 rw\n        rw->set_ro(ro); //添加类信息 ro\n        rw->flags = RW_REALIZED|RW_REALIZING|isMeta;\n        cls->setData(rw);\n    }\n\n    ...//一堆方法\n\n    // Attach categories\n    methodizeClass(cls, previously); //添加分类信息\n\n    return cls;\n}\n```\n\n可以看到在处理分类的信息之前，先从类里取出了类信息 ro，然后初始化了 rw，再将 ro 保存到 rw 里。\n\n### method_array_t\nmethods 是用 method_array_t 定义的，method_array_t 是一个 list_array_tt 类型的二维数组，method_array_t 里存储的是数组 method_list_t，数组 method_list_t 里存储的是 method_t：\n```\nclass method_array_t : \n    public list_array_tt<method_t, method_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<method_t, method_list_t> Super;\n\n public:\n    method_array_t() : Super() { }\n    method_array_t(method_list_t *l) : Super(l) { }\n\n    method_list_t * const *beginCategoryMethodLists() const {\n        return beginLists();\n    }\n    \n    method_list_t * const *endCategoryMethodLists(Class cls) const;\n\n    method_array_t duplicate() {\n        return Super::duplicate<method_array_t>();\n    }\n};\n```\n\n如果是类对象，methods 里保存的是对象方法，如果是元类对象，methods 里保存的是类方法。  \n\n### property_array_t\n\nproperties 是用 property_array_t 定义的，property_array_t 是一个 list_array_tt 类型的二维数组，property_array_t 里存储的是数组 property_t，数组 property_t 存储的是 property_t：\n```\nclass property_array_t : \n    public list_array_tt<property_t, property_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<property_t, property_list_t> Super;\n\n public:\n    property_array_t() : Super() { }\n    property_array_t(property_list_t *l) : Super(l) { }\n\n    property_array_t duplicate() {\n        return Super::duplicate<property_array_t>();\n    }\n};\n```\n\n### protocol_array_t\nprotocols 是用 protocol_array_t 定义的，protocol_array_t 是一个 list_array_tt 类型的二维数组，protocol_array_t 里存储的是数组 protocol_ref_t，数组 protocol_ref_t 存储的是 protocol_ref_t：\n```\nclass protocol_array_t : \n    public list_array_tt<protocol_ref_t, protocol_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<protocol_ref_t, protocol_list_t> Super;\n\n public:\n    protocol_array_t() : Super() { }\n    protocol_array_t(protocol_list_t *l) : Super(l) { }\n\n    protocol_array_t duplicate() {\n        return Super::duplicate<protocol_array_t>();\n    }\n};\n```\n\n\n## class_ro_t\nclass_ro_t 里面的 baseMethodList、baseProtocols、ivars、baseProperties 是一维数组，是只读的，包含了类的初始内容。\n```\nstruct class_ro_t {\n    ...... //省略\n\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    \n    ...... //省略\n\n    property_list_t *baseProperties;\n}\n```\n\n![Runtime10](Runtime/Runtime10.png)\n\n### method_list_t、ivar_list_t 和 property_list_t\n```\nstruct method_list_t : entsize_list_tt<method_t, method_list_t, 0x3> {\n    bool isUniqued() const;\n    bool isFixedUp() const;\n    void setFixedUp();\n\n    uint32_t indexOfMethod(const method_t *meth) const {\n        uint32_t i = \n            (uint32_t)(((uintptr_t)meth - (uintptr_t)this) / entsize());\n        ASSERT(i < count);\n        return i;\n    }\n};\n\nstruct ivar_list_t : entsize_list_tt<ivar_t, ivar_list_t, 0> {\n    bool containsIvar(Ivar ivar) const {\n        return (ivar >= (Ivar)&*begin()  &&  ivar < (Ivar)&*end());\n    }\n};\n\nstruct property_list_t : entsize_list_tt<property_t, property_list_t, 0> {\n};\n```\n\n## method_t\nmethod_t 是对方法\\函数的封装。\n```\nusing MethodListIMP = IMP;\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n\n    ...... //省略\n};\n```\n\n![Runtime11](Runtime/Runtime11.png)\n\n### IMP\n`IMP` 代表函数的具体实现：\n![Runtime12](Runtime/Runtime12.png)\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"%s\", __func__); //断点2\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    \n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    \n    [person test]; //断点1\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1打印 imp：\n![Runtime17](Runtime/Runtime17.png)\n\n断点2查看 `-(void)test` 的内存（选择 Debug -> Debug Workflow -> Always Show Disassembly）：\n![Runtime10](Runtime/Runtime18.png)\n\n从打印结果可以看到，imp 指向的内存地址就是 `-(void)test` 方法的内存地址。\n\n### SEL\n`SEL` 代表方法\\函数名，一般叫做选择器，底层结构跟 `char *` 类似。\n![Runtime13](Runtime/Runtime13.png)\n* 可以通过 `@selector()` 和 `sel_registerName()` 获得。\n* 可以通过 `sel_getName()` 和 `NSStringFromSelector()` 转成字符串。\n* 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    //SEL（@selector()）就是字符串\n    NSLog(@\"%s, %s\", \"test\", @selector(test));\n    \n    //可以通过@selector()和sel_registerName()获得\n    SEL sel1 = @selector(test);\n    SEL sel2 = sel_registerName(\"test\");\n    NSLog(@\"sel1：%s, sel2：%s\", sel1, sel2);\n    \n    //可以通过sel_getName()和NSStringFromSelector()转成字符串\n    char *selString1 = sel_getName(sel1);\n    NSString *selString2 = NSStringFromSelector(sel2);\n    NSLog(@\"selString1：%s, selString2：%@\", selString1, selString2);\n    \n    //不同类中相同名字的方法，所对应的方法选择器是相同的\n    NSLog(@\"%p, %p, %p\", @selector(test), @selector(test), sel_registerName(\"test\"));\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\ntest, test\nsel1：test, sel2：test\nselString1：test, selString2：test\n0x7fff5281ed06, 0x7fff5281ed06, 0x7fff5281ed06\n```\n\n### types\ntypes 包含了函数返回值、参数编码的字符串。\n![Runtime14](Runtime/Runtime14.png)\n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行，将 main.m 改成 main.mm：  \n例1：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    \n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    [person test]; //断点1\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1出打印 types：\n![Runtime19](Runtime/Runtime19.png)\n\"v16@0:8\" 是类型编码：`v`：返回值类型 void，`16`：参数占的字节数之和（id（8个字节） + SEL（8个字节）），`@`：第一个参数的类型 id，`0`：第一个参数内存的开始位置，`:`：第二个参数的类型 SEL，`8`：第二个参数内存的开始位置（id 占了8个字节）。  \n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行，将 main.m 改成 main.mm：\n```\n@implementation Person\n// v 16 @ 0 : 8\n//- (void)test:(id)self _cmd:(SEL)_cmd\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n例2：\n```\n@interface Person : NSObject\n- (int)test:(int)age height:(float)height;\n@end\n\n@implementation Person\n- (int)test:(int)age height:(float)height {\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    Person *person = [[Person alloc] init];\n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    [person test:20 height:30]; //断点1\n\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1出打印 types：：\n```\nPrinting description of data->methods->first.types:\n(const char *) types = 0x0000000100087d4d \"i24@0:8i16f20\"\n```\n\n\"i24@0:8i16f20\" 是类型编码：`i`：范围值类型 int，`24`：参数占的字节数之和（id（8个字节） + SEL（8个字节）+ int（4个字节）+ float（4个字节）），`@`：第一个参数的类型 id，`0`：第一个参数内存的开始位置，`:`：第二个参数的类型 SEL，`8`：第二个参数内存的开始位置（id 占了8个字节），`i`：第三个参数的类型 int，`16`：第三个参数的开始位置（id 占了8个字节 + SEL 占了8个字节），`f`：第四个参数的类型 float，`20`：第四个参数的开始位置（id 占了8个字节 + SEL 占了8个字节 + int 占了4个字节）。\n```\n@implementation Person\n// i 24 @ 0 : 8 i 16 f 20\n// int test:(id self, SEL _cmd, int age, float height)\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n### Type Encoding\n[Type Encodings](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html) 是 iOS 中提供的一个叫做 @encode 的指令，可以将具体的类型表示成字符串编码。  \n![Runtime15](Runtime/Runtime15.png)\n\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    NSLog(@\"id == %s，SEL == %s\", @encode(id), @encode(SEL));\n\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n id == @，SEL == :\n```\n\n## 方法缓存\nClass 内部结构中有个方法缓存 cache（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。\n![Runtime16](Runtime/Runtime16.png)\n\n缓存查找：objc-cache.mm -> `bucket_t * cache_t::find(cache_key_t k, id receiver)`\n\ncache_t 里通过 _buckets 缓存方法，通过 _mask 计算索引，通过 _occupied 统计已经缓存的方法的数量。_buckets 里缓存的是 bucke_t 结构体：\n```\n_key = @selector(方法名)\n_imp = 方法的函数地址\n```\n\n### _mask\n_mask 的值是散列表的长度-1，保证“与”运算的结果不会超出散列表的长度（&_mask <= _mask），即计算出的索引不会越界。\n\n假设 _mask = 0b0000 1000：\n```\n  0b0100 1101\n& 0b0000 1000\n--------------\n  0b0000 1000\n```\n\n散列表（哈希表）的实现逻辑：  \n1、实现一个方法1可以计算出索引；  \n2、实现一个方法2可以解决索引冲突（如：对索引减 1 计算出新的索引值）；\n\n使用求余 `%` 也可以实现散列表（哈希表），通过求余计算出的索引也可以保证不越界。\n\n### _buckets\n_buckets 在初始化时的空间大小是指定好的，并且内部的数据都是 NULL（空间换时间）。如果 _buckets 里的数据满了，_buckets 会将数据清空 -> 扩容x2（一倍）-> 重新缓存。\n\n先通过 `mask_t begin = cache_hash(sel, m)` 计算出索引 begin：  \n如果 begin 处没有值，缓存。  \n如果 begin 处有值，是当前需要缓存的方法，表示已经缓存过了直接返回。  \n如果 begin 处有值，不是当前需要缓存的方法，通过 `(i = cache_next(i, m)` 计算出新的索引，如果新的索引不等于 begin 则重新判断，如果新的索引等于 begin 则去扩容（bad_cache()）。\n```\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{\n    ...... //省略\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = occupied() + 1; //occupied() 散列表长度，newOccupied 添加后的长度\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) { //第一次\n        // Cache is read-only. Replace it.\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) { //已经缓存的数据不足3/4\n        // Cache is less than 3/4 full. Use it as-is.\n    }\n    else {\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE; //扩容x2\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true); //清空数据 -> 扩容\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m); //计算出索引\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    do {\n        if (fastpath(b[i].sel() == 0)) { //如果 begin 处没有值，缓存\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls);\n            return;\n        }\n        if (b[i].sel() == sel) { //索引处有值，是当前需要缓存的方法\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin)); //计算出新的索引，判断新的索引是否等于 begin，如果等于 begin 则重新判断，如果不等于 begin 则调用 bad_cache() 处理异常缓存\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n\n...... //省略\n\nvoid cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld)\n{\n    bucket_t *oldBuckets = buckets(); //旧的散列表\n    bucket_t *newBuckets = allocateBuckets(newCapacity); //新的散列表\n\n    // Cache's old contents are not propagated. \n    // This is thought to save cache memory at the cost of extra cache fills.\n    // fixme re-measure this\n\n    ASSERT(newCapacity > 0);\n    ASSERT((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1);\n\n    setBucketsAndMask(newBuckets, newCapacity - 1); //使用新的散列表，_mask = newCapacity - 1\n    \n    if (freeOld) {\n        cache_collect_free(oldBuckets, oldCapacity); //清空旧的数据\n    }\n}\n```\n\n`__arm64__` 下的 cache_next 方法：\n```\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return i ? i-1 : mask;\n}\n```\n\n### 空间换时间\n散列表（哈希表）遍历元素的效率比数组高的原因是牺牲了一定的空间换取了时间。  \n#### 例1：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n\n        [person testPerson];\n        [person testPerson];\n\n        NSLog(@\"--------\"); //断点\n\n        cache_t cache = cls->cache;\n        bucket_t *buckets = cache._buckets;\n        for (int i = 0; i <= cache._mask; i++) {\n            bucket_t bucket = buckets[i];\n            if (bucket._key && bucket._key > 10) {\n                NSLog(@\"%s %p\", bucket._key, bucket._imp);\n            } else {\n                NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n--------\ninit 0x7ffe558b5aa\ntestPerson 0xc5e8\n0 0x0\n1 0x600000781640\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime20](Runtime/Runtime20.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | bucket_t（_key = @selector(init), _imp）\n1  | bucket_t（_key = @selector(testPerson), _imp）\n2  | NULL\n3  | NULL\n\n第一次调用 `[person testPerson]` 即 `objc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"testPerson\"))` 向 person 实例对象发送一条 `sel_registerName(\"testPerson\")` 消息，person 会通过 isa 找到 Person 类对象查找 `-(void)testPerson` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，查到后返回。（如果没有找到，再通过 superclass 找到父类的类对象继续查找（查找方式相同）。假设在查找到基类的类对象时找到了 `-(void)testPerson` 方法，实列对象 person 会把 `-(void)testPerson` 方法缓存到 _buckets 里然后返回。）\n\n在缓存 `@selector(testPerson)` 方法时，先计算出索引（1），然后检查索引处是否有值，没值，将 `@selector(testPerson)` 缓存到对象的索引处。\n\n第二次调用 `[person testPerson]` 会先去实例对象 person 的 _buckets 里找，找到对应的索引处的值判断是否是当前方法 `@selector(testPerson)`，如果是就直接返回。（如果不是就将索引减 1 继续在 _buckets 里查找，找到了就直接返回。如果找了一圈还没有找到，会同第一次一样去类对象和父类的类对象查找，找到后缓存到 _buckets 里并返回。）\n\n#### 例2：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n\n        [person testPerson];\n        [person testPerson];\n        [person testStudent];\n        [person testStudent2];\n\n        NSLog(@\"--------\"); //断点\n\n        cache_t cache = cls->cache;\n        bucket_t *buckets = cache._buckets;\n        for (int i = 0; i <= cache._mask; i++) {\n            bucket_t bucket = buckets[i];\n            if (bucket._key && bucket._key > 10) {\n                NSLog(@\"%s %p\", bucket._key, bucket._imp);\n            } else {\n                NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n--------\ntestStudent2 0xc5\n0 0x0\n0 0x0\ntestStudent 0xc5d\n0 0x0\n0 0x0\n0 0x0\n1 0x600001008500\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime21](Runtime/Runtime21.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | bucket_t（_key = @selector(testStudent2), _imp）\n1  | NULL\n2  | NULL\n3  | bucket_t（_key = @selector(testStudent), _imp）\n4  | NULL\n5  | NULL\n6  | NULL\n7  | NULL\n\n在缓存 `@selector(testStudent)` 方法时，_buckets 的空间不够了，_buckets 清空数据 -> 扩容x2（8） -> 重新缓存。先计算出索引（3），然后检查索引处是否有值，没值，将 `@selector(testPerson)` 缓存到对象的索引处。\n\n在缓存 `@selector(testStudent2)` 方法时，先计算出索引（0），然后检查索引处是否有值，没值，将 `@selector(testStudent2)` 缓存到对象的索引处。（如果索引值与 `@selector(testStudent)` 相同（3），检查到索引处有值，然后将索引减 1 获取到新的索引（2），再检查新的索引处是否有值，没值，将 `@selector(testStudent2)` 缓存到对象的索引处。）\n\n#### 例3\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    Teacher *teacher = [[Teacher alloc] init];\n    test_objc_class *teacherClass = (__bridge test_objc_class *)[Teacher class];\n\n    [teacher teacherTest];\n    [teacher studentTest];\n    [teacher personTest];\n\n    NSLog(@\"--------\"); //断点\n\n    cache_t cache = teacherClass->cache;\n    bucket_t *buckets = cache._buckets;\n    for (int i = 0; i <= cache._mask; i++) {\n        bucket_t bucket = buckets[i];\n        if (bucket._key && bucket._key > 1) {\n            NSLog(@\"%s %p\", bucket._key, bucket._imp);\n        } else {\n            NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n        }\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n0 0x0\nstudentTest 0x5aa\n0 0x0\n0 0x0\n0 0x0\npersonTest 0x44c8\n0 0x0\n1 0x6000025f8380\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime22](Runtime/Runtime22.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | NULL\n1  | bucket_t（_key = @selector(studentTest), _imp）\n2  | NULL\n3  | NULL\n4  | NULL\n5  | bucket_t（_key = @selector(personTest), _imp）\n6  | NULL\n7  | NULL\n\n调用 `[teacher teacherTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"teacherTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"teacherTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找 `-(void)teacherTest` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，查到后缓存到 _buckets 里并返回。\n\n调用 `[teacher studentTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"studentTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"studentTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找 `-(void)studentTest` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，没查到。 Teacher 类对象通过 superclass 找到父类 Student 类对象，并在 Student 类对象的 _buckets 里查找，没找到，再通过到 class_rw_t 里查找，查到后缓存到 Teacher 类对象的 _buckets 里并返回。\n\n调用 `[teacher personTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"personTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"personTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找，先查找 _buckets，没查到，再到 class_rw_t 里的方法列表 methods 查找，没查到。Teacher 类对象会通过 superclass 找到父类 Student 类对象，并在 Student 类对象的 _buckets 里查找，没找到，再到 class_rw_t 里查找，没查到。 Student 类对象会通过 superclass 找到父类 Person 类对象，并在 Person 类对象的 _buckets 里查找，没查到，再到 class_rw_t 里查找，查到后缓存到 Teacher 类对象的 _buckets 里并返回。\n\n#### 小结\n1. 先查当前类对象的缓存 _buckets，再查当前类对象的方法列表 class_rw_t -> methods;\n2. 先查父类类对象的缓存 _buckets，再查父类类对象的方法列表 class_rw_t -> methods;\n3. 在当前类对象的缓存 _buckets 里查到后直接返回；\n4. 在当前类对象的方法列表 class_rw_t -> methods 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n5. 在父类类对象的缓存 _buckets 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n5. 在父类类对象的方法列表 class_rw_t -> methods 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n\n# objc_msgSend\nOC 中的方法调用，其实都是转换为 objc_msgSend 函数的调用。objc_msgSend 的执行流程可以分为三大阶段，即消息发送、动态方法解析和消息转发。\n\n## objc_msgSend 执行流程\n\n_objc_msgSend 的入口在汇编文件 objc-msg-arm64.s 里。runtime 的实现是用 c、c++ 和汇编语言组成的，对于一些调用频次比较高的方法一般使用汇编语言实现。对于 _objc_msgSend 等方法，为了提高效率都是使用汇编语言实现的。\n\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 _objc_msgSend 的实现。  \n\n### _objc_msgSend\n\nENTRY 的定义，ENTRY 是一个宏：\n```\n//macro 是宏的意思\n.macro ENTRY /* name */\n\t.text         //数据段\n\t.align 5\n\t.globl    $0  //全局名字\n$0:\n.endmacro\n```\n\n_objc_msgSend 的定义，从 ENTRY 开始，到 END_ENTRY 结束：\n```\nENTRY _objc_msgSend\n    //---------------------------- 消息发送 start ----------------------------\n\tUNWIND _objc_msgSend, NoFrame\n        //p0寄存器：消息接受者，receiver（_objc_msgSend 的第一个参数）\n\tcmp\tp0, #0\t\t\t// nil check and tagged pointer check\n#if SUPPORT_TAGGED_POINTERS\n        //b：跳转、调用。le：小于等于。如果 p0 小于等于 0，就跳转到 LNilOrTagged 方法（如果消息接收者是 nil 就跳转到 LNilOrTagged）\n\tb.le\tLNilOrTagged\t\t//  (MSB tagged pointer looks negative)\n#else\n\tb.eq\tLReturnZero\n#endif\n\tldr\tp13, [x0]\t\t// p13 = isa\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\nLGetIsaDone:\n\t// calls imp or objc_msgSend_uncached\n\tCacheLookup NORMAL, _objc_msgSend //查找缓存，参数 NORMAL。（实现👇）\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n        // 跳转到 LReturnZero 方法\n\tb.eq\tLReturnZero\t\t// nil check\n\n\t// tagged\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret //相当于 c 语言的 return\n\n\tEND_ENTRY _objc_msgSend\n```\n\n_objc_msgSend 涉及相关方法的实现\n```\n//👉 CacheLookup 的实现，查找缓存（在当前类对象的 cache 中查找）\n.macro CacheLookup\n\t//\n\t// Restart protocol:\n\t//\n\t//   As soon as we're past the LLookupStart$1 label we may have loaded\n\t//   an invalid cache pointer or mask.\n\t//\n\t//   When task_restartable_ranges_synchronize() is called,\n\t//   (or when a signal hits us) before we're past LLookupEnd$1,\n\t//   then our PC will be reset to LLookupRecover$1 which forcefully\n\t//   jumps to the cache-miss codepath which have the following\n\t//   requirements:\n\t//\n\t//   GETIMP:\n\t//     The cache-miss is just returning NULL (setting x0 to 0)\n\t//\n\t//   NORMAL and LOOKUP:\n\t//   - x0 contains the receiver\n\t//   - x1 contains the selector\n\t//   - x16 contains the isa\n\t//   - other registers are set as per calling conventions\n\t//\nLLookupStart$1:\n\n\t// p1 = SEL, p16 = isa\n\tldr\tp11, [x16, #CACHE]\t\t\t\t// p11 = mask|buckets\n\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tand\tp10, p11, #0x0000ffffffffffff\t// p10 = buckets (缓存)\n\tand\tp12, p1, p11, LSR #48\t\t// x12 = _cmd & mask (通过“与”运算计算索引)\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tand\tp10, p11, #~0xf\t\t\t// p10 = buckets\n\tand\tp11, p11, #0xf\t\t\t// p11 = maskShift\n\tmov\tp12, #0xffff\n\tlsr\tp11, p12, p11\t\t\t\t// p11 = mask = 0xffff >> p11\n\tand\tp12, p1, p11\t\t\t\t// x12 = _cmd & mask\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp (查找到函数地址，调用或者返回。hit：命中，找到。)\n\t\n2:\t// not hit: p12 = not-hit bucket（没有查找到）\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0 (实现👇)\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tadd\tp12, p12, p11, LSR #(48 - (1+PTRSHIFT))\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tadd\tp12, p12, p11, LSL #(1+PTRSHIFT)\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\nLLookupEnd$1:\nLLookupRecover$1:\n3:\t// double wrap\n\tJumpMiss $0\n\n.endmacro\n\n...... //省略\n\n//👉 CheckMiss 的实现\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL //调用 CacheLookup 时传入的参数是 NORMAL\n\tcbz\tp9, __objc_msgSend_uncached //调用 __objc_msgSend_uncached 方法（实现👇）\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n\n.macro JumpMiss\n.if $0 == GETIMP\n\tb\tLGetImpMiss\n.elseif $0 == NORMAL\n\tb\t__objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tb\t__objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n\n...... //省略\n\n//👉 __objc_msgSend_uncached 的实现\nSTATIC_ENTRY __objc_msgSend_uncached\nUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\n// THIS IS NOT A CALLABLE C FUNCTION\n// Out-of-band p16 is the class to search\n\nMethodTableLookup //查找方法列表（实现👇）\nTailCallFunctionPointer x17\n\nEND_ENTRY __objc_msgSend_uncached\n\n...... //省略\n\n//👉 MethodTableLookup 的实现\n.macro MethodTableLookup\n\t\n\t// push frame\n\tSignLR\n\tstp\tfp, lr, [sp, #-16]!\n\tmov\tfp, sp\n\n\t// save parameter registers: x0..x8, q0..q7\n\tsub\tsp, sp, #(10*8 + 8*16)\n\tstp\tq0, q1, [sp, #(0*16)]\n\tstp\tq2, q3, [sp, #(2*16)]\n\tstp\tq4, q5, [sp, #(4*16)]\n\tstp\tq6, q7, [sp, #(6*16)]\n\tstp\tx0, x1, [sp, #(8*16+0*8)]\n\tstp\tx2, x3, [sp, #(8*16+2*8)]\n\tstp\tx4, x5, [sp, #(8*16+4*8)]\n\tstp\tx6, x7, [sp, #(8*16+6*8)]\n\tstr\tx8,     [sp, #(8*16+8*8)]\n\n        // 这条注释可以看到在调用 lookUpImpOrForward 函数时的参数    \n\t// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)\n\t// receiver and selector already in x0 and x1\n\tmov\tx2, x16\n\tmov\tx3, #3\n\tbl\t_lookUpImpOrForward //_lookUpImpOrForward 方法返回的是函数地址 imp，bl imp：跳转\\调用imp。（实现👇）\n\n\t// IMP in x0\n\tmov\tx17, x0\n\t\n\t// restore registers and return\n\tldp\tq0, q1, [sp, #(0*16)]\n\tldp\tq2, q3, [sp, #(2*16)]\n\tldp\tq4, q5, [sp, #(4*16)]\n\tldp\tq6, q7, [sp, #(6*16)]\n\tldp\tx0, x1, [sp, #(8*16+0*8)]\n\tldp\tx2, x3, [sp, #(8*16+2*8)]\n\tldp\tx4, x5, [sp, #(8*16+4*8)]\n\tldp\tx6, x7, [sp, #(8*16+6*8)]\n\tldr\tx8,     [sp, #(8*16+8*8)]\n\n\tmov\tsp, fp\n\tldp\tfp, lr, [sp], #16\n\tAuthenticateLR\n\n.endmacro\n```\n\n### _lookUpImpOrForward\n👉 \\_lookUpImpOrForward 的实现在 objc-runtime-new.mm 文件。老版本的 runtime 源码在这里调用的是 `__class_lookupMethodAndLoadCache3`，`_class_lookupMethodAndLoadCache3` 函数里调用的才是 lookUpImpOrForward：\n```\nIMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) {\n    return lookUpImpOrForward(cls, sel, obj, YES/*initalize*/, NO/*cache*/, YES/*reslover*/);\n}\n```\n\n\\_lookUpImpOrForward 是一个通过 c 语言实现的函数（对于函数名，汇编语言转 c 语言需要去掉一个“`_`”）。\n```\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache; //默认消息转发（实现👇）\n    IMP imp = nil;\n    Class curClass;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) { //传入的 behavior 是 LOOKUP_INITIALIZE | LOOKUP_RESOLVER，条件不成立\n        imp = cache_getImp(cls, sel); //在缓存里查找\n        if (imp) goto done_nolock; //跳转到 done_nolock 方法\n    }\n\n    // runtimeLock is held during isRealized and isInitialized checking\n    // to prevent races against concurrent realization.\n\n    // runtimeLock is held during method search to make\n    // method-lookup + cache-fill atomic with respect to method addition.\n    // Otherwise, a category could be added but ignored indefinitely because\n    // the cache was re-filled with the old value after the cache flush on\n    // behalf of the category.\n\n    runtimeLock.lock();\n\n    // We don't want people to be able to craft a binary blob that looks like\n    // a class but really isn't one and do a CFI attack.\n    //\n    // To make these harder we want to make sure this is a class that was\n    // either built into the binary or legitimately registered through\n    // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.\n    //\n    // TODO: this check is quite costly during process startup.\n    checkIsKnownClass(cls);\n\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n    }\n\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n\n        // If sel == initialize, class_initialize will send +initialize and \n        // then the messenger will send +initialize again after this \n        // procedure finishes. Of course, if this is not being called \n        // from the messenger then it won't happen. 2778172\n    }\n\n    runtimeLock.assertLocked();\n    curClass = cls;\n\n    // The code used to lookpu the class's cache again right after\n    // we take the lock but for the vast majority of the cases\n    // evidence shows this is a miss most of the time, hence a time loss.\n    //\n    // The only codepath calling into this without having performed some\n    // kind of cache lookup is class_getInstanceMethod().\n\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.（curClass 的方法列表）\n        // for 循环第一次时，curClass 代表当前类\n        // for 循环非第一次时，curClass 代表父类\n        Method meth = getMethodNoSuper_nolock(curClass, sel); //到 curClass 的方法列表里面找（实现👇）\n        if (meth) { //如果找到了\n            imp = meth->imp; //取出方法的函数地址\n            goto done; //跳转到 done 方法\n        }\n        \n        // 执行 curClass = curClass->superclass，找到更上层父类，并判断新赋值的 curClass 是否为 nil（通过 for 循环重复执行，遍历父类）\n        if (slowpath((curClass = curClass->superclass) == nil)) { \n            // No implementation found, and method resolver didn't help.\n            // Use forwarding.\n            imp = forward_imp; //如果新赋值的 curClass 为 nil，说明没有更上层父类了，则设置 imp = forward_imp（消息转发）\n            break; //跳出 for 循环\n        }\n\n        // Halt if there is a cycle in the superclass chain.\n        if (slowpath(--attempts == 0)) { //判断 attempts - 1 后是否等于 0\n            _objc_fatal(\"Memory corruption in class list.\"); //如果等于 0 报错\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel); //到父类的缓存里查找（此时 curClass 代表父类）\n        \n        if (slowpath(imp == forward_imp)) {\n            // Found a forward:: entry in a superclass.\n            // Stop searching, but don't cache yet; call method\n            // resolver for this class first.\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done; //如果在父类的缓存里找到了，跳转到 done 方法\n        }\n    }\n    //---------------------------- 消息发送 end ----------------------------\n\n    //---------------------------- 动态方法解析 start ----------------------------\n    // No implementation found. Try method resolver once.\n    \n    if (slowpath(behavior & LOOKUP_RESOLVER)) { //behavior 里是否包含 LOOKUP_RESOLVER，判断是否有过动态方法解析了（传入的 behavior 是 LOOKUP_INITIALIZE | LOOKUP_RESOLVER）\n        behavior ^= LOOKUP_RESOLVER; //再加一个 LOOKUP_RESOLVER（动态方法解析执行完成后，会再走一遍 lookUpImpOrForward，保证只操作一次动态方法解析）\n        return resolveMethod_locked(inst, sel, cls, behavior); //实现👇\n    }\n    //---------------------------- 动态方法解析 end ----------------------------\n\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass); //将从 curClass 类里找到的函数地址 imp 填充到 cls（objc_msgSend的接收者）的缓存里（实现👇）\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp; //返回函数地址\n}\n```\n\n消息发送相关方法实现\n```\n//👉 getMethodNoSuper_nolock 的实现\nstatic method_t *\ngetMethodNoSuper_nolock(Class cls, SEL sel)\n{\n    runtimeLock.assertLocked();\n\n    ASSERT(cls->isRealized());\n    // fixme nil cls? \n    // fixme nil sel?\n\n    auto const methods = cls->data()->methods(); //cls->data() 返回到是 class_rw_t，即 class_rw_t->methods()\n    for (auto mlists = methods.beginLists(),\n              end = methods.endLists();\n         mlists != end;\n         ++mlists)\n    {\n        // <rdar://problem/46904873> getMethodNoSuper_nolock is the hottest\n        // caller of search_method_list, inlining it turns\n        // getMethodNoSuper_nolock into a frame-less function and eliminates\n        // any store from this codepath.\n        method_t *m = search_method_list_inline(*mlists, sel); //到方法列表里查找（实现👇）\n        if (m) return m;\n    }\n\n    return nil;\n}\n\n...... //省略\n\n//👉 search_method_list_inline 的实现\nstatic method_t *\nsearch_method_list_inline(const method_list_t *mlist, SEL sel)\n{\n    int methodListIsFixedUp = mlist->isFixedUp();\n    int methodListHasExpectedSize = mlist->entsize() == sizeof(method_t);\n    \n    if (fastpath(methodListIsFixedUp && methodListHasExpectedSize)) { //是否是排好序的方法列表\n        return findMethodInSortedMethodList(sel, mlist); //在已经排好序的方法列表里面查找（二分查找）（实现👇）\n    } else {\n        // 在没有排好序的方法列表里遍历查找\n        // Linear search of unsorted method list\n        for (auto& meth : *mlist) { \n            if (meth.name == sel) return &meth;\n        }\n    }\n\n#if DEBUG\n    // sanity-check negative results\n    if (mlist->isFixedUp()) {\n        for (auto& meth : *mlist) {\n            if (meth.name == sel) {\n                _objc_fatal(\"linear search worked when binary search did not\");\n            }\n        }\n    }\n#endif\n\n    return nil;\n}\n\n...... //省略\n\n//👉 findMethodInSortedMethodList 的实现\nALWAYS_INLINE static method_t *\nfindMethodInSortedMethodList(SEL key, const method_list_t *list)\n{\n    ASSERT(list);\n\n    const method_t * const first = &list->first;\n    const method_t *base = first;\n    const method_t *probe;\n    uintptr_t keyValue = (uintptr_t)key;\n    uint32_t count;\n    //二分查找\n    for (count = list->count; count != 0; count >>= 1) {\n        probe = base + (count >> 1);\n        \n        uintptr_t probeValue = (uintptr_t)probe->name;\n        \n        if (keyValue == probeValue) {\n            // `probe` is a match.\n            // Rewind looking for the *first* occurrence of this value.\n            // This is required for correct category overrides.\n            while (probe > first && keyValue == (uintptr_t)probe[-1].name) {\n                probe--;\n            }\n            return (method_t *)probe;\n        }\n        \n        if (keyValue > probeValue) {\n            base = probe + 1;\n            count--;\n        }\n    }\n    \n    return nil;\n}\n\n...... //省略\n\n//👉 log_and_fill_cache 的实现\nstatic void\nlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)\n{\n#if SUPPORT_MESSAGE_LOGGING\n    if (slowpath(objcMsgLogEnabled && implementer)) {\n        bool cacheIt = logMessageSend(implementer->isMetaClass(), \n                                      cls->nameForLogging(),\n                                      implementer->nameForLogging(), \n                                      sel);\n        if (!cacheIt) return;\n    }\n#endif\n    cache_fill(cls, sel, imp, receiver); //填充到缓存\n}\n\n//cache_fill 的实现在 objc-cache.mm 文件\nvoid cache_fill(Class cls, SEL sel, IMP imp, id receiver)\n{\n    runtimeLock.assertLocked();\n\n#if !DEBUG_TASK_THREADS\n    // Never cache before +initialize is done\n    if (cls->isInitialized()) {\n        cache_t *cache = getCache(cls);\n#if CONFIG_USE_CACHE_LOCK\n        mutex_locker_t lock(cacheUpdateLock);\n#endif\n        cache->insert(cls, sel, imp, receiver); //填充到缓存的具体实现（实现👇）\n    }\n#else\n    _collecting_in_critical();\n#endif\n}\n\n...... //省略\n\n//👉 cache_t::insert 的实现\nALWAYS_INLINE\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{\n#if CONFIG_USE_CACHE_LOCK\n    cacheUpdateLock.assertLocked();\n#else\n    runtimeLock.assertLocked();\n#endif\n\n    ASSERT(sel != 0 && cls->isInitialized());\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = occupied() + 1;\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) { //判断添加后的剩余空间\n        // Cache is less than 3/4 full. Use it as-is.\n    }\n    else { //扩容x2\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true);\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m); //计算索引\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    do {\n        if (fastpath(b[i].sel() == 0)) { //索引处没有方法\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls); //添加到缓存中对应的索引处\n            return;\n        }\n        if (b[i].sel() == sel) {  //索引处有方法并且是同一个方法，表示已经存储过了，返回\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin)); //重新计算索引（当前索引减 1），判断是否查了一圈了\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n```\n\n### resolveMethod_locked()\n动态方法解析相关方法实现\n```\n//👉 resolveMethod_locked 的实现\nstatic NEVER_INLINE IMP\nresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)\n{\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n\n    runtimeLock.unlock();\n\n    if (! cls->isMetaClass()) { \n        // 不是元类对象\n        // try [cls resolveInstanceMethod:sel]\n        resolveInstanceMethod(inst, sel, cls); //实现👇\n    } \n    else {\n        // 是元类对象\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n        resolveClassMethod(inst, sel, cls); //实现👇\n        if (!lookUpImpOrNil(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls); //实现👇\n        }\n    }\n\n    // chances are that calling the resolver have populated the cache\n    // so attempt using it\n    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE); //动态方法解析相关方法调用完成后，会再走一遍 lookUpImpOrForward 方法，即消息发送的第二步（实现👆）\n}\n\n//👉 resolveInstanceMethod 的实现\nstatic void resolveInstanceMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    SEL resolve_sel = @selector(resolveInstanceMethod:);\n\n    if (!lookUpImpOrNil(cls, resolve_sel, cls->ISA())) {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, resolve_sel, sel); //让 cls 调用 resolve_sel 方法\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNil(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n\n//👉 resolveClassMethod 的实现\nstatic void resolveClassMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    ASSERT(cls->isMetaClass());\n\n    if (!lookUpImpOrNil(inst, @selector(resolveClassMethod:), cls)) {\n        // Resolver not implemented.\n        return;\n    }\n\n    Class nonmeta;\n    {\n        mutex_locker_t lock(runtimeLock);\n        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);\n        // +initialize path should have realized nonmeta already\n        if (!nonmeta->isRealized()) {\n            _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\",\n                        nonmeta->nameForLogging(), nonmeta);\n        }\n    }\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveClassMethod adds to self->ISA() a.k.a. cls\n    IMP imp = lookUpImpOrNil(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n### __objc_msgForward_impcache\n消息转发相关方法的实现\n👉 __objc_msgForward_impcache 方法的实现在汇编文件 objc-msg-arm64.s\n```\n\tSTATIC_ENTRY __objc_msgForward_impcache\n\n\t// No stret specialization.\n\tb\t__objc_msgForward\n\n\tEND_ENTRY __objc_msgForward_impcache\n\n\t\n\tENTRY __objc_msgForward\n\n\tadrp\tx17, __objc_forward_handler@PAGE\n\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF] //实现👇\n\tTailCallFunctionPointer x17\n\t\n\tEND_ENTRY __objc_msgForward\n```\n\n👉 _objc_forward_handler 的实现在 C 语言文件 objc-runtime.mm。\n```\n#if !__OBJC2__\n\n// Default forward handler (nil) goes to forward:: dispatch.\nvoid *_objc_forward_handler = nil;\nvoid *_objc_forward_stret_handler = nil;\n\n#else\n\n// Default forward handler halts the process.\n__attribute__((noreturn, cold)) void\nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n```\n\n这里的 _objc_forward_handler 指针存储的是 objc_defaultForwardHandler 的函数地址。因为 _objc_forward_handler 没有开源，所以看不到其具体的内部实现，即无法知道该方法在消息转发阶段具体做了什么。在报错信息里可以看到消息转发最后调用了 `__forwarding__` 方法：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n报错信息：\n![Runtime26](Runtime/Runtime26.png)\n\n通过反编译可以看到 _objc_forward_handler 的具体实现，这里有一份根据汇编代码翻译成的 C 语言伪代码 `__forwarding__.c`：\n```\n// 伪代码\nint __forwarding__(void *frameStackPointer, int isStret) {\n    id receiver = *(id *)frameStackPointer;\n    SEL sel = *(SEL *)(frameStackPointer + 8);\n    const char *selName = sel_getName(sel);\n    Class receiverClass = object_getClass(receiver);\n\n    // 调用 forwardingTargetForSelector:\n    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {\n        id forwardingTarget = [receiver forwardingTargetForSelector:sel]; //实例对象 - 对象方法，类对象 - 类方法\n        if (forwardingTarget && forwardingTarget != receiver) {\n            if (isStret == 1) {\n                int ret;\n                objc_msgSend_stret(&ret,forwardingTarget, sel, ...);\n                return ret;\n            }\n            return objc_msgSend(forwardingTarget, sel, ...); //返回值 forwardingTarget 调用方法\n        }\n    }\n\n    // 僵尸对象\n    const char *className = class_getName(receiverClass);\n    const char *zombiePrefix = \"_NSZombie_\";\n    size_t prefixLen = strlen(zombiePrefix); // 0xa\n    if (strncmp(className, zombiePrefix, prefixLen) == 0) {\n        CFLog(kCFLogLevelError,\n              @\"*** -[%s %s]: message sent to deallocated instance %p\",\n              className + prefixLen,\n              selName,\n              receiver);\n        <breakpoint-interrupt>\n    }\n\n    // 调用 methodSignatureForSelector 获取类型编码后再调用 forwardInvocation\n    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {\n        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; //实例对象 - 对象方法，类对象 - 类方法\n        if (methodSignature) {\n            BOOL signatureIsStret = [methodSignature _frameDescriptor]->returnArgInfo.flags.isStruct;\n            if (signatureIsStret != isStret) {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.\",\n                      selName,\n                      signatureIsStret ? \"\" : not,\n                      isStret ? \"\" : not);\n            }\n            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {\n                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];\n\n                [receiver forwardInvocation:invocation];\n\n                void *returnValue = NULL;\n                [invocation getReturnValue:&value];\n                return returnValue;\n            } else {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\",\n                      receiver,\n                      className);\n                return 0;\n            }\n        }\n    }\n\n    SEL *registeredSel = sel_getUid(selName);\n\n    // selector 是否已经在 Runtime 注册过\n    if (sel != registeredSel) {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\",\n              sel,\n              selName,\n              registeredSel);\n    } // doesNotRecognizeSelector\n    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {\n        [receiver doesNotRecognizeSelector:sel];\n    }\n    else {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\",\n              receiver,\n              className);\n    }\n\n    // The point of no return.\n    kill(getpid(), 9);\n}\n```\n\n## 消息发送\n![Runtime23](Runtime/Runtime23.png)\n\n* receiver 通过 isa 指针找到 receiverClass，receiverClass 通过superclass 指针找到 superClass\n* 如果是从class_rw_t中查找方法  \n已经排序的，二分查找  \n没有排序的，遍历查找\n\n流程解析：\n1. 首先判断 receiver 是否为空，如果 receiver 为空直接退出，如果 receiver 不为空则到 receiverClass 的 cache 中查找方法；  \n2. 从 receiverClass 的 cache 中查找方法，找到了方法，则调用方法结束查找。没找到方法，则从 receiverClass 的 class_rw_t 中查找方法；\n3. 从 receiverClass 的 class_rw_t 中查找方法，找到了方法，则将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没有找到方法，则从 superclass 的 cache 中查找方法；\n4. 从 superclass 的 cache 中查找方法，找到了方法，将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没找到方法，则从 superclass 的 class_rw_t 中查找方法；\n5. 从 superclass 的 class_rw_t 中查找方法，找到了方法，则将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没有找到方法，则判断上层是否还有 superclass；\n6. 判断上层是否还有 superclass，有，则回到第4步。没有，则开始动态方法解析；\n\n## 动态方法解析\n![Runtime24](Runtime/Runtime24.png)\n* 开发者可以实现以下方法，来动态添加方法实现\n```\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n+ (BOOL)resolveClassMethod:(SEL)sel;\n```\n* 动态解析过后，会重新走“消息发送”的流程（“从 receiverClass的cache 中查找方法”这一步开始执行）\n\n### 动态添加对象方法\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        Method method = class_getInstanceMethod(self, @selector(other));\n        //动态添加方法\n        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Person other]\n```\n\nMethod 是指向结构体 method_t 的指针，即 struct objc_method == struct method_t，所以 `class_getInstanceMethod(self, @selector(other))` 返回的是结构体 method_t。Method 的定义：\n```\ntypedef struct objc_method *Method;\n```\n\n证明：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\nstruct method_t {\n    SEL sel;\n    char *types;\n    IMP imp;\n};\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        struct method_t *method = (struct method_t *)class_getInstanceMethod(self, @selector(other));\n        NSLog(@\"%s %s %p\", method->sel, method->types, method->imp);\n        //动态添加方法\n        class_addMethod(self, sel, method->imp, method->types);\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nother v16@0:8 0x100000b40\n-[Person other]\n```\n\n### 动态添加C语言函数\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\nvoid c_other(id self, SEL _cmd)\n{\n    NSLog(@\"c_other - %@ - %@\", self, NSStringFromSelector(_cmd));\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //动态添加方法，C语言的函数地址==函数名，函数编码\"v16@0:8\"（也可以写成 v@:）\n        class_addMethod(self, sel, (IMP)c_other, \"v16@0:8\");\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n### 动态添加类方法\n```\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (BOOL)resolveClassMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        Method method = class_getClassMethod(self, @selector(other));\n        //动态添加方法\n        class_addMethod(object_getClass(self), sel, method_getImplementation(method), method_getTypeEncoding(method));\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Person other]\n```\n\n\n## 消息转发\n![Runtime25](Runtime/Runtime25.png)\n* 开发者可以在 forwardInvocation: 方法中自定义任何逻辑\n* 以上方法都有对象方法、类方法2个版本（前面可以是加号+，也可以是减号-）\n\n### 对象方法的消息转发\n\n#### -forwardingTargetForSelector: 方法\n`-forwardingTargetForSelector:` 方法有返回值时，返回值调用方法：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return [[Student alloc] init];\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n#### -methodSignatureForSelector: 方法\n\n`-forwardingTargetForSelector:` 方法没有返回值时，会调用 `-methodSignatureForSelector:` 方法获取类型编码：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n//类型编码：返回值类型、参数类型\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]; //也可以写成 v@:\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    /*\n     anInvocation.target = [[Student alloc] init];\n     [anInvocation invoke]; //调用\n     */\n    [anInvocation invokeWithTarget:[[Student alloc] init]]; //传入 Target 调用\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n如果 `-methodSignatureForSelector:` 方法没有返回类型编码，则会报错：\n![Runtime27](Runtime/Runtime27.png)\n\n从调用栈可以看到停留在了 `doesNotRecognizeSelector:` 方法：\n![Runtime28](Runtime/Runtime28.png)\n\n类型编码的另一种返回方式：\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test:)) {\n        return [[[Student alloc] init] methodSignatureForSelector:aSelector];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n```\n\n因为 Student 实现了 `-(void)test:(int)age` 方法，所以调用 Student 的 `methodSignatureForSelector:` 方法可以返回 `-(void)test:(int)age` 方法的类型编码。\n\n### 类方法的消息转发\n\n#### +forwardingTargetForSelector: 方法\n\n在 `+forwardingTargetForSelector:` 方法里返回类对象：\n```\n@interface Student : NSObject\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) { //类方法和对象方法的方法名都是 \"test\"\n        return [Student class];         //objc_msgSend([Student class], @selector(\"test\"))\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Student test]\n```\n\n在 `+forwardingTargetForSelector:` 方法里返回实列对象：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) { //类方法和对象方法的方法名都是 \"test\"\n        return [[Student alloc] init];  //objc_msgSend([[Student alloc] init], @selector(\"test\"))\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n#### +methodSignatureForSelector: 方法\n\n`+forwardingTargetForSelector:` 方法没有返回值时，会调用 `+methodSignatureForSelector:` 方法获取类型编码：\n```\n@interface Student : NSObject\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]; //也可以写成 v@:\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n+ (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[Student class]];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Student test]\n```\n\n[Person test] 的本质是 objc_msgSend([Person class], @selector(test))，会先走一遍“消息发送”流程。因为 Person 没有实现 `-(void)test` 方法，所以\n\n#### NSInvocation\nNSInvocation 封装了一个方法调用，包括：方法调用者、方法名、方法参数和返回值（类型编码决定 NSInvocation 的方法参数和返回值）。  \nanInvocation.target 方法调用者  \nanInvocation.selector 方法名  \n[anInvocation getArgument:NULL atIndex:0] 方法参数\n\n示例代码：\n```\n@interface Student : NSObject\n- (int)test:(int)age;\n@end\n\n@implementation Student\n- (int)test:(int)age\n{\n    NSLog(@\"%s，age == %d\", __func__, age);\n    return age * 2;\n}\n@end\n\n@interface Person : NSObject\n- (int)test:(int)age;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test:)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test:)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"i24@0:8i16\"];;\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // to do 👇\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test:15];\n    }\n    return 0;\n}\n```\n\n👉 通过 `getArgument:atIndex:` 方法获取参数：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    int age;\n    [anInvocation getArgument:&age atIndex:2]; //传入 age 的地址和下标\n    NSLog(@\"age == %d\", age);\n}\n```\n\n打印结果：\n```\nage == 15\n```\n\n因为 `-(void)test:(int)age` 的 C 语言实现是 `void test(id self, SEL _cmd, int age)`，一共有三个参数，参数顺序：receiver、selector 和 other argument，所以参数 age 的下标是 2。\n\n👉 调用 `invokeWithTarget:` 方法，将消息转发给 Student 的实例对象：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    /**\n     anInvocation.target == person对象\n     anInvocation.selector == test:\n     anInvocation 的参数：15\n     */\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n}\n```\n\n打印结果：\n```\n-[Student test:]，age == 15\n```\n\n在调用 `invokeWithTarget:` 方法前，anInvocation 的 target 是 person 对象，selector 是 `-(void)test:(int)age` 方法，参数是 15。在调用 `invokeWithTarget:` 方法后， anInvocation 的 target 就变成了 student 对象了。相当于向 student 对象发送了一条“test:”消息 `objc_msgSend([[Student alloc] init], @selector(test:))`。\n\n👉 调用 `getReturnValue:` 方法获取返回值：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n    int returnAge;\n    [anInvocation getReturnValue:&returnAge];\n    NSLog(@\"returnAge == %d\", returnAge);\n}\n```\n\n打印结果：\n```\n-[Student test:]，age == 15\nreturnAge == 30\n```\n\n### @synthesize、@dynamic\n\n@synthesize 会自动生成属性 age 的成员变量 _age，同时生成属性 age 的 setter 和 getter 方法的实现。现在的 xcode 都是默认生成了，不用手写了。\n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Student\n@synthesize age = _age;\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *student = [[Student alloc] init];\n        student.age = 20;\n        NSLog(@\"student.age == %d\", student.age);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nstudent.age == 20\n```\n\n@dynamic 是告诉编译器不需要自动生成属性 age 的成员变量 _age，也不需要生成属性 age 的 setter 和 getter 方法的实现。 \n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age; //声明 age 的 setter 和 getter 方法\n@end\n\n@implementation Student\n@dynamic age;\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *student = [[Student alloc] init];\n        student.age = 20; //[student setAge:20]，有 setter 和 getter 方法的声明，没有 setter 和 getter 方法的实现\n        NSLog(@\"student.age == %d\", student.age);\n    }\n    return 0;\n}\n```\n\n报错：unrecognized selector sent to instance\n![Runtime29](Runtime/Runtime29.png)\n\n使用动态方法解析解决这个问题：\n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Student\n\n@dynamic age;\n\nvoid setAge(id self, SEL _cmd, int age)\n{\n    NSLog(@\"age is %d\", age);\n}\n\nint age(id self, SEL _cmd)\n{\n    return 15;\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(setAge:)) {\n        class_addMethod(self, sel, (IMP)setAge, \"v@:i\");\n        return YES;\n    } else if (sel == @selector(age)) {\n        class_addMethod(self, sel, (IMP)age, \"i@:\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n```\n\n打印结果：\n```\nage is 20\nstudent.age == 15\n```\n\n### 小结\n* `forwardingTargetForSelector:`、`methodSignatureForSelector:` 和 `forwardInvocation:` 方法本身并没有区分对象方法和类方法，但是在 _objc_forward_handler 的实现中，receiver （实列对象/类对象）会调用对应的方法（对象方法/类方法），所以实现的方法类型需要跟返回的类型统一。消息转发中，不要在意方法是对象方法还是类方法，本质还是 objc_msgSend 的消息接收者和方法名（实例对象 - 对象方法，类对象 - 类方法）。\n\n\n# super 的本质\n\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n@end\n\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"[self class] = %@\", [self class]);\n        NSLog(@\"[self superclass] = %@\", [self superclass]);\n        NSLog(@\"----------------------------\");\n        NSLog(@\"[super class] = %@\", [super class]);\n        NSLog(@\"[super superclass] = %@\", [super superclass]);\n    }\n    return self;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n [self class] = Student\n [self superclass] = Person\n ----------------------------\n [super class] = Student\n [super superclass] = Person\n```\n\n这里的 self 就是 person 实例对象，`[self class]` 返回的是 person 实例对象的类对象，`[self superclass]` 返回的是父类 Person 的类对象。  \n\n思考：  \nsuper 代表的是 student 的父类 person，那么 `[super class]` 应该就等于 `[person class]`，打印结果应该是 Person，而 `[super class]`  的打印结果却是 Student❓同样的 `[super superclass]` 应该就等于 `[person superclass]`，打印结果应该是 NSObject，而 `[super superclass]` 打印结果却是 Person❓\n\n## objc_super 结构体\n\n定义一个 `-(void)run` 方法：\n```\n@interface Person : NSObject\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%@\", __func__);\n}\n@end\n\n@interface Student : Person\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    [super run];\n}\n@end\n```\n\n通过终端命令 `xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc Student.m` 生成 c++ 代码 Student.cpp，查看 `-(void)run` 方法的 c++ 实现：\n```\nstatic void _I_Student_run(Student * self, SEL _cmd) {\n    //[super run];\n    ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"run\"));\n}\n```\n\n简化后的 `[super run]`：\n```\nobjc_msgSendSuper( (__rw_objc_super){\n                        self, //student 实例对象\n                        class_getSuperclass(objc_getClass(\"Student\")) //[Person class]\n                    }, //__rw_objc_super 结构体\n                    sel_registerName(\"run\") //@selector(run)) );\n```\n\n可以看到 `[super run]` 的底层实现调用的是 `objc_msgSendSuper()` 方法，第一个参数是 `__rw_objc_super` 结构体，第二参数是 `@selector(run)`。所以 super 的本质就是 `__rw_objc_super` 结构体：\n```\nstruct __rw_objc_super { \n\tstruct objc_object *object; \n\tstruct objc_object *superClass; \n\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) {} \n};\n```\n\n`__rw_objc_super` 结构体是在编译时生成的，并将参数传入 objc_msgSendSuper() 方法。但是 objc_msgSendSuper() 在定义时该位置的参数是一个 objc_super 结构体：\n```\nstruct objc_super {\n    /// Specifies an instance of a class.\n    __unsafe_unretained _Nonnull id receiver;\n\n    /// Specifies the particular superclass of the instance to message. \n#if !defined(__cplusplus)  &&  !__OBJC2__\n    /* For compatibility with old objc-runtime.h header */\n    __unsafe_unretained _Nonnull Class class;\n#else\n    __unsafe_unretained _Nonnull Class super_class;\n#endif\n    /* super_class is the first class to search */\n};\n```\n\n因为 `__rw_objc_super` 和 objc_super 的结构基本一致，所以 `__rw_objc_super` 结构体算是一个自定的 objc_super，作为参数传给 objc_msgSendSuper()。\n\n因为现在使用的是 `__OBJC2__`，所以 objc_super 可以简化为：\n```\nstruct objc_super {\n    __unsafe_unretained _Nonnull id receiver; //消息接收者\n    __unsafe_unretained _Nonnull Class super_class; //消息接收者的父类\n};\n```\n\n可以看到 objc_super 结构体的第一个参数是消息接收者，第二个参数是消息接收者的父类。所以 `[super run]` 的底层实现就是：\n```\nstruct __rw_objc_super arg = { \n    self, //消息接收者\n    [Person class] //消息接收者的父类 \n};\nobjc_msgSendSuper(arg, @selector(run));\n```\n\n## objc_msgSendSuper() 方法\n\n通过终端命令 `xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc Student.m` 生成的 c++ 代码 Student.cpp，查看 `[super run]` 的 c++ 实现是调用的 objc_msgSendSuper() 方法。  \n\n关于 `[super run]` 调用的方法 objc_msgSendSuper()：\n```\n/** \n * Sends a message with a simple return value to the superclass of an instance of a class.\n * \n * @param super A pointer to an \\c objc_super data structure. Pass values identifying the\n *  context the message was sent to, including the instance of the class that is to receive the\n *  message and the superclass at which to start searching for the method implementation.\n * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.\n * @param ...\n *   A variable argument list containing the arguments to the method.\n * \n * @return The return value of the method identified by \\e op.\n * \n * @see objc_msgSend\n */\nOBJC_EXPORT id _Nullable\nobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\n```\n\nobjc_msgSendSuper：向实例对象的 super 发送带有简单返回值的消息。第一个参数：super，第二个参数：op（方法的选择器 SEL）。  \n* super：是一个指向 `objc_super` 结构体的指针，在结构体的内部有接收消息的实例对象和开始搜索方法实现的类对象（从该类对象开始搜索方法的实现）。  \n* op：SEL 类型的指针。传递方法的选择器（@selector(run)），该方法就是要处理的消息。\n\n通过注释，可以知道 objc_msgSendSuper() 有两个参数 super 和 SEL，其中 super 里有一个消息接收者和一个类对象。objc_msgSendSuper() 会从 super 里的类对象开始查找 SEL，找到后交给 super 里的消息接收者处理。\n\n综上所述：  \n`[super run]`：设置消息接收者是 self（student 实例对象），并从 Person 类对象开始查找 `-(void)run` 方法：\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(run));\n```\n\n`[super method]` 流程图：\n![Runtime30](Runtime/Runtime30.png)\n\n## objc_msgSendSuper2()\n\n### 查看汇编代码\n在 `[super superclass];` 处添加断点，选择 Debug -> Debug Workflow -> Always Show Disassembly：\n![Runtime31](Runtime/Runtime31.png)\n可以看到 `[super class]` 和 `[super superclass]` 底层实现调用的并不是 `objc_msgSendSuper()` 方法而是 `objc_msgSendSuper2()` 方法。\n\n\n`objc_msgSendSuper2()` 方法的具体实现在汇编文件 objc-msg-arm64.s 里：\n```\n\tENTRY _objc_msgSendSuper2\n\tUNWIND _objc_msgSendSuper2, NoFrame\n\n\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class\n\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class->superclass\n\tCacheLookup NORMAL, _objc_msgSendSuper2\n\n\tEND_ENTRY _objc_msgSendSuper2\n```\n\n也可以通过选择 Product -> Perform Action -> Assemble \"Student.m\" 将 OC 代码转成汇编代码，搜索 “:21”（第21行）找到具体的代码实现：\n```\n......//省略\n\nLtmp0:\n\t.loc\t3 21 5 prologue_end     ## Runtime-test2/Student.m:21:5 //Student.m 文件的第 21 行\n\tmovq\t-8(%rbp), %rax\n\tmovq\t%rax, -32(%rbp)\n\tmovq\t_OBJC_CLASSLIST_SUP_REFS_$_(%rip), %rax\n\tmovq\t%rax, -24(%rbp)\n\tmovq\t_OBJC_SELECTOR_REFERENCES_(%rip), %rsi\n\tleaq\t-32(%rbp), %rdi\n\tcallq\t_objc_msgSendSuper2\n\t.loc\t3 22 1                  ## Runtime-test2/Student.m:22:1\n\taddq\t$32, %rsp\n\tpopq\t%rbp\n\tretq\n\n......//省略\n```\n\n右边的注释代表的是 Student.m 第21行（:21）。在这里也可以看到 `[super run]` 调用的是 `_objc_msgSendSuper2` 方法。\n\n### 查看 LLVM 的中间代码（IR）\nObjective-C 在变为机器代码之前，会被 LLVM 编译器转换为[中间代码（Intermediate Representation）](https://llvm.org/docs/LangRef.html)。\n\n|  语法   | 简介  |\n| - | ----- |\n| @ | 全局变量 |\n| % | 局部变量 |\n| alloca | 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存 |\n| i32 | 32位4字节的整数 |\n| align | 对齐 |\n| load | 读出 |\n| store | 写入 |\n| icmp | 两个整数值比较，返回布尔值 |\n| br | 选择分支，根据条件来转向 label，不根据条件跳转的话类似 goto |\n| label | 代码标签 |\n| call | 调用函数 |\n\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\nvoid test(int param)\n{\n    \n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    return [NSMethodSignature signatureWithObjCTypes:@\"v@:\"];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    [super forwardInvocation:anInvocation];\n    \n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    test(c);\n}\n@end\n```\n\n使用以下命令行指令生成中间代码 Person.ll：\n```\nclang -emit-llvm -S Person.m\n```\n\n找到对应的方法实现：\n```\n......//省略\n//%1*：self，i8*：_cmd，%2*：anInvocation\ndefine internal void @\"\\01-[Person forwardInvocation:]\"(%1*, i8*, %2*) #2 {\n  %4 = alloca %1*, align 8\n  %5 = alloca i8*, align 8\n  %6 = alloca %2*, align 8\n  %7 = alloca %struct._objc_super, align 8\n  %8 = alloca i32, align 4\n  %9 = alloca i32, align 4\n  %10 = alloca i32, align 4\n  store %1* %0, %1** %4, align 8\n  store i8* %1, i8** %5, align 8\n  store %2* %2, %2** %6, align 8\n  %11 = load %1*, %1** %4, align 8\n  %12 = load %2*, %2** %6, align 8\n  %13 = bitcast %1* %11 to i8*\n  %14 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 0\n  store i8* %13, i8** %14, align 8\n  %15 = load %struct._class_t*, %struct._class_t** @\"OBJC_CLASSLIST_SUP_REFS_$_\", align 8\n  %16 = bitcast %struct._class_t* %15 to i8*\n  %17 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 1\n  store i8* %16, i8** %17, align 8\n  %18 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !9\n  //调用 objc_msgSendSuper2，参数一：_objc_super，参数二：i8* _cmd\n  call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)\n  store i32 10, i32* %8, align 4    //将10写入到%8\n  store i32 20, i32* %9, align 4    //将20写入到%9\n  %19 = load i32, i32* %8, align 4  //将%8读出到%19\n  %20 = load i32, i32* %9, align 4  //将%9读出到%20\n  %21 = add nsw i32 %19, %20        //将%19加上%20赋值给%21\n  store i32 %21, i32* %10, align 4  //将%21写入到%10\n  %22 = load i32, i32* %10, align 4 //将%10读出到%22\n  call void @test(i32 %22)          //调用 test(%22)\n  ret void\n}\n\n......//省略\n```\n\n### 小结\n通过终端命令行生成的 c++ 代码中 `[super run]` 的底层实现是 `objc_msgSendSuper()` 方法，通过查看汇编代码和 LLVM 的中间代码可以看到 `[super run]` 的底层实现是 `objc_msgSendSuper2()` 方法。这个问题还是之前提到过的，通过终端命令生成的编译文件很运行时生成的编译文件相比，在某些细节的地方还是有区别的。不过并不影响理解具体的实现逻辑。\n\n## self、class 和 superclass 的底层实现\n\nself、class 和 superclass 的底层实现在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件。\n```\n+ (id)self {\n    return (id)self;\n}\n\n- (id)self {\n    return self;\n}\n\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n\n+ (Class)superclass {\n    return self->superclass;\n}\n\n- (Class)superclass {\n    return [self class]->superclass;\n}\n```\n\n`[super class]` 设置的消息接收者是 self（student 实例对象），并从 Person 类对象开始查找对象方法 `-(Class)class`。在 Person 类对象里没有找到，通过 superclass 指针找到父类的类对象 NSObject，在 NSObject 类对象里找到了对象方法 `-(Class)class` 后交给消息接收者处理。因为是由消息接收者处理对象方法 `-(Class)class`，所以对象方法 `- (Class)class` 的参数 self 自然就是消息接收者本身了。所以 `[super class]` 最终的返回值就是 Student（`[student class]`）。\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(class));\n```\n\n`[super superclass]` 设置的消息接收者是 self（student 实例对象），并从 Person 类对象开始查找对象方法 `-(Class)superclass`。在 Person 类对象里没有找到，通过 superclass 指针找到父类的类对象 NSObject，在 NSObject 类对象里找到了对象方法 `-(Class)superclass` 后交给消息接收者处理。因为是由消息接收者处理对象方法 `-(Class)superclass`，所以对象方法 `- (Class)superclass` 的参数 self 自然就是消息接收者本身了。所以 `[super superclass]` 的返回值就是 Person（`[student superclass]`）。\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(superclass));\n```\n\n现在再看这四个方法，就很清晰了：\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self class];       //消息接收者：student，调用方法：-(void)class\n        [self superclass];  //消息接收者：student，调用方法：-(void)superclass\n\n        [super class];      //消息接收者：student，调用方法：-(void)class\n        [super superclass]; //消息接收者：student，调用方法：-(void)superclass\n    }\n    return self;\n}\n@end\n```\n\n## isKindOfClass: 和 isMemberOfClass:\n\n`isKindOfClass:` 和 `isMemberOfClass:` 的底层实现在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件。\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n* `-isMemberOfClass:`：获取 self 的类对象与传入的 cls 进行比较。\n\n* `+isMemberOfClass:`：因为自身是类方法，所以这里是拿 self->ISA()（元类）作为 tcls 与传入的 cls 进行比较。\n\n* `+isKindOfClass:`：方法内部是一个 for 循环，因为自身是类方法，所以这里是拿 self->ISA()（元类）与传入的 cls 进行比较。如果不相等再遍历 tcls 的 superclass 与传入的 cls 进行比较。遍历过程中有一个相等就结束遍历返回 YES，遍历结束后没有找到相等的类就返回 NO。\n\n* `-isKindOfClass:`：方法内部是一个 for 循环，先获取到 self 的类对象 tcls 与传入的 cls 进行比较。如果不相等再遍历 tcls 的 superclass 与传入的 cls 进行比较。遍历过程中有一个相等就结束遍历返回 YES，遍历结束后没有找到相等的类就返回 NO。\n\n### +isMemberOfClass: 和 +isKindOfClass:\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];   //1\n        BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]]; //2\n        BOOL res3 = [[Person class] isKindOfClass:[Person class]];       //3\n        BOOL res4 = [[Person class] isMemberOfClass:[Person class]];     //4\n        NSLog(@\"%d, %d, %d, %d\", res1, res2, res3, res4);\n    }\n    return self;\n}\n@end\n```\n\n打印结果：\n```\n1, 0, 0, 0\n```\n\n打印结果解析：  \n`+isKindOfClass:` 方法，先通过 self->ISA() 找到 NSObject \b元类对象，不等于 NSObject 类对象。再通过 NSObject \b元类对象的 superclass 指针找到 NSObject 类对象，等于 NSObject 类对象。所以结果等于 YES：\n```\nNSLog(@\"%d\", [[NSObject class] isKindOfClass:[NSObject class]]); //1\n\n//等于\nNSLog(@\"%d\", [NSObject isKindOfClass:[NSObject class]]); //1\n```\n\n`+isMemberOfClass:` 方法，通过 self->ISA() 找到 NSObject \b元类对象，不等于 NSObject 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[NSObject class] isMemberOfClass:[NSObject class]]); //0\n//等于\nNSLog(@\"%d\", [NSObject isMemberOfClass:[NSObject class]]); //0\n```\n\n`+isKindOfClass:` 方法，先通过 self->ISA() 找到 Person \b元类对象，不等于 Person 类对象。再通过 Person \b元类对象的 superclass 指针找到 NSObject 元类对象，不等于 Person 类对象。再通过 NSObject \b元类对象的 superclass 指针找到 NSObject 类对象，不等于 Person 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[Person class] isKindOfClass:[Person class]]); //0\n//等于\nNSLog(@\"%d\", [Person isKindOfClass:[Person class]]); //0\n```\n\n`+isMemberOfClass:` 方法，通过 self->ISA() 找到 Person \b元类对象，不等于 Person 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[Person class] isMemberOfClass:[Person class]]); //0\n//等于\nNSLog(@\"%d\", [Person isMemberOfClass:[Person class]]); //0\n```\n\n#### 小结\n因为当类对象调用类方法 `+isMemberOfClass:` 和 `+isKindOfClass:` 时，是拿类对象的元类对象跟传入的对象做对比，所以除 NSObject 外，其它类对象调用这两个类方法时，右边传入的至少应该是元类对象才有意义。\n\n### -isMemberOfClass: 和 -isKindOfClass:\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        Person *person = [[Person alloc] init];\n        NSObject *object = [[NSObject alloc] init];\n        BOOL res5 = [object isKindOfClass:[NSObject class]];\n        BOOL res6 = [object isMemberOfClass:[NSObject class]];\n        BOOL res7 = [person isKindOfClass:[Person class]];\n        BOOL res8 = [person isMemberOfClass:[Person class]];\n        NSLog(@\"%d, %d, %d, %d\", res5, res6, res7, res8);\n    }\n    return self;\n}\n@end\n```\n\n打印结果：\n```\n1, 1, 1, 1\n```\n\n`-isKindOfClass:` 方法，通过 [self class] 找到 NSObject 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [object isKindOfClass:[NSObject class]]); //1\n```\n\n`-isMemberOfClass:` 方法，通过 [self class] 找到 NSObject 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [object isMemberOfClass:[NSObject class]]); //1\n```\n\n`-isKindOfClass:` 方法，通过 [self class] 找到 Person 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [person isKindOfClass:[Person class]]); //1\n```\n\n`-isMemberOfClass:` 方法，通过 [self class] 找到 Person 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [person isMemberOfClass:[Person class]]); //1\n```\n\n#### 小结\n因为当实例对象调用对象方法 `-isMemberOfClass:` 和 `-isKindOfClass:` 时，是拿实例对象的类对象跟传入的对象做对比，所以在实例对象调用这两个对象方法时，右边传入的至少应该是类对象才有意义。\n\n\n## 对象方法的调用原理\n\n### 正常调用\n![Runtime32](Runtime/Runtime32.png)\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"Person -run %@\", self->_name);\n}\n@end\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    Person *person = [[Person alloc] init];\n    [person run];\n}\n@end\n```\n\n打印结果：\n```\nPerson -run (null)\n```\n\n指针 person 存储着 person 实例对象的地址（person 实例对象的 isa 地址），而 person 实例对象的 isa 指针里存储着 Person 类对象的地址（Person 类对象的 isa 地址）。`[person run]` 是通过 person 实例对象的 isa 指针找到 Person 类对象查找 `-(void)run` 方法，`-(void)run` 方法内部的 self 就是消息接收者（person 实例对象）。person 实例对象内部存储着 isa 指针和成员变量，`self->_name` 是从 isa 的地址开始在 person 实例对象的内存里向下查找成员变量 _name。\n\n### 自定义调用\n![Runtime33](Runtime/Runtime33.png) \n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"Person -run %@\", self.name);\n}\n@end\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad]; //高地址\n    \n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj run];\n}\n@end\n```\n\n打印结果：\n```\n Person -run <ViewController: 0x7fd88fb0a400>\n```\n\n思考：  \n1. `[(__bridge id)obj run]` 为什么能够调用成功？  \n2. 为什么 self.name 变成了 ViewController?  \n\n局部变量的内存分配在栈空间，从高地址到低地址：\n```\nvoid test()\n{\n    long long a = 1; //0x7ffeefbff518（高地址）\n    long long b = 2; //0x7ffeefbff510   ↓\n    long long c = 3; //0x7ffeefbff508   ↓\n    long long d = 4; //0x7ffeefbff500（低地址）\n    NSLog(@\"%p, %p, %p, %p\", &a, &b, &c, &d);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x7ffeefbff518, 0x7ffeefbff510, 0x7ffeefbff508, 0x7ffeefbff500\n```\n\n从打印结果可以看到 a、b、c、d 的内存分配顺序是从高地址到低地址。\n\n`[(__bridge id)obj run]` 图解：\n![Runtime35](Runtime/Runtime35.png) \n\n图中可以看到 obj、cls 和 self 的内存都分配在栈空间，`[UIViewController class]` 在全局区，self 的地址值最大，obj 的地址值最小。self 和 `[UIViewController class]` 来自 `[super viewDidLoad]` 的结构体 `__rw_objc_super`，`__rw_objc_super` 也是一个临时变量：\n```\nstruct __rw_objc_super arg = { \n    self, \n    [ViewController class] \n};\nobjc_msgSendSuper(arg, @selector(viewDidLoad));\n```\n\n这一点可以通过打印内存进行验证（`x/4g`：打印4个数据，每个数据8个字节）：\n```\n(lldb) p/x obj\n(Person *) $0 = 0x00007ffeea236178\n(lldb) x/4g 0x00007ffeea236178\n0x7ffeea236178: 0x00000001059cb5c0 0x00007fc0cb00a9b0\n0x7ffeea236188: 0x00000001059cb4f8 0x00007fff51ec8b0c\n(lldb) p (Class)0x00000001059cb5c0\n(Class) $1 = Person\n(lldb) po 0x00007fc0cb00a9b0\n<ViewController: 0x7fc0cb00a9b0>\n\n(lldb) p (Class)0x00000001059cb4f8\n(Class) $3 = ViewController\n```\n\n从打印结果可以看到，依次是 Person 类对象、<ViewController: 0x7fc0cb00a9b0> 实列对象和 ViewController 类对象。\n\n注释掉 `[super viewDidLoad]` 就会报坏内存访问的错误：\n![Runtime36](Runtime/Runtime36.png)\n\n修改 ViewController.m 实现，添加成员变量 test：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSString *test = @\"123\";\n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj run];\n}\n@end\n```\n\n打印结果：\n```\nPerson -run 123\n```\n\n指针 obj 存储着 cls 的地址，而 cls 存储着 Person 类对象的地址（Person 类对象的 isa 地址）。`[(__bridge id)obj run]` 是通过 cls 找到 Person 类对象查找 `-(void)run` 方法，`-(void)run` 方法内部的 self 就是消息接收者 obj。从 obj 的内存开始在 obj 所在的内存中向下查找成员变量 _name，最后找到的却是 cls 下面的局部变量 test：\n![Runtime34](Runtime/Runtime34.png) \n\n从图中可以看到 obj、cls 和 test 三个变量的内存都分配在栈空间，test 的地址值最大，obj 的地址值最小。\n\n* `[(__bridge id)obj run]` 为什么能够调用成功？  \n因为指针 obj 存储着 cls 的地址，而 cls 存储着 Person 类对象的地址（Person 类对象的 isa 地址），所以 `[(__bridge id)obj run]` 是通过 cls 找到 Person 类对象查找 `-(void)run` 方法(这里的 cls 相当于 person 实例对象的 isa)。\n* 为什么 self.name 变成了 ViewController？  \n因为 `-(void)run` 方法内部的 self 就是消息接收者 obj，`obj->_name` 是在 obj 所在的内存中从 obj 的地址开始向下查找成员变量 _name，而 obj 所在的内存（栈区）向下找到的是 cls 下面的指针 self（ViewController 实例对象），所以最终的打印结果是 `<ViewController: 0x7fd88fb0a400>`。\n\n# Runtime API\n\n## 类\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)` | 动态创建一个类（参数：父类，类名，额外的内存空间）|\n| `void objc_registerClassPair(Class cls)` | 注册一个类（要在类注册之前添加成员变量）|\n| `void objc_disposeClassPair(Class cls)` | 销毁一个类|\n| `Class object_getClass(id obj)` | 获取 isa 指向的 Class |\n| `Class object_setClass(id obj, Class cls)` | 设置 isa 指向的 Class |\n| `BOOL object_isClass(id obj)` | 判断一个 OC 对象是否为 Class |\n| `BOOL class_isMetaClass(Class cls)` | 判断一个 Class 是否为元类 |\n| `Class class_getSuperclass(Class cls)` | 获取父类 |\n\n```\n@interface Person : NSObject\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Student : NSObject\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//动态创建一个类，注册一个类\");\n        Class Teacher = objc_allocateClassPair([NSObject class], \"Teacher\", 0); //创建类对象和元类对象\n        objc_registerClassPair(Teacher); //注册类\n        NSLog(@\"Teacher 的内存大小%zd个字节\", class_getInstanceSize(Teacher)); //8个字节\n        \n        Person *person = [[Person alloc] init];\n        \n        NSLog(@\"---------------------------------------//获取 isa 指向的 Class\");\n        NSLog(@\"类对象：%p，类对象：%p\", [Person class], object_getClass(person));\n        NSLog(@\"类对象：%p，元类对象：%p\", [Person class], object_getClass([Person class]));\n        \n        NSLog(@\"---------------------------------------//设置 isa 指向的 Class\");\n        object_setClass(person, [Student class]);\n        [person run]; //这里的 Person 是 (Student *) 类型，isa 指向 Student 类对象\n        \n        NSLog(@\"---------------------------------------//判断一个 OC 对象是否为 Class\");\n        NSLog(@\"%d %d %d\", object_isClass(person), object_isClass([Person class]), object_isClass(object_getClass([Person class]))); //元类对象是一种特殊的类对象\n        \n        NSLog(@\"---------------------------------------//判断一个 Class 是否为元类\");\n        NSLog(@\"%d %d\", class_isMetaClass([Person class]), class_isMetaClass(object_getClass([Person class]))); //元类对象是一种特殊的类对象\n        \n        NSLog(@\"---------------------------------------//获取父类\");\n        NSLog(@\"%@类对象：%p, %@元类对象：%p\", class_getSuperclass([Person class]), class_getSuperclass([Person class]),\n            class_getSuperclass(object_getClass([Person class])), class_getSuperclass(object_getClass([Person class])));\n\n        NSLog(@\"---------------------------------------//销毁一个类\");\n        id teacher2 = [[Teacher alloc] init];\n        //    person = nil; \n        //    teacher = nil; \n        teacher2 = nil; //实例中只要有一个置为 nil，就可以调用了！❓\n        objc_disposeClassPair(Teacher); //当类或者它的子类的实例还存在，则不能调用 objc_disposeClassPair 方法\n        objc_disposeClassPair(Teacher); //报错“Attempt to use unknown class 0x1030b92a0.”\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//动态创建一个类，注册一个类\nTeacher 的内存大小8个字节\n---------------------------------------//获取 isa 指向的 Class\n类对象：0x100003228，类对象：0x100003228\n类对象：0x100003228，元类对象：0x100003200\n---------------------------------------//设置 isa 指向的 Class\n-[Student run]\n---------------------------------------//判断一个 OC 对象是否为 Class\n0 1 1\n---------------------------------------//判断一个 Class 是否为元类\n0 1\n---------------------------------------//获取父类\nNSObject类对象：0x7fff94b06118, NSObject元类对象：0x7fff94b060f0\n---------------------------------------//销毁一个类\nobjc[15858]: Attempt to use unknown class 0x102905440.\n```\n\n## 成员变量\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Ivar class_getInstanceVariable(Class cls, const char *name)` | 获取一个实例变量信息 |\n| `Ivar *class_copyIvarList(Class cls, unsigned int *outCount)` | 拷贝实例变量列表（最后需要调用free释放）|\n| `void object_setIvar(id obj, Ivar ivar, id value)` | 设置成员变量的值 |\n| `id object_getIvar(id obj, Ivar ivar)` | 获取成员变量的值 |\n| `BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)` | 动态添加成员变量（已经注册的类是不能动态添加成员变量的）|\n| `const char *ivar_getName(Ivar v)` | 获取成员变量的名字 |\n| `const char *ivar_getTypeEncoding(Ivar v)` | 获取成员变量的类型编码 |\n\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Student : NSObject\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//动态添加成员变量（已经注册的类是不能动态添加成员变量的）\");\n        Class Teacher = objc_allocateClassPair([NSObject class], \"Teacher\", 0); //动态创建一个类（包括类对象和元类对象，参数：父类，类名，额外的内存空间）\n        \n        class_addIvar(Teacher, \"_age\", 4, 1, @encode(int)); //在类注册之前添加成员变量（因为类的成员变量列表是只读的，所有类一旦注册后就不能修改成员变量列表了）\n        class_addIvar(Teacher, \"_weight\", 4, 1, @encode(int));\n\n        //添加方法是随时可以操作的，最好是写在注册类前，逻辑比较清晰\n        class_addMethod(Teacher, @selector(run), (IMP)run, \"v@:\");\n        \n        objc_registerClassPair(Teacher); //注册类\n        NSLog(@\"%zd\", class_getInstanceSize(Teacher)); //isa(8个字节) + _age(4个字节) + _weight(4个字节) = 16个字节\n        \n        NSLog(@\"---------------------------------------//修改/获取成员变量的值\");\n        id teacher = [[Teacher alloc] init];\n        [teacher setValue:@10 forKey:@\"_age\"];\n        [teacher setValue:@20 forKey:@\"_weight\"];\n        NSLog(@\"_age：%@, _weight：%@\", [teacher valueForKey:@\"_age\"], [teacher valueForKey:@\"_weight\"]);\n\n        NSLog(@\"---------------------------------------//调用添加的方法\");\n        [teacher run];\n\n        NSLog(@\"---------------------------------------//设置 isa 指向的 Class\");\n        Person *person = [[Person alloc] init];\n        object_setClass(person, Teacher);\n        [person run];\n        \n        NSLog(@\"---------------------------------------//获取成员变量的相关信息\");\n        Ivar ageIvar = class_getInstanceVariable([Person class], \"_age\");\n        NSLog(@\"%s %s\", ivar_getName(ageIvar), ivar_getTypeEncoding(ageIvar));\n        \n        NSLog(@\"---------------------------------------//设置和获取成员变量的值\");\n        Ivar nameIvar = class_getInstanceVariable([Person class], \"_name\");\n        Person *person2 = [[Person alloc] init];\n        object_setIvar(person2, nameIvar, @\"name\"); //设置 _name\n        object_setIvar(person2, ageIvar, (__bridge id)(void *)10); //设置 _age（使用 runtime 方法，底层没有转换直接赋值，先转成指针变量，再转成 id 类型的对象）\n        //[person2 setValue:@10 forKey:@\"age\"]; //NSNumber 类型的 10 在赋值给 age 时会转成 int 类型\n        NSLog(@\"%@\", object_getIvar(person2, nameIvar)); //获取 _name\n        \n        NSLog(@\"---------------------------------------//拷贝实例变量列表（最后需要调用free释放）+ 获取成员变量的相关信息\");\n        unsigned int count;\n        Ivar *ivars = class_copyIvarList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            Ivar ivar = ivars[i];\n            NSLog(@\"%s %s\", ivar_getName(ivar), ivar_getTypeEncoding(ivar));\n        }\n        free(ivars);\n    }\n    return 0;\n}\n```\n\n在使用 `object_setIvar()` 方法设置 int 类型的成员变量时，因为数值不能直接转为对象，所以先将数值转成指针（指针是用来存值的），再将指针转成 id 类型的对象。\n\n打印结果：\n```\n---------------------------------------//动态添加成员变量（已经注册的类是不能动态添加成员变量的）\n16\n---------------------------------------//修改/获取成员变量的值\n_age：10, _weight：20\n---------------------------------------//调用添加的方法\n<Teacher: 0x100525bc0> - run\n---------------------------------------//设置 isa 指向的 Class\n<Teacher: 0x10041dda0> - run\n---------------------------------------//获取成员变量的相关信息\n_age i\n---------------------------------------//设置和获取成员变量的值\nname 10\n---------------------------------------//拷贝实例变量列表（最后需要调用free释放）+ 获取成员变量的相关信息\n_age i\n_name @\"NSString\"\n```\n\n\n## 属性\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `objc_property_t class_getProperty(Class cls, const char *name)` | 获取一个属性 |\n| `objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)` | 拷贝属性列表 |\n| `BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)` | 动态添加属性 |\n| `void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)` | 动态替换属性 |\n| `const char *property_getName(objc_property_t property)` | 获取属性名 |\n| `const char *property_getAttributes(objc_property_t property)` | 获取属性的真实类型 |\n\n`test3()` 实现：\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//获取一个属性\");\n        objc_property_t name = class_getProperty([Person class], \"name\");\n        NSLog(@\"%s\", property_getName(name));\n        \n        NSLog(@\"---------------------------------------//拷贝属性列表\");\n        unsigned int count;\n        objc_property_t *propertys = class_copyPropertyList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            objc_property_t property = propertys[i];\n            NSLog(@\"%s %s\", property_getName(property), property_getAttributes(property));//T 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n        }\n        free(propertys);\n        \n        NSLog(@\"---------------------------------------//动态添加属性\");\n        objc_property_attribute_t type = { \"T\", \"@\\\"NSString\\\"\"}; //数据类型\n        objc_property_attribute_t ownership1 = { \"C\", \"\"}; //copy\n        objc_property_attribute_t ownership2 = { \"N\", \"\"}; //nonatomic\n        objc_property_attribute_t backingivar = { \"V\", \"_newName\"}; //_newName\n        objc_property_attribute_t attrs[] = {type, ownership1, ownership2, backingivar};\n        class_addProperty([Person class], \"newName\", attrs, 4);\n        objc_property_t newName = class_getProperty([Person class], \"newName\");\n        NSLog(@\"%s %s\", property_getName(newName), property_getAttributes(newName));\n        \n        NSLog(@\"---------------------------------------//动态替换属性\");\n        objc_property_attribute_t type1 = { \"T\", \"@\\\"NSString\\\"\"}; //数据类型\n        objc_property_attribute_t ownership3 = { \"C\", \"\"}; //copy\n        objc_property_attribute_t ownership4 = { \"N\", \"\"}; //nonatomic\n        objc_property_attribute_t backingivar1 = { \"V\", \"_replaceName\"}; //_newName\n        objc_property_attribute_t attrs1[] = {type1, ownership3, ownership4, backingivar1};\n        class_replaceProperty([Person class], \"name\", attrs1, 4);\n        objc_property_t replaceName = class_getProperty([Person class], \"name\");\n        NSLog(@\"%s %s\", property_getName(replaceName), property_getAttributes(replaceName));\n        \n        NSLog(@\"---------------------------------------//拷贝属性列表\");\n        unsigned int count1;\n        objc_property_t *propertys1 = class_copyPropertyList([Person class], &count1);\n        for (int i=0; i<count1; i++) {\n            objc_property_t property = propertys1[i];\n            NSLog(@\"%s %s\", property_getName(property), property_getAttributes(property));//T 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n        }\n        free(propertys1);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//获取一个属性\nname\n---------------------------------------//拷贝属性列表\nID Ti,N,V_ID\nage Ti,N,V_age\nname T@\"NSString\",C,N,V_name\n---------------------------------------//动态添加属性\nnewName T@\"NSString\",C,N,V_newName\n---------------------------------------//动态替换属性\nname T@\"NSString\",C,N,V_replaceName\n---------------------------------------//拷贝属性列表\nnewName T@\"NSString\",C,N,V_newName\nID Ti,N,V_ID\nage Ti,N,V_age\nname T@\"NSString\",C,N,V_replaceName\n```\n\nT 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n\n关于 `property_getAttributes()` 获取到的结果，可以参考 [Declared Properties](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1)。\n![Runtime38](Runtime/Runtime38.png)\n\n![Runtime39](Runtime/Runtime39.png)\n\n## 方法\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Method class_getInstanceMethod(Class cls, SEL name)` | 获得一个实例方法 |\n| `Method class_getClassMethod(Class cls, SEL name)` | 获得一个类方法 |\n| `IMP class_getMethodImplementation(Class cls, SEL name)` | 根据 Class 和 SEL 获取方法的 imp 指针 |\n| `IMP method_setImplementation(Method m, IMP imp)` | 修改方法的 imp 指针 |\n| `void method_exchangeImplementations(Method m1, Method m2)` | 交换方法的 imp 指针 |\n| `Method *class_copyMethodList(Class cls, unsigned int *outCount)` | 拷贝方法列表（最后需要调用free释放） |\n| `BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)` | 动态添加方法 |\n| `IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)` | 动态替换方法|\n| `SEL method_getName(Method m)` | 获取方法名 |\n| `IMP method_getImplementation(Method m)` | 根据 Method 获取方法的 imp 指针 |\n| `const char *method_getTypeEncoding(Method m)` | 获取方法的类型编码 |\n| `unsigned int method_getNumberOfArguments(Method m)` | 根据 Method 获取方法的参数个数 |\n| `char *method_copyReturnType(Method m)` | 根据 Method 获取方法的返回值的类型编码（带有copy的需要调用free去释放） |\n| `char *method_copyArgumentType(Method m, unsigned int index)` | 根据 Method 获取方法的索引位置的参数的类型编码（带有copy的需要调用free去释放） |\n| `const char *sel_getName(SEL sel)` | 根据 SEL 获取方法的名称 |\n| `SEL sel_registerName(const char *str)` | 根据方法名注册 SEL |\n| `IMP imp_implementationWithBlock(id block)` | 用 block 作为方法实现 |\n| `id imp_getBlock(IMP anImp)` | 根据 block 的 IMP 生成 block 对象 |\n| `BOOL imp_removeBlock(IMP anImp)` | 移除 imp_implementationWithBlock() 生成的 IMP |\n\n```\n@interface Person : NSObject\n+ (void)personRun;\n\n- (void)run;\n- (void)test;\n\n- (void)run2;\n- (void)test2;\n\n- (void)run3;\n- (void)test3;\n\n- (int)run4:(int)age name:(NSString *)name;\n@end\n\n@implementation Person\n+ (void)personRun\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run2\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test2\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run3\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test3\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (int)run4:(int)age name:(NSString *)name\n{\n    NSLog(@\"%s\", __func__);\n    return 10;\n}\n@end\n\nvoid newRun()\n{\n    NSLog(@\"newRun\");\n}\n\nvoid newTest()\n{\n    NSLog(@\"newTest\");\n}\n\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//获得一个实例方法\");\n        Method runMethod = class_getInstanceMethod([Person class], @selector(run));\n        NSLog(@\"%@\", NSStringFromSelector(method_getName(runMethod)));\n        \n        NSLog(@\"---------------------------------------//获得一个类方法\");\n        Method personRunMethod = class_getClassMethod([Person class], @selector(personRun));\n        NSLog(@\"%@\", NSStringFromSelector(method_getName(personRunMethod)));\n        \n        NSLog(@\"---------------------------------------//根据 Class 和 SEL 获取方法的 imp 指针\");\n        IMP runIMP = class_getMethodImplementation([Person class], @selector(run));\n        NSLog(@\"%p\", runIMP);\n        \n        NSLog(@\"---------------------------------------//修改方法的 imp 指针\");\n        IMP testIMP = class_getMethodImplementation([Person class], @selector(test));\n        method_setImplementation(runMethod, testIMP);\n        Person *person = [[Person alloc] init];\n        [person run]; //调用 -test\n        \n        NSLog(@\"---------------------------------------//交换方法的 imp 指针\");\n        Method run2Method = class_getInstanceMethod([Person class], @selector(run2));\n        Method testMethod = class_getInstanceMethod([Person class], @selector(test2));\n        method_exchangeImplementations(runMethod, testMethod);\n        [person run2];\n        \n        NSLog(@\"---------------------------------------//动态添加方法\");\n        class_addMethod([Person class], @selector(newRun), (IMP)newRun, \"v@:\");\n        [person performSelector:@selector(newRun)];\n\n        NSLog(@\"---------------------------------------//拷贝方法列表（最后需要调用free释放）\");\n        unsigned int count;\n        Method *methods = class_copyMethodList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            Method aMethod = methods[i];\n            NSLog(@\"%@\", NSStringFromSelector(method_getName(aMethod)));\n        }\n        free(methods);\n        \n        NSLog(@\"---------------------------------------//动态替换方法\");\n        class_replaceMethod([Person class], @selector(test3), (IMP)newTest, \"v@:\");\n        [person test3];\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的 imp 指针\");\n        Method run3Method = class_getInstanceMethod([Person class], @selector(run3));\n        IMP runIMP3 = method_getImplementation(run3Method);\n        NSLog(@\"%p\", runIMP3);\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的类型编码\");\n        NSLog(@\"%s\", method_getTypeEncoding(run3Method));\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的参数个数\");\n        Method run4Method = class_getInstanceMethod([Person class], @selector(run4:name:));\n        NSLog(@\"%d\", method_getNumberOfArguments(run4Method)); //self、_cmd、age 和 name\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的返回值的类型编码\");\n        const char *returnType = method_copyReturnType(run4Method);\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:returnType encoding:NSUTF8StringEncoding]);\n        free((void *)returnType);\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的索引位置的参数的类型编码\");\n        const char *argumentType = method_copyArgumentType(run4Method, 3); //name：@\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:argumentType encoding:NSUTF8StringEncoding]);\n        free((void *)argumentType);\n        \n        NSLog(@\"---------------------------------------//根据 SEL 获取方法名\");\n        const char *selName = sel_getName(@selector(run));\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:selName encoding:NSUTF8StringEncoding]);\n        \n        NSLog(@\"---------------------------------------//根据方法名注册 SEL\");\n        SEL registerSel = sel_registerName(\"registerSel\");\n        NSLog(@\"%@\", NSStringFromSelector(registerSel));\n        \n        NSLog(@\"---------------------------------------//用 block 作为方法实现\");\n        IMP blockImp = imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        });\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), blockImp, \"v\");\n        [Person personRun];\n        \n        NSLog(@\"---------------------------------------//根据 block 的 IMP 生成 block 对象\");\n        Block aBlock = imp_getBlock(blockImp);\n        aBlock();\n        \n        \n        NSLog(@\"---------------------------------------//移除 imp_implementationWithBlock() 生成的 IMP\");\n        BOOL isRemvoeBlockImpSucc = imp_removeBlock(blockImp);\n        NSLog(@\"isRemvoeBlockImpSucc：%d\", isRemvoeBlockImpSucc);\n        Block aBlock2 = imp_getBlock(blockImp); //blockImp 已经不存在\n        NSLog(@\"aBlock2：%@\", aBlock2);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//获得一个实例方法\nrun\n---------------------------------------//获得一个类方法\npersonRun\n---------------------------------------//根据 Class 和 SEL 获取方法的 imp 指针\n0x100001ad0\n---------------------------------------//修改方法的 imp 指针\n-[Person test]\n---------------------------------------//交换方法的 imp 指针\n-[Person run2]\n---------------------------------------//动态添加方法\nnewRun\n---------------------------------------//拷贝方法列表（最后需要调用free释放）\nnewRun\nrun2\ntest2\nrun3\ntest3\nrun4:name:\nrun\ntest\n---------------------------------------//动态替换方法\nnewTest\n---------------------------------------//根据 Method 获取方法的 imp 指针\n0x100001b90\n---------------------------------------//根据 Method 获取方法的类型编码\nv16@0:8\n---------------------------------------//根据 Method 获取方法的参数个数\n4\n---------------------------------------//根据 Method 获取方法的返回值的类型编码\ni\n---------------------------------------//根据 Method 获取方法的索引位置的参数的类型编码\n@\n---------------------------------------//根据 SEL 获取方法名\nrun\n---------------------------------------//根据方法名注册 SEL\nregisterSel\n---------------------------------------//用 block 作为方法实现\nthis is a block\n---------------------------------------//根据 block 的 IMP 生成 block 对象\nthis is a block\n---------------------------------------//移除 imp_implementationWithBlock() 生成的 IMP\nisRemvoeBlockImpSucc：1\naBlock2：(null)\n```\n\n## 拓展\n\n### class_rw_ext_t\n\n`class_rw_ext_t` 里保存着 `class_rw_t` 的方法列表、属性列表、协议列表和 `class_ro_t` 等信息。\n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    ......//省略\n\npublic:\n    class_rw_ext_t *ext() const {\n        return get_ro_or_rwe().dyn_cast<class_rw_ext_t *>();\n    }\n\n    class_rw_ext_t *extAllocIfNeeded() {\n        auto v = get_ro_or_rwe();\n        if (fastpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>();\n        } else {\n            return extAlloc(v.get<const class_ro_t *>());\n        }\n    }\n\n    class_rw_ext_t *deepCopy(const class_ro_t *ro) {\n        return extAlloc(ro, true);\n    }\n\n    ......//省略\n```\n\n### 动态添加的属性存到哪了?  \n\n查看 `class_addProperty()` 的实现\n```\nBOOL \nclass_addProperty(Class cls, const char *name, \n                  const objc_property_attribute_t *attrs, unsigned int n)\n{\n    return _class_addProperty(cls, name, attrs, n, NO);\n}\n\nvoid \nclass_replaceProperty(Class cls, const char *name, \n                      const objc_property_attribute_t *attrs, unsigned int n)\n{\n    _class_addProperty(cls, name, attrs, n, YES);\n}\n\nstatic bool \n_class_addProperty(Class cls, const char *name, \n                   const objc_property_attribute_t *attrs, unsigned int count, \n                   bool replace)\n{\n    if (!cls) return NO;\n    if (!name) return NO;\n\n    property_t *prop = class_getProperty(cls, name);\n    if (prop  &&  !replace) { //已经存在 & 替换\n        // already exists, refuse to replace\n        return NO;\n    } \n    else if (prop) { //已经存在\n        // replace existing\n        mutex_locker_t lock(runtimeLock);\n        try_free(prop->attributes);\n        prop->attributes = copyPropertyAttributeString(attrs, count);\n        return YES;\n    }\n    else {\n        mutex_locker_t lock(runtimeLock); \n        auto rwe = cls->data()->extAllocIfNeeded(); //class_rw_ext_t\n        \n        ASSERT(cls->isRealized());\n        \n        property_list_t *proplist = (property_list_t *)\n            malloc(sizeof(*proplist));\n        proplist->count = 1;\n        proplist->entsizeAndFlags = sizeof(proplist->first);\n        proplist->first.name = strdupIfMutable(name);\n        proplist->first.attributes = copyPropertyAttributeString(attrs, count);\n        \n        rwe->properties.attachLists(&proplist, 1); //保存到 class_rw_ext_t 的 properties 里\n        \n        return YES;\n    }\n}\n```\n\n查看 `class_addProperty()` 的 Runtime 实现可以看到，`class_addProperty()` 方法内部调用的是 `_class_addProperty()` 方法。`_class_addProperty()` 方法内部先判断了方法是否已经存在，又判断了是否要替换。如果即不存在也不替换，就保存到 `class_rw_ext_t` 的 properties 里，即类对象的属性列表里。（class_rw_ext_t：class_read_write_extension_table，即 class_rw_t 的拓展表）。\n\n#### 动态添加的方法存到哪了?  \n\n查看 `class_addMethod()` 的实现\n```\nBOOL \nclass_addMethod(Class cls, SEL name, IMP imp, const char *types)\n{\n    if (!cls) return NO;\n\n    mutex_locker_t lock(runtimeLock);\n    return ! addMethod(cls, name, imp, types ?: \"\", NO);\n}\n\nstatic IMP \naddMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)\n{\n    IMP result = nil;\n\n    runtimeLock.assertLocked();\n\n    checkIsKnownClass(cls);\n    \n    ASSERT(types);\n    ASSERT(cls->isRealized());\n\n    method_t *m;\n    if ((m = getMethodNoSuper_nolock(cls, name))) { //是否存在\n        // already exists\n        if (!replace) { //是否替换\n            result = m->imp;\n        } else {\n            result = _method_setImplementation(cls, m, imp);\n        }\n    } else {\n        auto rwe = cls->data()->extAllocIfNeeded(); //class_rw_ext_t\n\n        // fixme optimize\n        method_list_t *newlist;\n        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);\n        newlist->entsizeAndFlags = \n            (uint32_t)sizeof(method_t) | fixed_up_method_list;\n        newlist->count = 1;\n        newlist->first.name = name;\n        newlist->first.types = strdupIfMutable(types);\n        newlist->first.imp = imp;\n\n        prepareMethodLists(cls, &newlist, 1, NO, NO);\n        rwe->methods.attachLists(&newlist, 1); //保存到 class_rw_ext_t 的 methods 里\n        flushCaches(cls);\n\n        result = nil;\n    }\n\n    return result;\n}\n```\n查看 `class_addMethod()` 的 Runtime 实现可以看到 `class_addMethod()` 方法内部调用的是 `addMethod()` 方法。`addMethod()` 方法内部先判断了方法是否已经存在，又判断了是否要替换。如果即不存，就保存到 `class_rw_ext_t` 的 methods 里，即类对象的方法列表里。（class_rw_ext_t：class_read_write_extension_table，即 class_rw_t 的拓展表）。\n\n### method_exchangeImplementations 的实现原理\n```\nvoid method_exchangeImplementations(Method m1, Method m2)\n{\n    if (!m1  ||  !m2) return;\n\n    mutex_locker_t lock(runtimeLock);\n\n    IMP m1_imp = m1->imp;\n    m1->imp = m2->imp;\n    m2->imp = m1_imp;\n\n\n    // RR/AWZ updates are slow because class is unknown\n    // Cache updates are slow because class is unknown\n    // fixme build list of classes whose Methods are known externally?\n\n    flushCaches(nil); //清空方法缓存\n\n    adjustCustomFlagsForMethodChange(nil, m1);\n    adjustCustomFlagsForMethodChange(nil, m2);\n}\n\n......//省略\n\nstatic void flushCaches(Class cls)\n{\n    runtimeLock.assertLocked();\n#if CONFIG_USE_CACHE_LOCK\n    mutex_locker_t lock(cacheUpdateLock);\n#endif\n\n    if (cls) {\n        foreach_realized_class_and_subclass(cls, [](Class c){\n            cache_erase_nolock(c);\n            return true;\n        });\n    }\n    else {\n        foreach_realized_class_and_metaclass([](Class c){\n            cache_erase_nolock(c);\n            return true;\n        });\n    }\n}\n\n......//省略\n\nvoid cache_erase_nolock(Class cls)\n{\n#if CONFIG_USE_CACHE_LOCK\n    cacheUpdateLock.assertLocked();\n#else\n    runtimeLock.assertLocked();\n#endif\n\n    cache_t *cache = getCache(cls);\n\n    mask_t capacity = cache->capacity();\n    if (capacity > 0  &&  cache->occupied() > 0) {\n        auto oldBuckets = cache->buckets();\n        auto buckets = emptyBucketsForCapacity(capacity);\n        cache->setBucketsAndMask(buckets, capacity - 1); // also clears occupied\n\n        cache_collect_free(oldBuckets, capacity);\n    }\n}\n```\n\nmethod_exchangeImplementations 的底层实现是交换了两个方法的 `imp` 指针，然后调用 `flushCaches()` 方法清空了方法缓存。\n![Runtime37](Runtime/Runtime37.png)\n\n## 应用\n\n### 查看私有成员变量\n\n修改 UITextField 占位文字的颜色：\n\n方案一：正常的 OC 代码\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableDictionary *attrs = [NSMutableDictionary dictionary];\n    attrs[NSForegroundColorAttributeName] = [UIColor redColor];\n    self.textField.attributedPlaceholder = [[NSMutableAttributedString alloc] initWithString:@\"请输入用户名\" attributes:attrs];\n}\n@end\n```\n\n方案二：使用 KVC 修改（iOS 13 后禁用）\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.textField.placeholder = @\"请输入用户名\";\n    UILabel *placeholderLabel = [self.textField valueForKeyPath:@\"_placeholderLabel\"];\n    placeholderLabel.textColor = [UIColor redColor];\n\n    //简化版：[self.textField setValue:[UIColor redColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n}\n@end\n```\n\n报错：\n```\n*** Terminating app due to uncaught exception 'NSGenericException', reason: 'Access to UITextField's _placeholderLabel ivar is prohibited. This is an application bug'\n```\n\n方案三：使用 Runtime（还不如 OC 省事）\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.textField.placeholder = @\"请输入用户名\";\n    Ivar ivar = class_getInstanceVariable([UITextField class], \"_placeholderLabel\");\n    UILabel *placeholderLabel = object_getIvar(self.textField, ivar);\n    placeholderLabel.textColor = [UIColor redColor];\n}\n@end\n```\n\n### 字典转模型\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int ID;\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n@end\n\n@interface Teacher : Person\n@property (nonatomic, assign) int weight;\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Teacher\n@end\n\n@interface NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json;\n@end\n\n@implementation NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json\n{\n    id obj = [[self alloc] init];\n    [self enumerateIvarsWithObject:obj class:self json:json];\n    return obj;\n}\n\n+ (void)enumerateIvarsWithObject:(id)obj class:(Class)class json:(NSDictionary *)json\n{\n    Class superclass = [class superclass];\n    if (superclass && superclass != [NSObject class]) { //处理继承\n        [self enumerateIvarsWithObject:obj class:superclass json:json];\n    }\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(class, &count);\n    for (int i=0; i<count; i++) {\n        Ivar ivar = ivars[i]; //取出 i 位置的成员变量\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)]; //去掉“_”\n        id value = json[name]; //设置\n        if ([name isEqualToString:@\"ID\"]) { //处理特殊数据\n            value = json[@\"id\"];\n        }\n        [obj setValue:value forKey:name];\n    }\n    free(ivars);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSDictionary *json = @{\n            @\"id\" : @10,\n            @\"age\" : @20,\n            @\"weight\" : @60,\n            @\"height\" : @160,\n            @\"name\" : @\"Tom\"\n        };\n        Teacher *teacher = [Teacher yq_objectWithJson:json];\n        NSLog(@\"%d, %d, %d, %d, %@\", teacher.ID, teacher.age, teacher.weight, teacher.height, teacher.name);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n10, 20, 60, 160, Tom\n```\n\n### 归档解档\n```\n@interface NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json;\n\n- (void)encodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class;\n- (void)decodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class;\n\n- (void)archive;\n+ (instancetype)unarchive;\n@end\n\n@implementation NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json\n{\n    id obj = [[self alloc] init];\n    [self enumerateIvarsWithObject:obj class:self json:json];\n    return obj;\n}\n\n+ (void)enumerateIvarsWithObject:(id)obj class:(Class)class json:(NSDictionary *)json\n{\n    Class superclass = [class superclass];\n    if (superclass && superclass != [NSObject class]) {\n        [self enumerateIvarsWithObject:obj class:superclass json:json];\n    }\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        //设置\n        id value = json[name];\n        if ([name isEqualToString:@\"ID\"]) {\n            value = json[@\"id\"];\n        }\n        [obj setValue:value forKey:name];\n    }\n    free(ivars);\n}\n\n- (void)encodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class\n{\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(Class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSString *typeEncode = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        if ([typeEncode isEqualToString:@\"i\"]) {\n            int value = [[self valueForKey:name] intValue];\n            [coder encodeInt:value forKey:name];\n        } else if ([typeEncode isEqualToString:@\"@\\\"NSString\\\"\"]) {\n            id value = [self valueForKey:name];\n            [coder encodeObject:value forKey:name];\n        }\n    }\n    free(ivars);\n}\n\n- (void)decodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class\n{\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(Class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSString *typeEncode = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        if ([typeEncode isEqualToString:@\"i\"]) {\n            int value = [coder decodeIntForKey:name];\n            [self setValue:@(value) forKey:name];\n        } else if ([typeEncode isEqualToString:@\"@\\\"NSString\\\"\"]) {\n            id value = [coder decodeObjectForKey:name];\n            [self setValue:value forKey:name];\n        }\n    }\n    free(ivars);\n}\n\n- (void)archive\n{\n    NSString *name = [NSString stringWithFormat:@\"obj.%@\", NSStringFromClass([self class])];\n    NSString *temp = NSTemporaryDirectory();\n    NSString *filePath = [temp stringByAppendingPathComponent:name]; //以类名作为保存文件的扩展名\n    [NSKeyedArchiver archiveRootObject:self toFile:filePath];\n}\n\n+ (instancetype)unarchive\n{\n    NSString *name = [NSString stringWithFormat:@\"obj.%@\", NSStringFromClass(self)];\n    NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:name];\n    id obj = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];\n    return obj;\n}\n@end\n\n@interface Person : NSObject<NSCoding>\n@property (nonatomic, assign) int ID;\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n- (void)encodeWithCoder:(NSCoder *)coder\n{\n    [self encodeIvarsWithCoder:coder Class:[Person class]];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super init];\n    if (self) {\n        [self decodeIvarsWithCoder:coder Class:[Person class]];\n    }\n    return self;\n}\n@end\n\n@interface Teacher : Person<NSCoding>\n@property (nonatomic, assign) int weight;\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Teacher\n- (void)encodeWithCoder:(NSCoder *)coder\n{\n    [super encodeWithCoder:coder];\n    [self encodeIvarsWithCoder:coder Class:[Teacher class]];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super initWithCoder:coder];\n    if (self) {\n        [self decodeIvarsWithCoder:coder Class:[Teacher class]];\n    }\n    return self;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //归档\n//        NSDictionary *json = @{\n//            @\"id\" : @100,\n//            @\"age\" : @200,\n//            @\"weight\" : @700,\n//            @\"height\" : @1700,\n//            @\"name\" : @\"Tom\"\n//        };\n//        Teacher *teacher = [Teacher yq_objectWithJson:json];\n//        [teacher archive];\n        //解档\n        Teacher *teacher = [Teacher unarchive];\n        NSLog(@\"%d, %d, %d, %d, %@\", teacher.ID, teacher.age, teacher.weight, teacher.height, teacher.name);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n100, 200, 700, 1700, Tom\n```\n\n### 替换方法实现\n\nclass_replaceMethod\n```\n@interface Person : NSObject\n- (void)run;\n+ (void)personRun;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (void)personRun\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nvoid myRun()\n{\n    NSLog(@\"---myRun\");\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //使用 myRun 替换类方法 +personRun，传入元类对象\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), (IMP)myRun, \"v\");\n        [Person personRun];\n        //使用 block 替换类方法 +personRun\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        }), \"v\");\n        [Person personRun];\n        \n        //使用 myRun 替换对象方法 -run，传入类对象\n        class_replaceMethod([Person class], @selector(run), (IMP)myRun, \"v\");\n        Person *person = [[Person alloc] init];\n        [person run];\n        //使用 block 替换对象方法 -run\n        class_replaceMethod([Person class], @selector(run), imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        }), \"v\");\n        [person run];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---myRun\nthis is a block\n---myRun\nthis is a block\n```\n\n### 拦截所有按钮的点击事件\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface UIControl (Extension)\n@end\n\n@implementation UIControl (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Method method1 = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));\n        Method method2 = class_getInstanceMethod(self, @selector(yq_sendAction:to:forEvent:));\n        method_exchangeImplementations(method1, method2);        \n    });\n}\n\n- (void)yq_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event\n{\n    NSLog(@\"%@-%@-%@\", self, target, NSStringFromSelector(action));\n    //调用系统原来的实现\n    [self yq_sendAction:action to:target forEvent:event];\n}\n@end\n\n@interface ViewController : UIViewController\n@end\n\n@implementation ViewController\n- (IBAction)click1:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n- (IBAction)click2:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n- (IBAction)click3:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n<UIButton: 0x7f8d0ad093e0; frame = (148 332; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001bd0560>>-<ViewController: 0x7f8d0ac06850>-click1:\n-[ViewController click1:]\n<UIButton: 0x7f8d0ae0c4f0; frame = (148 411; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001be5740>>-<ViewController: 0x7f8d0ac06850>-click2:\n-[ViewController click2:]\n<UIButton: 0x7f8d0ad096b0; frame = (148 492; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001bd06e0>>-<ViewController: 0x7f8d0ac06850>-click3:\n-[ViewController click3:]\n```\n\n### 拦截数组添加数据方法\n\n数组的 `addObject:` 和 `insertObject:` 方法调用的都是 `insertObject:atIndex:` 方法。拦截 `insertObject:atIndex:` 方法，可以解决添加空数据导致的崩溃。\n\n类簇：NSData、NSArray、NSDictionary 和 NSString。它们的类并不一样，比如 NSMutableArray 的类是 `__NSArrayM`。\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface NSMutableArray (Extension)\n@end\n\n@implementation NSMutableArray (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class cls = NSClassFromString(@\"__NSArrayM\");\n        Method method1 = class_getInstanceMethod(cls, @selector(insertObject:atIndex:));\n        Method method2 = class_getInstanceMethod(cls, @selector(yq_insertObject:atIndex:));\n        method_exchangeImplementations(method1, method2);        \n    });\n}\n\n- (void)yq_insertObject:(id)anObject atIndex:(NSUInteger)index\n{\n    if (anObject == nil) return;\n    [self yq_insertObject:anObject atIndex:index];\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableArray *arrayM = [[NSMutableArray alloc] init];\n    NSString *obj = nil;\n    [arrayM addObject:obj];\n}\n@end\n```\n\n### 拦截字典添加数据方法\n\n字典赋值的 `setObject:forKey:` 方法最终调用的是 `setObject:forKeyedSubscript:`。拦截 `setObject:forKeyedSubscript:` 方法，可以解决添加空数据导致的崩溃。\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface NSMutableDictionary (Extension)\n@end\n\n@implementation NSMutableDictionary (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class cls = NSClassFromString(@\"__NSDictionaryM\");\n        Method method1 = class_getInstanceMethod(cls, @selector(setObject:forKeyedSubscript:));\n        Method method2 = class_getInstanceMethod(cls, @selector(yq_setObject:forKeyedSubscript:));\n        method_exchangeImplementations(method1, method2);\n        \n        Class cls2 = NSClassFromString(@\"__NSDictionaryI\");\n        Method method3 = class_getInstanceMethod(cls2, @selector(objectForKeyedSubscript:));\n        Method method4 = class_getInstanceMethod(cls2, @selector(yq_objectForKeyedSubscript:));\n        method_exchangeImplementations(method3, method4);\n    });\n}\n\n- (void)yq_setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key\n{\n    if (!key || !obj) return;\n    [self yq_setObject:obj forKeyedSubscript:key];\n}\n\n- (id)yq_objectForKeyedSubscript:(id)key\n{\n    if (!key) return nil;\n    return [self yq_objectForKeyedSubscript:key];\n}\n\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableDictionary *dictionaryM = [NSMutableDictionary dictionary];\n    dictionaryM[obj] = obj;\n    NSString *obj2 = dictionaryM[obj];\n}\n@end\n```\n\n# 总结\n* 讲一下 OC 的消息机制  \nOC 中的方法调用其实都是转成了 objc_msgSend 函数的调用，给 receiver（方法调用者）发送了一条消息（selector(方法名)）。  \nobjc_msgSend 底层有三大阶段：  \n    * 消息发送：先调在当前类的 cache 里找，再到当前类的 methods 里找。如果在当前类没有找到，再遍历父类查找，先在父类的 cache 里找，再到父类的 methods 里找。\n    * 动态方法解析：在当前类及其父类里没有找到方法时，会调用 `resolveInstanceMethod:` 或者 `resolveClassMethod:` 方法动态添加方法。  \n    * 消息转发：如果没有动态添加方法，会调用 `forwardingTargetForSelector:` 方法获取可以处理消息的对象。如果没有实现  `forwardingTargetForSelector:` 方法或者该方法返回的是 nil，会调用 `methodSignatureForSelector:` 方法获取类型编码，在获取类型编码成功后再调用 `forwardInvocation:` 方法进行自定义操作。如果没有实现 `methodSignatureForSelector:` 方法或者该方法返回的是 nil，会调用 `doesNotRecognizeSelector:` 方法终止流程。 \n\n* 消息转发机制流程  \n如果没有动态添加方法，会调用 `forwardingTargetForSelector:` 方法获取可以处理消息的对象。如果没有实现  `forwardingTargetForSelector:` 方法或者该方法返回的是 nil，会调用 `methodSignatureForSelector:` 方法获取类型编码，在获取类型编码成功后再调用 `forwardInvocation:` 方法进行自定义操作。如果没有实现 `methodSignatureForSelector:` 方法或者该方法返回的是 nil，会调用 `doesNotRecognizeSelector:` 方法终止流程。 \n\n* 什么是 Runtime ？平时项目中有用过么？  \nOC 是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。OC 的动态性就是由 Runtime 来支撑和实现的，Runtime 是一套 C 语言的 API，封装了很多动态性相关的函数，平时编写的OC代码，底层都是转换成了 Runtime API 进行调用。\n\n  具体应用  \n  1、利用关联对象（AssociatedObject）给分类添加属性；  \n  2、遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）；  \n  3、交换方法实现（交换系统的方法）；  \n  4、利用消息转发机制解决方法找不到的异常问题；  \n  ......\n","source":"_posts/OC底层原理/Runtime.md","raw":"---\ntitle: Runtime\ndate: 2020-06-12 18:27:54\ntags: OC底层原理\n---\n\n思考：\n* 讲一下 OC 的消息机制\n* 消息转发机制流程\n* 什么是 Runtime？平时项目中有用过么？\n* Runtime 的具体应用\n\n<!-- more -->\n\n* 打印结果分别是什么？\n```\n//打印1\n@interface Person : NSObject\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n@end\n\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"[self class] = %@\", [self class]);\n        NSLog(@\"[super class] = %@\", [super class]);\n        NSLog(@\"[self superclass] = %@\", [self superclass]);\n        NSLog(@\"[super superclass] = %@\", [super superclass]);\n    }\n    return self;\n}\n@end\n\n//打印2\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];\n        BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];\n        BOOL res3 = [[Person class] isKindOfClass:[Person class]];\n        BOOL res4 = [[Person class] isMemberOfClass:[Person class]];\n        NSLog(@\"%d %d %d %d\", res1, res2, res3, res4);\n    }\n    return 0;\n}\n```\n\n* 以下代码能不能执行成功？如果可以，打印结果是什么？\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)print;\n@end\n\n@implementation Person\n- (void)print {\n    NSLog(@\"my name's %@\", self.name);\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj print];\n}\n@end\n```\n\nObjective-C 是一门动态性比较强的编程语言，跟 C、C++ 等语言有着很大的不同，Objective-C 的动态性是由 Runtime API 来支撑的，Runtime API 提供的接口基本都是 C 语言的，源码由 C\\C++\\汇编语言编写。\n\n# isa 详解\n学习 Runtime，首先要了解它底层的一些常用数据结构，比如 isa 指针。在 arm64 架构之前，isa 就是一个普通的指针，存储着 Class、Meta-Class 对象的内存地址。从 arm64 架构开始，对 isa 进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。\n\n## 位运算\n```\n@interface Person : NSObject\n@property (nonatomic, assign, getter=isTall) BOOL tall;\n@property (nonatomic, assign, getter=isRich) BOOL rich;\n@property (nonatomic, assign, getter=isHandsome) BOOL handsome;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = YES;\n        person.handsome = YES;\n        \n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n        NSLog(@\"person的大小：%zd\", class_getInstanceSize([person class]));\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：1, handsome：1\nperson的大小：16\n```\n\ntall（1个字节）+ rich（1个字节）+ handsome（1个字节）+ isa（8个字节）= 11个字节。根据内存对齐原则，person 的内存大小是16个字节。\n\n因为 tall、rich 和 handsome 都是 BOOL 类型，它们的值只有0和1，所以可以用3个二进制位来存储他们的值。\n\n### 设计  \n定义一个 char 类型的变量 _tallRichHandsome 用来存储3个 BOOL 类型变量的值：\n```\n@interface Person()\n{\n    char _tallRichHandsome; //0b 0000 0000\n}\n@end\n```\n\n_tallRichHandsome 占1个字节（8位：`0b 0000 0000`），让它最右边的3位（`0b00000111`）分别存储 tall、rich 和 handsome：\n```\n0b 0000 0111 //_tallRichHandsome（tall：YES, rich：YES, handsome：YES）\n\n0b 0000 0001 //tall\n0b 0000 0010 //rich\n0b 0000 0100 //handsome\n```\n\n### 取值\n* 按位与运算符（`&`）  \n定义：参加运算的两个数据，按二进制位进行“与”运算。  \n运算规则：`0&0=0`，`0&1=0`，`1&0=0`，`1&1=1`。  \n总结：两位同时为1，结果才为1，否则结果为0。 \n\n因为“与”运算可以获取到特定位的值，所以可以通过“与”运算分别获取三个变量的值：\n\n初始化 _tallRichHandsome\n```\n_tallRichHandsome = 0b00000101; //（tall：YES, rich：NO, handsome：YES）\n```\n\n获取 tall（`_tallRichHandsome & 0b00000001`）\n```\n  0b00000101\n& 0b00000001\n-------------\n  0b00000001\n```\n\n获取 rich（`_tallRichHandsome & 0b00000010`）\n```\n  0b00000101\n& 0b00000010\n-------------\n  0b00000000\n```\n\n获取 handsome（`_tallRichHandsome & 0b00000100`）\n```\n  0b00000101\n& 0b00000100\n-------------\n  0b00000100\n```\n\n代码实现：\n```\n@interface Person : NSObject\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n@end\n\n@interface Person()\n{\n    char _tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _tallRichHandsome = 0b00000101;\n    }\n    return self;\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & 1); //1（十进制）== 0b 0000 0001（二进制）\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & 2); //2（十进制）== 0b 0000 0010（二进制）\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & 4); //4（十进制）== 0b 0000 0100（二进制）\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：0, handsome：1\n```\n\n因为返回的是 BOOL 类型，而“与”运算取出的是有值（`0b00000001`、`0b00000100`）和0（`0b00000000`），所以为了可以获取到 YES 和 NO，可以在“与”运算的结果前加`!!`取反两次：\n```\n!(0b00000000)   YES\n!!(0b00000000)  NO   //!!(_tallRichHandsome & 2)\n \n!(0b00000001)   NO\n!!(0b00000001)  YES  //!!(_tallRichHandsome & 1)\n\n!(0b00000100)   NO\n!!(0b00000100)  YES  //!!(_tallRichHandsome & 4)\n```\n\n### 掩码\n上面👆的实现太抽象，可以使用掩码增加可读性：\n```\n#define TallMask 1\n#define RichMask 2\n#define HandsomeMask 4\n```\n\n直接使用二进制定义掩码会更直观：\n```\n#define TallMask 0b00000001\n#define RichMask 0b00000010\n#define HandsomeMask 0b00000100\n```\n\n使用位移运算符，简化代码：\n```\n#define TallMask (1<<0)     //左移0位：0b00000001（二进制），1（十进制）\n#define RichMask (1<<1)     //左移1位：0b00000010（二进制），2（十进制）\n#define HandsomeMask (1<<2) //左移2位：0b00000100（二进制），4（十进制）\n```\n\n* 左移运算符（`<<`）  \n定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n\n最终实现：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n@implementation Person\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & HandsomeMask);\n}\n@end\n```\n\n### 设值\n* 按位或运算符（`|`）  \n定义：参加运算的两个对象，按二进制位进行“或”运算。  \n运算规则：`0|0=0`，`0|1=1`，`1|0=1`，`1|1=1`。  \n总结：参加运算的两个对象只要有一个为1，其值为1。\n\n* 取反运算符 (`~`)  \n定义：参加运算的一个数据，按二进制进行“取反”运算。  \n运算规则：`~1=0`，`~0=1`。  \n总结：对一个二进制数按位取反，即将0变1，1变0。\n\n设置 YES 时，跟 _tallRichHandsome 进行按位“或”运算，修改特定位置的值。  \n设置 NO 时，先对 rich 的二进制数按位取反，再跟 _tallRichHandsome 进行按位“与”运算。\n\n初始化 _tallRichHandsome\n```\n_tallRichHandsome = 0b00000010; //（tall：NO, rich：YES, handsome：NO）\n```\n\n设置 tall 为 YES（`_tallRichHandsome |= 0b00000001`）\n```\n  0b00000010\n| 0b00000001\n-------------\n  0b00000011\n```\n\n设置 rich 为 NO（`_tallRichHandsome &= ~0b00000010`）\n```\n  0b00000010\n& 0b11111101  //~0b00000010（按位取反） \n-------------\n  0b00000000\n```\n\n设置 handsome 为 YES（`_tallRichHandsome |= 0b00000001`）\n```\n  0b00000010\n| 0b00000100\n-------------\n  0b00000110\n```\n\n代码实现：\n```\n@interface Person : NSObject\n- (void)setTall:(BOOL)tall;\n- (void)setRich:(BOOL)rich;\n- (void)setHandsome:(BOOL)handsome;\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n@end\n\n\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n\n@interface Person()\n{\n    char _tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (void)setTall:(BOOL)tall {\n    if (tall) {\n        _tallRichHandsome |= TallMask;\n    } else {\n        _tallRichHandsome &= ~TallMask;\n    }\n}\n\n- (void)setRich:(BOOL)rich {\n    if (rich) {\n        _tallRichHandsome |= RichMask;\n    } else {\n        _tallRichHandsome &= ~RichMask;\n    }\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    if (handsome) {\n        _tallRichHandsome |= HandsomeMask;\n    } else {\n        _tallRichHandsome &= ~HandsomeMask;\n    }\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome & HandsomeMask);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：1, rich：0, handsome：1\n```\n\n## 位域\n位域，C 语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。利用位段能够用较少的位数存储数据。\n\n机构体的第一个成员变量在结构体内存的最右边一个二进制位，其它变量依次从左往右排。\n\n使用位域增加可读性。定义结构体 _tallRichHandsome，成员变量 tall，并通过“`:`”设置 tall 在内存中只占1位。\n```\n@interface Person()\n{\n    struct {\n        char tall : 1; //1位\n    } _tallRichHandsome; //1个字节\n}\n@end\n\n@implementation Person\n- (void)setTall:(BOOL)tall {\n    _tallRichHandsome.tall = tall;\n}\n\n- (BOOL)isTall {\n    BOOL ret = _tallRichHandsome.tall;\n    return ret; //断点2\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        NSLog(@\"tall：%d\", person.isTall); //断点1\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：-1\n```\n\n在断点1处查看 _tallRichHandsome 的内存：\n```\n(lldb) p/x &(person->_tallRichHandsome)\n((anonymous struct) *) $0 = 0x0000000100493d98\n(lldb) x 0x0000000100493d98\n0x100493d98: 01 00 00 00 00 00 00 00 2d 5b 4e 53 54 61 62 50  ........-[NSTabP\n0x100493da8: 69 63 6b 65 72 56 69 65 77 43 6f 6e 74 72 6f 6c  ickerViewControl\n```\n\n内存中的“01”是十六进制的，转成二进制就是`0b 0000 0001`。即 tall：YES。\n\n在断点2处查看 ret 的内存：\n```\n(lldb) p/x & ret\n(BOOL *) $0 = 0x00007ffeefbff4ff 255\n(lldb) x 0x00007ffeefbff4ff\n0x7ffeefbff4ff: ff b1 4e cb 5e ff 7f 00 00 90 81 16 03 01 00 00  ..N.^...........\n0x7ffeefbff50f: 00 50 f5 bf ef fe 7f 00 00 90 0c 00 00 01 00 00  .P..............\n```\n\n内存中的“ff”是十六进制的（0xFF），转成二进制就是`0b11111111`，转成十进制是255（无符号）或-1（有符号）。这是因为 tall 原本是一个二进制位，即 tall：0b1，而返回值要求的是 BOOL 类型的值（8位：`0b00000000`），所以在返回时 tall 强转成了一个8位的值：\n```\n0b1 -> 0b 1111 1111（二进制） //0xff（十六进制）\n```\n\n因为在系统中整数是以补码形式存放的，所以要想找到打印结果为“-1”的原因需要先算出 `0b11111111` 的原码。\n* 补码求原码  \n如果补码的符号位为“0”，表示是一个正数，其原码就是补码。  \n如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。  \n\n因为 tall 是一个 char 类型的整型变量，是有符号的（LLVM），所以此时的 `0b11111111` 是有符号的。\n\n因为 `0b11111111` 的最高位是符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。其余七位取反后为 `0b10000000`；再加1，所以是 `0b10000001`，十进制就是 -1。所以 tall 在设置为 YES 时，打印结果是 -1。\n\n如果将 tall 设置为 NO 的话，_tallRichHandsome 和 ret 的内存都是 `0b00000000`。\n```\n(lldb) p/x &(person->_tallRichHandsome)\n((anonymous struct) *) $1 = 0x0000000102c6fb28\n(lldb) x 0x0000000102c6fb28\n0x102c6fb28: 00 00 00 00 00 00 00 00 2d 5b 4e 53 56 69 62 72  ........-[NSVibr\n0x102c6fb38: 61 6e 74 53 70 6c 69 74 44 69 76 69 64 65 72 56  antSplitDividerV\n\n(lldb) p/x & ret\n(BOOL *) $0 = 0x00007ffeefbff4ff NO\n(lldb) x 0x00007ffeefbff4ff\n0x7ffeefbff4ff: 00 b1 4e cb 5e ff 7f 00 00 20 fb c6 02 01 00 00  ..N.^.... ......\n0x7ffeefbff50f: 00 50 f5 bf ef fe 7f 00 00 8d 0c 00 00 01 00 00  .P..............\n```\n\n综上所述，在对 tall 进行修改时，会有两个返回值“-1”和“0”。为了保证返回的结果正确，可以使用上面👆提到过的取反两次`!!`。\n\n最终实现：  \n定义结构体 _tallRichHandsome，同时定义成员变量 tall、rich 和 handsome，并通过“:”设置她们在内存中只占1位：\n```\n@interface Person()\n{\n    struct {\n        char tall : 1; //只占1位\n        char rich : 1;\n        char handsome : 1;\n    } _tallRichHandsome;\n}\n@end\n\n@implementation Person\n- (void)setTall:(BOOL)tall {\n    _tallRichHandsome.tall = tall;\n}\n\n- (void)setRich:(BOOL)rich {\n    _tallRichHandsome.rich = rich;\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    _tallRichHandsome.handsome = handsome;\n}\n\n- (BOOL)isTall {\n    return !!_tallRichHandsome.tall;\n}\n\n- (BOOL)isRich {\n    return !!_tallRichHandsome.rich;\n}\n\n- (BOOL)isHandsome {\n    return !!_tallRichHandsome.handsome;\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = YES;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome); //断点1\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n tall：1, rich：0, handsome：1\n```\n\n_tallRichHandsome 的二级制就是`0b00000111`，tall 是第一个成员变量在最右边，然后依次从左往右排。\n\n## 共用体（union）\n\n### struct\nstruct 结构体里的成员变量各自拥有一块内存，单独存在：\n![Runtime01](Runtime/Runtime01.png)\n\n定义一个结构体 Date，内部有三个 int 类型的成员变量 year、month 和 day：\n```\nstruct Date {\n    int year;  //4个字节\n    int month; //4个字节\n    int day;   //4个字节\n}; //12个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //struct Date date = {2020, 6, 17};\n        struct Date date;\n        date.year = 2020;\n        date.month = 6;\n        date.day = 17;\n        NSLog(@\"year：%d, month：%d, day：%d\", date.year, date.month, date.day);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：6, day：17\n```\n\n因为三个变量各自拥有自己的内存，所以打印结果各不相同。\n\n### union\nunion 共用体里的成员变量共用一块内存，共用体的内存大小以成员变量的最大内存为准：\n![Runtime02](Runtime/Runtime02.png)\n\n定义共用体 Date，内部有三个 int 类型的变量 year、month 和 day：\n```\nunion Date {\n    int year;  //4个字节\n    int month; //4个字节\n    int day;   //4个字节\n}; //4个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        union Date date;\n        date.year = 2020;\n        NSLog(@\"year：%d, month：%d, day：%d\", date.year, date.month, date.day);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：2020, day：2020\n```\n\n因为三个变量共用一块内存，所以三个变量访问的内存是同一块内存地址。\n\n定义共用体 Date，内部有一个 int 类型的变量 year 和一个 char 类型的变量 month：\n```\nunion Date {\n    int year;   //4个字节\n    char month; //1个字节\n}; //4个字节\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        union Date date;\n        date.year = 2020;\n        NSLog(@\"year：%d, month：%d\", date.year, date.month);\n    }\n}\n```\n\n打印结果：\n```\nyear：2020, month：2020\n```\n\n### 实现\n将位运算和位域结合在一起定义一个共用体，用位运算读取/写入变量的值，用位域增加可读性：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<1)\n#define HandsomeMask (1<<2)\n\n@interface Person()\n{\n    union {\n        char bits;\n        struct {\n            char tall : 1;\n            char rich : 1;\n            char handsome : 1;\n        };\n    }_tallRichHandsome;\n}\n@end\n\n@implementation Person\n\n- (void)setTall:(BOOL)tall {\n    if (tall) {\n        _tallRichHandsome.bits |= TallMask;\n    } else {\n        _tallRichHandsome.bits &= ~TallMask;\n    }\n}\n\n- (void)setRich:(BOOL)rich {\n    if (rich) {\n        _tallRichHandsome.bits |= RichMask;\n    } else {\n        _tallRichHandsome.bits &= ~RichMask;\n    }\n}\n\n- (void)setHandsome:(BOOL)handsome {\n    if (handsome) {\n        _tallRichHandsome.bits |= HandsomeMask;\n    } else {\n        _tallRichHandsome.bits &= ~HandsomeMask;\n    }\n}\n\n- (BOOL)isTall {\n    return !!(_tallRichHandsome.bits & TallMask);\n}\n\n- (BOOL)isRich {\n    return !!(_tallRichHandsome.bits & RichMask);\n}\n\n- (BOOL)isHandsome {\n    return !!(_tallRichHandsome.bits & HandsomeMask);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        person.tall = NO;\n        person.rich = NO;\n        person.handsome = YES;\n        NSLog(@\"tall：%d, rich：%d, handsome：%d\", person.isTall, person.isRich, person.isHandsome);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\ntall：0, rich：0, handsome：1\n```\n\n这里定义的 tall、rich 和 handsome 都是占1个二进制位的，如果想要修改它们占二进制位的个数，bits 也要修改为相应的定义：\n\ntall、rich 和 handsome 都是占4个二进制位，那 bits 就需要定义成 int 类型（4个字节），掩码也需要占4个二进制位：\n```\n#define TallMask (1<<0)\n#define RichMask (1<<4)\n#define HandsomeMask (1<<8)\n\n@interface Person()\n{\n    union {\n        int bits;\n        struct {\n            char tall : 4;\n            char rich : 4;\n            char handsome : 4;\n        };\n    }_tallRichHandsome;\n}\n@end\n```\n\n掩码也可以写成：\n```\n#define TallMask (0b1111<<0)\n#define RichMask (0b1111<<4)\n#define HandsomeMask (0b1111<<8)\n```\n\n或者\n```\n#define TallMask (15<<0)\n#define RichMask (15<<4)\n#define HandsomeMask (15<<8)\n```\n\n## isa\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 isa 的定义。  \n\n找到 OC 对象的结构体 objc_object：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n    \n    ··· //省略一堆方法\n}\n```\n\n### isa_t\n\n可以看到 isa 是一个 isa_t 类型的变量，Jump To Definition -> isa_t：\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    //位域\n    struct { \n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n```\n\n位域中是一个宏 ISA_BITFIELD，ISA_BITFIELD 在 `__arm64__`（真机） 和 `__x86_64__`（mac电脑/模拟器） 架构有不同的定义：\n```\n# if __arm64__ //真机上市 arm64\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__ //模拟器是 x86 架构\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                        \\\n      uintptr_t nonpointer        : 1;                                         \\\n      uintptr_t has_assoc         : 1;                                         \\\n      uintptr_t has_cxx_dtor      : 1;                                         \\\n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                         \\\n      uintptr_t weakly_referenced : 1;                                         \\\n      uintptr_t deallocating      : 1;                                         \\\n      uintptr_t has_sidetable_rc  : 1;                                         \\\n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n\n# else\n#   error unknown architecture for packed isa\n# endif\n```\n\n将宏 `ISA_BITFIELD` 替换掉，保留真机（arm64）代码，可以看到一个比较完整的 isa_t：\n![Runtime05](Runtime/Runtime05.png)\n\n 因为 isa 指针的定义区分 `__arm64__`（真机）和 `__x86_64__`（mac/模拟器），所以需要用真机运行项目才能看到 `ISA_BITFIELD` 正确的成员变量的值：\n ```\n int main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n ```\n\n查看 person 对象的 isa 指针的内存：\n```\n(lldb) p/x person->isa\n(Class) $0 = 0x1A100455641 Person\n```\n\n转成二进制：\n![Runtime04](Runtime/Runtime04.png)\n\n### 位域  \n* nonpointer  \n0，代表普通的指针，isa 只存储着 Class、Meta-Class 对象的内存地址  \n1，代表优化过，isa 使用位域存储更多的信息\n* has_assoc  \n是否有设置过关联对象，如果没有，释放时会更快\n* has_cxx_dtor  \n是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快\n* shiftcls  \n存储着 Class、Meta-Class 对象的内存地址信息\n* magic  \n用于在调试时分辨对象是否未完成初始化\n* weakly_referenced  \n是否有被弱引用指向过，如果没有，释放时会更快\n* deallocating  \n对象是否正在释放\n* extra_rc  \n里面存储的值是引用计数器减1\n* has_sidetable_rc  \n引用计数器是否过大无法存储在 isa 中，如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中\n\n![Runtime06](Runtime/Runtime06.png)\nnonpointer：占1个二进制位，在最低位为1（第0位）。  \nhas_assoc（has_associate）：占1个二进制位，为0（第1位）。  \nhas_cxx_dtor：占1个二进制位，为0（第2位）。     \nshiftcls：占33个二进制位（从第3位到第35位）。 \nmagic：占6个二进制位（从第36位到第41位）。magic 的值可以从宏 `ISA_MAGIC_VALUE` 看到（1a）。magic == 1a 表示初始化成功。  \nweakly_referenced：占1个二进制位，为0（第42位）。  \ndeallocating：占1个二进制位，为0（第43位）。   \nhas_sidetable_rc：占1个二进制位，为0（第44位）。  \nextra_rc（extra_retain_count）：占19个二进制位，为0（从第45位到63位）。\n\n#### has_assoc 和 weakly_referenced\n\nhas_assoc 和 weakly_referenced 标记的是曾经是否设置过，如果添加了 __weak 和关联对象再移除掉，这两个变量的值依然是1：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    __weak Person *weakPerson = person;\n    weakPerson = nil;\n    objc_setAssociatedObject(person, @\"name\", @\"Tom\", OBJC_ASSOCIATION_COPY_NONATOMIC); //添加关联对象\n    objc_setAssociatedObject(person, @\"name\", nil, OBJC_ASSOCIATION_COPY_NONATOMIC); //移除关联对象\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n查看内存：\n![Runtime07](Runtime/Runtime07.png)\n\n#### 如果没有，释放时会更快\n如果 has_assoc、has_cxx_dtor 和 weakly_referenced 为0，即没有添加过关联对象、没有析构函数和没有被弱引用指向过，会让实例对象的释放变得更快。这点可以从源码里看出来。  \n\n销毁实列对象的方法 objc_destructInstance：\n```\n/***********************************************************************\n* objc_destructInstance\n* Destroys an instance without freeing memory. \n* Calls C++ destructors.\n* Calls ARC ivar cleanup.\n* Removes associative references.\n* Returns `obj`. Does nothing if `obj` is nil.\n**********************************************************************/\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n```\n\n可以看到在销毁实例对象的方法里，判断了有没有析构函数和关联对象，如果有的话需要先处理析构函数和关联对象。\n\nJump To Definition -> clearDeallocating：\n```\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```\n\nJump To Definition -> clearDeallocating_slow：\n```\n// Slow path of clearDeallocating() \n// for objects with nonpointer isa\n// that were ever weakly referenced \n// or whose retain count ever overflowed to the side table.\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n\n在 `clearDeallocating()` 方法里判断了是否有弱引用指向过，如果有的话需要在 `clearDeallocating_slow()` 方法里处理 weakly_referenced。\n\n### ISA_MASK \n通过 `isa & ISA_MASK ` 能够取出 shiftcls 的值（Class、Meta-Class 对象的内存地址信息）。因为 `ISA_MASK` 最后面三位都是0，所以获取到的 Class、Meta-Class 对象的内存地址的最后三位肯定也为0。`ISA_MASK`：\n![Runtime03](Runtime/Runtime03.png)\n\n证明：\n```\n@interface ViewController()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSLog(@\"%p\", [ViewController class]);\n    NSLog(@\"%p\", object_getClass([ViewController class]));\n    NSLog(@\"%p\", [Person class]);\n    NSLog(@\"%p\", object_getClass([Person class]));\n}\n@end\n```\n\n打印结果：\n```\n0x1007d5550\n0x1007d5578\n0x1007d5618\n0x1007d55f0\n```\n\n可以看到打印结果的最后一位都是”8“或”0“，即”`1000`“或”`0000`“。所以 Class、Meta-Class 对象的内存地址的最后三为为0。\n\n## 位运算补充\n\n用左移定义枚举的成员变量，用”或“运算传入多个值，用”与“运算获取传入的都有哪些值：\n```\ntypedef enum {\n    OptionsOne = 1<<0,\n    OptionsTwo = 1<<1,\n    OptionsThree = 1<<2,\n    OptionsFour = 1<<3\n} Options;\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)setOptions:(Options)option {\n    if (option & OptionsOne) {\n        NSLog(@\"OptionsOne\");\n    }\n    if (option & OptionsTwo) {\n        NSLog(@\"OptionsTwo\");\n    }\n    if (option & OptionsThree) {\n        NSLog(@\"OptionsThree\");\n    }\n    if (option & OptionsFour) {\n        NSLog(@\"OptionsFour\");\n    }\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self setOptions:OptionsOne | OptionsTwo | OptionsFour];\n}\n@end\n```\n\n打印结果：\n```\nOptionsOne\nOptionsTwo\nOptionsFour\n```\n\n# Class 的结构\n\n类对象和元类对象都是 Class 类型的对象，元类对象是一种特殊的类对象。\n\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 objc_class 的定义。 \n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\n    ...... //省略\n}\n\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    ...... //省略\n}\n```\n\n结构图：\n![Runtime08](Runtime/Runtime08.png)\n\n结构图里出现的 `rw`和 `ro` 分别表示 readwrite 和 readonly。\n\n## class_rw_t\nclass_rw_t 里面的 methods、properties、protocols 是二维数组，是可读可写的，包含了类的初始内容、分类的内容。  \n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    ...... //省略\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    ...... //省略\n}\n```\n\n![Runtime09](Runtime/Runtime09.png)\n\n类的信息在编译时是放在 class_ro_t 里的，在程序运行时，会将类的 class_ro_t 里的信息和分类的信息（注意顺序）合并起来放到 class_rw_t 里。找到合并分类信息的方法 `realizeClassWithoutSwift()`：\n```\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n    runtimeLock.assertLocked();\n\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n\n    if (!cls) return nil;\n    if (cls->isRealized()) return cls;\n    ASSERT(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n\n    auto ro = (const class_ro_t *)cls->data(); //取出类信息 ro\n    auto isMeta = ro->flags & RO_META;\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();\n        ro = cls->data()->ro();\n        ASSERT(!isMeta);\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        rw = objc::zalloc<class_rw_t>(); //初始化 rw\n        rw->set_ro(ro); //添加类信息 ro\n        rw->flags = RW_REALIZED|RW_REALIZING|isMeta;\n        cls->setData(rw);\n    }\n\n    ...//一堆方法\n\n    // Attach categories\n    methodizeClass(cls, previously); //添加分类信息\n\n    return cls;\n}\n```\n\n可以看到在处理分类的信息之前，先从类里取出了类信息 ro，然后初始化了 rw，再将 ro 保存到 rw 里。\n\n### method_array_t\nmethods 是用 method_array_t 定义的，method_array_t 是一个 list_array_tt 类型的二维数组，method_array_t 里存储的是数组 method_list_t，数组 method_list_t 里存储的是 method_t：\n```\nclass method_array_t : \n    public list_array_tt<method_t, method_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<method_t, method_list_t> Super;\n\n public:\n    method_array_t() : Super() { }\n    method_array_t(method_list_t *l) : Super(l) { }\n\n    method_list_t * const *beginCategoryMethodLists() const {\n        return beginLists();\n    }\n    \n    method_list_t * const *endCategoryMethodLists(Class cls) const;\n\n    method_array_t duplicate() {\n        return Super::duplicate<method_array_t>();\n    }\n};\n```\n\n如果是类对象，methods 里保存的是对象方法，如果是元类对象，methods 里保存的是类方法。  \n\n### property_array_t\n\nproperties 是用 property_array_t 定义的，property_array_t 是一个 list_array_tt 类型的二维数组，property_array_t 里存储的是数组 property_t，数组 property_t 存储的是 property_t：\n```\nclass property_array_t : \n    public list_array_tt<property_t, property_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<property_t, property_list_t> Super;\n\n public:\n    property_array_t() : Super() { }\n    property_array_t(property_list_t *l) : Super(l) { }\n\n    property_array_t duplicate() {\n        return Super::duplicate<property_array_t>();\n    }\n};\n```\n\n### protocol_array_t\nprotocols 是用 protocol_array_t 定义的，protocol_array_t 是一个 list_array_tt 类型的二维数组，protocol_array_t 里存储的是数组 protocol_ref_t，数组 protocol_ref_t 存储的是 protocol_ref_t：\n```\nclass protocol_array_t : \n    public list_array_tt<protocol_ref_t, protocol_list_t> //list_array_tt<Element, List>\n{\n    typedef list_array_tt<protocol_ref_t, protocol_list_t> Super;\n\n public:\n    protocol_array_t() : Super() { }\n    protocol_array_t(protocol_list_t *l) : Super(l) { }\n\n    protocol_array_t duplicate() {\n        return Super::duplicate<protocol_array_t>();\n    }\n};\n```\n\n\n## class_ro_t\nclass_ro_t 里面的 baseMethodList、baseProtocols、ivars、baseProperties 是一维数组，是只读的，包含了类的初始内容。\n```\nstruct class_ro_t {\n    ...... //省略\n\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    \n    ...... //省略\n\n    property_list_t *baseProperties;\n}\n```\n\n![Runtime10](Runtime/Runtime10.png)\n\n### method_list_t、ivar_list_t 和 property_list_t\n```\nstruct method_list_t : entsize_list_tt<method_t, method_list_t, 0x3> {\n    bool isUniqued() const;\n    bool isFixedUp() const;\n    void setFixedUp();\n\n    uint32_t indexOfMethod(const method_t *meth) const {\n        uint32_t i = \n            (uint32_t)(((uintptr_t)meth - (uintptr_t)this) / entsize());\n        ASSERT(i < count);\n        return i;\n    }\n};\n\nstruct ivar_list_t : entsize_list_tt<ivar_t, ivar_list_t, 0> {\n    bool containsIvar(Ivar ivar) const {\n        return (ivar >= (Ivar)&*begin()  &&  ivar < (Ivar)&*end());\n    }\n};\n\nstruct property_list_t : entsize_list_tt<property_t, property_list_t, 0> {\n};\n```\n\n## method_t\nmethod_t 是对方法\\函数的封装。\n```\nusing MethodListIMP = IMP;\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n\n    ...... //省略\n};\n```\n\n![Runtime11](Runtime/Runtime11.png)\n\n### IMP\n`IMP` 代表函数的具体实现：\n![Runtime12](Runtime/Runtime12.png)\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"%s\", __func__); //断点2\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    \n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    \n    [person test]; //断点1\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1打印 imp：\n![Runtime17](Runtime/Runtime17.png)\n\n断点2查看 `-(void)test` 的内存（选择 Debug -> Debug Workflow -> Always Show Disassembly）：\n![Runtime10](Runtime/Runtime18.png)\n\n从打印结果可以看到，imp 指向的内存地址就是 `-(void)test` 方法的内存地址。\n\n### SEL\n`SEL` 代表方法\\函数名，一般叫做选择器，底层结构跟 `char *` 类似。\n![Runtime13](Runtime/Runtime13.png)\n* 可以通过 `@selector()` 和 `sel_registerName()` 获得。\n* 可以通过 `sel_getName()` 和 `NSStringFromSelector()` 转成字符串。\n* 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行：\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    //SEL（@selector()）就是字符串\n    NSLog(@\"%s, %s\", \"test\", @selector(test));\n    \n    //可以通过@selector()和sel_registerName()获得\n    SEL sel1 = @selector(test);\n    SEL sel2 = sel_registerName(\"test\");\n    NSLog(@\"sel1：%s, sel2：%s\", sel1, sel2);\n    \n    //可以通过sel_getName()和NSStringFromSelector()转成字符串\n    char *selString1 = sel_getName(sel1);\n    NSString *selString2 = NSStringFromSelector(sel2);\n    NSLog(@\"selString1：%s, selString2：%@\", selString1, selString2);\n    \n    //不同类中相同名字的方法，所对应的方法选择器是相同的\n    NSLog(@\"%p, %p, %p\", @selector(test), @selector(test), sel_registerName(\"test\"));\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\ntest, test\nsel1：test, sel2：test\nselString1：test, selString2：test\n0x7fff5281ed06, 0x7fff5281ed06, 0x7fff5281ed06\n```\n\n### types\ntypes 包含了函数返回值、参数编码的字符串。\n![Runtime14](Runtime/Runtime14.png)\n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行，将 main.m 改成 main.mm：  \n例1：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    Person *person = [[Person alloc] init];\n    \n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    [person test]; //断点1\n    \n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1出打印 types：\n![Runtime19](Runtime/Runtime19.png)\n\"v16@0:8\" 是类型编码：`v`：返回值类型 void，`16`：参数占的字节数之和（id（8个字节） + SEL（8个字节）），`@`：第一个参数的类型 id，`0`：第一个参数内存的开始位置，`:`：第二个参数的类型 SEL，`8`：第二个参数内存的开始位置（id 占了8个字节）。  \n\n下面的代码需要用到 ClassInfo.h，并且需要真机运行，将 main.m 改成 main.mm：\n```\n@implementation Person\n// v 16 @ 0 : 8\n//- (void)test:(id)self _cmd:(SEL)_cmd\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n例2：\n```\n@interface Person : NSObject\n- (int)test:(int)age height:(float)height;\n@end\n\n@implementation Person\n- (int)test:(int)age height:(float)height {\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    Person *person = [[Person alloc] init];\n    test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n    class_rw_t *data = cls->data();\n    [person test:20 height:30]; //断点1\n\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n断点1出打印 types：：\n```\nPrinting description of data->methods->first.types:\n(const char *) types = 0x0000000100087d4d \"i24@0:8i16f20\"\n```\n\n\"i24@0:8i16f20\" 是类型编码：`i`：范围值类型 int，`24`：参数占的字节数之和（id（8个字节） + SEL（8个字节）+ int（4个字节）+ float（4个字节）），`@`：第一个参数的类型 id，`0`：第一个参数内存的开始位置，`:`：第二个参数的类型 SEL，`8`：第二个参数内存的开始位置（id 占了8个字节），`i`：第三个参数的类型 int，`16`：第三个参数的开始位置（id 占了8个字节 + SEL 占了8个字节），`f`：第四个参数的类型 float，`20`：第四个参数的开始位置（id 占了8个字节 + SEL 占了8个字节 + int 占了4个字节）。\n```\n@implementation Person\n// i 24 @ 0 : 8 i 16 f 20\n// int test:(id self, SEL _cmd, int age, float height)\n- (void)test {\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n### Type Encoding\n[Type Encodings](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html) 是 iOS 中提供的一个叫做 @encode 的指令，可以将具体的类型表示成字符串编码。  \n![Runtime15](Runtime/Runtime15.png)\n\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    NSLog(@\"id == %s，SEL == %s\", @encode(id), @encode(SEL));\n\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n id == @，SEL == :\n```\n\n## 方法缓存\nClass 内部结构中有个方法缓存 cache（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。\n![Runtime16](Runtime/Runtime16.png)\n\n缓存查找：objc-cache.mm -> `bucket_t * cache_t::find(cache_key_t k, id receiver)`\n\ncache_t 里通过 _buckets 缓存方法，通过 _mask 计算索引，通过 _occupied 统计已经缓存的方法的数量。_buckets 里缓存的是 bucke_t 结构体：\n```\n_key = @selector(方法名)\n_imp = 方法的函数地址\n```\n\n### _mask\n_mask 的值是散列表的长度-1，保证“与”运算的结果不会超出散列表的长度（&_mask <= _mask），即计算出的索引不会越界。\n\n假设 _mask = 0b0000 1000：\n```\n  0b0100 1101\n& 0b0000 1000\n--------------\n  0b0000 1000\n```\n\n散列表（哈希表）的实现逻辑：  \n1、实现一个方法1可以计算出索引；  \n2、实现一个方法2可以解决索引冲突（如：对索引减 1 计算出新的索引值）；\n\n使用求余 `%` 也可以实现散列表（哈希表），通过求余计算出的索引也可以保证不越界。\n\n### _buckets\n_buckets 在初始化时的空间大小是指定好的，并且内部的数据都是 NULL（空间换时间）。如果 _buckets 里的数据满了，_buckets 会将数据清空 -> 扩容x2（一倍）-> 重新缓存。\n\n先通过 `mask_t begin = cache_hash(sel, m)` 计算出索引 begin：  \n如果 begin 处没有值，缓存。  \n如果 begin 处有值，是当前需要缓存的方法，表示已经缓存过了直接返回。  \n如果 begin 处有值，不是当前需要缓存的方法，通过 `(i = cache_next(i, m)` 计算出新的索引，如果新的索引不等于 begin 则重新判断，如果新的索引等于 begin 则去扩容（bad_cache()）。\n```\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{\n    ...... //省略\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = occupied() + 1; //occupied() 散列表长度，newOccupied 添加后的长度\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) { //第一次\n        // Cache is read-only. Replace it.\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) { //已经缓存的数据不足3/4\n        // Cache is less than 3/4 full. Use it as-is.\n    }\n    else {\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE; //扩容x2\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true); //清空数据 -> 扩容\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m); //计算出索引\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    do {\n        if (fastpath(b[i].sel() == 0)) { //如果 begin 处没有值，缓存\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls);\n            return;\n        }\n        if (b[i].sel() == sel) { //索引处有值，是当前需要缓存的方法\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin)); //计算出新的索引，判断新的索引是否等于 begin，如果等于 begin 则重新判断，如果不等于 begin 则调用 bad_cache() 处理异常缓存\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n\n...... //省略\n\nvoid cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld)\n{\n    bucket_t *oldBuckets = buckets(); //旧的散列表\n    bucket_t *newBuckets = allocateBuckets(newCapacity); //新的散列表\n\n    // Cache's old contents are not propagated. \n    // This is thought to save cache memory at the cost of extra cache fills.\n    // fixme re-measure this\n\n    ASSERT(newCapacity > 0);\n    ASSERT((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1);\n\n    setBucketsAndMask(newBuckets, newCapacity - 1); //使用新的散列表，_mask = newCapacity - 1\n    \n    if (freeOld) {\n        cache_collect_free(oldBuckets, oldCapacity); //清空旧的数据\n    }\n}\n```\n\n`__arm64__` 下的 cache_next 方法：\n```\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return i ? i-1 : mask;\n}\n```\n\n### 空间换时间\n散列表（哈希表）遍历元素的效率比数组高的原因是牺牲了一定的空间换取了时间。  \n#### 例1：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n\n        [person testPerson];\n        [person testPerson];\n\n        NSLog(@\"--------\"); //断点\n\n        cache_t cache = cls->cache;\n        bucket_t *buckets = cache._buckets;\n        for (int i = 0; i <= cache._mask; i++) {\n            bucket_t bucket = buckets[i];\n            if (bucket._key && bucket._key > 10) {\n                NSLog(@\"%s %p\", bucket._key, bucket._imp);\n            } else {\n                NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n--------\ninit 0x7ffe558b5aa\ntestPerson 0xc5e8\n0 0x0\n1 0x600000781640\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime20](Runtime/Runtime20.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | bucket_t（_key = @selector(init), _imp）\n1  | bucket_t（_key = @selector(testPerson), _imp）\n2  | NULL\n3  | NULL\n\n第一次调用 `[person testPerson]` 即 `objc_msgSend(objc_getClass(\"Person\"), sel_registerName(\"testPerson\"))` 向 person 实例对象发送一条 `sel_registerName(\"testPerson\")` 消息，person 会通过 isa 找到 Person 类对象查找 `-(void)testPerson` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，查到后返回。（如果没有找到，再通过 superclass 找到父类的类对象继续查找（查找方式相同）。假设在查找到基类的类对象时找到了 `-(void)testPerson` 方法，实列对象 person 会把 `-(void)testPerson` 方法缓存到 _buckets 里然后返回。）\n\n在缓存 `@selector(testPerson)` 方法时，先计算出索引（1），然后检查索引处是否有值，没值，将 `@selector(testPerson)` 缓存到对象的索引处。\n\n第二次调用 `[person testPerson]` 会先去实例对象 person 的 _buckets 里找，找到对应的索引处的值判断是否是当前方法 `@selector(testPerson)`，如果是就直接返回。（如果不是就将索引减 1 继续在 _buckets 里查找，找到了就直接返回。如果找了一圈还没有找到，会同第一次一样去类对象和父类的类对象查找，找到后缓存到 _buckets 里并返回。）\n\n#### 例2：\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        test_objc_class *cls = (__bridge test_objc_class*)[Person class];\n\n        [person testPerson];\n        [person testPerson];\n        [person testStudent];\n        [person testStudent2];\n\n        NSLog(@\"--------\"); //断点\n\n        cache_t cache = cls->cache;\n        bucket_t *buckets = cache._buckets;\n        for (int i = 0; i <= cache._mask; i++) {\n            bucket_t bucket = buckets[i];\n            if (bucket._key && bucket._key > 10) {\n                NSLog(@\"%s %p\", bucket._key, bucket._imp);\n            } else {\n                NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n--------\ntestStudent2 0xc5\n0 0x0\n0 0x0\ntestStudent 0xc5d\n0 0x0\n0 0x0\n0 0x0\n1 0x600001008500\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime21](Runtime/Runtime21.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | bucket_t（_key = @selector(testStudent2), _imp）\n1  | NULL\n2  | NULL\n3  | bucket_t（_key = @selector(testStudent), _imp）\n4  | NULL\n5  | NULL\n6  | NULL\n7  | NULL\n\n在缓存 `@selector(testStudent)` 方法时，_buckets 的空间不够了，_buckets 清空数据 -> 扩容x2（8） -> 重新缓存。先计算出索引（3），然后检查索引处是否有值，没值，将 `@selector(testPerson)` 缓存到对象的索引处。\n\n在缓存 `@selector(testStudent2)` 方法时，先计算出索引（0），然后检查索引处是否有值，没值，将 `@selector(testStudent2)` 缓存到对象的索引处。（如果索引值与 `@selector(testStudent)` 相同（3），检查到索引处有值，然后将索引减 1 获取到新的索引（2），再检查新的索引处是否有值，没值，将 `@selector(testStudent2)` 缓存到对象的索引处。）\n\n#### 例3\n```\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n    }\n    \n    Teacher *teacher = [[Teacher alloc] init];\n    test_objc_class *teacherClass = (__bridge test_objc_class *)[Teacher class];\n\n    [teacher teacherTest];\n    [teacher studentTest];\n    [teacher personTest];\n\n    NSLog(@\"--------\"); //断点\n\n    cache_t cache = teacherClass->cache;\n    bucket_t *buckets = cache._buckets;\n    for (int i = 0; i <= cache._mask; i++) {\n        bucket_t bucket = buckets[i];\n        if (bucket._key && bucket._key > 1) {\n            NSLog(@\"%s %p\", bucket._key, bucket._imp);\n        } else {\n            NSLog(@\"%lu %p\", bucket._key, bucket._imp);\n        }\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}\n```\n\n打印结果：\n```\n0 0x0\nstudentTest 0x5aa\n0 0x0\n0 0x0\n0 0x0\npersonTest 0x44c8\n0 0x0\n1 0x6000025f8380\n```\n\n断点处查看 _mask 和 _occupied：\n![Runtime22](Runtime/Runtime22.png)\n\n索引 | 缓存的方法\n-- | ------\n0  | NULL\n1  | bucket_t（_key = @selector(studentTest), _imp）\n2  | NULL\n3  | NULL\n4  | NULL\n5  | bucket_t（_key = @selector(personTest), _imp）\n6  | NULL\n7  | NULL\n\n调用 `[teacher teacherTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"teacherTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"teacherTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找 `-(void)teacherTest` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，查到后缓存到 _buckets 里并返回。\n\n调用 `[teacher studentTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"studentTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"studentTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找 `-(void)studentTest` 方法，先查 cache（_buckets），没查到，再通过 bits 找到 class_rw_t 里的 methods 查，没查到。 Teacher 类对象通过 superclass 找到父类 Student 类对象，并在 Student 类对象的 _buckets 里查找，没找到，再通过到 class_rw_t 里查找，查到后缓存到 Teacher 类对象的 _buckets 里并返回。\n\n调用 `[teacher personTest]` 即 `objc_msgSend(objc_getClass(\"Teacher\"), sel_registerName(\"personTest\"))` 向 teacher 实例对象发送一条 `sel_registerName(\"personTest\")` 消息，teacher 会通过 isa 找到 Teacher 类对象查找，先查找 _buckets，没查到，再到 class_rw_t 里的方法列表 methods 查找，没查到。Teacher 类对象会通过 superclass 找到父类 Student 类对象，并在 Student 类对象的 _buckets 里查找，没找到，再到 class_rw_t 里查找，没查到。 Student 类对象会通过 superclass 找到父类 Person 类对象，并在 Person 类对象的 _buckets 里查找，没查到，再到 class_rw_t 里查找，查到后缓存到 Teacher 类对象的 _buckets 里并返回。\n\n#### 小结\n1. 先查当前类对象的缓存 _buckets，再查当前类对象的方法列表 class_rw_t -> methods;\n2. 先查父类类对象的缓存 _buckets，再查父类类对象的方法列表 class_rw_t -> methods;\n3. 在当前类对象的缓存 _buckets 里查到后直接返回；\n4. 在当前类对象的方法列表 class_rw_t -> methods 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n5. 在父类类对象的缓存 _buckets 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n5. 在父类类对象的方法列表 class_rw_t -> methods 里查到后，先缓存到当前类对象的 _buckets 里，再返回；\n\n# objc_msgSend\nOC 中的方法调用，其实都是转换为 objc_msgSend 函数的调用。objc_msgSend 的执行流程可以分为三大阶段，即消息发送、动态方法解析和消息转发。\n\n## objc_msgSend 执行流程\n\n_objc_msgSend 的入口在汇编文件 objc-msg-arm64.s 里。runtime 的实现是用 c、c++ 和汇编语言组成的，对于一些调用频次比较高的方法一般使用汇编语言实现。对于 _objc_msgSend 等方法，为了提高效率都是使用汇编语言实现的。\n\n在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 中查找 _objc_msgSend 的实现。  \n\n### _objc_msgSend\n\nENTRY 的定义，ENTRY 是一个宏：\n```\n//macro 是宏的意思\n.macro ENTRY /* name */\n\t.text         //数据段\n\t.align 5\n\t.globl    $0  //全局名字\n$0:\n.endmacro\n```\n\n_objc_msgSend 的定义，从 ENTRY 开始，到 END_ENTRY 结束：\n```\nENTRY _objc_msgSend\n    //---------------------------- 消息发送 start ----------------------------\n\tUNWIND _objc_msgSend, NoFrame\n        //p0寄存器：消息接受者，receiver（_objc_msgSend 的第一个参数）\n\tcmp\tp0, #0\t\t\t// nil check and tagged pointer check\n#if SUPPORT_TAGGED_POINTERS\n        //b：跳转、调用。le：小于等于。如果 p0 小于等于 0，就跳转到 LNilOrTagged 方法（如果消息接收者是 nil 就跳转到 LNilOrTagged）\n\tb.le\tLNilOrTagged\t\t//  (MSB tagged pointer looks negative)\n#else\n\tb.eq\tLReturnZero\n#endif\n\tldr\tp13, [x0]\t\t// p13 = isa\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\nLGetIsaDone:\n\t// calls imp or objc_msgSend_uncached\n\tCacheLookup NORMAL, _objc_msgSend //查找缓存，参数 NORMAL。（实现👇）\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n        // 跳转到 LReturnZero 方法\n\tb.eq\tLReturnZero\t\t// nil check\n\n\t// tagged\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret //相当于 c 语言的 return\n\n\tEND_ENTRY _objc_msgSend\n```\n\n_objc_msgSend 涉及相关方法的实现\n```\n//👉 CacheLookup 的实现，查找缓存（在当前类对象的 cache 中查找）\n.macro CacheLookup\n\t//\n\t// Restart protocol:\n\t//\n\t//   As soon as we're past the LLookupStart$1 label we may have loaded\n\t//   an invalid cache pointer or mask.\n\t//\n\t//   When task_restartable_ranges_synchronize() is called,\n\t//   (or when a signal hits us) before we're past LLookupEnd$1,\n\t//   then our PC will be reset to LLookupRecover$1 which forcefully\n\t//   jumps to the cache-miss codepath which have the following\n\t//   requirements:\n\t//\n\t//   GETIMP:\n\t//     The cache-miss is just returning NULL (setting x0 to 0)\n\t//\n\t//   NORMAL and LOOKUP:\n\t//   - x0 contains the receiver\n\t//   - x1 contains the selector\n\t//   - x16 contains the isa\n\t//   - other registers are set as per calling conventions\n\t//\nLLookupStart$1:\n\n\t// p1 = SEL, p16 = isa\n\tldr\tp11, [x16, #CACHE]\t\t\t\t// p11 = mask|buckets\n\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tand\tp10, p11, #0x0000ffffffffffff\t// p10 = buckets (缓存)\n\tand\tp12, p1, p11, LSR #48\t\t// x12 = _cmd & mask (通过“与”运算计算索引)\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tand\tp10, p11, #~0xf\t\t\t// p10 = buckets\n\tand\tp11, p11, #0xf\t\t\t// p11 = maskShift\n\tmov\tp12, #0xffff\n\tlsr\tp11, p12, p11\t\t\t\t// p11 = mask = 0xffff >> p11\n\tand\tp12, p1, p11\t\t\t\t// x12 = _cmd & mask\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp (查找到函数地址，调用或者返回。hit：命中，找到。)\n\t\n2:\t// not hit: p12 = not-hit bucket（没有查找到）\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0 (实现👇)\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tadd\tp12, p12, p11, LSR #(48 - (1+PTRSHIFT))\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tadd\tp12, p12, p11, LSL #(1+PTRSHIFT)\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\nLLookupEnd$1:\nLLookupRecover$1:\n3:\t// double wrap\n\tJumpMiss $0\n\n.endmacro\n\n...... //省略\n\n//👉 CheckMiss 的实现\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL //调用 CacheLookup 时传入的参数是 NORMAL\n\tcbz\tp9, __objc_msgSend_uncached //调用 __objc_msgSend_uncached 方法（实现👇）\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n\n.macro JumpMiss\n.if $0 == GETIMP\n\tb\tLGetImpMiss\n.elseif $0 == NORMAL\n\tb\t__objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tb\t__objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n\n...... //省略\n\n//👉 __objc_msgSend_uncached 的实现\nSTATIC_ENTRY __objc_msgSend_uncached\nUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\n// THIS IS NOT A CALLABLE C FUNCTION\n// Out-of-band p16 is the class to search\n\nMethodTableLookup //查找方法列表（实现👇）\nTailCallFunctionPointer x17\n\nEND_ENTRY __objc_msgSend_uncached\n\n...... //省略\n\n//👉 MethodTableLookup 的实现\n.macro MethodTableLookup\n\t\n\t// push frame\n\tSignLR\n\tstp\tfp, lr, [sp, #-16]!\n\tmov\tfp, sp\n\n\t// save parameter registers: x0..x8, q0..q7\n\tsub\tsp, sp, #(10*8 + 8*16)\n\tstp\tq0, q1, [sp, #(0*16)]\n\tstp\tq2, q3, [sp, #(2*16)]\n\tstp\tq4, q5, [sp, #(4*16)]\n\tstp\tq6, q7, [sp, #(6*16)]\n\tstp\tx0, x1, [sp, #(8*16+0*8)]\n\tstp\tx2, x3, [sp, #(8*16+2*8)]\n\tstp\tx4, x5, [sp, #(8*16+4*8)]\n\tstp\tx6, x7, [sp, #(8*16+6*8)]\n\tstr\tx8,     [sp, #(8*16+8*8)]\n\n        // 这条注释可以看到在调用 lookUpImpOrForward 函数时的参数    \n\t// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)\n\t// receiver and selector already in x0 and x1\n\tmov\tx2, x16\n\tmov\tx3, #3\n\tbl\t_lookUpImpOrForward //_lookUpImpOrForward 方法返回的是函数地址 imp，bl imp：跳转\\调用imp。（实现👇）\n\n\t// IMP in x0\n\tmov\tx17, x0\n\t\n\t// restore registers and return\n\tldp\tq0, q1, [sp, #(0*16)]\n\tldp\tq2, q3, [sp, #(2*16)]\n\tldp\tq4, q5, [sp, #(4*16)]\n\tldp\tq6, q7, [sp, #(6*16)]\n\tldp\tx0, x1, [sp, #(8*16+0*8)]\n\tldp\tx2, x3, [sp, #(8*16+2*8)]\n\tldp\tx4, x5, [sp, #(8*16+4*8)]\n\tldp\tx6, x7, [sp, #(8*16+6*8)]\n\tldr\tx8,     [sp, #(8*16+8*8)]\n\n\tmov\tsp, fp\n\tldp\tfp, lr, [sp], #16\n\tAuthenticateLR\n\n.endmacro\n```\n\n### _lookUpImpOrForward\n👉 \\_lookUpImpOrForward 的实现在 objc-runtime-new.mm 文件。老版本的 runtime 源码在这里调用的是 `__class_lookupMethodAndLoadCache3`，`_class_lookupMethodAndLoadCache3` 函数里调用的才是 lookUpImpOrForward：\n```\nIMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) {\n    return lookUpImpOrForward(cls, sel, obj, YES/*initalize*/, NO/*cache*/, YES/*reslover*/);\n}\n```\n\n\\_lookUpImpOrForward 是一个通过 c 语言实现的函数（对于函数名，汇编语言转 c 语言需要去掉一个“`_`”）。\n```\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache; //默认消息转发（实现👇）\n    IMP imp = nil;\n    Class curClass;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) { //传入的 behavior 是 LOOKUP_INITIALIZE | LOOKUP_RESOLVER，条件不成立\n        imp = cache_getImp(cls, sel); //在缓存里查找\n        if (imp) goto done_nolock; //跳转到 done_nolock 方法\n    }\n\n    // runtimeLock is held during isRealized and isInitialized checking\n    // to prevent races against concurrent realization.\n\n    // runtimeLock is held during method search to make\n    // method-lookup + cache-fill atomic with respect to method addition.\n    // Otherwise, a category could be added but ignored indefinitely because\n    // the cache was re-filled with the old value after the cache flush on\n    // behalf of the category.\n\n    runtimeLock.lock();\n\n    // We don't want people to be able to craft a binary blob that looks like\n    // a class but really isn't one and do a CFI attack.\n    //\n    // To make these harder we want to make sure this is a class that was\n    // either built into the binary or legitimately registered through\n    // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.\n    //\n    // TODO: this check is quite costly during process startup.\n    checkIsKnownClass(cls);\n\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n    }\n\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n\n        // If sel == initialize, class_initialize will send +initialize and \n        // then the messenger will send +initialize again after this \n        // procedure finishes. Of course, if this is not being called \n        // from the messenger then it won't happen. 2778172\n    }\n\n    runtimeLock.assertLocked();\n    curClass = cls;\n\n    // The code used to lookpu the class's cache again right after\n    // we take the lock but for the vast majority of the cases\n    // evidence shows this is a miss most of the time, hence a time loss.\n    //\n    // The only codepath calling into this without having performed some\n    // kind of cache lookup is class_getInstanceMethod().\n\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.（curClass 的方法列表）\n        // for 循环第一次时，curClass 代表当前类\n        // for 循环非第一次时，curClass 代表父类\n        Method meth = getMethodNoSuper_nolock(curClass, sel); //到 curClass 的方法列表里面找（实现👇）\n        if (meth) { //如果找到了\n            imp = meth->imp; //取出方法的函数地址\n            goto done; //跳转到 done 方法\n        }\n        \n        // 执行 curClass = curClass->superclass，找到更上层父类，并判断新赋值的 curClass 是否为 nil（通过 for 循环重复执行，遍历父类）\n        if (slowpath((curClass = curClass->superclass) == nil)) { \n            // No implementation found, and method resolver didn't help.\n            // Use forwarding.\n            imp = forward_imp; //如果新赋值的 curClass 为 nil，说明没有更上层父类了，则设置 imp = forward_imp（消息转发）\n            break; //跳出 for 循环\n        }\n\n        // Halt if there is a cycle in the superclass chain.\n        if (slowpath(--attempts == 0)) { //判断 attempts - 1 后是否等于 0\n            _objc_fatal(\"Memory corruption in class list.\"); //如果等于 0 报错\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel); //到父类的缓存里查找（此时 curClass 代表父类）\n        \n        if (slowpath(imp == forward_imp)) {\n            // Found a forward:: entry in a superclass.\n            // Stop searching, but don't cache yet; call method\n            // resolver for this class first.\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done; //如果在父类的缓存里找到了，跳转到 done 方法\n        }\n    }\n    //---------------------------- 消息发送 end ----------------------------\n\n    //---------------------------- 动态方法解析 start ----------------------------\n    // No implementation found. Try method resolver once.\n    \n    if (slowpath(behavior & LOOKUP_RESOLVER)) { //behavior 里是否包含 LOOKUP_RESOLVER，判断是否有过动态方法解析了（传入的 behavior 是 LOOKUP_INITIALIZE | LOOKUP_RESOLVER）\n        behavior ^= LOOKUP_RESOLVER; //再加一个 LOOKUP_RESOLVER（动态方法解析执行完成后，会再走一遍 lookUpImpOrForward，保证只操作一次动态方法解析）\n        return resolveMethod_locked(inst, sel, cls, behavior); //实现👇\n    }\n    //---------------------------- 动态方法解析 end ----------------------------\n\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass); //将从 curClass 类里找到的函数地址 imp 填充到 cls（objc_msgSend的接收者）的缓存里（实现👇）\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp; //返回函数地址\n}\n```\n\n消息发送相关方法实现\n```\n//👉 getMethodNoSuper_nolock 的实现\nstatic method_t *\ngetMethodNoSuper_nolock(Class cls, SEL sel)\n{\n    runtimeLock.assertLocked();\n\n    ASSERT(cls->isRealized());\n    // fixme nil cls? \n    // fixme nil sel?\n\n    auto const methods = cls->data()->methods(); //cls->data() 返回到是 class_rw_t，即 class_rw_t->methods()\n    for (auto mlists = methods.beginLists(),\n              end = methods.endLists();\n         mlists != end;\n         ++mlists)\n    {\n        // <rdar://problem/46904873> getMethodNoSuper_nolock is the hottest\n        // caller of search_method_list, inlining it turns\n        // getMethodNoSuper_nolock into a frame-less function and eliminates\n        // any store from this codepath.\n        method_t *m = search_method_list_inline(*mlists, sel); //到方法列表里查找（实现👇）\n        if (m) return m;\n    }\n\n    return nil;\n}\n\n...... //省略\n\n//👉 search_method_list_inline 的实现\nstatic method_t *\nsearch_method_list_inline(const method_list_t *mlist, SEL sel)\n{\n    int methodListIsFixedUp = mlist->isFixedUp();\n    int methodListHasExpectedSize = mlist->entsize() == sizeof(method_t);\n    \n    if (fastpath(methodListIsFixedUp && methodListHasExpectedSize)) { //是否是排好序的方法列表\n        return findMethodInSortedMethodList(sel, mlist); //在已经排好序的方法列表里面查找（二分查找）（实现👇）\n    } else {\n        // 在没有排好序的方法列表里遍历查找\n        // Linear search of unsorted method list\n        for (auto& meth : *mlist) { \n            if (meth.name == sel) return &meth;\n        }\n    }\n\n#if DEBUG\n    // sanity-check negative results\n    if (mlist->isFixedUp()) {\n        for (auto& meth : *mlist) {\n            if (meth.name == sel) {\n                _objc_fatal(\"linear search worked when binary search did not\");\n            }\n        }\n    }\n#endif\n\n    return nil;\n}\n\n...... //省略\n\n//👉 findMethodInSortedMethodList 的实现\nALWAYS_INLINE static method_t *\nfindMethodInSortedMethodList(SEL key, const method_list_t *list)\n{\n    ASSERT(list);\n\n    const method_t * const first = &list->first;\n    const method_t *base = first;\n    const method_t *probe;\n    uintptr_t keyValue = (uintptr_t)key;\n    uint32_t count;\n    //二分查找\n    for (count = list->count; count != 0; count >>= 1) {\n        probe = base + (count >> 1);\n        \n        uintptr_t probeValue = (uintptr_t)probe->name;\n        \n        if (keyValue == probeValue) {\n            // `probe` is a match.\n            // Rewind looking for the *first* occurrence of this value.\n            // This is required for correct category overrides.\n            while (probe > first && keyValue == (uintptr_t)probe[-1].name) {\n                probe--;\n            }\n            return (method_t *)probe;\n        }\n        \n        if (keyValue > probeValue) {\n            base = probe + 1;\n            count--;\n        }\n    }\n    \n    return nil;\n}\n\n...... //省略\n\n//👉 log_and_fill_cache 的实现\nstatic void\nlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)\n{\n#if SUPPORT_MESSAGE_LOGGING\n    if (slowpath(objcMsgLogEnabled && implementer)) {\n        bool cacheIt = logMessageSend(implementer->isMetaClass(), \n                                      cls->nameForLogging(),\n                                      implementer->nameForLogging(), \n                                      sel);\n        if (!cacheIt) return;\n    }\n#endif\n    cache_fill(cls, sel, imp, receiver); //填充到缓存\n}\n\n//cache_fill 的实现在 objc-cache.mm 文件\nvoid cache_fill(Class cls, SEL sel, IMP imp, id receiver)\n{\n    runtimeLock.assertLocked();\n\n#if !DEBUG_TASK_THREADS\n    // Never cache before +initialize is done\n    if (cls->isInitialized()) {\n        cache_t *cache = getCache(cls);\n#if CONFIG_USE_CACHE_LOCK\n        mutex_locker_t lock(cacheUpdateLock);\n#endif\n        cache->insert(cls, sel, imp, receiver); //填充到缓存的具体实现（实现👇）\n    }\n#else\n    _collecting_in_critical();\n#endif\n}\n\n...... //省略\n\n//👉 cache_t::insert 的实现\nALWAYS_INLINE\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{\n#if CONFIG_USE_CACHE_LOCK\n    cacheUpdateLock.assertLocked();\n#else\n    runtimeLock.assertLocked();\n#endif\n\n    ASSERT(sel != 0 && cls->isInitialized());\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = occupied() + 1;\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) { //判断添加后的剩余空间\n        // Cache is less than 3/4 full. Use it as-is.\n    }\n    else { //扩容x2\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true);\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m); //计算索引\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    do {\n        if (fastpath(b[i].sel() == 0)) { //索引处没有方法\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls); //添加到缓存中对应的索引处\n            return;\n        }\n        if (b[i].sel() == sel) {  //索引处有方法并且是同一个方法，表示已经存储过了，返回\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin)); //重新计算索引（当前索引减 1），判断是否查了一圈了\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n```\n\n### resolveMethod_locked()\n动态方法解析相关方法实现\n```\n//👉 resolveMethod_locked 的实现\nstatic NEVER_INLINE IMP\nresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)\n{\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n\n    runtimeLock.unlock();\n\n    if (! cls->isMetaClass()) { \n        // 不是元类对象\n        // try [cls resolveInstanceMethod:sel]\n        resolveInstanceMethod(inst, sel, cls); //实现👇\n    } \n    else {\n        // 是元类对象\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n        resolveClassMethod(inst, sel, cls); //实现👇\n        if (!lookUpImpOrNil(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls); //实现👇\n        }\n    }\n\n    // chances are that calling the resolver have populated the cache\n    // so attempt using it\n    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE); //动态方法解析相关方法调用完成后，会再走一遍 lookUpImpOrForward 方法，即消息发送的第二步（实现👆）\n}\n\n//👉 resolveInstanceMethod 的实现\nstatic void resolveInstanceMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    SEL resolve_sel = @selector(resolveInstanceMethod:);\n\n    if (!lookUpImpOrNil(cls, resolve_sel, cls->ISA())) {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, resolve_sel, sel); //让 cls 调用 resolve_sel 方法\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNil(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n\n//👉 resolveClassMethod 的实现\nstatic void resolveClassMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    ASSERT(cls->isMetaClass());\n\n    if (!lookUpImpOrNil(inst, @selector(resolveClassMethod:), cls)) {\n        // Resolver not implemented.\n        return;\n    }\n\n    Class nonmeta;\n    {\n        mutex_locker_t lock(runtimeLock);\n        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);\n        // +initialize path should have realized nonmeta already\n        if (!nonmeta->isRealized()) {\n            _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\",\n                        nonmeta->nameForLogging(), nonmeta);\n        }\n    }\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveClassMethod adds to self->ISA() a.k.a. cls\n    IMP imp = lookUpImpOrNil(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n### __objc_msgForward_impcache\n消息转发相关方法的实现\n👉 __objc_msgForward_impcache 方法的实现在汇编文件 objc-msg-arm64.s\n```\n\tSTATIC_ENTRY __objc_msgForward_impcache\n\n\t// No stret specialization.\n\tb\t__objc_msgForward\n\n\tEND_ENTRY __objc_msgForward_impcache\n\n\t\n\tENTRY __objc_msgForward\n\n\tadrp\tx17, __objc_forward_handler@PAGE\n\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF] //实现👇\n\tTailCallFunctionPointer x17\n\t\n\tEND_ENTRY __objc_msgForward\n```\n\n👉 _objc_forward_handler 的实现在 C 语言文件 objc-runtime.mm。\n```\n#if !__OBJC2__\n\n// Default forward handler (nil) goes to forward:: dispatch.\nvoid *_objc_forward_handler = nil;\nvoid *_objc_forward_stret_handler = nil;\n\n#else\n\n// Default forward handler halts the process.\n__attribute__((noreturn, cold)) void\nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n```\n\n这里的 _objc_forward_handler 指针存储的是 objc_defaultForwardHandler 的函数地址。因为 _objc_forward_handler 没有开源，所以看不到其具体的内部实现，即无法知道该方法在消息转发阶段具体做了什么。在报错信息里可以看到消息转发最后调用了 `__forwarding__` 方法：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n报错信息：\n![Runtime26](Runtime/Runtime26.png)\n\n通过反编译可以看到 _objc_forward_handler 的具体实现，这里有一份根据汇编代码翻译成的 C 语言伪代码 `__forwarding__.c`：\n```\n// 伪代码\nint __forwarding__(void *frameStackPointer, int isStret) {\n    id receiver = *(id *)frameStackPointer;\n    SEL sel = *(SEL *)(frameStackPointer + 8);\n    const char *selName = sel_getName(sel);\n    Class receiverClass = object_getClass(receiver);\n\n    // 调用 forwardingTargetForSelector:\n    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {\n        id forwardingTarget = [receiver forwardingTargetForSelector:sel]; //实例对象 - 对象方法，类对象 - 类方法\n        if (forwardingTarget && forwardingTarget != receiver) {\n            if (isStret == 1) {\n                int ret;\n                objc_msgSend_stret(&ret,forwardingTarget, sel, ...);\n                return ret;\n            }\n            return objc_msgSend(forwardingTarget, sel, ...); //返回值 forwardingTarget 调用方法\n        }\n    }\n\n    // 僵尸对象\n    const char *className = class_getName(receiverClass);\n    const char *zombiePrefix = \"_NSZombie_\";\n    size_t prefixLen = strlen(zombiePrefix); // 0xa\n    if (strncmp(className, zombiePrefix, prefixLen) == 0) {\n        CFLog(kCFLogLevelError,\n              @\"*** -[%s %s]: message sent to deallocated instance %p\",\n              className + prefixLen,\n              selName,\n              receiver);\n        <breakpoint-interrupt>\n    }\n\n    // 调用 methodSignatureForSelector 获取类型编码后再调用 forwardInvocation\n    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {\n        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; //实例对象 - 对象方法，类对象 - 类方法\n        if (methodSignature) {\n            BOOL signatureIsStret = [methodSignature _frameDescriptor]->returnArgInfo.flags.isStruct;\n            if (signatureIsStret != isStret) {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.\",\n                      selName,\n                      signatureIsStret ? \"\" : not,\n                      isStret ? \"\" : not);\n            }\n            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {\n                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];\n\n                [receiver forwardInvocation:invocation];\n\n                void *returnValue = NULL;\n                [invocation getReturnValue:&value];\n                return returnValue;\n            } else {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\",\n                      receiver,\n                      className);\n                return 0;\n            }\n        }\n    }\n\n    SEL *registeredSel = sel_getUid(selName);\n\n    // selector 是否已经在 Runtime 注册过\n    if (sel != registeredSel) {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\",\n              sel,\n              selName,\n              registeredSel);\n    } // doesNotRecognizeSelector\n    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {\n        [receiver doesNotRecognizeSelector:sel];\n    }\n    else {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\",\n              receiver,\n              className);\n    }\n\n    // The point of no return.\n    kill(getpid(), 9);\n}\n```\n\n## 消息发送\n![Runtime23](Runtime/Runtime23.png)\n\n* receiver 通过 isa 指针找到 receiverClass，receiverClass 通过superclass 指针找到 superClass\n* 如果是从class_rw_t中查找方法  \n已经排序的，二分查找  \n没有排序的，遍历查找\n\n流程解析：\n1. 首先判断 receiver 是否为空，如果 receiver 为空直接退出，如果 receiver 不为空则到 receiverClass 的 cache 中查找方法；  \n2. 从 receiverClass 的 cache 中查找方法，找到了方法，则调用方法结束查找。没找到方法，则从 receiverClass 的 class_rw_t 中查找方法；\n3. 从 receiverClass 的 class_rw_t 中查找方法，找到了方法，则将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没有找到方法，则从 superclass 的 cache 中查找方法；\n4. 从 superclass 的 cache 中查找方法，找到了方法，将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没找到方法，则从 superclass 的 class_rw_t 中查找方法；\n5. 从 superclass 的 class_rw_t 中查找方法，找到了方法，则将方法缓存到 receiverClass 的 cache 中，并调用方法结束查找。没有找到方法，则判断上层是否还有 superclass；\n6. 判断上层是否还有 superclass，有，则回到第4步。没有，则开始动态方法解析；\n\n## 动态方法解析\n![Runtime24](Runtime/Runtime24.png)\n* 开发者可以实现以下方法，来动态添加方法实现\n```\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n+ (BOOL)resolveClassMethod:(SEL)sel;\n```\n* 动态解析过后，会重新走“消息发送”的流程（“从 receiverClass的cache 中查找方法”这一步开始执行）\n\n### 动态添加对象方法\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        Method method = class_getInstanceMethod(self, @selector(other));\n        //动态添加方法\n        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Person other]\n```\n\nMethod 是指向结构体 method_t 的指针，即 struct objc_method == struct method_t，所以 `class_getInstanceMethod(self, @selector(other))` 返回的是结构体 method_t。Method 的定义：\n```\ntypedef struct objc_method *Method;\n```\n\n证明：\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n- (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\nstruct method_t {\n    SEL sel;\n    char *types;\n    IMP imp;\n};\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        struct method_t *method = (struct method_t *)class_getInstanceMethod(self, @selector(other));\n        NSLog(@\"%s %s %p\", method->sel, method->types, method->imp);\n        //动态添加方法\n        class_addMethod(self, sel, method->imp, method->types);\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nother v16@0:8 0x100000b40\n-[Person other]\n```\n\n### 动态添加C语言函数\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\nvoid c_other(id self, SEL _cmd)\n{\n    NSLog(@\"c_other - %@ - %@\", self, NSStringFromSelector(_cmd));\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //动态添加方法，C语言的函数地址==函数名，函数编码\"v16@0:8\"（也可以写成 v@:）\n        class_addMethod(self, sel, (IMP)c_other, \"v16@0:8\");\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n### 动态添加类方法\n```\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (void)other\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (BOOL)resolveClassMethod:(SEL)sel\n{\n    if (sel == @selector(test)) {\n        //获取其它方法\n        Method method = class_getClassMethod(self, @selector(other));\n        //动态添加方法\n        class_addMethod(object_getClass(self), sel, method_getImplementation(method), method_getTypeEncoding(method));\n        //返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Person other]\n```\n\n\n## 消息转发\n![Runtime25](Runtime/Runtime25.png)\n* 开发者可以在 forwardInvocation: 方法中自定义任何逻辑\n* 以上方法都有对象方法、类方法2个版本（前面可以是加号+，也可以是减号-）\n\n### 对象方法的消息转发\n\n#### -forwardingTargetForSelector: 方法\n`-forwardingTargetForSelector:` 方法有返回值时，返回值调用方法：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return [[Student alloc] init];\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n#### -methodSignatureForSelector: 方法\n\n`-forwardingTargetForSelector:` 方法没有返回值时，会调用 `-methodSignatureForSelector:` 方法获取类型编码：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n- (void)test;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n//类型编码：返回值类型、参数类型\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]; //也可以写成 v@:\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    /*\n     anInvocation.target = [[Student alloc] init];\n     [anInvocation invoke]; //调用\n     */\n    [anInvocation invokeWithTarget:[[Student alloc] init]]; //传入 Target 调用\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n如果 `-methodSignatureForSelector:` 方法没有返回类型编码，则会报错：\n![Runtime27](Runtime/Runtime27.png)\n\n从调用栈可以看到停留在了 `doesNotRecognizeSelector:` 方法：\n![Runtime28](Runtime/Runtime28.png)\n\n类型编码的另一种返回方式：\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test:)) {\n        return [[[Student alloc] init] methodSignatureForSelector:aSelector];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n```\n\n因为 Student 实现了 `-(void)test:(int)age` 方法，所以调用 Student 的 `methodSignatureForSelector:` 方法可以返回 `-(void)test:(int)age` 方法的类型编码。\n\n### 类方法的消息转发\n\n#### +forwardingTargetForSelector: 方法\n\n在 `+forwardingTargetForSelector:` 方法里返回类对象：\n```\n@interface Student : NSObject\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) { //类方法和对象方法的方法名都是 \"test\"\n        return [Student class];         //objc_msgSend([Student class], @selector(\"test\"))\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Student test]\n```\n\n在 `+forwardingTargetForSelector:` 方法里返回实列对象：\n```\n@interface Student : NSObject\n- (void)test;\n@end\n\n@implementation Student\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) { //类方法和对象方法的方法名都是 \"test\"\n        return [[Student alloc] init];  //objc_msgSend([[Student alloc] init], @selector(\"test\"))\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n-[Student test]\n```\n\n#### +methodSignatureForSelector: 方法\n\n`+forwardingTargetForSelector:` 方法没有返回值时，会调用 `+methodSignatureForSelector:` 方法获取类型编码：\n```\n@interface Student : NSObject\n+ (void)test;\n@end\n\n@implementation Student\n+ (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n@implementation Person\n+ (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]; //也可以写成 v@:\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n+ (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[Student class]];\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        [Person test];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n+[Student test]\n```\n\n[Person test] 的本质是 objc_msgSend([Person class], @selector(test))，会先走一遍“消息发送”流程。因为 Person 没有实现 `-(void)test` 方法，所以\n\n#### NSInvocation\nNSInvocation 封装了一个方法调用，包括：方法调用者、方法名、方法参数和返回值（类型编码决定 NSInvocation 的方法参数和返回值）。  \nanInvocation.target 方法调用者  \nanInvocation.selector 方法名  \n[anInvocation getArgument:NULL atIndex:0] 方法参数\n\n示例代码：\n```\n@interface Student : NSObject\n- (int)test:(int)age;\n@end\n\n@implementation Student\n- (int)test:(int)age\n{\n    NSLog(@\"%s，age == %d\", __func__, age);\n    return age * 2;\n}\n@end\n\n@interface Person : NSObject\n- (int)test:(int)age;\n@end\n\n@implementation Person\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    if (aSelector == @selector(test:)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(test:)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"i24@0:8i16\"];;\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // to do 👇\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *person = [[Person alloc] init];\n        [person test:15];\n    }\n    return 0;\n}\n```\n\n👉 通过 `getArgument:atIndex:` 方法获取参数：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    int age;\n    [anInvocation getArgument:&age atIndex:2]; //传入 age 的地址和下标\n    NSLog(@\"age == %d\", age);\n}\n```\n\n打印结果：\n```\nage == 15\n```\n\n因为 `-(void)test:(int)age` 的 C 语言实现是 `void test(id self, SEL _cmd, int age)`，一共有三个参数，参数顺序：receiver、selector 和 other argument，所以参数 age 的下标是 2。\n\n👉 调用 `invokeWithTarget:` 方法，将消息转发给 Student 的实例对象：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    /**\n     anInvocation.target == person对象\n     anInvocation.selector == test:\n     anInvocation 的参数：15\n     */\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n}\n```\n\n打印结果：\n```\n-[Student test:]，age == 15\n```\n\n在调用 `invokeWithTarget:` 方法前，anInvocation 的 target 是 person 对象，selector 是 `-(void)test:(int)age` 方法，参数是 15。在调用 `invokeWithTarget:` 方法后， anInvocation 的 target 就变成了 student 对象了。相当于向 student 对象发送了一条“test:”消息 `objc_msgSend([[Student alloc] init], @selector(test:))`。\n\n👉 调用 `getReturnValue:` 方法获取返回值：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n    int returnAge;\n    [anInvocation getReturnValue:&returnAge];\n    NSLog(@\"returnAge == %d\", returnAge);\n}\n```\n\n打印结果：\n```\n-[Student test:]，age == 15\nreturnAge == 30\n```\n\n### @synthesize、@dynamic\n\n@synthesize 会自动生成属性 age 的成员变量 _age，同时生成属性 age 的 setter 和 getter 方法的实现。现在的 xcode 都是默认生成了，不用手写了。\n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Student\n@synthesize age = _age;\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *student = [[Student alloc] init];\n        student.age = 20;\n        NSLog(@\"student.age == %d\", student.age);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\nstudent.age == 20\n```\n\n@dynamic 是告诉编译器不需要自动生成属性 age 的成员变量 _age，也不需要生成属性 age 的 setter 和 getter 方法的实现。 \n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age; //声明 age 的 setter 和 getter 方法\n@end\n\n@implementation Student\n@dynamic age;\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *student = [[Student alloc] init];\n        student.age = 20; //[student setAge:20]，有 setter 和 getter 方法的声明，没有 setter 和 getter 方法的实现\n        NSLog(@\"student.age == %d\", student.age);\n    }\n    return 0;\n}\n```\n\n报错：unrecognized selector sent to instance\n![Runtime29](Runtime/Runtime29.png)\n\n使用动态方法解析解决这个问题：\n```\n@interface Student : NSObject\n@property (nonatomic, assign) int age;\n@end\n\n@implementation Student\n\n@dynamic age;\n\nvoid setAge(id self, SEL _cmd, int age)\n{\n    NSLog(@\"age is %d\", age);\n}\n\nint age(id self, SEL _cmd)\n{\n    return 15;\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(setAge:)) {\n        class_addMethod(self, sel, (IMP)setAge, \"v@:i\");\n        return YES;\n    } else if (sel == @selector(age)) {\n        class_addMethod(self, sel, (IMP)age, \"i@:\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n```\n\n打印结果：\n```\nage is 20\nstudent.age == 15\n```\n\n### 小结\n* `forwardingTargetForSelector:`、`methodSignatureForSelector:` 和 `forwardInvocation:` 方法本身并没有区分对象方法和类方法，但是在 _objc_forward_handler 的实现中，receiver （实列对象/类对象）会调用对应的方法（对象方法/类方法），所以实现的方法类型需要跟返回的类型统一。消息转发中，不要在意方法是对象方法还是类方法，本质还是 objc_msgSend 的消息接收者和方法名（实例对象 - 对象方法，类对象 - 类方法）。\n\n\n# super 的本质\n\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\n@end\n\n@interface Student : Person\n@end\n\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"[self class] = %@\", [self class]);\n        NSLog(@\"[self superclass] = %@\", [self superclass]);\n        NSLog(@\"----------------------------\");\n        NSLog(@\"[super class] = %@\", [super class]);\n        NSLog(@\"[super superclass] = %@\", [super superclass]);\n    }\n    return self;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc] init];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n [self class] = Student\n [self superclass] = Person\n ----------------------------\n [super class] = Student\n [super superclass] = Person\n```\n\n这里的 self 就是 person 实例对象，`[self class]` 返回的是 person 实例对象的类对象，`[self superclass]` 返回的是父类 Person 的类对象。  \n\n思考：  \nsuper 代表的是 student 的父类 person，那么 `[super class]` 应该就等于 `[person class]`，打印结果应该是 Person，而 `[super class]`  的打印结果却是 Student❓同样的 `[super superclass]` 应该就等于 `[person superclass]`，打印结果应该是 NSObject，而 `[super superclass]` 打印结果却是 Person❓\n\n## objc_super 结构体\n\n定义一个 `-(void)run` 方法：\n```\n@interface Person : NSObject\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%@\", __func__);\n}\n@end\n\n@interface Student : Person\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    [super run];\n}\n@end\n```\n\n通过终端命令 `xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc Student.m` 生成 c++ 代码 Student.cpp，查看 `-(void)run` 方法的 c++ 实现：\n```\nstatic void _I_Student_run(Student * self, SEL _cmd) {\n    //[super run];\n    ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"run\"));\n}\n```\n\n简化后的 `[super run]`：\n```\nobjc_msgSendSuper( (__rw_objc_super){\n                        self, //student 实例对象\n                        class_getSuperclass(objc_getClass(\"Student\")) //[Person class]\n                    }, //__rw_objc_super 结构体\n                    sel_registerName(\"run\") //@selector(run)) );\n```\n\n可以看到 `[super run]` 的底层实现调用的是 `objc_msgSendSuper()` 方法，第一个参数是 `__rw_objc_super` 结构体，第二参数是 `@selector(run)`。所以 super 的本质就是 `__rw_objc_super` 结构体：\n```\nstruct __rw_objc_super { \n\tstruct objc_object *object; \n\tstruct objc_object *superClass; \n\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) {} \n};\n```\n\n`__rw_objc_super` 结构体是在编译时生成的，并将参数传入 objc_msgSendSuper() 方法。但是 objc_msgSendSuper() 在定义时该位置的参数是一个 objc_super 结构体：\n```\nstruct objc_super {\n    /// Specifies an instance of a class.\n    __unsafe_unretained _Nonnull id receiver;\n\n    /// Specifies the particular superclass of the instance to message. \n#if !defined(__cplusplus)  &&  !__OBJC2__\n    /* For compatibility with old objc-runtime.h header */\n    __unsafe_unretained _Nonnull Class class;\n#else\n    __unsafe_unretained _Nonnull Class super_class;\n#endif\n    /* super_class is the first class to search */\n};\n```\n\n因为 `__rw_objc_super` 和 objc_super 的结构基本一致，所以 `__rw_objc_super` 结构体算是一个自定的 objc_super，作为参数传给 objc_msgSendSuper()。\n\n因为现在使用的是 `__OBJC2__`，所以 objc_super 可以简化为：\n```\nstruct objc_super {\n    __unsafe_unretained _Nonnull id receiver; //消息接收者\n    __unsafe_unretained _Nonnull Class super_class; //消息接收者的父类\n};\n```\n\n可以看到 objc_super 结构体的第一个参数是消息接收者，第二个参数是消息接收者的父类。所以 `[super run]` 的底层实现就是：\n```\nstruct __rw_objc_super arg = { \n    self, //消息接收者\n    [Person class] //消息接收者的父类 \n};\nobjc_msgSendSuper(arg, @selector(run));\n```\n\n## objc_msgSendSuper() 方法\n\n通过终端命令 `xcrun -sdk iphoneos clang -arch arm64  -rewrite-objc Student.m` 生成的 c++ 代码 Student.cpp，查看 `[super run]` 的 c++ 实现是调用的 objc_msgSendSuper() 方法。  \n\n关于 `[super run]` 调用的方法 objc_msgSendSuper()：\n```\n/** \n * Sends a message with a simple return value to the superclass of an instance of a class.\n * \n * @param super A pointer to an \\c objc_super data structure. Pass values identifying the\n *  context the message was sent to, including the instance of the class that is to receive the\n *  message and the superclass at which to start searching for the method implementation.\n * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.\n * @param ...\n *   A variable argument list containing the arguments to the method.\n * \n * @return The return value of the method identified by \\e op.\n * \n * @see objc_msgSend\n */\nOBJC_EXPORT id _Nullable\nobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);\n```\n\nobjc_msgSendSuper：向实例对象的 super 发送带有简单返回值的消息。第一个参数：super，第二个参数：op（方法的选择器 SEL）。  \n* super：是一个指向 `objc_super` 结构体的指针，在结构体的内部有接收消息的实例对象和开始搜索方法实现的类对象（从该类对象开始搜索方法的实现）。  \n* op：SEL 类型的指针。传递方法的选择器（@selector(run)），该方法就是要处理的消息。\n\n通过注释，可以知道 objc_msgSendSuper() 有两个参数 super 和 SEL，其中 super 里有一个消息接收者和一个类对象。objc_msgSendSuper() 会从 super 里的类对象开始查找 SEL，找到后交给 super 里的消息接收者处理。\n\n综上所述：  \n`[super run]`：设置消息接收者是 self（student 实例对象），并从 Person 类对象开始查找 `-(void)run` 方法：\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(run));\n```\n\n`[super method]` 流程图：\n![Runtime30](Runtime/Runtime30.png)\n\n## objc_msgSendSuper2()\n\n### 查看汇编代码\n在 `[super superclass];` 处添加断点，选择 Debug -> Debug Workflow -> Always Show Disassembly：\n![Runtime31](Runtime/Runtime31.png)\n可以看到 `[super class]` 和 `[super superclass]` 底层实现调用的并不是 `objc_msgSendSuper()` 方法而是 `objc_msgSendSuper2()` 方法。\n\n\n`objc_msgSendSuper2()` 方法的具体实现在汇编文件 objc-msg-arm64.s 里：\n```\n\tENTRY _objc_msgSendSuper2\n\tUNWIND _objc_msgSendSuper2, NoFrame\n\n\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class\n\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class->superclass\n\tCacheLookup NORMAL, _objc_msgSendSuper2\n\n\tEND_ENTRY _objc_msgSendSuper2\n```\n\n也可以通过选择 Product -> Perform Action -> Assemble \"Student.m\" 将 OC 代码转成汇编代码，搜索 “:21”（第21行）找到具体的代码实现：\n```\n......//省略\n\nLtmp0:\n\t.loc\t3 21 5 prologue_end     ## Runtime-test2/Student.m:21:5 //Student.m 文件的第 21 行\n\tmovq\t-8(%rbp), %rax\n\tmovq\t%rax, -32(%rbp)\n\tmovq\t_OBJC_CLASSLIST_SUP_REFS_$_(%rip), %rax\n\tmovq\t%rax, -24(%rbp)\n\tmovq\t_OBJC_SELECTOR_REFERENCES_(%rip), %rsi\n\tleaq\t-32(%rbp), %rdi\n\tcallq\t_objc_msgSendSuper2\n\t.loc\t3 22 1                  ## Runtime-test2/Student.m:22:1\n\taddq\t$32, %rsp\n\tpopq\t%rbp\n\tretq\n\n......//省略\n```\n\n右边的注释代表的是 Student.m 第21行（:21）。在这里也可以看到 `[super run]` 调用的是 `_objc_msgSendSuper2` 方法。\n\n### 查看 LLVM 的中间代码（IR）\nObjective-C 在变为机器代码之前，会被 LLVM 编译器转换为[中间代码（Intermediate Representation）](https://llvm.org/docs/LangRef.html)。\n\n|  语法   | 简介  |\n| - | ----- |\n| @ | 全局变量 |\n| % | 局部变量 |\n| alloca | 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存 |\n| i32 | 32位4字节的整数 |\n| align | 对齐 |\n| load | 读出 |\n| store | 写入 |\n| icmp | 两个整数值比较，返回布尔值 |\n| br | 选择分支，根据条件来转向 label，不根据条件跳转的话类似 goto |\n| label | 代码标签 |\n| call | 调用函数 |\n\n```\n@interface Person : NSObject\n@end\n\n@implementation Person\nvoid test(int param)\n{\n    \n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    return [NSMethodSignature signatureWithObjCTypes:@\"v@:\"];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    [super forwardInvocation:anInvocation];\n    \n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    test(c);\n}\n@end\n```\n\n使用以下命令行指令生成中间代码 Person.ll：\n```\nclang -emit-llvm -S Person.m\n```\n\n找到对应的方法实现：\n```\n......//省略\n//%1*：self，i8*：_cmd，%2*：anInvocation\ndefine internal void @\"\\01-[Person forwardInvocation:]\"(%1*, i8*, %2*) #2 {\n  %4 = alloca %1*, align 8\n  %5 = alloca i8*, align 8\n  %6 = alloca %2*, align 8\n  %7 = alloca %struct._objc_super, align 8\n  %8 = alloca i32, align 4\n  %9 = alloca i32, align 4\n  %10 = alloca i32, align 4\n  store %1* %0, %1** %4, align 8\n  store i8* %1, i8** %5, align 8\n  store %2* %2, %2** %6, align 8\n  %11 = load %1*, %1** %4, align 8\n  %12 = load %2*, %2** %6, align 8\n  %13 = bitcast %1* %11 to i8*\n  %14 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 0\n  store i8* %13, i8** %14, align 8\n  %15 = load %struct._class_t*, %struct._class_t** @\"OBJC_CLASSLIST_SUP_REFS_$_\", align 8\n  %16 = bitcast %struct._class_t* %15 to i8*\n  %17 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 1\n  store i8* %16, i8** %17, align 8\n  %18 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !9\n  //调用 objc_msgSendSuper2，参数一：_objc_super，参数二：i8* _cmd\n  call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)\n  store i32 10, i32* %8, align 4    //将10写入到%8\n  store i32 20, i32* %9, align 4    //将20写入到%9\n  %19 = load i32, i32* %8, align 4  //将%8读出到%19\n  %20 = load i32, i32* %9, align 4  //将%9读出到%20\n  %21 = add nsw i32 %19, %20        //将%19加上%20赋值给%21\n  store i32 %21, i32* %10, align 4  //将%21写入到%10\n  %22 = load i32, i32* %10, align 4 //将%10读出到%22\n  call void @test(i32 %22)          //调用 test(%22)\n  ret void\n}\n\n......//省略\n```\n\n### 小结\n通过终端命令行生成的 c++ 代码中 `[super run]` 的底层实现是 `objc_msgSendSuper()` 方法，通过查看汇编代码和 LLVM 的中间代码可以看到 `[super run]` 的底层实现是 `objc_msgSendSuper2()` 方法。这个问题还是之前提到过的，通过终端命令生成的编译文件很运行时生成的编译文件相比，在某些细节的地方还是有区别的。不过并不影响理解具体的实现逻辑。\n\n## self、class 和 superclass 的底层实现\n\nself、class 和 superclass 的底层实现在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件。\n```\n+ (id)self {\n    return (id)self;\n}\n\n- (id)self {\n    return self;\n}\n\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n\n+ (Class)superclass {\n    return self->superclass;\n}\n\n- (Class)superclass {\n    return [self class]->superclass;\n}\n```\n\n`[super class]` 设置的消息接收者是 self（student 实例对象），并从 Person 类对象开始查找对象方法 `-(Class)class`。在 Person 类对象里没有找到，通过 superclass 指针找到父类的类对象 NSObject，在 NSObject 类对象里找到了对象方法 `-(Class)class` 后交给消息接收者处理。因为是由消息接收者处理对象方法 `-(Class)class`，所以对象方法 `- (Class)class` 的参数 self 自然就是消息接收者本身了。所以 `[super class]` 最终的返回值就是 Student（`[student class]`）。\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(class));\n```\n\n`[super superclass]` 设置的消息接收者是 self（student 实例对象），并从 Person 类对象开始查找对象方法 `-(Class)superclass`。在 Person 类对象里没有找到，通过 superclass 指针找到父类的类对象 NSObject，在 NSObject 类对象里找到了对象方法 `-(Class)superclass` 后交给消息接收者处理。因为是由消息接收者处理对象方法 `-(Class)superclass`，所以对象方法 `- (Class)superclass` 的参数 self 自然就是消息接收者本身了。所以 `[super superclass]` 的返回值就是 Person（`[student superclass]`）。\n```\nobjc_msgSendSuper({ self, [Person class] }, @selector(superclass));\n```\n\n现在再看这四个方法，就很清晰了：\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        [self class];       //消息接收者：student，调用方法：-(void)class\n        [self superclass];  //消息接收者：student，调用方法：-(void)superclass\n\n        [super class];      //消息接收者：student，调用方法：-(void)class\n        [super superclass]; //消息接收者：student，调用方法：-(void)superclass\n    }\n    return self;\n}\n@end\n```\n\n## isKindOfClass: 和 isMemberOfClass:\n\n`isKindOfClass:` 和 `isMemberOfClass:` 的底层实现在源码 [objc4-781](https://opensource.apple.com/tarballs/objc4/) 的 NSObject.mm 文件。\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n* `-isMemberOfClass:`：获取 self 的类对象与传入的 cls 进行比较。\n\n* `+isMemberOfClass:`：因为自身是类方法，所以这里是拿 self->ISA()（元类）作为 tcls 与传入的 cls 进行比较。\n\n* `+isKindOfClass:`：方法内部是一个 for 循环，因为自身是类方法，所以这里是拿 self->ISA()（元类）与传入的 cls 进行比较。如果不相等再遍历 tcls 的 superclass 与传入的 cls 进行比较。遍历过程中有一个相等就结束遍历返回 YES，遍历结束后没有找到相等的类就返回 NO。\n\n* `-isKindOfClass:`：方法内部是一个 for 循环，先获取到 self 的类对象 tcls 与传入的 cls 进行比较。如果不相等再遍历 tcls 的 superclass 与传入的 cls 进行比较。遍历过程中有一个相等就结束遍历返回 YES，遍历结束后没有找到相等的类就返回 NO。\n\n### +isMemberOfClass: 和 +isKindOfClass:\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];   //1\n        BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]]; //2\n        BOOL res3 = [[Person class] isKindOfClass:[Person class]];       //3\n        BOOL res4 = [[Person class] isMemberOfClass:[Person class]];     //4\n        NSLog(@\"%d, %d, %d, %d\", res1, res2, res3, res4);\n    }\n    return self;\n}\n@end\n```\n\n打印结果：\n```\n1, 0, 0, 0\n```\n\n打印结果解析：  \n`+isKindOfClass:` 方法，先通过 self->ISA() 找到 NSObject \b元类对象，不等于 NSObject 类对象。再通过 NSObject \b元类对象的 superclass 指针找到 NSObject 类对象，等于 NSObject 类对象。所以结果等于 YES：\n```\nNSLog(@\"%d\", [[NSObject class] isKindOfClass:[NSObject class]]); //1\n\n//等于\nNSLog(@\"%d\", [NSObject isKindOfClass:[NSObject class]]); //1\n```\n\n`+isMemberOfClass:` 方法，通过 self->ISA() 找到 NSObject \b元类对象，不等于 NSObject 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[NSObject class] isMemberOfClass:[NSObject class]]); //0\n//等于\nNSLog(@\"%d\", [NSObject isMemberOfClass:[NSObject class]]); //0\n```\n\n`+isKindOfClass:` 方法，先通过 self->ISA() 找到 Person \b元类对象，不等于 Person 类对象。再通过 Person \b元类对象的 superclass 指针找到 NSObject 元类对象，不等于 Person 类对象。再通过 NSObject \b元类对象的 superclass 指针找到 NSObject 类对象，不等于 Person 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[Person class] isKindOfClass:[Person class]]); //0\n//等于\nNSLog(@\"%d\", [Person isKindOfClass:[Person class]]); //0\n```\n\n`+isMemberOfClass:` 方法，通过 self->ISA() 找到 Person \b元类对象，不等于 Person 类对象。所以结果等于 NO：\n```\nNSLog(@\"%d\", [[Person class] isMemberOfClass:[Person class]]); //0\n//等于\nNSLog(@\"%d\", [Person isMemberOfClass:[Person class]]); //0\n```\n\n#### 小结\n因为当类对象调用类方法 `+isMemberOfClass:` 和 `+isKindOfClass:` 时，是拿类对象的元类对象跟传入的对象做对比，所以除 NSObject 外，其它类对象调用这两个类方法时，右边传入的至少应该是元类对象才有意义。\n\n### -isMemberOfClass: 和 -isKindOfClass:\n```\n@implementation Student\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        Person *person = [[Person alloc] init];\n        NSObject *object = [[NSObject alloc] init];\n        BOOL res5 = [object isKindOfClass:[NSObject class]];\n        BOOL res6 = [object isMemberOfClass:[NSObject class]];\n        BOOL res7 = [person isKindOfClass:[Person class]];\n        BOOL res8 = [person isMemberOfClass:[Person class]];\n        NSLog(@\"%d, %d, %d, %d\", res5, res6, res7, res8);\n    }\n    return self;\n}\n@end\n```\n\n打印结果：\n```\n1, 1, 1, 1\n```\n\n`-isKindOfClass:` 方法，通过 [self class] 找到 NSObject 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [object isKindOfClass:[NSObject class]]); //1\n```\n\n`-isMemberOfClass:` 方法，通过 [self class] 找到 NSObject 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [object isMemberOfClass:[NSObject class]]); //1\n```\n\n`-isKindOfClass:` 方法，通过 [self class] 找到 Person 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [person isKindOfClass:[Person class]]); //1\n```\n\n`-isMemberOfClass:` 方法，通过 [self class] 找到 Person 类对象，所以结果等于 YES：\n```\nNSLog(@\"%d\", [person isMemberOfClass:[Person class]]); //1\n```\n\n#### 小结\n因为当实例对象调用对象方法 `-isMemberOfClass:` 和 `-isKindOfClass:` 时，是拿实例对象的类对象跟传入的对象做对比，所以在实例对象调用这两个对象方法时，右边传入的至少应该是类对象才有意义。\n\n\n## 对象方法的调用原理\n\n### 正常调用\n![Runtime32](Runtime/Runtime32.png)\n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"Person -run %@\", self->_name);\n}\n@end\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    Person *person = [[Person alloc] init];\n    [person run];\n}\n@end\n```\n\n打印结果：\n```\nPerson -run (null)\n```\n\n指针 person 存储着 person 实例对象的地址（person 实例对象的 isa 地址），而 person 实例对象的 isa 指针里存储着 Person 类对象的地址（Person 类对象的 isa 地址）。`[person run]` 是通过 person 实例对象的 isa 指针找到 Person 类对象查找 `-(void)run` 方法，`-(void)run` 方法内部的 self 就是消息接收者（person 实例对象）。person 实例对象内部存储着 isa 指针和成员变量，`self->_name` 是从 isa 的地址开始在 person 实例对象的内存里向下查找成员变量 _name。\n\n### 自定义调用\n![Runtime33](Runtime/Runtime33.png) \n```\n@interface Person : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"Person -run %@\", self.name);\n}\n@end\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad]; //高地址\n    \n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj run];\n}\n@end\n```\n\n打印结果：\n```\n Person -run <ViewController: 0x7fd88fb0a400>\n```\n\n思考：  \n1. `[(__bridge id)obj run]` 为什么能够调用成功？  \n2. 为什么 self.name 变成了 ViewController?  \n\n局部变量的内存分配在栈空间，从高地址到低地址：\n```\nvoid test()\n{\n    long long a = 1; //0x7ffeefbff518（高地址）\n    long long b = 2; //0x7ffeefbff510   ↓\n    long long c = 3; //0x7ffeefbff508   ↓\n    long long d = 4; //0x7ffeefbff500（低地址）\n    NSLog(@\"%p, %p, %p, %p\", &a, &b, &c, &d);\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n0x7ffeefbff518, 0x7ffeefbff510, 0x7ffeefbff508, 0x7ffeefbff500\n```\n\n从打印结果可以看到 a、b、c、d 的内存分配顺序是从高地址到低地址。\n\n`[(__bridge id)obj run]` 图解：\n![Runtime35](Runtime/Runtime35.png) \n\n图中可以看到 obj、cls 和 self 的内存都分配在栈空间，`[UIViewController class]` 在全局区，self 的地址值最大，obj 的地址值最小。self 和 `[UIViewController class]` 来自 `[super viewDidLoad]` 的结构体 `__rw_objc_super`，`__rw_objc_super` 也是一个临时变量：\n```\nstruct __rw_objc_super arg = { \n    self, \n    [ViewController class] \n};\nobjc_msgSendSuper(arg, @selector(viewDidLoad));\n```\n\n这一点可以通过打印内存进行验证（`x/4g`：打印4个数据，每个数据8个字节）：\n```\n(lldb) p/x obj\n(Person *) $0 = 0x00007ffeea236178\n(lldb) x/4g 0x00007ffeea236178\n0x7ffeea236178: 0x00000001059cb5c0 0x00007fc0cb00a9b0\n0x7ffeea236188: 0x00000001059cb4f8 0x00007fff51ec8b0c\n(lldb) p (Class)0x00000001059cb5c0\n(Class) $1 = Person\n(lldb) po 0x00007fc0cb00a9b0\n<ViewController: 0x7fc0cb00a9b0>\n\n(lldb) p (Class)0x00000001059cb4f8\n(Class) $3 = ViewController\n```\n\n从打印结果可以看到，依次是 Person 类对象、<ViewController: 0x7fc0cb00a9b0> 实列对象和 ViewController 类对象。\n\n注释掉 `[super viewDidLoad]` 就会报坏内存访问的错误：\n![Runtime36](Runtime/Runtime36.png)\n\n修改 ViewController.m 实现，添加成员变量 test：\n```\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSString *test = @\"123\";\n    id cls = [Person class];\n    void *obj = &cls;\n    [(__bridge id)obj run];\n}\n@end\n```\n\n打印结果：\n```\nPerson -run 123\n```\n\n指针 obj 存储着 cls 的地址，而 cls 存储着 Person 类对象的地址（Person 类对象的 isa 地址）。`[(__bridge id)obj run]` 是通过 cls 找到 Person 类对象查找 `-(void)run` 方法，`-(void)run` 方法内部的 self 就是消息接收者 obj。从 obj 的内存开始在 obj 所在的内存中向下查找成员变量 _name，最后找到的却是 cls 下面的局部变量 test：\n![Runtime34](Runtime/Runtime34.png) \n\n从图中可以看到 obj、cls 和 test 三个变量的内存都分配在栈空间，test 的地址值最大，obj 的地址值最小。\n\n* `[(__bridge id)obj run]` 为什么能够调用成功？  \n因为指针 obj 存储着 cls 的地址，而 cls 存储着 Person 类对象的地址（Person 类对象的 isa 地址），所以 `[(__bridge id)obj run]` 是通过 cls 找到 Person 类对象查找 `-(void)run` 方法(这里的 cls 相当于 person 实例对象的 isa)。\n* 为什么 self.name 变成了 ViewController？  \n因为 `-(void)run` 方法内部的 self 就是消息接收者 obj，`obj->_name` 是在 obj 所在的内存中从 obj 的地址开始向下查找成员变量 _name，而 obj 所在的内存（栈区）向下找到的是 cls 下面的指针 self（ViewController 实例对象），所以最终的打印结果是 `<ViewController: 0x7fd88fb0a400>`。\n\n# Runtime API\n\n## 类\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)` | 动态创建一个类（参数：父类，类名，额外的内存空间）|\n| `void objc_registerClassPair(Class cls)` | 注册一个类（要在类注册之前添加成员变量）|\n| `void objc_disposeClassPair(Class cls)` | 销毁一个类|\n| `Class object_getClass(id obj)` | 获取 isa 指向的 Class |\n| `Class object_setClass(id obj, Class cls)` | 设置 isa 指向的 Class |\n| `BOOL object_isClass(id obj)` | 判断一个 OC 对象是否为 Class |\n| `BOOL class_isMetaClass(Class cls)` | 判断一个 Class 是否为元类 |\n| `Class class_getSuperclass(Class cls)` | 获取父类 |\n\n```\n@interface Person : NSObject\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Student : NSObject\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//动态创建一个类，注册一个类\");\n        Class Teacher = objc_allocateClassPair([NSObject class], \"Teacher\", 0); //创建类对象和元类对象\n        objc_registerClassPair(Teacher); //注册类\n        NSLog(@\"Teacher 的内存大小%zd个字节\", class_getInstanceSize(Teacher)); //8个字节\n        \n        Person *person = [[Person alloc] init];\n        \n        NSLog(@\"---------------------------------------//获取 isa 指向的 Class\");\n        NSLog(@\"类对象：%p，类对象：%p\", [Person class], object_getClass(person));\n        NSLog(@\"类对象：%p，元类对象：%p\", [Person class], object_getClass([Person class]));\n        \n        NSLog(@\"---------------------------------------//设置 isa 指向的 Class\");\n        object_setClass(person, [Student class]);\n        [person run]; //这里的 Person 是 (Student *) 类型，isa 指向 Student 类对象\n        \n        NSLog(@\"---------------------------------------//判断一个 OC 对象是否为 Class\");\n        NSLog(@\"%d %d %d\", object_isClass(person), object_isClass([Person class]), object_isClass(object_getClass([Person class]))); //元类对象是一种特殊的类对象\n        \n        NSLog(@\"---------------------------------------//判断一个 Class 是否为元类\");\n        NSLog(@\"%d %d\", class_isMetaClass([Person class]), class_isMetaClass(object_getClass([Person class]))); //元类对象是一种特殊的类对象\n        \n        NSLog(@\"---------------------------------------//获取父类\");\n        NSLog(@\"%@类对象：%p, %@元类对象：%p\", class_getSuperclass([Person class]), class_getSuperclass([Person class]),\n            class_getSuperclass(object_getClass([Person class])), class_getSuperclass(object_getClass([Person class])));\n\n        NSLog(@\"---------------------------------------//销毁一个类\");\n        id teacher2 = [[Teacher alloc] init];\n        //    person = nil; \n        //    teacher = nil; \n        teacher2 = nil; //实例中只要有一个置为 nil，就可以调用了！❓\n        objc_disposeClassPair(Teacher); //当类或者它的子类的实例还存在，则不能调用 objc_disposeClassPair 方法\n        objc_disposeClassPair(Teacher); //报错“Attempt to use unknown class 0x1030b92a0.”\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//动态创建一个类，注册一个类\nTeacher 的内存大小8个字节\n---------------------------------------//获取 isa 指向的 Class\n类对象：0x100003228，类对象：0x100003228\n类对象：0x100003228，元类对象：0x100003200\n---------------------------------------//设置 isa 指向的 Class\n-[Student run]\n---------------------------------------//判断一个 OC 对象是否为 Class\n0 1 1\n---------------------------------------//判断一个 Class 是否为元类\n0 1\n---------------------------------------//获取父类\nNSObject类对象：0x7fff94b06118, NSObject元类对象：0x7fff94b060f0\n---------------------------------------//销毁一个类\nobjc[15858]: Attempt to use unknown class 0x102905440.\n```\n\n## 成员变量\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Ivar class_getInstanceVariable(Class cls, const char *name)` | 获取一个实例变量信息 |\n| `Ivar *class_copyIvarList(Class cls, unsigned int *outCount)` | 拷贝实例变量列表（最后需要调用free释放）|\n| `void object_setIvar(id obj, Ivar ivar, id value)` | 设置成员变量的值 |\n| `id object_getIvar(id obj, Ivar ivar)` | 获取成员变量的值 |\n| `BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)` | 动态添加成员变量（已经注册的类是不能动态添加成员变量的）|\n| `const char *ivar_getName(Ivar v)` | 获取成员变量的名字 |\n| `const char *ivar_getTypeEncoding(Ivar v)` | 获取成员变量的类型编码 |\n\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n- (void)run;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\n@interface Student : NSObject\n- (void)run;\n@end\n\n@implementation Student\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//动态添加成员变量（已经注册的类是不能动态添加成员变量的）\");\n        Class Teacher = objc_allocateClassPair([NSObject class], \"Teacher\", 0); //动态创建一个类（包括类对象和元类对象，参数：父类，类名，额外的内存空间）\n        \n        class_addIvar(Teacher, \"_age\", 4, 1, @encode(int)); //在类注册之前添加成员变量（因为类的成员变量列表是只读的，所有类一旦注册后就不能修改成员变量列表了）\n        class_addIvar(Teacher, \"_weight\", 4, 1, @encode(int));\n\n        //添加方法是随时可以操作的，最好是写在注册类前，逻辑比较清晰\n        class_addMethod(Teacher, @selector(run), (IMP)run, \"v@:\");\n        \n        objc_registerClassPair(Teacher); //注册类\n        NSLog(@\"%zd\", class_getInstanceSize(Teacher)); //isa(8个字节) + _age(4个字节) + _weight(4个字节) = 16个字节\n        \n        NSLog(@\"---------------------------------------//修改/获取成员变量的值\");\n        id teacher = [[Teacher alloc] init];\n        [teacher setValue:@10 forKey:@\"_age\"];\n        [teacher setValue:@20 forKey:@\"_weight\"];\n        NSLog(@\"_age：%@, _weight：%@\", [teacher valueForKey:@\"_age\"], [teacher valueForKey:@\"_weight\"]);\n\n        NSLog(@\"---------------------------------------//调用添加的方法\");\n        [teacher run];\n\n        NSLog(@\"---------------------------------------//设置 isa 指向的 Class\");\n        Person *person = [[Person alloc] init];\n        object_setClass(person, Teacher);\n        [person run];\n        \n        NSLog(@\"---------------------------------------//获取成员变量的相关信息\");\n        Ivar ageIvar = class_getInstanceVariable([Person class], \"_age\");\n        NSLog(@\"%s %s\", ivar_getName(ageIvar), ivar_getTypeEncoding(ageIvar));\n        \n        NSLog(@\"---------------------------------------//设置和获取成员变量的值\");\n        Ivar nameIvar = class_getInstanceVariable([Person class], \"_name\");\n        Person *person2 = [[Person alloc] init];\n        object_setIvar(person2, nameIvar, @\"name\"); //设置 _name\n        object_setIvar(person2, ageIvar, (__bridge id)(void *)10); //设置 _age（使用 runtime 方法，底层没有转换直接赋值，先转成指针变量，再转成 id 类型的对象）\n        //[person2 setValue:@10 forKey:@\"age\"]; //NSNumber 类型的 10 在赋值给 age 时会转成 int 类型\n        NSLog(@\"%@\", object_getIvar(person2, nameIvar)); //获取 _name\n        \n        NSLog(@\"---------------------------------------//拷贝实例变量列表（最后需要调用free释放）+ 获取成员变量的相关信息\");\n        unsigned int count;\n        Ivar *ivars = class_copyIvarList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            Ivar ivar = ivars[i];\n            NSLog(@\"%s %s\", ivar_getName(ivar), ivar_getTypeEncoding(ivar));\n        }\n        free(ivars);\n    }\n    return 0;\n}\n```\n\n在使用 `object_setIvar()` 方法设置 int 类型的成员变量时，因为数值不能直接转为对象，所以先将数值转成指针（指针是用来存值的），再将指针转成 id 类型的对象。\n\n打印结果：\n```\n---------------------------------------//动态添加成员变量（已经注册的类是不能动态添加成员变量的）\n16\n---------------------------------------//修改/获取成员变量的值\n_age：10, _weight：20\n---------------------------------------//调用添加的方法\n<Teacher: 0x100525bc0> - run\n---------------------------------------//设置 isa 指向的 Class\n<Teacher: 0x10041dda0> - run\n---------------------------------------//获取成员变量的相关信息\n_age i\n---------------------------------------//设置和获取成员变量的值\nname 10\n---------------------------------------//拷贝实例变量列表（最后需要调用free释放）+ 获取成员变量的相关信息\n_age i\n_name @\"NSString\"\n```\n\n\n## 属性\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `objc_property_t class_getProperty(Class cls, const char *name)` | 获取一个属性 |\n| `objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)` | 拷贝属性列表 |\n| `BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)` | 动态添加属性 |\n| `void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)` | 动态替换属性 |\n| `const char *property_getName(objc_property_t property)` | 获取属性名 |\n| `const char *property_getAttributes(objc_property_t property)` | 获取属性的真实类型 |\n\n`test3()` 实现：\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//获取一个属性\");\n        objc_property_t name = class_getProperty([Person class], \"name\");\n        NSLog(@\"%s\", property_getName(name));\n        \n        NSLog(@\"---------------------------------------//拷贝属性列表\");\n        unsigned int count;\n        objc_property_t *propertys = class_copyPropertyList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            objc_property_t property = propertys[i];\n            NSLog(@\"%s %s\", property_getName(property), property_getAttributes(property));//T 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n        }\n        free(propertys);\n        \n        NSLog(@\"---------------------------------------//动态添加属性\");\n        objc_property_attribute_t type = { \"T\", \"@\\\"NSString\\\"\"}; //数据类型\n        objc_property_attribute_t ownership1 = { \"C\", \"\"}; //copy\n        objc_property_attribute_t ownership2 = { \"N\", \"\"}; //nonatomic\n        objc_property_attribute_t backingivar = { \"V\", \"_newName\"}; //_newName\n        objc_property_attribute_t attrs[] = {type, ownership1, ownership2, backingivar};\n        class_addProperty([Person class], \"newName\", attrs, 4);\n        objc_property_t newName = class_getProperty([Person class], \"newName\");\n        NSLog(@\"%s %s\", property_getName(newName), property_getAttributes(newName));\n        \n        NSLog(@\"---------------------------------------//动态替换属性\");\n        objc_property_attribute_t type1 = { \"T\", \"@\\\"NSString\\\"\"}; //数据类型\n        objc_property_attribute_t ownership3 = { \"C\", \"\"}; //copy\n        objc_property_attribute_t ownership4 = { \"N\", \"\"}; //nonatomic\n        objc_property_attribute_t backingivar1 = { \"V\", \"_replaceName\"}; //_newName\n        objc_property_attribute_t attrs1[] = {type1, ownership3, ownership4, backingivar1};\n        class_replaceProperty([Person class], \"name\", attrs1, 4);\n        objc_property_t replaceName = class_getProperty([Person class], \"name\");\n        NSLog(@\"%s %s\", property_getName(replaceName), property_getAttributes(replaceName));\n        \n        NSLog(@\"---------------------------------------//拷贝属性列表\");\n        unsigned int count1;\n        objc_property_t *propertys1 = class_copyPropertyList([Person class], &count1);\n        for (int i=0; i<count1; i++) {\n            objc_property_t property = propertys1[i];\n            NSLog(@\"%s %s\", property_getName(property), property_getAttributes(property));//T 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n        }\n        free(propertys1);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//获取一个属性\nname\n---------------------------------------//拷贝属性列表\nID Ti,N,V_ID\nage Ti,N,V_age\nname T@\"NSString\",C,N,V_name\n---------------------------------------//动态添加属性\nnewName T@\"NSString\",C,N,V_newName\n---------------------------------------//动态替换属性\nname T@\"NSString\",C,N,V_replaceName\n---------------------------------------//拷贝属性列表\nnewName T@\"NSString\",C,N,V_newName\nID Ti,N,V_ID\nage Ti,N,V_age\nname T@\"NSString\",C,N,V_replaceName\n```\n\nT 后面是该属性的数据类型。V 后面是该属性的变量名称。N 是属性的非原子属性 nonatomic 的标识。C 是属性的 copy 标识。\n\n关于 `property_getAttributes()` 获取到的结果，可以参考 [Declared Properties](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1)。\n![Runtime38](Runtime/Runtime38.png)\n\n![Runtime39](Runtime/Runtime39.png)\n\n## 方法\n\n|  方法   | 注释  |\n|  -----  | ---  |\n| `Method class_getInstanceMethod(Class cls, SEL name)` | 获得一个实例方法 |\n| `Method class_getClassMethod(Class cls, SEL name)` | 获得一个类方法 |\n| `IMP class_getMethodImplementation(Class cls, SEL name)` | 根据 Class 和 SEL 获取方法的 imp 指针 |\n| `IMP method_setImplementation(Method m, IMP imp)` | 修改方法的 imp 指针 |\n| `void method_exchangeImplementations(Method m1, Method m2)` | 交换方法的 imp 指针 |\n| `Method *class_copyMethodList(Class cls, unsigned int *outCount)` | 拷贝方法列表（最后需要调用free释放） |\n| `BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)` | 动态添加方法 |\n| `IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)` | 动态替换方法|\n| `SEL method_getName(Method m)` | 获取方法名 |\n| `IMP method_getImplementation(Method m)` | 根据 Method 获取方法的 imp 指针 |\n| `const char *method_getTypeEncoding(Method m)` | 获取方法的类型编码 |\n| `unsigned int method_getNumberOfArguments(Method m)` | 根据 Method 获取方法的参数个数 |\n| `char *method_copyReturnType(Method m)` | 根据 Method 获取方法的返回值的类型编码（带有copy的需要调用free去释放） |\n| `char *method_copyArgumentType(Method m, unsigned int index)` | 根据 Method 获取方法的索引位置的参数的类型编码（带有copy的需要调用free去释放） |\n| `const char *sel_getName(SEL sel)` | 根据 SEL 获取方法的名称 |\n| `SEL sel_registerName(const char *str)` | 根据方法名注册 SEL |\n| `IMP imp_implementationWithBlock(id block)` | 用 block 作为方法实现 |\n| `id imp_getBlock(IMP anImp)` | 根据 block 的 IMP 生成 block 对象 |\n| `BOOL imp_removeBlock(IMP anImp)` | 移除 imp_implementationWithBlock() 生成的 IMP |\n\n```\n@interface Person : NSObject\n+ (void)personRun;\n\n- (void)run;\n- (void)test;\n\n- (void)run2;\n- (void)test2;\n\n- (void)run3;\n- (void)test3;\n\n- (int)run4:(int)age name:(NSString *)name;\n@end\n\n@implementation Person\n+ (void)personRun\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run2\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test2\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)run3\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (void)test3\n{\n    NSLog(@\"%s\", __func__);\n}\n\n- (int)run4:(int)age name:(NSString *)name\n{\n    NSLog(@\"%s\", __func__);\n    return 10;\n}\n@end\n\nvoid newRun()\n{\n    NSLog(@\"newRun\");\n}\n\nvoid newTest()\n{\n    NSLog(@\"newTest\");\n}\n\ntypedef void(^Block)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"---------------------------------------//获得一个实例方法\");\n        Method runMethod = class_getInstanceMethod([Person class], @selector(run));\n        NSLog(@\"%@\", NSStringFromSelector(method_getName(runMethod)));\n        \n        NSLog(@\"---------------------------------------//获得一个类方法\");\n        Method personRunMethod = class_getClassMethod([Person class], @selector(personRun));\n        NSLog(@\"%@\", NSStringFromSelector(method_getName(personRunMethod)));\n        \n        NSLog(@\"---------------------------------------//根据 Class 和 SEL 获取方法的 imp 指针\");\n        IMP runIMP = class_getMethodImplementation([Person class], @selector(run));\n        NSLog(@\"%p\", runIMP);\n        \n        NSLog(@\"---------------------------------------//修改方法的 imp 指针\");\n        IMP testIMP = class_getMethodImplementation([Person class], @selector(test));\n        method_setImplementation(runMethod, testIMP);\n        Person *person = [[Person alloc] init];\n        [person run]; //调用 -test\n        \n        NSLog(@\"---------------------------------------//交换方法的 imp 指针\");\n        Method run2Method = class_getInstanceMethod([Person class], @selector(run2));\n        Method testMethod = class_getInstanceMethod([Person class], @selector(test2));\n        method_exchangeImplementations(runMethod, testMethod);\n        [person run2];\n        \n        NSLog(@\"---------------------------------------//动态添加方法\");\n        class_addMethod([Person class], @selector(newRun), (IMP)newRun, \"v@:\");\n        [person performSelector:@selector(newRun)];\n\n        NSLog(@\"---------------------------------------//拷贝方法列表（最后需要调用free释放）\");\n        unsigned int count;\n        Method *methods = class_copyMethodList([Person class], &count);\n        for (int i=0; i<count; i++) {\n            Method aMethod = methods[i];\n            NSLog(@\"%@\", NSStringFromSelector(method_getName(aMethod)));\n        }\n        free(methods);\n        \n        NSLog(@\"---------------------------------------//动态替换方法\");\n        class_replaceMethod([Person class], @selector(test3), (IMP)newTest, \"v@:\");\n        [person test3];\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的 imp 指针\");\n        Method run3Method = class_getInstanceMethod([Person class], @selector(run3));\n        IMP runIMP3 = method_getImplementation(run3Method);\n        NSLog(@\"%p\", runIMP3);\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的类型编码\");\n        NSLog(@\"%s\", method_getTypeEncoding(run3Method));\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的参数个数\");\n        Method run4Method = class_getInstanceMethod([Person class], @selector(run4:name:));\n        NSLog(@\"%d\", method_getNumberOfArguments(run4Method)); //self、_cmd、age 和 name\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的返回值的类型编码\");\n        const char *returnType = method_copyReturnType(run4Method);\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:returnType encoding:NSUTF8StringEncoding]);\n        free((void *)returnType);\n        \n        NSLog(@\"---------------------------------------//根据 Method 获取方法的索引位置的参数的类型编码\");\n        const char *argumentType = method_copyArgumentType(run4Method, 3); //name：@\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:argumentType encoding:NSUTF8StringEncoding]);\n        free((void *)argumentType);\n        \n        NSLog(@\"---------------------------------------//根据 SEL 获取方法名\");\n        const char *selName = sel_getName(@selector(run));\n        NSLog(@\"%@\", [[NSString alloc] initWithCString:selName encoding:NSUTF8StringEncoding]);\n        \n        NSLog(@\"---------------------------------------//根据方法名注册 SEL\");\n        SEL registerSel = sel_registerName(\"registerSel\");\n        NSLog(@\"%@\", NSStringFromSelector(registerSel));\n        \n        NSLog(@\"---------------------------------------//用 block 作为方法实现\");\n        IMP blockImp = imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        });\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), blockImp, \"v\");\n        [Person personRun];\n        \n        NSLog(@\"---------------------------------------//根据 block 的 IMP 生成 block 对象\");\n        Block aBlock = imp_getBlock(blockImp);\n        aBlock();\n        \n        \n        NSLog(@\"---------------------------------------//移除 imp_implementationWithBlock() 生成的 IMP\");\n        BOOL isRemvoeBlockImpSucc = imp_removeBlock(blockImp);\n        NSLog(@\"isRemvoeBlockImpSucc：%d\", isRemvoeBlockImpSucc);\n        Block aBlock2 = imp_getBlock(blockImp); //blockImp 已经不存在\n        NSLog(@\"aBlock2：%@\", aBlock2);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---------------------------------------//获得一个实例方法\nrun\n---------------------------------------//获得一个类方法\npersonRun\n---------------------------------------//根据 Class 和 SEL 获取方法的 imp 指针\n0x100001ad0\n---------------------------------------//修改方法的 imp 指针\n-[Person test]\n---------------------------------------//交换方法的 imp 指针\n-[Person run2]\n---------------------------------------//动态添加方法\nnewRun\n---------------------------------------//拷贝方法列表（最后需要调用free释放）\nnewRun\nrun2\ntest2\nrun3\ntest3\nrun4:name:\nrun\ntest\n---------------------------------------//动态替换方法\nnewTest\n---------------------------------------//根据 Method 获取方法的 imp 指针\n0x100001b90\n---------------------------------------//根据 Method 获取方法的类型编码\nv16@0:8\n---------------------------------------//根据 Method 获取方法的参数个数\n4\n---------------------------------------//根据 Method 获取方法的返回值的类型编码\ni\n---------------------------------------//根据 Method 获取方法的索引位置的参数的类型编码\n@\n---------------------------------------//根据 SEL 获取方法名\nrun\n---------------------------------------//根据方法名注册 SEL\nregisterSel\n---------------------------------------//用 block 作为方法实现\nthis is a block\n---------------------------------------//根据 block 的 IMP 生成 block 对象\nthis is a block\n---------------------------------------//移除 imp_implementationWithBlock() 生成的 IMP\nisRemvoeBlockImpSucc：1\naBlock2：(null)\n```\n\n## 拓展\n\n### class_rw_ext_t\n\n`class_rw_ext_t` 里保存着 `class_rw_t` 的方法列表、属性列表、协议列表和 `class_ro_t` 等信息。\n```\nstruct class_rw_ext_t {\n    const class_ro_t *ro;\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    char *demangledName;\n    uint32_t version;\n};\n\nstruct class_rw_t {\n    ......//省略\n\npublic:\n    class_rw_ext_t *ext() const {\n        return get_ro_or_rwe().dyn_cast<class_rw_ext_t *>();\n    }\n\n    class_rw_ext_t *extAllocIfNeeded() {\n        auto v = get_ro_or_rwe();\n        if (fastpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>();\n        } else {\n            return extAlloc(v.get<const class_ro_t *>());\n        }\n    }\n\n    class_rw_ext_t *deepCopy(const class_ro_t *ro) {\n        return extAlloc(ro, true);\n    }\n\n    ......//省略\n```\n\n### 动态添加的属性存到哪了?  \n\n查看 `class_addProperty()` 的实现\n```\nBOOL \nclass_addProperty(Class cls, const char *name, \n                  const objc_property_attribute_t *attrs, unsigned int n)\n{\n    return _class_addProperty(cls, name, attrs, n, NO);\n}\n\nvoid \nclass_replaceProperty(Class cls, const char *name, \n                      const objc_property_attribute_t *attrs, unsigned int n)\n{\n    _class_addProperty(cls, name, attrs, n, YES);\n}\n\nstatic bool \n_class_addProperty(Class cls, const char *name, \n                   const objc_property_attribute_t *attrs, unsigned int count, \n                   bool replace)\n{\n    if (!cls) return NO;\n    if (!name) return NO;\n\n    property_t *prop = class_getProperty(cls, name);\n    if (prop  &&  !replace) { //已经存在 & 替换\n        // already exists, refuse to replace\n        return NO;\n    } \n    else if (prop) { //已经存在\n        // replace existing\n        mutex_locker_t lock(runtimeLock);\n        try_free(prop->attributes);\n        prop->attributes = copyPropertyAttributeString(attrs, count);\n        return YES;\n    }\n    else {\n        mutex_locker_t lock(runtimeLock); \n        auto rwe = cls->data()->extAllocIfNeeded(); //class_rw_ext_t\n        \n        ASSERT(cls->isRealized());\n        \n        property_list_t *proplist = (property_list_t *)\n            malloc(sizeof(*proplist));\n        proplist->count = 1;\n        proplist->entsizeAndFlags = sizeof(proplist->first);\n        proplist->first.name = strdupIfMutable(name);\n        proplist->first.attributes = copyPropertyAttributeString(attrs, count);\n        \n        rwe->properties.attachLists(&proplist, 1); //保存到 class_rw_ext_t 的 properties 里\n        \n        return YES;\n    }\n}\n```\n\n查看 `class_addProperty()` 的 Runtime 实现可以看到，`class_addProperty()` 方法内部调用的是 `_class_addProperty()` 方法。`_class_addProperty()` 方法内部先判断了方法是否已经存在，又判断了是否要替换。如果即不存在也不替换，就保存到 `class_rw_ext_t` 的 properties 里，即类对象的属性列表里。（class_rw_ext_t：class_read_write_extension_table，即 class_rw_t 的拓展表）。\n\n#### 动态添加的方法存到哪了?  \n\n查看 `class_addMethod()` 的实现\n```\nBOOL \nclass_addMethod(Class cls, SEL name, IMP imp, const char *types)\n{\n    if (!cls) return NO;\n\n    mutex_locker_t lock(runtimeLock);\n    return ! addMethod(cls, name, imp, types ?: \"\", NO);\n}\n\nstatic IMP \naddMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)\n{\n    IMP result = nil;\n\n    runtimeLock.assertLocked();\n\n    checkIsKnownClass(cls);\n    \n    ASSERT(types);\n    ASSERT(cls->isRealized());\n\n    method_t *m;\n    if ((m = getMethodNoSuper_nolock(cls, name))) { //是否存在\n        // already exists\n        if (!replace) { //是否替换\n            result = m->imp;\n        } else {\n            result = _method_setImplementation(cls, m, imp);\n        }\n    } else {\n        auto rwe = cls->data()->extAllocIfNeeded(); //class_rw_ext_t\n\n        // fixme optimize\n        method_list_t *newlist;\n        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);\n        newlist->entsizeAndFlags = \n            (uint32_t)sizeof(method_t) | fixed_up_method_list;\n        newlist->count = 1;\n        newlist->first.name = name;\n        newlist->first.types = strdupIfMutable(types);\n        newlist->first.imp = imp;\n\n        prepareMethodLists(cls, &newlist, 1, NO, NO);\n        rwe->methods.attachLists(&newlist, 1); //保存到 class_rw_ext_t 的 methods 里\n        flushCaches(cls);\n\n        result = nil;\n    }\n\n    return result;\n}\n```\n查看 `class_addMethod()` 的 Runtime 实现可以看到 `class_addMethod()` 方法内部调用的是 `addMethod()` 方法。`addMethod()` 方法内部先判断了方法是否已经存在，又判断了是否要替换。如果即不存，就保存到 `class_rw_ext_t` 的 methods 里，即类对象的方法列表里。（class_rw_ext_t：class_read_write_extension_table，即 class_rw_t 的拓展表）。\n\n### method_exchangeImplementations 的实现原理\n```\nvoid method_exchangeImplementations(Method m1, Method m2)\n{\n    if (!m1  ||  !m2) return;\n\n    mutex_locker_t lock(runtimeLock);\n\n    IMP m1_imp = m1->imp;\n    m1->imp = m2->imp;\n    m2->imp = m1_imp;\n\n\n    // RR/AWZ updates are slow because class is unknown\n    // Cache updates are slow because class is unknown\n    // fixme build list of classes whose Methods are known externally?\n\n    flushCaches(nil); //清空方法缓存\n\n    adjustCustomFlagsForMethodChange(nil, m1);\n    adjustCustomFlagsForMethodChange(nil, m2);\n}\n\n......//省略\n\nstatic void flushCaches(Class cls)\n{\n    runtimeLock.assertLocked();\n#if CONFIG_USE_CACHE_LOCK\n    mutex_locker_t lock(cacheUpdateLock);\n#endif\n\n    if (cls) {\n        foreach_realized_class_and_subclass(cls, [](Class c){\n            cache_erase_nolock(c);\n            return true;\n        });\n    }\n    else {\n        foreach_realized_class_and_metaclass([](Class c){\n            cache_erase_nolock(c);\n            return true;\n        });\n    }\n}\n\n......//省略\n\nvoid cache_erase_nolock(Class cls)\n{\n#if CONFIG_USE_CACHE_LOCK\n    cacheUpdateLock.assertLocked();\n#else\n    runtimeLock.assertLocked();\n#endif\n\n    cache_t *cache = getCache(cls);\n\n    mask_t capacity = cache->capacity();\n    if (capacity > 0  &&  cache->occupied() > 0) {\n        auto oldBuckets = cache->buckets();\n        auto buckets = emptyBucketsForCapacity(capacity);\n        cache->setBucketsAndMask(buckets, capacity - 1); // also clears occupied\n\n        cache_collect_free(oldBuckets, capacity);\n    }\n}\n```\n\nmethod_exchangeImplementations 的底层实现是交换了两个方法的 `imp` 指针，然后调用 `flushCaches()` 方法清空了方法缓存。\n![Runtime37](Runtime/Runtime37.png)\n\n## 应用\n\n### 查看私有成员变量\n\n修改 UITextField 占位文字的颜色：\n\n方案一：正常的 OC 代码\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableDictionary *attrs = [NSMutableDictionary dictionary];\n    attrs[NSForegroundColorAttributeName] = [UIColor redColor];\n    self.textField.attributedPlaceholder = [[NSMutableAttributedString alloc] initWithString:@\"请输入用户名\" attributes:attrs];\n}\n@end\n```\n\n方案二：使用 KVC 修改（iOS 13 后禁用）\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.textField.placeholder = @\"请输入用户名\";\n    UILabel *placeholderLabel = [self.textField valueForKeyPath:@\"_placeholderLabel\"];\n    placeholderLabel.textColor = [UIColor redColor];\n\n    //简化版：[self.textField setValue:[UIColor redColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n}\n@end\n```\n\n报错：\n```\n*** Terminating app due to uncaught exception 'NSGenericException', reason: 'Access to UITextField's _placeholderLabel ivar is prohibited. This is an application bug'\n```\n\n方案三：使用 Runtime（还不如 OC 省事）\n```\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UITextField *textField;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.textField.placeholder = @\"请输入用户名\";\n    Ivar ivar = class_getInstanceVariable([UITextField class], \"_placeholderLabel\");\n    UILabel *placeholderLabel = object_getIvar(self.textField, ivar);\n    placeholderLabel.textColor = [UIColor redColor];\n}\n@end\n```\n\n### 字典转模型\n```\n@interface Person : NSObject\n@property (nonatomic, assign) int ID;\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n@end\n\n@interface Teacher : Person\n@property (nonatomic, assign) int weight;\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Teacher\n@end\n\n@interface NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json;\n@end\n\n@implementation NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json\n{\n    id obj = [[self alloc] init];\n    [self enumerateIvarsWithObject:obj class:self json:json];\n    return obj;\n}\n\n+ (void)enumerateIvarsWithObject:(id)obj class:(Class)class json:(NSDictionary *)json\n{\n    Class superclass = [class superclass];\n    if (superclass && superclass != [NSObject class]) { //处理继承\n        [self enumerateIvarsWithObject:obj class:superclass json:json];\n    }\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(class, &count);\n    for (int i=0; i<count; i++) {\n        Ivar ivar = ivars[i]; //取出 i 位置的成员变量\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)]; //去掉“_”\n        id value = json[name]; //设置\n        if ([name isEqualToString:@\"ID\"]) { //处理特殊数据\n            value = json[@\"id\"];\n        }\n        [obj setValue:value forKey:name];\n    }\n    free(ivars);\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSDictionary *json = @{\n            @\"id\" : @10,\n            @\"age\" : @20,\n            @\"weight\" : @60,\n            @\"height\" : @160,\n            @\"name\" : @\"Tom\"\n        };\n        Teacher *teacher = [Teacher yq_objectWithJson:json];\n        NSLog(@\"%d, %d, %d, %d, %@\", teacher.ID, teacher.age, teacher.weight, teacher.height, teacher.name);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n10, 20, 60, 160, Tom\n```\n\n### 归档解档\n```\n@interface NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json;\n\n- (void)encodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class;\n- (void)decodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class;\n\n- (void)archive;\n+ (instancetype)unarchive;\n@end\n\n@implementation NSObject (Json)\n+ (instancetype)yq_objectWithJson:(NSDictionary *)json\n{\n    id obj = [[self alloc] init];\n    [self enumerateIvarsWithObject:obj class:self json:json];\n    return obj;\n}\n\n+ (void)enumerateIvarsWithObject:(id)obj class:(Class)class json:(NSDictionary *)json\n{\n    Class superclass = [class superclass];\n    if (superclass && superclass != [NSObject class]) {\n        [self enumerateIvarsWithObject:obj class:superclass json:json];\n    }\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        //设置\n        id value = json[name];\n        if ([name isEqualToString:@\"ID\"]) {\n            value = json[@\"id\"];\n        }\n        [obj setValue:value forKey:name];\n    }\n    free(ivars);\n}\n\n- (void)encodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class\n{\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(Class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSString *typeEncode = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        if ([typeEncode isEqualToString:@\"i\"]) {\n            int value = [[self valueForKey:name] intValue];\n            [coder encodeInt:value forKey:name];\n        } else if ([typeEncode isEqualToString:@\"@\\\"NSString\\\"\"]) {\n            id value = [self valueForKey:name];\n            [coder encodeObject:value forKey:name];\n        }\n    }\n    free(ivars);\n}\n\n- (void)decodeIvarsWithCoder:(NSCoder *)coder Class:(Class)Class\n{\n    unsigned int count;\n    Ivar *ivars = class_copyIvarList(Class, &count);\n    for (int i=0; i<count; i++) {\n        //取出成员变量\n        Ivar ivar = ivars[i];\n        NSString *typeEncode = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];\n        [name deleteCharactersInRange:NSMakeRange(0, 1)];\n        if ([typeEncode isEqualToString:@\"i\"]) {\n            int value = [coder decodeIntForKey:name];\n            [self setValue:@(value) forKey:name];\n        } else if ([typeEncode isEqualToString:@\"@\\\"NSString\\\"\"]) {\n            id value = [coder decodeObjectForKey:name];\n            [self setValue:value forKey:name];\n        }\n    }\n    free(ivars);\n}\n\n- (void)archive\n{\n    NSString *name = [NSString stringWithFormat:@\"obj.%@\", NSStringFromClass([self class])];\n    NSString *temp = NSTemporaryDirectory();\n    NSString *filePath = [temp stringByAppendingPathComponent:name]; //以类名作为保存文件的扩展名\n    [NSKeyedArchiver archiveRootObject:self toFile:filePath];\n}\n\n+ (instancetype)unarchive\n{\n    NSString *name = [NSString stringWithFormat:@\"obj.%@\", NSStringFromClass(self)];\n    NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:name];\n    id obj = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];\n    return obj;\n}\n@end\n\n@interface Person : NSObject<NSCoding>\n@property (nonatomic, assign) int ID;\n@property (nonatomic, assign) int age;\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Person\n- (void)encodeWithCoder:(NSCoder *)coder\n{\n    [self encodeIvarsWithCoder:coder Class:[Person class]];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super init];\n    if (self) {\n        [self decodeIvarsWithCoder:coder Class:[Person class]];\n    }\n    return self;\n}\n@end\n\n@interface Teacher : Person<NSCoding>\n@property (nonatomic, assign) int weight;\n@property (nonatomic, assign) int height;\n@end\n\n@implementation Teacher\n- (void)encodeWithCoder:(NSCoder *)coder\n{\n    [super encodeWithCoder:coder];\n    [self encodeIvarsWithCoder:coder Class:[Teacher class]];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super initWithCoder:coder];\n    if (self) {\n        [self decodeIvarsWithCoder:coder Class:[Teacher class]];\n    }\n    return self;\n}\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //归档\n//        NSDictionary *json = @{\n//            @\"id\" : @100,\n//            @\"age\" : @200,\n//            @\"weight\" : @700,\n//            @\"height\" : @1700,\n//            @\"name\" : @\"Tom\"\n//        };\n//        Teacher *teacher = [Teacher yq_objectWithJson:json];\n//        [teacher archive];\n        //解档\n        Teacher *teacher = [Teacher unarchive];\n        NSLog(@\"%d, %d, %d, %d, %@\", teacher.ID, teacher.age, teacher.weight, teacher.height, teacher.name);\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n100, 200, 700, 1700, Tom\n```\n\n### 替换方法实现\n\nclass_replaceMethod\n```\n@interface Person : NSObject\n- (void)run;\n+ (void)personRun;\n@end\n\n@implementation Person\n- (void)run\n{\n    NSLog(@\"%s\", __func__);\n}\n\n+ (void)personRun\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n\nvoid myRun()\n{\n    NSLog(@\"---myRun\");\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        //使用 myRun 替换类方法 +personRun，传入元类对象\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), (IMP)myRun, \"v\");\n        [Person personRun];\n        //使用 block 替换类方法 +personRun\n        class_replaceMethod(object_getClass([Person class]), @selector(personRun), imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        }), \"v\");\n        [Person personRun];\n        \n        //使用 myRun 替换对象方法 -run，传入类对象\n        class_replaceMethod([Person class], @selector(run), (IMP)myRun, \"v\");\n        Person *person = [[Person alloc] init];\n        [person run];\n        //使用 block 替换对象方法 -run\n        class_replaceMethod([Person class], @selector(run), imp_implementationWithBlock(^{\n            NSLog(@\"this is a block\");\n        }), \"v\");\n        [person run];\n    }\n    return 0;\n}\n```\n\n打印结果：\n```\n---myRun\nthis is a block\n---myRun\nthis is a block\n```\n\n### 拦截所有按钮的点击事件\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface UIControl (Extension)\n@end\n\n@implementation UIControl (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Method method1 = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));\n        Method method2 = class_getInstanceMethod(self, @selector(yq_sendAction:to:forEvent:));\n        method_exchangeImplementations(method1, method2);        \n    });\n}\n\n- (void)yq_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event\n{\n    NSLog(@\"%@-%@-%@\", self, target, NSStringFromSelector(action));\n    //调用系统原来的实现\n    [self yq_sendAction:action to:target forEvent:event];\n}\n@end\n\n@interface ViewController : UIViewController\n@end\n\n@implementation ViewController\n- (IBAction)click1:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n- (IBAction)click2:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n- (IBAction)click3:(id)sender\n{\n    NSLog(@\"%s\", __func__);\n}\n@end\n```\n\n打印结果：\n```\n<UIButton: 0x7f8d0ad093e0; frame = (148 332; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001bd0560>>-<ViewController: 0x7f8d0ac06850>-click1:\n-[ViewController click1:]\n<UIButton: 0x7f8d0ae0c4f0; frame = (148 411; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001be5740>>-<ViewController: 0x7f8d0ac06850>-click2:\n-[ViewController click2:]\n<UIButton: 0x7f8d0ad096b0; frame = (148 492; 46 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x600001bd06e0>>-<ViewController: 0x7f8d0ac06850>-click3:\n-[ViewController click3:]\n```\n\n### 拦截数组添加数据方法\n\n数组的 `addObject:` 和 `insertObject:` 方法调用的都是 `insertObject:atIndex:` 方法。拦截 `insertObject:atIndex:` 方法，可以解决添加空数据导致的崩溃。\n\n类簇：NSData、NSArray、NSDictionary 和 NSString。它们的类并不一样，比如 NSMutableArray 的类是 `__NSArrayM`。\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface NSMutableArray (Extension)\n@end\n\n@implementation NSMutableArray (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class cls = NSClassFromString(@\"__NSArrayM\");\n        Method method1 = class_getInstanceMethod(cls, @selector(insertObject:atIndex:));\n        Method method2 = class_getInstanceMethod(cls, @selector(yq_insertObject:atIndex:));\n        method_exchangeImplementations(method1, method2);        \n    });\n}\n\n- (void)yq_insertObject:(id)anObject atIndex:(NSUInteger)index\n{\n    if (anObject == nil) return;\n    [self yq_insertObject:anObject atIndex:index];\n}\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableArray *arrayM = [[NSMutableArray alloc] init];\n    NSString *obj = nil;\n    [arrayM addObject:obj];\n}\n@end\n```\n\n### 拦截字典添加数据方法\n\n字典赋值的 `setObject:forKey:` 方法最终调用的是 `setObject:forKeyedSubscript:`。拦截 `setObject:forKeyedSubscript:` 方法，可以解决添加空数据导致的崩溃。\n\n使用 method_exchangeImplementations 交换系统方法实现方法拦截：\n```\n@interface NSMutableDictionary (Extension)\n@end\n\n@implementation NSMutableDictionary (Extension)\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class cls = NSClassFromString(@\"__NSDictionaryM\");\n        Method method1 = class_getInstanceMethod(cls, @selector(setObject:forKeyedSubscript:));\n        Method method2 = class_getInstanceMethod(cls, @selector(yq_setObject:forKeyedSubscript:));\n        method_exchangeImplementations(method1, method2);\n        \n        Class cls2 = NSClassFromString(@\"__NSDictionaryI\");\n        Method method3 = class_getInstanceMethod(cls2, @selector(objectForKeyedSubscript:));\n        Method method4 = class_getInstanceMethod(cls2, @selector(yq_objectForKeyedSubscript:));\n        method_exchangeImplementations(method3, method4);\n    });\n}\n\n- (void)yq_setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key\n{\n    if (!key || !obj) return;\n    [self yq_setObject:obj forKeyedSubscript:key];\n}\n\n- (id)yq_objectForKeyedSubscript:(id)key\n{\n    if (!key) return nil;\n    return [self yq_objectForKeyedSubscript:key];\n}\n\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSMutableDictionary *dictionaryM = [NSMutableDictionary dictionary];\n    dictionaryM[obj] = obj;\n    NSString *obj2 = dictionaryM[obj];\n}\n@end\n```\n\n# 总结\n* 讲一下 OC 的消息机制  \nOC 中的方法调用其实都是转成了 objc_msgSend 函数的调用，给 receiver（方法调用者）发送了一条消息（selector(方法名)）。  \nobjc_msgSend 底层有三大阶段：  \n    * 消息发送：先调在当前类的 cache 里找，再到当前类的 methods 里找。如果在当前类没有找到，再遍历父类查找，先在父类的 cache 里找，再到父类的 methods 里找。\n    * 动态方法解析：在当前类及其父类里没有找到方法时，会调用 `resolveInstanceMethod:` 或者 `resolveClassMethod:` 方法动态添加方法。  \n    * 消息转发：如果没有动态添加方法，会调用 `forwardingTargetForSelector:` 方法获取可以处理消息的对象。如果没有实现  `forwardingTargetForSelector:` 方法或者该方法返回的是 nil，会调用 `methodSignatureForSelector:` 方法获取类型编码，在获取类型编码成功后再调用 `forwardInvocation:` 方法进行自定义操作。如果没有实现 `methodSignatureForSelector:` 方法或者该方法返回的是 nil，会调用 `doesNotRecognizeSelector:` 方法终止流程。 \n\n* 消息转发机制流程  \n如果没有动态添加方法，会调用 `forwardingTargetForSelector:` 方法获取可以处理消息的对象。如果没有实现  `forwardingTargetForSelector:` 方法或者该方法返回的是 nil，会调用 `methodSignatureForSelector:` 方法获取类型编码，在获取类型编码成功后再调用 `forwardInvocation:` 方法进行自定义操作。如果没有实现 `methodSignatureForSelector:` 方法或者该方法返回的是 nil，会调用 `doesNotRecognizeSelector:` 方法终止流程。 \n\n* 什么是 Runtime ？平时项目中有用过么？  \nOC 是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。OC 的动态性就是由 Runtime 来支撑和实现的，Runtime 是一套 C 语言的 API，封装了很多动态性相关的函数，平时编写的OC代码，底层都是转换成了 Runtime API 进行调用。\n\n  具体应用  \n  1、利用关联对象（AssociatedObject）给分类添加属性；  \n  2、遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）；  \n  3、交换方法实现（交换系统的方法）；  \n  4、利用消息转发机制解决方法找不到的异常问题；  \n  ......\n","slug":"OC底层原理/Runtime","published":1,"updated":"2023-08-22T09:52:13.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgzh0039aq7k0hk6qagb"},{"title":"不二医疗技术支持网址","date":"2020-03-14T06:37:34.000Z","_content":"\n提供APP技术支持，审核人员有问题可联系：  \n邮箱：565034021@qq.com  \n地址：中国河北省保定市北市区或竞秀区百花东路地勘院宿舍8-4-301。谢谢！！","source":"_posts/Other/不二医疗/不二医疗技术支持网址.md","raw":"---\ntitle: 不二医疗技术支持网址\ndate: 2020-03-14 14:37:34\ntags: Other\n---\n\n提供APP技术支持，审核人员有问题可联系：  \n邮箱：565034021@qq.com  \n地址：中国河北省保定市北市区或竞秀区百花东路地勘院宿舍8-4-301。谢谢！！","slug":"Other/不二医疗/不二医疗技术支持网址","published":1,"updated":"2023-08-22T09:52:14.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgzq003baq7k29tfujco"},{"title":"不二医疗隐私政策","date":"2020-03-14T06:07:21.000Z","_content":"\n一、适用范围\n1、本政策仅适用于不二医疗APP软件、以及APP运营主体，客户端的使用人在本政策中称为“用户”或“您”。  \n2、用户在使用客户端的各项服务前，仔细阅读并充分理解本隐私保护政策，您在点击“确认”按钮后，即构成对双方有约束力的法律文件，即表示您同意不二医疗按照本政策收集、使用、处理和存储您的相关信息。 如果您对本隐私政策有任何疑问、意见或建议，可通过留言反映具体情况。  \n3、不二医疗知晓个人信息对您的重要性，并会尽全力保护您的个人信息安全可靠，承诺：将按业界最成熟的安全标准，采取相应的安全保护措施来保护您的个人信息不被泄露。\n<!-- more -->\n二、隐私保护政策具体内容  \n1、当您注册、登录不二医疗客户端并使用客户端相关功能及相关服务时，需要通过手机号创建帐号，当您通过手机验证码的方式登录、注册时，您将授权我们获取您在第三方平台注册的公开信息（头像、昵称、地区、和性别信息），用于手机号的绑定，使您可以直接登录并使用本产品和相关服务。  \n2、您浏览的内容包括医院信息、科室信息、医生信息、评论、健康类文章、科普视频、养生保健类信息、上门护理类信息，为此，我们可能会收集您使用如设备型号、操作系统、运营商等软硬件信息，还可能收集您的浏览器类型，为您提供信息展示的最优方案。在您使用浏览功能的过程中，会自动收集您使用不二医疗客户端的详细情况，并作为有关的网络信息保存，包括您输入的搜索关键词信息和点击的链接，您浏览的内容及评论信息，访问日期和时间、网页记录、软件版本号、IP信息等。  \n3、您注册成为不二医疗的用户后，可以在问诊平台问诊，在问诊过程中，可能会开启手机拍摄、读取相册、录音、读取外部存储以及写入外部存储的有关权限，用于问诊过程中相关资料的传输及参考。同时在此过程中，我们可能会收集您的患者姓名、性别、年龄、症状及病史等信息，用于患者病情的诊断等。  \n4、在您使用注册会员过程中会需要进行支付。  \n5、我们会基于收集的信息，对您的偏好、习惯、位置作特征分析，以便为您提供更适合的定制化服务，例如向您展现或推荐相关程度更高的搜索结果，因此我们需要收集包括您的设备信息、浏览记录等。  \n6、我们致力于为您提供安全、可信的产品与使用环境，提供优质而可靠的服务，为实现安全保障功能所收集的信息是必要信息。  \n7、为了保障软件与服务的安全运行，我们可能会收集您的硬件型号、操作系统版本号、网络设备硬件地址、IP 地址、WLAN接入点、软件版本号、网络接入方式、类型、网络质量数据等。我们可能会使用您的账户信息、设备信息等，在获得您授权或依法可以共享的信息下，在关联公司或合作方的操作下用于判断账户安全、进行身份验证、检测及防范安全事件。\n\n三、我们不会向任何公司、组织和个人分享您的个人信息，但以下情况除外：  \n1、在获得您明确同意的情况下共享，我们会与第三方共享您的个人信息。  \n2、与授权合作伙伴共享，仅为实现本政策中声明的目的，我们可能会与合作伙伴共享或提供您的某些个人信息，以提供更好的客户服务和用户体验。我们仅会出于合法、正当、明确的目的共享您的个人信息，并且只会共享提供服务时所必要的个人信息。我们的合作伙伴无权将共享的个人信息用于任何其他用途。  \n3、我们不会将您的个人信息转让给任何公司、组织和个人， 除非在获取您明确同意的情况下转让。  \n4、我们仅会在以下情况下，公开披露您的个人信息：获得您明确同意后，在法律或政府主管部门强制性要求的情况下，我们可能会公开披露您的个人信息。\n\n四、发生个人信息泄露事件后，我们将按照法律法规的要求，及时通过推送方式、信函、电话等方式向您告知，造成的影响，我们将会采取相应的处置措施，您也可自主进行防范和降低风险的措施，对您进行补救等。难以逐个告知个人信息主体时，我们会采取合理、有效的方式发布公告，同时，我们还将按照监管部门要求，主动上报事件的处置情况。\n\n五、您的权利\\n按照相关的法律法规，我们保障您对自己的个人信息行使以下权利：  \n1：您有权访问您的个人信息  \n2：您有权更正您的个人信息  \n3：您有权删除及注销您的个人信息  \n我们会先要求您验证自己的身份，然后我们以最快的方式处理您的请求。\n\n六、 我们的产品及客户端的服务主要面向成年人，儿童不得创建自己的账户，我们只会在受到法律允许、父母或监护人明确同意或者保护儿童所必要的情况下使用或公开披露此信息，我们将不满15周岁的（含15周岁）均视为儿童。\n\n七、本政策的适用及更新\\n我们可能会不时对《不二医疗隐私政策》进行修订，隐私政策发生修订时，我们会在版本更新后以推送通知、弹窗等形式向您告知，但请您注意，只有在您确认修订后的《不二医疗客户端隐私政策》后，我们才会按照修订后的《不二医疗客户端隐私政策》收集、使用、处理和存储您的个人信息。您可以选择不同意修订后的《不二医疗客户端隐私政策》，但可能导致您无法使用不二医疗客户端的部分服务功能。  \n\n未经您同意，我们不会削减您按照本隐私政策所应享有的权利，对于重大变更，我们还会提供更为显著的通知。  \n\n如果您对本隐私政策有任何疑问、意见或建议，通过留言与我们联系。谢谢！","source":"_posts/Other/不二医疗/不二医疗隐私政策.md","raw":"---\ntitle: 不二医疗隐私政策\ndate: 2020-03-14 14:07:21\ntags: Other\n---\n\n一、适用范围\n1、本政策仅适用于不二医疗APP软件、以及APP运营主体，客户端的使用人在本政策中称为“用户”或“您”。  \n2、用户在使用客户端的各项服务前，仔细阅读并充分理解本隐私保护政策，您在点击“确认”按钮后，即构成对双方有约束力的法律文件，即表示您同意不二医疗按照本政策收集、使用、处理和存储您的相关信息。 如果您对本隐私政策有任何疑问、意见或建议，可通过留言反映具体情况。  \n3、不二医疗知晓个人信息对您的重要性，并会尽全力保护您的个人信息安全可靠，承诺：将按业界最成熟的安全标准，采取相应的安全保护措施来保护您的个人信息不被泄露。\n<!-- more -->\n二、隐私保护政策具体内容  \n1、当您注册、登录不二医疗客户端并使用客户端相关功能及相关服务时，需要通过手机号创建帐号，当您通过手机验证码的方式登录、注册时，您将授权我们获取您在第三方平台注册的公开信息（头像、昵称、地区、和性别信息），用于手机号的绑定，使您可以直接登录并使用本产品和相关服务。  \n2、您浏览的内容包括医院信息、科室信息、医生信息、评论、健康类文章、科普视频、养生保健类信息、上门护理类信息，为此，我们可能会收集您使用如设备型号、操作系统、运营商等软硬件信息，还可能收集您的浏览器类型，为您提供信息展示的最优方案。在您使用浏览功能的过程中，会自动收集您使用不二医疗客户端的详细情况，并作为有关的网络信息保存，包括您输入的搜索关键词信息和点击的链接，您浏览的内容及评论信息，访问日期和时间、网页记录、软件版本号、IP信息等。  \n3、您注册成为不二医疗的用户后，可以在问诊平台问诊，在问诊过程中，可能会开启手机拍摄、读取相册、录音、读取外部存储以及写入外部存储的有关权限，用于问诊过程中相关资料的传输及参考。同时在此过程中，我们可能会收集您的患者姓名、性别、年龄、症状及病史等信息，用于患者病情的诊断等。  \n4、在您使用注册会员过程中会需要进行支付。  \n5、我们会基于收集的信息，对您的偏好、习惯、位置作特征分析，以便为您提供更适合的定制化服务，例如向您展现或推荐相关程度更高的搜索结果，因此我们需要收集包括您的设备信息、浏览记录等。  \n6、我们致力于为您提供安全、可信的产品与使用环境，提供优质而可靠的服务，为实现安全保障功能所收集的信息是必要信息。  \n7、为了保障软件与服务的安全运行，我们可能会收集您的硬件型号、操作系统版本号、网络设备硬件地址、IP 地址、WLAN接入点、软件版本号、网络接入方式、类型、网络质量数据等。我们可能会使用您的账户信息、设备信息等，在获得您授权或依法可以共享的信息下，在关联公司或合作方的操作下用于判断账户安全、进行身份验证、检测及防范安全事件。\n\n三、我们不会向任何公司、组织和个人分享您的个人信息，但以下情况除外：  \n1、在获得您明确同意的情况下共享，我们会与第三方共享您的个人信息。  \n2、与授权合作伙伴共享，仅为实现本政策中声明的目的，我们可能会与合作伙伴共享或提供您的某些个人信息，以提供更好的客户服务和用户体验。我们仅会出于合法、正当、明确的目的共享您的个人信息，并且只会共享提供服务时所必要的个人信息。我们的合作伙伴无权将共享的个人信息用于任何其他用途。  \n3、我们不会将您的个人信息转让给任何公司、组织和个人， 除非在获取您明确同意的情况下转让。  \n4、我们仅会在以下情况下，公开披露您的个人信息：获得您明确同意后，在法律或政府主管部门强制性要求的情况下，我们可能会公开披露您的个人信息。\n\n四、发生个人信息泄露事件后，我们将按照法律法规的要求，及时通过推送方式、信函、电话等方式向您告知，造成的影响，我们将会采取相应的处置措施，您也可自主进行防范和降低风险的措施，对您进行补救等。难以逐个告知个人信息主体时，我们会采取合理、有效的方式发布公告，同时，我们还将按照监管部门要求，主动上报事件的处置情况。\n\n五、您的权利\\n按照相关的法律法规，我们保障您对自己的个人信息行使以下权利：  \n1：您有权访问您的个人信息  \n2：您有权更正您的个人信息  \n3：您有权删除及注销您的个人信息  \n我们会先要求您验证自己的身份，然后我们以最快的方式处理您的请求。\n\n六、 我们的产品及客户端的服务主要面向成年人，儿童不得创建自己的账户，我们只会在受到法律允许、父母或监护人明确同意或者保护儿童所必要的情况下使用或公开披露此信息，我们将不满15周岁的（含15周岁）均视为儿童。\n\n七、本政策的适用及更新\\n我们可能会不时对《不二医疗隐私政策》进行修订，隐私政策发生修订时，我们会在版本更新后以推送通知、弹窗等形式向您告知，但请您注意，只有在您确认修订后的《不二医疗客户端隐私政策》后，我们才会按照修订后的《不二医疗客户端隐私政策》收集、使用、处理和存储您的个人信息。您可以选择不同意修订后的《不二医疗客户端隐私政策》，但可能导致您无法使用不二医疗客户端的部分服务功能。  \n\n未经您同意，我们不会削减您按照本隐私政策所应享有的权利，对于重大变更，我们还会提供更为显著的通知。  \n\n如果您对本隐私政策有任何疑问、意见或建议，通过留言与我们联系。谢谢！","slug":"Other/不二医疗/不二医疗隐私政策","published":1,"updated":"2023-08-22T09:52:14.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmgzx003daq7kqj4mfpp9"},{"title":"AFHTTPSessionManager","date":"2017-07-14T16:00:00.000Z","_content":"\n# 概述\nAFHTTPSessionManager 继承自 AFURLSessionManager，它是对 AFURLSessionManager 里的方法进行了二次封装，使用时更加便捷，是网络请求最常用的类。\n\n<!-- more -->\n\n![AFHTTPSessionManager](AFHTTPSessionManager/AFHTTPSessionManager.png)\n\n# AFHTTPSessionManager\n下面是 AFHTTPSessionManager 引用的类：\n\n.h 文件  \n\n```\n#import <Foundation/Foundation.h>\n#if !TARGET_OS_WATCH\n//提供和联网相关的function, 可用来检查网络连接状态\n#import <SystemConfiguration/SystemConfiguration.h>\n#endif\n#import <TargetConditionals.h>\n\n#if TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV\n#import <MobileCoreServices/MobileCoreServices.h>\n#else\n#import <CoreServices/CoreServices.h>\n#endif\n\n#import \"AFURLSessionManager.h\"\n```\n.m 文件\n\n```\n#import \"AFHTTPSessionManager.h\"\n\n#import \"AFURLRequestSerialization.h\"\n#import \"AFURLResponseSerialization.h\"\n\n#import <Availability.h>\n#import <TargetConditionals.h>\n#import <Security/Security.h>\n\n#import <netinet/in.h>\n#import <netinet6/in6.h>\n#import <arpa/inet.h>\n#import <ifaddrs.h>\n#import <netdb.h>\n\n#if TARGET_OS_IOS || TARGET_OS_TV\n#import <UIKit/UIKit.h>\n#elif TARGET_OS_WATCH\n#import <WatchKit/WatchKit.h>\n#endif\n```\n## 类库介绍\n### SystemConfiguration\n\n### [TargetConditionals](https://www.cocoanetics.com/2012/09/target-conditionals-and-availability/)\n\n“Target Conditionals” 目标条件，是由 Apple 提供的，内部定义了多种方便的宏代码。如果要使用内部的一些宏，就需要导入 \\<TargetConditionals.h> ，否则在用到时会提示未定义。作为判断条件这里用到的宏是：  \n\n* TARGET_OS\\_IOS\n* TARGET_OS\\_WATCH\n* TARGET_OS\\_TV    \n\n还有几个有趣的宏：\n\n* TARGET_IPHONE\\_SIMULATOR\n* TARGET_OS\\_MAC\n* TARGET_OS\\_IPHONE\n\n这里需要注意的是 iPhone OS 是 Mac OS 演变过来的子系统，所以当运行在手机系统上时，TARGET\\_OS\\_MAC 也会被定义。这个时候，如果想限制代码只包含在手机系统上时，可以使用 TARGET\\_OS\\_IPHONE，相应的只包含在 Mac 系统上使用 #if !TARGET\\_OS\\_IPHONE。\n\n\n### Availability  \n\n### Security  \n\n### netinet/in.h\n\n### netinet6/in6.h  \n\n### arpa/inet.h  \n\n### ifaddrs.h  \n\n### netdb.h  \n\n\n\n1. [AFURLSessionManager](http://kevinyanggit.github.io/2017/08/10/AFURLSessionManager/#more) 是网络请求类。主要做了两件事，一是创建 NSURLSession 对象并实现相应的代理方法；二是创建 NSURLSessionDataTask 对象并管理；\n\n2. [AFURLRequestSerialization]() 是序列化请求数据类。它会将请求数据进行序列化后生成一个 NSMutableURLRequest 对象，用于创建 NSURLSessionDataTask 对象；\n3. [AFURLResponseSerialization]() 是序列化返回结果类。它会将服务器返回的数据进行序列化后，返回给开发者。\n\nAFHTTPSessionManager 中实现的 GET、HEAD、POST、PUT、PATCH、DELETE 等方法，都是基于下面的这个私有方法。下面的这个方法会根据传入的 method 来区分具体实现的方法。\n\n```\n- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method\n                                       URLString:(NSString *)URLString\n                                      parameters:(id)parameters\n                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress\n                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress\n                                         success:(void (^)(NSURLSessionDataTask *, id))success\n                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure\n{\n    NSError *serializationError = nil;\n//1.创建 request\n    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&serializationError];\n    if (serializationError) {\n        if (failure) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgnu\"\n            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{\n                failure(nil, serializationError);\n            });\n#pragma clang diagnostic pop\n        }\n\n        return nil;\n    }\n//2.创建 dataTask\n    __block NSURLSessionDataTask *dataTask = nil;\n    dataTask = [self dataTaskWithRequest:request\n                          uploadProgress:uploadProgress\n                        downloadProgress:downloadProgress\n                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {\n        if (error) {\n            if (failure) {\n                failure(dataTask, error);\n            }\n        } else {\n            if (success) {\n                success(dataTask, responseObject);\n            }\n        }\n    }];\n\n    return dataTask;\n}\n```\n以上描述也可以简单的概括为：  \n\n* AFHTTPSessionManager 通过 AFURLRequestSerialization —> request  \n* AFHTTPSessionManager 通过 AFURLSessionManager + request —> dataTask  \n* AFHTTPSessionManager 通过 AFURLResponseSerialization —> 序列化后的请求结果  \n\n# 知识点梳理\n\n## \\#pragma\n[#pragma](http://nshipster.cn/pragma/) 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。通过使用#pragma clang diagnostic push/pop，你可以告诉编译器仅仅为某一特定部分的代码（最初的诊断设置在最后的pop被恢复）来忽视特定警告。\n这里的 [#pragma clang diagnostic ignored \"-Wgnu\"](http://fuckingclangwarnings.com) 就是用来忽略警告的。\n\n```\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgnu\"\n            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{\n                failure(nil, serializationError);\n            });\n#pragma clang diagnostic pop\n```\n\n## block\n对象 dataTask 在被 [__block](http://www.jianshu.com/p/710026d5bcfb) 修饰后，会生成一个结构体，里面记录了 dataTask 对象的地址。当 block 的函数体内部调用 dataTask 时，该结构体会作为 block 实例内的一个变量被 block 函数体记录。由于记录的是 dataTask 对象的地址，所以在函数体内部可以对其进行修改，同样的，在外部被修改时，函数体内部的 dataTask 也会被修改，毕竟它们访问的是同一个地址。\n\n```\n__block NSURLSessionDataTask *dataTask = nil;\ndataTask = [self dataTaskWithRequest:request\n                      uploadProgress:uploadProgress\n                    downloadProgress:downloadProgress\n                   completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {\n    if (error) \n        if (failure) {\n            failure(dataTask, error);\n        }\n    } else {\n        if (success) {\n            success(dataTask, responseObject);\n        }\n    }\n}];\n```\n可以用 clang -rewrite-objc 命令查看它的 c++ 实现：\n\n\n```\n//__block NSURLSessionDataTask *dataTask = nil;\n//============= 对应代码 =============\nstruct __Block_byref_dataTask_0 {\n void *__isa;\n __Block_byref_dataTask_0 *__forwarding;\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n NSURLSessionDataTask *dataTask;\n};\n\n//============= block 变量 =============\nstruct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0 {\n  struct __block_impl impl;\n  struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0* Desc;\n  struct __block_impl *failure;\n  struct __block_impl *success;\n  __Block_byref_dataTask_0 *dataTask; // by ref\n  __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0(void *fp, struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0 *desc, void *_failure, void *_success, __Block_byref_dataTask_0 *_dataTask, int flags=0) : failure((struct __block_impl *)_failure), success((struct __block_impl *)_success), dataTask(_dataTask->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\n//============= block 函数体 =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_func_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0 *__cself, NSURLResponse *response, id responseObject, NSError *error) {\n  __Block_byref_dataTask_0 *dataTask = __cself->dataTask; // bound by ref\n  void (*failure)(NSURLSessionDataTask *, NSError *) = (void (*)(NSURLSessionDataTask *, NSError *))__cself->failure; // bound by copy\n  void (*success)(NSURLSessionDataTask *, id) = (void (*)(NSURLSessionDataTask *, id))__cself->success; // bound by copy\n\n        if (error) {\n            if (failure) {\n                ((void (*)(__block_impl *, NSURLSessionDataTask *, NSError *))((__block_impl *)failure)->FuncPtr)((__block_impl *)failure, (dataTask->__forwarding->dataTask), error);\n            }\n        } else {\n            if (success) {\n                ((void (*)(__block_impl *, NSURLSessionDataTask *, id))((__block_impl *)success)->FuncPtr)((__block_impl *)success, (dataTask->__forwarding->dataTask), responseObject);\n            }\n        }\n    }\n    \n//============= copy =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_copy_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*dst,   \nstruct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*src) {  \n_Block_object_assign((void*)&dst->failure, (void*)src->failure, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n_Block_object_assign((void*)&dst->dataTask, (void*)src->dataTask, 8/*BLOCK_FIELD_IS_BYREF*/);  \n_Block_object_assign((void*)&dst->success, (void*)src->success, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n}\n\n//============= release =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_dispose_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*src) {  \n_Block_object_dispose((void*)src->failure, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n_Block_object_dispose((void*)src->dataTask, 8/*BLOCK_FIELD_IS_BYREF*/);  \n_Block_object_dispose((void*)src->success, 7/*BLOCK_FIELD_IS_BLOCK*/);}  \n\n//============= block的内存管理 =============\nstatic struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0 {\n  size_t reserved;  \n  size_t Block_size;  \n  void (*copy)(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*,  \n  struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*);    \n  void (*dispose)(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*);  \n} __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0_DATA = { 0,   \nsizeof(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0),  \n__AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_copy_0,  \n__AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_dispose_0};  \n```\n在 block 变量结构体内部有这样一句代码，它表示了该 block 的类型：\n\n```\nimpl.isa = &_NSConcreteStackBlock;\n```\n\n* _NSConcreteStackBlock：(栈区)  \n\t只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。\n\tStackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。\n\n* _NSConcreteMallocBlock：(堆区)  \n\t有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制\n\n* _NSConcreteGlobalBlock：(全局)  \n   没有用到外界变量或只用到全局变量、静态变量的block为\\_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。\n\n## NSSecure​Coding\n[NSSecureCoding](http://nshipster.cn/nssecurecoding/) 是在 iOS 6 / OS X Mountain Lion SDKs 里推出的协议。如果一个类符合 NSSecureCoding 协议并在 supportsSecureCoding 返回 YES，就声明了它可以处理本身实例的编码解码方式，以防止替换攻击。  \n\nNSSecureCoding 和 NSCoding 的区别在于解数据时要指定 Class，用 decodeObjectOfClass:forKey: 方法代替了 decodeObjectForKey:。这样做更安全，因为序列化后的数据有可能被篡改，若不指定 Class，decode 出来的对象可能不是原来的对象，有潜在风险。\n\n## NSParameterAssert\n\n基础类库中定义了两套断言宏：\n\n* [NSAssert / NSCAssert](http://nshipster.cn/nsassertionhandler/)\n* [NSParameterAssert / NSCParameterAssert](http://nshipster.cn/nsassertionhandler/)\n\n基础类库从语义学上和功能性上使断言处理器的 API 在两个方面区别开来。  \n第一个区别在于一般断言（NSAssert）和参数化断言（NSParameterAssert）。  \n第二个区别在于 C 和 Objective-C 的断言：NSAssert 应当只用于 Objective-C 环境中（即方法实现中），而 NSCAssert 应当只用于 C 环境中（即函数中）。  \n\nNSAssertionHandler:自定义处理方法,程序不会直接崩溃。  \n\n* 当 NSAssert 或 NSParameterAssert 的条件不满足时，断言处理器会调用   \n  -handleFailureInMethod:object:file:lineNumber:description: 方法。  \n* 当 NSCAssert 或 NSCParameterAssert 的条件不满足时，断言处理器会调用  \n  -handleFailureInFunction:file:lineNumber:description: 方法。\n  \nNSAssert/NSParameterAssert 两者的区别是前者是所有断言, 后者只是针对参数是否存在的断言。  \nPS : Xcode 已经默认将 release 环境下的断言取消了, 避免了忘记关闭断言造成的程序不稳定。\n\n\n","source":"_posts/iOS/AFHTTPSessionManager/AFHTTPSessionManager.md","raw":"---\ntitle: AFHTTPSessionManager\ndate: 2017-07-15 \ntags: OC\n---\n\n# 概述\nAFHTTPSessionManager 继承自 AFURLSessionManager，它是对 AFURLSessionManager 里的方法进行了二次封装，使用时更加便捷，是网络请求最常用的类。\n\n<!-- more -->\n\n![AFHTTPSessionManager](AFHTTPSessionManager/AFHTTPSessionManager.png)\n\n# AFHTTPSessionManager\n下面是 AFHTTPSessionManager 引用的类：\n\n.h 文件  \n\n```\n#import <Foundation/Foundation.h>\n#if !TARGET_OS_WATCH\n//提供和联网相关的function, 可用来检查网络连接状态\n#import <SystemConfiguration/SystemConfiguration.h>\n#endif\n#import <TargetConditionals.h>\n\n#if TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV\n#import <MobileCoreServices/MobileCoreServices.h>\n#else\n#import <CoreServices/CoreServices.h>\n#endif\n\n#import \"AFURLSessionManager.h\"\n```\n.m 文件\n\n```\n#import \"AFHTTPSessionManager.h\"\n\n#import \"AFURLRequestSerialization.h\"\n#import \"AFURLResponseSerialization.h\"\n\n#import <Availability.h>\n#import <TargetConditionals.h>\n#import <Security/Security.h>\n\n#import <netinet/in.h>\n#import <netinet6/in6.h>\n#import <arpa/inet.h>\n#import <ifaddrs.h>\n#import <netdb.h>\n\n#if TARGET_OS_IOS || TARGET_OS_TV\n#import <UIKit/UIKit.h>\n#elif TARGET_OS_WATCH\n#import <WatchKit/WatchKit.h>\n#endif\n```\n## 类库介绍\n### SystemConfiguration\n\n### [TargetConditionals](https://www.cocoanetics.com/2012/09/target-conditionals-and-availability/)\n\n“Target Conditionals” 目标条件，是由 Apple 提供的，内部定义了多种方便的宏代码。如果要使用内部的一些宏，就需要导入 \\<TargetConditionals.h> ，否则在用到时会提示未定义。作为判断条件这里用到的宏是：  \n\n* TARGET_OS\\_IOS\n* TARGET_OS\\_WATCH\n* TARGET_OS\\_TV    \n\n还有几个有趣的宏：\n\n* TARGET_IPHONE\\_SIMULATOR\n* TARGET_OS\\_MAC\n* TARGET_OS\\_IPHONE\n\n这里需要注意的是 iPhone OS 是 Mac OS 演变过来的子系统，所以当运行在手机系统上时，TARGET\\_OS\\_MAC 也会被定义。这个时候，如果想限制代码只包含在手机系统上时，可以使用 TARGET\\_OS\\_IPHONE，相应的只包含在 Mac 系统上使用 #if !TARGET\\_OS\\_IPHONE。\n\n\n### Availability  \n\n### Security  \n\n### netinet/in.h\n\n### netinet6/in6.h  \n\n### arpa/inet.h  \n\n### ifaddrs.h  \n\n### netdb.h  \n\n\n\n1. [AFURLSessionManager](http://kevinyanggit.github.io/2017/08/10/AFURLSessionManager/#more) 是网络请求类。主要做了两件事，一是创建 NSURLSession 对象并实现相应的代理方法；二是创建 NSURLSessionDataTask 对象并管理；\n\n2. [AFURLRequestSerialization]() 是序列化请求数据类。它会将请求数据进行序列化后生成一个 NSMutableURLRequest 对象，用于创建 NSURLSessionDataTask 对象；\n3. [AFURLResponseSerialization]() 是序列化返回结果类。它会将服务器返回的数据进行序列化后，返回给开发者。\n\nAFHTTPSessionManager 中实现的 GET、HEAD、POST、PUT、PATCH、DELETE 等方法，都是基于下面的这个私有方法。下面的这个方法会根据传入的 method 来区分具体实现的方法。\n\n```\n- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method\n                                       URLString:(NSString *)URLString\n                                      parameters:(id)parameters\n                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress\n                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress\n                                         success:(void (^)(NSURLSessionDataTask *, id))success\n                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure\n{\n    NSError *serializationError = nil;\n//1.创建 request\n    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&serializationError];\n    if (serializationError) {\n        if (failure) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgnu\"\n            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{\n                failure(nil, serializationError);\n            });\n#pragma clang diagnostic pop\n        }\n\n        return nil;\n    }\n//2.创建 dataTask\n    __block NSURLSessionDataTask *dataTask = nil;\n    dataTask = [self dataTaskWithRequest:request\n                          uploadProgress:uploadProgress\n                        downloadProgress:downloadProgress\n                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {\n        if (error) {\n            if (failure) {\n                failure(dataTask, error);\n            }\n        } else {\n            if (success) {\n                success(dataTask, responseObject);\n            }\n        }\n    }];\n\n    return dataTask;\n}\n```\n以上描述也可以简单的概括为：  \n\n* AFHTTPSessionManager 通过 AFURLRequestSerialization —> request  \n* AFHTTPSessionManager 通过 AFURLSessionManager + request —> dataTask  \n* AFHTTPSessionManager 通过 AFURLResponseSerialization —> 序列化后的请求结果  \n\n# 知识点梳理\n\n## \\#pragma\n[#pragma](http://nshipster.cn/pragma/) 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。通过使用#pragma clang diagnostic push/pop，你可以告诉编译器仅仅为某一特定部分的代码（最初的诊断设置在最后的pop被恢复）来忽视特定警告。\n这里的 [#pragma clang diagnostic ignored \"-Wgnu\"](http://fuckingclangwarnings.com) 就是用来忽略警告的。\n\n```\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgnu\"\n            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{\n                failure(nil, serializationError);\n            });\n#pragma clang diagnostic pop\n```\n\n## block\n对象 dataTask 在被 [__block](http://www.jianshu.com/p/710026d5bcfb) 修饰后，会生成一个结构体，里面记录了 dataTask 对象的地址。当 block 的函数体内部调用 dataTask 时，该结构体会作为 block 实例内的一个变量被 block 函数体记录。由于记录的是 dataTask 对象的地址，所以在函数体内部可以对其进行修改，同样的，在外部被修改时，函数体内部的 dataTask 也会被修改，毕竟它们访问的是同一个地址。\n\n```\n__block NSURLSessionDataTask *dataTask = nil;\ndataTask = [self dataTaskWithRequest:request\n                      uploadProgress:uploadProgress\n                    downloadProgress:downloadProgress\n                   completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {\n    if (error) \n        if (failure) {\n            failure(dataTask, error);\n        }\n    } else {\n        if (success) {\n            success(dataTask, responseObject);\n        }\n    }\n}];\n```\n可以用 clang -rewrite-objc 命令查看它的 c++ 实现：\n\n\n```\n//__block NSURLSessionDataTask *dataTask = nil;\n//============= 对应代码 =============\nstruct __Block_byref_dataTask_0 {\n void *__isa;\n __Block_byref_dataTask_0 *__forwarding;\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n NSURLSessionDataTask *dataTask;\n};\n\n//============= block 变量 =============\nstruct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0 {\n  struct __block_impl impl;\n  struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0* Desc;\n  struct __block_impl *failure;\n  struct __block_impl *success;\n  __Block_byref_dataTask_0 *dataTask; // by ref\n  __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0(void *fp, struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0 *desc, void *_failure, void *_success, __Block_byref_dataTask_0 *_dataTask, int flags=0) : failure((struct __block_impl *)_failure), success((struct __block_impl *)_success), dataTask(_dataTask->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\n//============= block 函数体 =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_func_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0 *__cself, NSURLResponse *response, id responseObject, NSError *error) {\n  __Block_byref_dataTask_0 *dataTask = __cself->dataTask; // bound by ref\n  void (*failure)(NSURLSessionDataTask *, NSError *) = (void (*)(NSURLSessionDataTask *, NSError *))__cself->failure; // bound by copy\n  void (*success)(NSURLSessionDataTask *, id) = (void (*)(NSURLSessionDataTask *, id))__cself->success; // bound by copy\n\n        if (error) {\n            if (failure) {\n                ((void (*)(__block_impl *, NSURLSessionDataTask *, NSError *))((__block_impl *)failure)->FuncPtr)((__block_impl *)failure, (dataTask->__forwarding->dataTask), error);\n            }\n        } else {\n            if (success) {\n                ((void (*)(__block_impl *, NSURLSessionDataTask *, id))((__block_impl *)success)->FuncPtr)((__block_impl *)success, (dataTask->__forwarding->dataTask), responseObject);\n            }\n        }\n    }\n    \n//============= copy =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_copy_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*dst,   \nstruct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*src) {  \n_Block_object_assign((void*)&dst->failure, (void*)src->failure, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n_Block_object_assign((void*)&dst->dataTask, (void*)src->dataTask, 8/*BLOCK_FIELD_IS_BYREF*/);  \n_Block_object_assign((void*)&dst->success, (void*)src->success, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n}\n\n//============= release =============\nstatic void __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_dispose_0(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*src) {  \n_Block_object_dispose((void*)src->failure, 7/*BLOCK_FIELD_IS_BLOCK*/);  \n_Block_object_dispose((void*)src->dataTask, 8/*BLOCK_FIELD_IS_BYREF*/);  \n_Block_object_dispose((void*)src->success, 7/*BLOCK_FIELD_IS_BLOCK*/);}  \n\n//============= block的内存管理 =============\nstatic struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0 {\n  size_t reserved;  \n  size_t Block_size;  \n  void (*copy)(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*,  \n  struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*);    \n  void (*dispose)(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0*);  \n} __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_desc_0_DATA = { 0,   \nsizeof(struct __AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_impl_0),  \n__AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_copy_0,  \n__AFHTTPSessionManager__dataTaskWithHTTPMethod_URLString_parameters_uploadProgress_downloadProgress_success_failure__block_dispose_0};  \n```\n在 block 变量结构体内部有这样一句代码，它表示了该 block 的类型：\n\n```\nimpl.isa = &_NSConcreteStackBlock;\n```\n\n* _NSConcreteStackBlock：(栈区)  \n\t只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。\n\tStackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。\n\n* _NSConcreteMallocBlock：(堆区)  \n\t有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制\n\n* _NSConcreteGlobalBlock：(全局)  \n   没有用到外界变量或只用到全局变量、静态变量的block为\\_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。\n\n## NSSecure​Coding\n[NSSecureCoding](http://nshipster.cn/nssecurecoding/) 是在 iOS 6 / OS X Mountain Lion SDKs 里推出的协议。如果一个类符合 NSSecureCoding 协议并在 supportsSecureCoding 返回 YES，就声明了它可以处理本身实例的编码解码方式，以防止替换攻击。  \n\nNSSecureCoding 和 NSCoding 的区别在于解数据时要指定 Class，用 decodeObjectOfClass:forKey: 方法代替了 decodeObjectForKey:。这样做更安全，因为序列化后的数据有可能被篡改，若不指定 Class，decode 出来的对象可能不是原来的对象，有潜在风险。\n\n## NSParameterAssert\n\n基础类库中定义了两套断言宏：\n\n* [NSAssert / NSCAssert](http://nshipster.cn/nsassertionhandler/)\n* [NSParameterAssert / NSCParameterAssert](http://nshipster.cn/nsassertionhandler/)\n\n基础类库从语义学上和功能性上使断言处理器的 API 在两个方面区别开来。  \n第一个区别在于一般断言（NSAssert）和参数化断言（NSParameterAssert）。  \n第二个区别在于 C 和 Objective-C 的断言：NSAssert 应当只用于 Objective-C 环境中（即方法实现中），而 NSCAssert 应当只用于 C 环境中（即函数中）。  \n\nNSAssertionHandler:自定义处理方法,程序不会直接崩溃。  \n\n* 当 NSAssert 或 NSParameterAssert 的条件不满足时，断言处理器会调用   \n  -handleFailureInMethod:object:file:lineNumber:description: 方法。  \n* 当 NSCAssert 或 NSCParameterAssert 的条件不满足时，断言处理器会调用  \n  -handleFailureInFunction:file:lineNumber:description: 方法。\n  \nNSAssert/NSParameterAssert 两者的区别是前者是所有断言, 后者只是针对参数是否存在的断言。  \nPS : Xcode 已经默认将 release 环境下的断言取消了, 避免了忘记关闭断言造成的程序不稳定。\n\n\n","slug":"iOS/AFHTTPSessionManager/AFHTTPSessionManager","published":1,"updated":"2024-02-02T11:04:33.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4jmh3l003gaq7k1wxdynhl"}],"PostAsset":[{"_id":"source/_posts/2022年打怪/算法列表/20220607_th.jpeg","slug":"20220607_th.jpeg","post":"cls4jmgrb0003aq7kf8tjnh0c","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/14.png","slug":"14.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/15.png","slug":"15.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/22.png","slug":"22.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/24.png","slug":"24.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/23.png","slug":"23.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/25.png","slug":"25.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/26.png","slug":"26.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop05.png","slug":"RunLoop05.png","post":"cls4jmgsn000uaq7kedfkgchk","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop12.png","slug":"RunLoop12.png","post":"cls4jmgsn000uaq7kedfkgchk","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/block/block16.png","slug":"block16.png","post":"cls4jmgv7002taq7kc4ti2wyp","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/多线程/多线程15.png","slug":"多线程15.png","post":"cls4jmgva002xaq7k62a1f195","modified":1,"renderable":0},{"_id":"source/_posts/Swift/Swift简介/15.png","slug":"15.png","post":"cls4jmgtt001eaq7kkx2dmwco","modified":1,"renderable":0},{"_id":"source/_posts/Swift/集合类/25.png","slug":"25.png","post":"cls4jmgun001uaq7ktuhpuj4v","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/B树/B树05.png","slug":"B树05.png","post":"cls4jmguu0026aq7kv2u4j2kz","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/B树/B树30.gif","slug":"B树30.gif","post":"cls4jmguu0026aq7kv2u4j2kz","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树15.png","slug":"二叉树15.png","post":"cls4jmguw0029aq7ksoz1xk8v","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组02.png","slug":"动态数组02.png","post":"cls4jmgux002daq7k2h90v57v","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建21.png","slug":"环境搭建21.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/链表/链表13.png","slug":"链表13.png","post":"cls4jmgv5002paq7k3swohwmu","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/链表/链表18.png","slug":"链表18.png","post":"cls4jmgv5002paq7k3swohwmu","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/链表/链表20.png","slug":"链表20.png","post":"cls4jmgv5002paq7k3swohwmu","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之基础Widget/21.png","slug":"21.png","post":"cls4jmgv6002raq7k189ra6rb","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/block/block17.png","slug":"block17.png","post":"cls4jmgv7002taq7kc4ti2wyp","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/block/block18.png","slug":"block18.png","post":"cls4jmgv7002taq7kc4ti2wyp","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/多线程/多线程18.png","slug":"多线程18.png","post":"cls4jmgva002xaq7k62a1f195","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序12.png","slug":"微信小程序12.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序28.png","slug":"微信小程序28.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序26.png","slug":"微信小程序26.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Swift/Swift简介/Swift08.png","slug":"Swift08.png","post":"cls4jmgtt001eaq7kkx2dmwco","modified":1,"renderable":0},{"_id":"source/_posts/Swift/集合类/27.png","slug":"27.png","post":"cls4jmgun001uaq7ktuhpuj4v","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树14.png","slug":"二叉树14.png","post":"cls4jmguw0029aq7ksoz1xk8v","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/39.png","slug":"39.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/Runtime/Runtime06.png","slug":"Runtime06.png","post":"cls4jmgzh0039aq7k0hk6qagb","modified":1,"renderable":0},{"_id":"source/_posts/Other/Apple官方文档阅读指南/07.png","slug":"07.png","post":"cls4jmgtd0016aq7kjrq3x05e","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序05.png","slug":"微信小程序05.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序10.png","slug":"微信小程序10.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序23.png","slug":"微信小程序23.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序24.png","slug":"微信小程序24.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序25.png","slug":"微信小程序25.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序34.png","slug":"微信小程序34.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/initialize方法/initialize方法01.png","post":"cls4jmgsi000saq7kdzopg4t7","slug":"initialize方法01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/load的实现原理/load的实现原理01.png","post":"cls4jmgsa000naq7k7110g6m6","slug":"load的实现原理01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/load的实现原理/load的实现原理02.png","post":"cls4jmgsa000naq7k7110g6m6","slug":"load的实现原理02.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Hexo安装笔记/Hexo安装笔记01.png","post":"cls4jmgt80014aq7kw3y0yvui","slug":"Hexo安装笔记01.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Hexo安装笔记/Hexo安装笔记02.png","post":"cls4jmgt80014aq7kw3y0yvui","slug":"Hexo安装笔记02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类01.png","post":"cls4jmgrs000caq7kox2zw1da","slug":"OC对象的分类01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类02.png","post":"cls4jmgrs000caq7kox2zw1da","slug":"OC对象的分类02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的分类/OC对象的分类03.png","post":"cls4jmgrs000caq7kox2zw1da","slug":"OC对象的分类03.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation01.png","post":"cls4jmgum001saq7knkqledw2","slug":"Orientation01.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation02.png","post":"cls4jmgum001saq7knkqledw2","slug":"Orientation02.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/iOS横竖屏/Orientation03.png","post":"cls4jmgum001saq7knkqledw2","slug":"Orientation03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理01.png","post":"cls4jmgs7000laq7k5o86rcmw","slug":"Category的实现原理01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理02.png","post":"cls4jmgs7000laq7k5o86rcmw","slug":"Category的实现原理02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理03.png","post":"cls4jmgs7000laq7k5o86rcmw","slug":"Category的实现原理03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Category的实现原理/Category的实现原理04.png","post":"cls4jmgs7000laq7k5o86rcmw","slug":"Category的实现原理04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/关联对象/关联对象01.png","post":"cls4jmgsv000xaq7k1h3g9xr8","slug":"关联对象01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/关联对象/关联对象02.png","post":"cls4jmgsv000xaq7k1h3g9xr8","slug":"关联对象02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/关联对象/关联对象03.png","post":"cls4jmgsv000xaq7k1h3g9xr8","slug":"关联对象03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/关联对象/关联对象04.png","post":"cls4jmgsv000xaq7k1h3g9xr8","slug":"关联对象04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/关联对象/关联对象05.png","post":"cls4jmgsv000xaq7k1h3g9xr8","slug":"关联对象05.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/01.png","post":"cls4jmgs0000haq7k2aakujar","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/02.png","post":"cls4jmgs0000haq7k2aakujar","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/03.png","post":"cls4jmgs0000haq7k2aakujar","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/04.png","post":"cls4jmgs0000haq7k2aakujar","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/05.png","post":"cls4jmgs0000haq7k2aakujar","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Masonry/06.png","post":"cls4jmgs0000haq7k2aakujar","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/诗和远方/20221018_th.jpeg","slug":"20221018_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Other/诗和远方/20221101_th.jpeg","slug":"20221101_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Other/诗和远方/20221103_th.jpeg","slug":"20221103_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Other/诗和远方/20221106_th.jpeg","slug":"20221106_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Other/诗和远方/20221115_th.jpeg","slug":"20221115_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Other/诗和远方/20230608_th.jpeg","slug":"20230608_th.jpeg","post":"cls4jmgto001baq7k1cabrxw2","modified":1,"renderable":0},{"_id":"source/_posts/Swift/流程控制/01.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/流程控制/02.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/流程控制/03.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/流程控制/04.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/流程控制/05.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/流程控制/06.png","post":"cls4jmgue001oaq7kbhds1fjw","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度01.png","slug":"复杂度01.png","post":"cls4jmguz002gaq7k25huq6n7","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度02.png","post":"cls4jmguz002gaq7k25huq6n7","slug":"复杂度02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度03.png","post":"cls4jmguz002gaq7k25huq6n7","slug":"复杂度03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度04.png","slug":"复杂度04.png","post":"cls4jmguz002gaq7k25huq6n7","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度05.png","post":"cls4jmguz002gaq7k25huq6n7","slug":"复杂度05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/复杂度/复杂度06.png","post":"cls4jmguz002gaq7k25huq6n7","slug":"复杂度06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈01.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈02.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈03.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈04.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈05.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈06.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈07.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/栈/栈08.png","post":"cls4jmgv0002iaq7khza5fryu","slug":"栈08.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/01.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/02.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/03.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/04.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/05.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/06.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/07.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/08.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Github开源框架/Alamofire/09.png","post":"cls4jmgrp000aaq7kocxwjpsx","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/01.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/02.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/03.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/04.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/05.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/06.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/07.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/08.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之布局/09.png","post":"cls4jmgrm0007aq7kxwxkivsl","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/01.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/02.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/03.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/04.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/05.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/06.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/07.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/08.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/函数和闭包/09.png","post":"cls4jmgty001gaq7k67j43dfb","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列01.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列02.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列03.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列04.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列05.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列06.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列07.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列08.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/队列/队列09.png","post":"cls4jmgv4002naq7kkkmhh3mr","slug":"队列09.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/AFHTTPSessionManager/AFHTTPSessionManager/AFHTTPSessionManager.jpeg","slug":"AFHTTPSessionManager.jpeg","post":"cls4jmh3l003gaq7k1wxdynhl","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质02.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质03.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶01.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶02.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶03.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶04.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶05.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/OC对象的本质进阶06.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"OC对象的本质进阶06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/ObjectiveC_C_C++_汇编语言_机器语言.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"ObjectiveC_C_C++_汇编语言_机器语言.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/OC对象的本质/取消编译main_arm64_cpp.png","post":"cls4jmgs4000jaq7k6dc0xf0v","slug":"取消编译main_arm64_cpp.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/01.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/02.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/03.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/04.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/05.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/06.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/07.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/08.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/09.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/10.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/11.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之Dart/12.png","post":"cls4jmgr70002aq7kq7qlbf1v","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计01.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计02.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计03.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计04.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计05.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计06.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计07.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计08.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计09.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计10.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计11.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/架构设计/架构设计12.png","post":"cls4jmgsz000zaq7kcu22re62","slug":"架构设计12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化01.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化02.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化03.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化04.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化05.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化06.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化07.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化08.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化09.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化10.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化11.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/性能优化/性能优化12.png","post":"cls4jmgt30011aq7k17iusbax","slug":"性能优化12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组01.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组03.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组04.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组05.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组06.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组07.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组08.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组09.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组10.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组11.png","slug":"动态数组11.png","post":"cls4jmgux002daq7k2h90v57v","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组12.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/动态数组/动态数组13.png","post":"cls4jmgux002daq7k2h90v57v","slug":"动态数组13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass01.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass02.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass03.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass04.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass05.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass06.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass07.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass08.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass09.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass10.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass11.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass12.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass13.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/isa和superclass/isa和superclass14.png","post":"cls4jmgse000paq7ke4h1hfiz","slug":"isa和superclass14.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建17.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建17.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树01.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树02.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树03.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树04.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树05.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树06.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树07.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树08.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树09.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树10.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树11.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树12.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉树/二叉树13.png","post":"cls4jmguw0029aq7ksoz1xk8v","slug":"二叉树13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO01.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO02.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO03.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO04.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO05.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO06.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/KVO07.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"KVO07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_01.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_02.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_03.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_04.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_05.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_06.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_07.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_08.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/KVO/accessInstanceVariablesDirectly_09.png","post":"cls4jmgrx000faq7k87bbdtin","slug":"accessInstanceVariablesDirectly_09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop01.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop02.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop03.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop04.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop06.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop07.png","slug":"RunLoop07.png","post":"cls4jmgsn000uaq7kedfkgchk","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop08.png","slug":"RunLoop08.png","post":"cls4jmgsn000uaq7kedfkgchk","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop09.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop10.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop11.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop13.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop14.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop14.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop15.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop15.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/RunLoop/RunLoop16.png","post":"cls4jmgsn000uaq7kedfkgchk","slug":"RunLoop16.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/01.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/02.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/03.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/04.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/05.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/06.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/08.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/21.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/22.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"22.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/23.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"23.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/24.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/25.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"25.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/26.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"26.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/27.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"27.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/28.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"28.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Apple官方文档阅读指南/29.png","post":"cls4jmgtd0016aq7kjrq3x05e","slug":"29.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/01.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/02.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/03.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/04.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/05.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/06.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/07.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/08.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/09.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/10.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/11.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/12.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/13.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/14.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/15.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/16.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/运算符/17.png","post":"cls4jmgul001qaq7kixhdysbr","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/12.png","slug":"12.png","post":"cls4jmgtt001eaq7kkx2dmwco","modified":1,"renderable":0},{"_id":"source/_posts/Swift/Swift简介/13.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/14.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/16.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/17.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/18.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift01.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift02.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift03.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift04.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift05.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift06.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift07.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift09.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift10.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift10.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/Swift简介/Swift11.png","post":"cls4jmgtt001eaq7kkx2dmwco","slug":"Swift11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建16.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建16.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理01.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理02.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理03.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理04.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理05.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理06.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理07.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理08.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理09.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理10.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理11.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理12.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理13.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理14.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理14.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理15.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理15.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理16.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理16.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理17.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理17.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理18.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理18.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理19.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理19.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/内存管理/内存管理20.png","post":"cls4jmgv8002vaq7kamrvukbn","slug":"内存管理20.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/01.png","post":"cls4jmgri0006aq7kez71u7re","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/02.png","post":"cls4jmgri0006aq7kez71u7re","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/03.png","post":"cls4jmgri0006aq7kez71u7re","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/04.png","post":"cls4jmgri0006aq7kez71u7re","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/05.png","post":"cls4jmgri0006aq7kez71u7re","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/06.png","post":"cls4jmgri0006aq7kez71u7re","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/07.png","post":"cls4jmgri0006aq7kez71u7re","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/08.png","post":"cls4jmgri0006aq7kez71u7re","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/09.png","post":"cls4jmgri0006aq7kez71u7re","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/10.png","post":"cls4jmgri0006aq7kez71u7re","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/11.png","post":"cls4jmgri0006aq7kez71u7re","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/12.png","post":"cls4jmgri0006aq7kez71u7re","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/13.png","slug":"13.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之初见/14.png","slug":"14.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之初见/15.png","slug":"15.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之初见/16.png","slug":"16.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之初见/17.png","slug":"17.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之初见/18.png","post":"cls4jmgri0006aq7kez71u7re","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/19.png","post":"cls4jmgri0006aq7kez71u7re","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/20.png","post":"cls4jmgri0006aq7kez71u7re","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/21.png","post":"cls4jmgri0006aq7kez71u7re","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之初见/22.png","slug":"22.png","post":"cls4jmgri0006aq7kez71u7re","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建28.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建28.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/01.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/02.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/03.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/04.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/05.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/06.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/07.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/08.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/09.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/10.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/11.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/12.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/13.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/14.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/15.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/16.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/17.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/18.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/19.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/20.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/21.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/22.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"22.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/23.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"23.png","modified":1,"renderable":1},{"_id":"source/_posts/iOS/UIBezierPath/24.png","post":"cls4jmguq0021aq7k51bjzy0p","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树01.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树02.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树03.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树04.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树05.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树06.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树07.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树08.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树09.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树10.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树11.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树12.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树13.png","slug":"AVL树13.png","post":"cls4jmgut0024aq7k4wtfph6o","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树14.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树14.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树15.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树15.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树16.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树16.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树17.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树17.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树18.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树18.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树19.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树19.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树20.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树20.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树21.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树21.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树22.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树22.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树23.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树23.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树24.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树24.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树25.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树25.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/AVL树/AVL树26.png","post":"cls4jmgut0024aq7k4wtfph6o","slug":"AVL树26.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树01.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树02.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树03.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树04.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树05.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树06.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树07.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树08.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树09.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树10.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树11.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树12.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树13.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树13.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树14.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树14.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树15.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树15.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树16.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树16.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树17.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树17.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树18.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树18.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树19.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树19.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树20.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树20.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树21.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树21.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树22.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树22.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树23.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树23.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树24.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树24.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树25.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树25.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/二叉搜索树/二叉搜索树26.png","post":"cls4jmguw002baq7kkj0fyfi8","slug":"二叉搜索树26.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/01.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/02.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/03.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/04.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/05.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/06.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/07.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/08.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/09.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/10.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/11.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/12.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/13.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/16.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/17.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/18.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/19.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之基础Widget/20.png","post":"cls4jmgv6002raq7k189ra6rb","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表03.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block01.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block02.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block03.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block04.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block05.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block06.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block07.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block08.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block09.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block10.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block11.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block12.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block13.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block14.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block14.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block15.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block15.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block19.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block19.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block20.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block20.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block21.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block21.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block22.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block22.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block23.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block23.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block24.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block24.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block25.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block25.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block26.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block26.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block27.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block27.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/block/block28.png","post":"cls4jmgv7002taq7kc4ti2wyp","slug":"block28.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树01.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树02.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树03.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树04.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树06.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树07.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树08.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树09.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树10.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树11.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树12.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树13.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树13.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树14.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树14.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树15.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树15.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树16.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树16.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树17.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树17.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树18.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树18.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树19.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树19.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树20.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树20.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树21.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树21.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树22.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树22.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树23.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树23.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树24.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树24.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树25.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树25.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树26.png","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树26.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树27.gif","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树27.gif","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树28.gif","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树28.gif","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/B树/B树29.gif","post":"cls4jmguu0026aq7kv2u4j2kz","slug":"B树29.gif","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/01.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/02.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/03.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/04.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/05.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/06.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/07.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/08.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/09.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/10.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/11.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/12.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/13.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/14.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/15.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/16.png","slug":"16.png","post":"cls4jmgun001uaq7ktuhpuj4v","modified":1,"renderable":0},{"_id":"source/_posts/Swift/集合类/17.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/18.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/19.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/20.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/21.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/22.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"22.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/23.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"23.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/24.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/26.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"26.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/28.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"28.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/29.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"29.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/30.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"30.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/31.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"31.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/32.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"32.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/33.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"33.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/34.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"34.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/集合类/35.png","post":"cls4jmgun001uaq7ktuhpuj4v","slug":"35.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建01.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建02.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建03.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建03.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建04.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建05.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建06.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建07.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建08.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建09.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建10.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建11.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建12.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建13.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建13.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建14.png","slug":"环境搭建14.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建15.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建15.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建18.png","slug":"环境搭建18.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建19.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建19.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建20.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建20.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建22.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建22.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建23.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建23.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建24.png","slug":"环境搭建24.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建25.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建25.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建26.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建26.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建27.png","slug":"环境搭建27.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建29.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建29.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建30.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建30.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建31.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建31.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建32.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建32.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建33.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建33.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建34.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建34.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建35.png","post":"cls4jmgv2002laq7kyein6k9z","slug":"环境搭建35.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/环境搭建/环境搭建36.png","slug":"环境搭建36.png","post":"cls4jmgv2002laq7kyein6k9z","modified":1,"renderable":0},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType01.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType02.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType03.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType04.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType06.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType07.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType08.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType08.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType09.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType10.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType10.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType11.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType11.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType12.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType12.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType13.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType13.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType14.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType14.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType15.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType15.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType16.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType16.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType17.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType17.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType18.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType18.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType19.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType19.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType20.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType20.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType21.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType21.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType22.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType22.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType23.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType23.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType24.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType24.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType25.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType25.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType26.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType26.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType27.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType27.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType28.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType28.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType29.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType29.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType30.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType30.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType31.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType31.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType32.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType32.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType33.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType33.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType34.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType34.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType35.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType35.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType36.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType36.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType37.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType37.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType38.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType38.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/基本数据类型/BasicDataType39.png","post":"cls4jmgu3001jaq7ksple8qhi","slug":"BasicDataType39.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/02.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程01.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程02.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程03.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程04.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程05.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程06.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程06.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程07.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程08.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程09.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程10.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程11.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程12.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程13.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程14.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程14.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程16.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程16.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程17.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程17.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程19.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程19.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程20.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程20.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程21.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程21.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程22.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程22.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程23.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程23.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程24.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程24.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程25.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程25.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程26.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程26.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程27.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程27.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程28.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程28.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程29.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程29.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程30.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程30.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程31.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程31.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程32.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程32.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程33.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程33.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程34.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程34.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程35.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程35.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程36.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程36.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程37.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程37.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程38.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程38.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程39.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程39.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程40.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程40.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/多线程/多线程41.png","post":"cls4jmgva002xaq7k62a1f195","slug":"多线程41.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/29.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"29.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/01.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/03.png","slug":"03.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/04.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/05.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/06.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/07.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/08.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/09.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/10.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/11.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/12.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/13.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/14.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/15.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/16.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/17.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/18.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/19.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/20.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/21.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/22.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"22.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/23.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"23.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/24.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/25.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"25.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/26.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"26.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/27.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"27.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/28.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"28.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/30.png","slug":"30.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/31.png","slug":"31.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/32.png","slug":"32.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/33.png","slug":"33.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/34.png","slug":"34.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/Flutter/Flutter之环境搭建/35.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"35.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/36.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"36.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/37.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"37.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/38.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"38.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/40.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"40.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/41.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"41.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/42.png","post":"cls4jmgrf0005aq7k1h9pp46b","slug":"42.png","modified":1,"renderable":1},{"_id":"source/_posts/Flutter/Flutter之环境搭建/43.png","slug":"43.png","post":"cls4jmgrf0005aq7k1h9pp46b","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/链表/链表01.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表01.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表02.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表02.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表04.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表04.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表05.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表05.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表06.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表06.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表07.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表07.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表08.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表08.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表09.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表09.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表10.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表10.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表11.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表11.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表12.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表12.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表14.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表14.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表15.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表15.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表16.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表16.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表17.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表17.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表19.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表19.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表21.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表21.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表22.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表22.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表23.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表23.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表24.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表24.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表25.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表25.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表26.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表26.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表27.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表27.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表28.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表28.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表29.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表29.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表30.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表30.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表31.png","slug":"链表31.png","post":"cls4jmgv5002paq7k3swohwmu","modified":1,"renderable":0},{"_id":"source/_posts/数据结构与算法/链表/链表32.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表32.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表33.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表33.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表34.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表34.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表35.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表35.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表36.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表36.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表37.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表37.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表38.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表38.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表39.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表39.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表40.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表40.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表41.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表41.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表42.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表42.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表43.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表43.png","modified":1,"renderable":1},{"_id":"source/_posts/数据结构与算法/链表/链表44.png","post":"cls4jmgv5002paq7k3swohwmu","slug":"链表44.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序16.png","slug":"微信小程序16.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序17.png","slug":"微信小程序17.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序38.png","slug":"微信小程序38.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk01.png","post":"cls4jmgza0037aq7klm2ler9k","slug":"gitalk01.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk02.png","slug":"gitalk02.png","post":"cls4jmgza0037aq7klm2ler9k","modified":1,"renderable":0},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk03.png","post":"cls4jmgza0037aq7klm2ler9k","slug":"gitalk03.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk04.png","post":"cls4jmgza0037aq7klm2ler9k","slug":"gitalk04.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/Personal blog/gitalk/gitalk05.png","post":"cls4jmgza0037aq7klm2ler9k","slug":"gitalk05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/01.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/02.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/03.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/04.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/05.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/06.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"06.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/07.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"07.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/08.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"08.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/09.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"09.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/10.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/11.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/12.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/13.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/14.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/15.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/16.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"16.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/17.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/18.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"18.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/19.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/20.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"20.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/21.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"21.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/22.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"22.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/23.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"23.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/24.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/Swift/面向对象编程/25.png","post":"cls4jmgz90035aq7kwcyqpk3p","slug":"25.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序01.png","slug":"微信小程序01.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序02.png","slug":"微信小程序02.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序03.png","slug":"微信小程序03.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序04.png","slug":"微信小程序04.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序06.png","slug":"微信小程序06.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序07.png","slug":"微信小程序07.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序08.png","slug":"微信小程序08.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序09.png","slug":"微信小程序09.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序11.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序11.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序13.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序13.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序14.png","slug":"微信小程序14.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序15.png","slug":"微信小程序15.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序18.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序18.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序19.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序19.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序20.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序20.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序21.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序21.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序22.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序22.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序27.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序27.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序29.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序29.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序30.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序30.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序31.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序31.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序32.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序32.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序33.png","slug":"微信小程序33.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/Other/微信小程序/微信小程序35.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序35.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序36.png","post":"cls4jmgz80034aq7khz36ansn","slug":"微信小程序36.png","modified":1,"renderable":1},{"_id":"source/_posts/Other/微信小程序/微信小程序37.png","slug":"微信小程序37.png","post":"cls4jmgz80034aq7khz36ansn","modified":1,"renderable":0},{"_id":"source/_posts/OC底层原理/Runtime/Runtime01.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime01.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime02.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime02.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime03.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime03.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime04.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime04.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime05.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime05.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime07.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime07.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime08.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime08.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime09.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime09.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime10.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime10.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime11.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime11.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime12.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime12.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime13.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime13.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime14.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime14.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime15.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime15.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime16.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime16.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime17.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime17.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime18.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime18.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime19.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime19.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime20.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime20.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime21.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime21.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime22.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime22.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime23.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime23.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime24.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime24.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime25.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime25.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime26.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime26.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime27.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime27.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime28.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime28.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime29.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime29.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime30.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime30.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime31.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime31.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime32.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime32.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime33.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime33.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime34.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime34.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime35.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime35.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime36.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime36.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime37.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime37.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime38.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime38.png","modified":1,"renderable":1},{"_id":"source/_posts/OC底层原理/Runtime/Runtime39.png","post":"cls4jmgzh0039aq7k0hk6qagb","slug":"Runtime39.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cls4jmgri0006aq7kez71u7re","tag_id":"cls4jmgrd0004aq7kh0qa3zsh","_id":"cls4jmgrp0009aq7k9qi6czx3"},{"post_id":"cls4jmgr70002aq7kq7qlbf1v","tag_id":"cls4jmgrd0004aq7kh0qa3zsh","_id":"cls4jmgrs000baq7ktqum6bdx"},{"post_id":"cls4jmgrm0007aq7kxwxkivsl","tag_id":"cls4jmgrd0004aq7kh0qa3zsh","_id":"cls4jmgrx000eaq7kqbvyhits"},{"post_id":"cls4jmgrb0003aq7kf8tjnh0c","tag_id":"cls4jmgrn0008aq7k3seo4n2p","_id":"cls4jmgs0000gaq7ke88069h8"},{"post_id":"cls4jmgrf0005aq7k1h9pp46b","tag_id":"cls4jmgrd0004aq7kh0qa3zsh","_id":"cls4jmgs4000kaq7kkdrt2xb9"},{"post_id":"cls4jmgrp000aaq7kocxwjpsx","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgsb000oaq7kth4ohbln"},{"post_id":"cls4jmgsa000naq7k7110g6m6","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgsi000qaq7k6ssqboh6"},{"post_id":"cls4jmgrs000caq7kox2zw1da","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgsm000taq7kihovqozr"},{"post_id":"cls4jmgse000paq7ke4h1hfiz","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgsu000vaq7kej0vmklp"},{"post_id":"cls4jmgsi000saq7kdzopg4t7","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgsy000yaq7k2s1wxo8z"},{"post_id":"cls4jmgrx000faq7k87bbdtin","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgt30010aq7kdi7u8jtl"},{"post_id":"cls4jmgsn000uaq7kedfkgchk","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgt80013aq7kp3ybli2l"},{"post_id":"cls4jmgsv000xaq7k1h3g9xr8","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgtd0015aq7kgcosnwle"},{"post_id":"cls4jmgsz000zaq7kcu22re62","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgtj0018aq7kwgj0tm2y"},{"post_id":"cls4jmgs0000haq7k2aakujar","tag_id":"cls4jmgsu000waq7k2lcf0php","_id":"cls4jmgto001aaq7ka9sqiqts"},{"post_id":"cls4jmgt30011aq7k17iusbax","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgtt001daq7k5umy560y"},{"post_id":"cls4jmgs4000jaq7k6dc0xf0v","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgty001faq7klsaa7bz0"},{"post_id":"cls4jmgs7000laq7k5o86rcmw","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgu3001iaq7ksgf3qtwb"},{"post_id":"cls4jmgtt001eaq7kkx2dmwco","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgu8001kaq7ke5splv2v"},{"post_id":"cls4jmgt80014aq7kw3y0yvui","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmgue001naq7kjmdutzzs"},{"post_id":"cls4jmgty001gaq7k67j43dfb","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmguk001paq7k9u3al1xt"},{"post_id":"cls4jmgu3001jaq7ksple8qhi","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgum001raq7k1hbistdz"},{"post_id":"cls4jmgtd0016aq7kjrq3x05e","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmgun001taq7k5yf7nhlk"},{"post_id":"cls4jmgu8001laq7kgbr4qmd0","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmguo001waq7kwbqj6y2p"},{"post_id":"cls4jmgue001oaq7kbhds1fjw","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgup001yaq7kczl4jdd4"},{"post_id":"cls4jmgtj0019aq7k1asw0j9q","tag_id":"cls4jmgu9001maq7kagexp7gb","_id":"cls4jmguq0020aq7kybqvoxz8"},{"post_id":"cls4jmgul001qaq7kixhdysbr","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgut0023aq7kictr8gij"},{"post_id":"cls4jmgun001uaq7ktuhpuj4v","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmguu0025aq7ke6usu5mf"},{"post_id":"cls4jmgup001zaq7kh61c2ive","tag_id":"cls4jmgun001vaq7ktveixkrc","_id":"cls4jmguv0028aq7klmsov279"},{"post_id":"cls4jmgum001saq7knkqledw2","tag_id":"cls4jmgun001vaq7ktveixkrc","_id":"cls4jmguw002aaq7km2jwpc1m"},{"post_id":"cls4jmguq0021aq7k51bjzy0p","tag_id":"cls4jmgun001vaq7ktveixkrc","_id":"cls4jmgux002caq7k7twr9elh"},{"post_id":"cls4jmguo001xaq7kgxotrvrx","tag_id":"cls4jmgun001vaq7ktveixkrc","_id":"cls4jmguz002faq7kcpul13z8"},{"post_id":"cls4jmguw002baq7kkj0fyfi8","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv0002haq7kj7ux3ca8"},{"post_id":"cls4jmgut0024aq7k4wtfph6o","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv2002kaq7ktjmh3dv7"},{"post_id":"cls4jmgux002daq7k2h90v57v","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv3002maq7ksz9qefi1"},{"post_id":"cls4jmguz002gaq7k25huq6n7","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv5002oaq7ki00rpn44"},{"post_id":"cls4jmguu0026aq7kv2u4j2kz","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv6002qaq7kyj3cjgb5"},{"post_id":"cls4jmgv0002iaq7khza5fryu","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv7002saq7kfigxc4jd"},{"post_id":"cls4jmgv2002laq7kyein6k9z","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv8002uaq7kentrgedr"},{"post_id":"cls4jmguw0029aq7ksoz1xk8v","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgv9002waq7kk9914c00"},{"post_id":"cls4jmgv4002naq7kkkmhh3mr","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgvb002yaq7kur5gvups"},{"post_id":"cls4jmgv5002paq7k3swohwmu","tag_id":"cls4jmguv0027aq7k3rv9v1p3","_id":"cls4jmgvb002zaq7ktv4cbsr7"},{"post_id":"cls4jmgv6002raq7k189ra6rb","tag_id":"cls4jmgrd0004aq7kh0qa3zsh","_id":"cls4jmgvc0030aq7k4bj4k6jj"},{"post_id":"cls4jmgv7002taq7kc4ti2wyp","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgvc0031aq7k21wd9nlu"},{"post_id":"cls4jmgv8002vaq7kamrvukbn","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgvc0032aq7kciuwr5a1"},{"post_id":"cls4jmgva002xaq7k62a1f195","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgvc0033aq7kq381no3y"},{"post_id":"cls4jmgz80034aq7khz36ansn","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmgza0036aq7ks0icu1u4"},{"post_id":"cls4jmgz90035aq7kwcyqpk3p","tag_id":"cls4jmgs1000iaq7kj2apua4n","_id":"cls4jmgzh0038aq7kc5f6lb3a"},{"post_id":"cls4jmgza0037aq7klm2ler9k","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmgzq003aaq7kkpwopx03"},{"post_id":"cls4jmgzh0039aq7k0hk6qagb","tag_id":"cls4jmgsa000maq7k7wg1z31v","_id":"cls4jmgzx003caq7kzpgq0z4v"},{"post_id":"cls4jmgzq003baq7k29tfujco","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmh05003eaq7ky8sexkhn"},{"post_id":"cls4jmgzx003daq7kqj4mfpp9","tag_id":"cls4jmgtp001caq7k87v4dtwp","_id":"cls4jmh0d003faq7kh8wysekr"},{"post_id":"cls4jmh3l003gaq7k1wxdynhl","tag_id":"cls4jmgun001vaq7ktveixkrc","_id":"cls4jmh3m003haq7k15khis07"}],"Tag":[{"name":"Flutter","_id":"cls4jmgrd0004aq7kh0qa3zsh"},{"name":"2022打怪","_id":"cls4jmgrn0008aq7k3seo4n2p"},{"name":"Swift","_id":"cls4jmgs1000iaq7kj2apua4n"},{"name":"OC底层原理","_id":"cls4jmgsa000maq7k7wg1z31v"},{"name":"Github开源框架","_id":"cls4jmgsu000waq7k2lcf0php"},{"name":"Other","_id":"cls4jmgtp001caq7k87v4dtwp"},{"name":"Math","_id":"cls4jmgu9001maq7kagexp7gb"},{"name":"OC","_id":"cls4jmgun001vaq7ktveixkrc"},{"name":"数据结构与算法","_id":"cls4jmguv0027aq7k3rv9v1p3"}]}}